<Type Name="TaskScheduler" FullName="System.Threading.Tasks.TaskScheduler">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="9101875b3c768590b23db0c0c08ee17d09fc5e38" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37609227" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class TaskScheduler" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit TaskScheduler extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.TaskScheduler" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class TaskScheduler" />
  <TypeSignature Language="C++ CLI" Value="public ref class TaskScheduler abstract" />
  <TypeSignature Language="F#" Value="type TaskScheduler = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerDisplay("Id={Id}")</AttributeName>
    </Attribute>
    <Attribute>
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Threading.Tasks.TaskScheduler/SystemThreadingTasks_TaskSchedulerDebugView))</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="ead8f-101">Representa un objeto que administra el trabajo de bajo nivel de poner en cola tareas en los subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ead8f-101">Represents an object that handles the low-level work of queuing tasks onto threads.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-102">Una instancia de la <xref:System.Threading.Tasks.TaskScheduler> clase representa un programador de tareas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-102">An instance of the <xref:System.Threading.Tasks.TaskScheduler> class represents a task scheduler.</span></span> <span data-ttu-id="ead8f-103">Un programador de tareas asegura que se ejecuta el trabajo de una tarea.</span><span class="sxs-lookup"><span data-stu-id="ead8f-103">A task scheduler ensures that the work of a task is eventually executed.</span></span>  
  
 <span data-ttu-id="ead8f-104">El programador de tareas predeterminado está basado en el grupo de subprocesos .NET Framework 4, que proporciona robo de trabajo para el equilibrio de carga, inyección/retirada de subprocesos, a fin de obtener el máximo resultado y un buen rendimiento en general.</span><span class="sxs-lookup"><span data-stu-id="ead8f-104">The default task scheduler is based on the .NET Framework 4 thread pool, which provides work-stealing for load-balancing, thread injection/retirement for maximum throughput, and overall good performance.</span></span> <span data-ttu-id="ead8f-105">Debería ser suficiente para la mayoría de los escenarios.</span><span class="sxs-lookup"><span data-stu-id="ead8f-105">It should be sufficient for most scenarios.</span></span>  
  
 <span data-ttu-id="ead8f-106">La <xref:System.Threading.Tasks.TaskScheduler> clase también actúa como el punto de extensión para toda la lógica de programación personalizable.</span><span class="sxs-lookup"><span data-stu-id="ead8f-106">The <xref:System.Threading.Tasks.TaskScheduler> class also serves as the extension point for all customizable scheduling logic.</span></span>  <span data-ttu-id="ead8f-107">Esto incluye mecanismos, como cómo programar una tarea para su ejecución y las tareas programadas de cómo se debe exponer a los depuradores.</span><span class="sxs-lookup"><span data-stu-id="ead8f-107">This includes mechanisms such as how to schedule a task for execution, and how scheduled tasks should be exposed to debuggers.</span></span> <span data-ttu-id="ead8f-108">Si necesita funcionalidad especial, puede crear a un programador personalizado y habilitarlo para tareas específicas o las consultas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-108">If you require special functionality, you can create a custom scheduler and enable it for specific tasks or queries.</span></span>  
  
 <span data-ttu-id="ead8f-109">En este tema:</span><span class="sxs-lookup"><span data-stu-id="ead8f-109">In this topic:</span></span>  
[<span data-ttu-id="ead8f-110">El programador de tareas predeterminado y el grupo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="ead8f-110">The default task scheduler and the thread pool</span></span>](#Default)  
 [<span data-ttu-id="ead8f-111">La cola global frente a las colas locales</span><span class="sxs-lookup"><span data-stu-id="ead8f-111">The global queue vs. local queues</span></span>](#Queues)  
 [<span data-ttu-id="ead8f-112">Robo de trabajo</span><span class="sxs-lookup"><span data-stu-id="ead8f-112">Work stealing</span></span>](#Stealing)  
 [<span data-ttu-id="ead8f-113">Tareas de ejecución prolongada</span><span class="sxs-lookup"><span data-stu-id="ead8f-113">Long-running tasks</span></span>](#LongRunning)  
 [<span data-ttu-id="ead8f-114">Inclusión de tareas</span><span class="sxs-lookup"><span data-stu-id="ead8f-114">Task inlining</span></span>](#Inlining)  
[<span data-ttu-id="ead8f-115">Especifica un contexto de sincronización</span><span class="sxs-lookup"><span data-stu-id="ead8f-115">Specifying a synchronization context</span></span>](#Sync)  
  
<a name="Default"></a>   
## <a name="the-default-task-scheduler-and-the-thread-pool"></a><span data-ttu-id="ead8f-116">El programador de tareas predeterminado y el grupo de subprocesos</span><span class="sxs-lookup"><span data-stu-id="ead8f-116">The default task scheduler and the thread pool</span></span>  
 <span data-ttu-id="ead8f-117">El programador predeterminado para la biblioteca TPL y PLINQ usa el grupo de subprocesos de .NET Framework, que viene representado por la <xref:System.Threading.ThreadPool> (clase), para poner en cola y ejecutar el trabajo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-117">The default scheduler for the Task Parallel Library and PLINQ uses the .NET Framework thread pool, which is represented by the <xref:System.Threading.ThreadPool> class, to queue and execute work.</span></span> <span data-ttu-id="ead8f-118">El grupo de subprocesos usa la información suministrada por el <xref:System.Threading.Tasks.Task> tipo para admitir el paralelismo específico (unidades efímeras de trabajo) que en paralelo las tareas y las consultas a menudo representan de forma eficaz.</span><span class="sxs-lookup"><span data-stu-id="ead8f-118">The thread pool uses the information that is provided by the <xref:System.Threading.Tasks.Task> type to efficiently     support the fine-grained parallelism (short-lived units of work) that parallel tasks and queries often represent.</span></span>  
  
<a name="Queues"></a>   
### <a name="the-global-queue-vs-local-queues"></a><span data-ttu-id="ead8f-119">La cola global frente a las colas locales</span><span class="sxs-lookup"><span data-stu-id="ead8f-119">The global queue vs. local queues</span></span>  
 <span data-ttu-id="ead8f-120">El grupo de subprocesos mantiene la cola de subprocesos en cada dominio de aplicación de trabajo de un global FIFO (primero en salir).</span><span class="sxs-lookup"><span data-stu-id="ead8f-120">The thread pool maintains a global FIFO (first-in, first-out) work queue for threads in each application domain.</span></span> <span data-ttu-id="ead8f-121">Cada vez que un programa llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (o <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) método, el trabajo es poner en esta cola compartida y finalmente sale de la cola hacia el subproceso siguiente que está disponible.</span><span class="sxs-lookup"><span data-stu-id="ead8f-121">Whenever a program calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A?displayProperty=nameWithType> (or <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A?displayProperty=nameWithType>) method, the work is put on this shared queue and eventually de-queued onto the next thread that becomes available.</span></span> <span data-ttu-id="ead8f-122">A partir de .NET Framework 4, esta cola se ha mejorado para usar un algoritmo sin bloqueo que se parezca a la <xref:System.Collections.Concurrent.ConcurrentQueue%601> clase.</span><span class="sxs-lookup"><span data-stu-id="ead8f-122">Starting with the .NET Framework 4, this queue has been improved to use a lock-free algorithm that resembles the <xref:System.Collections.Concurrent.ConcurrentQueue%601> class.</span></span> <span data-ttu-id="ead8f-123">Mediante esta implementación sin bloqueo, el grupo de subprocesos emplea menos tiempo en poner y sacar elementos de trabajo de las colas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-123">By using this lock-free implementation, the thread pool spends less time when it queues and de-queues work items.</span></span> <span data-ttu-id="ead8f-124">Esta ventaja de rendimiento está disponible para todos los programas que usan el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-124">This performance benefit is available to all programs that use the thread pool.</span></span>  
  
 <span data-ttu-id="ead8f-125">Las tareas de nivel superior, que son tareas que no se crean en el contexto de otra tarea, se colocan en la cola global igual que cualquier otro elemento de trabajo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-125">Top-level tasks, which are tasks that are not created in the context of another task, are put on the global queue just like any other work item.</span></span> <span data-ttu-id="ead8f-126">Sin embargo, las tareas anidadas o secundarias, que se crean en el contexto de otra tarea, se controlan de forma bastante distinta.</span><span class="sxs-lookup"><span data-stu-id="ead8f-126">However, nested or child tasks, which are created in the context of another task, are handled quite differently.</span></span> <span data-ttu-id="ead8f-127">Una tarea secundaria o anidada se coloca en una cola local que es específica del subproceso en el que la tarea primaria se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="ead8f-127">A child or nested task is put on a local queue that is specific to the thread on which the parent task is executing.</span></span> <span data-ttu-id="ead8f-128">La tarea primaria puede ser una tarea de nivel superior o también puede ser el elemento secundario de otra tarea.</span><span class="sxs-lookup"><span data-stu-id="ead8f-128">The parent task may be a top-level task or it also may be the child of another task.</span></span> <span data-ttu-id="ead8f-129">Cuando este subproceso está listo para más trabajo, primero busca en la cola local.</span><span class="sxs-lookup"><span data-stu-id="ead8f-129">When this thread is ready for more work, it first looks in the local queue.</span></span> <span data-ttu-id="ead8f-130">Si hay elementos de trabajo esperando, se puede tener acceso a ellos rápidamente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-130">If work items are waiting there, they can be accessed quickly.</span></span> <span data-ttu-id="ead8f-131">Se tiene acceso a las colas locales en el orden último en salir (LIFO) para conservar la localidad de memoria caché y reducir la contención.</span><span class="sxs-lookup"><span data-stu-id="ead8f-131">The local queues are accessed in last-in, first-out order (LIFO) to preserve cache locality and reduce contention.</span></span> <span data-ttu-id="ead8f-132">Para obtener más información acerca de las tareas secundarias y anidadas, vea [adjuntas y tareas secundarias desasociadas](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span><span class="sxs-lookup"><span data-stu-id="ead8f-132">For more information about child tasks and nested tasks, see [Attached and Detached Child Tasks](~/docs/standard/parallel-programming/attached-and-detached-child-tasks.md).</span></span>  
  
 <span data-ttu-id="ead8f-133">El uso de colas locales no sólo reduce la presión en la cola global, sino que también aprovecha las ventajas de la localidad de los datos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-133">The use of local queues not only reduces pressure on the global queue, but also takes advantage of data locality.</span></span> <span data-ttu-id="ead8f-134">Los elementos de trabajo locales en cola con frecuencia las estructuras de datos de referencia que se encuentran físicamente próximos entre sí en memoria.</span><span class="sxs-lookup"><span data-stu-id="ead8f-134">Work items in the local queue frequently reference data structures that are physically near one another in memory.</span></span> <span data-ttu-id="ead8f-135">En estos casos, los datos ya están en la memoria caché después de la primera tarea se ha ejecutado y se puede acceder rápidamente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-135">In these cases, the data is already in the cache after the first task has run and can be accessed quickly.</span></span> <span data-ttu-id="ead8f-136">Ambos [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) y <xref:System.Threading.Tasks.Parallel> ampliamente de clases usa tareas anidadas y tareas secundarias y conseguir aumentos significativos de velocidad mediante las colas de trabajo local.</span><span class="sxs-lookup"><span data-stu-id="ead8f-136">Both [Parallel LINQ (PLINQ)](~/docs/standard/parallel-programming/parallel-linq-plinq.md) and the <xref:System.Threading.Tasks.Parallel> class use nested tasks and child tasks extensively, and achieve significant speedups by using the local work queues.</span></span>  
  
<a name="Stealing"></a>   
### <a name="work-stealing"></a><span data-ttu-id="ead8f-137">Robo de trabajo</span><span class="sxs-lookup"><span data-stu-id="ead8f-137">Work stealing</span></span>  
 <span data-ttu-id="ead8f-138">A partir de .NET Framework 4, el grupo de subprocesos también incluye un algoritmo de robo de trabajo para ayudar a asegurarse de que no se encuentra ningún subproceso inactivo mientras otros todavía tienen trabajo en sus colas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-138">Starting with the .NET Framework 4, the thread pool also features a work-stealing algorithm to help make sure that no threads are sitting idle while others still have work in their queues.</span></span> <span data-ttu-id="ead8f-139">Cuando un subproceso ThreadPool está listo para más trabajo, examina primero el encabezado de la cola local, a continuación, en la cola global y después en las colas locales de otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-139">When a thread-pool thread is ready for more work, it first looks at the head of its local queue, then in the global queue, and then in the local queues of other threads.</span></span> <span data-ttu-id="ead8f-140">Si encuentra un elemento de trabajo en la cola local de otro subproceso, aplica primero heurística para asegurarse de que puede ejecutar el trabajo eficazmente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-140">If it finds a work item in the local queue of another thread, it first applies heuristics to make sure that it can run the work efficiently.</span></span> <span data-ttu-id="ead8f-141">Si es posible, quita de la cola el elemento de trabajo de la cola (en orden FIFO).</span><span class="sxs-lookup"><span data-stu-id="ead8f-141">If it can, it de-queues the work item from the tail (in FIFO order).</span></span> <span data-ttu-id="ead8f-142">Esto reduce la contención en cada cola local y mantiene la situación de los datos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-142">This reduces contention on each local queue and preserves data locality.</span></span> <span data-ttu-id="ead8f-143">Esta arquitectura permite el equilibrio de carga de grupo de subprocesos funcione de manera más eficaz que versiones anteriores.</span><span class="sxs-lookup"><span data-stu-id="ead8f-143">This architecture helps the  thread pool load-balance work more efficiently than past versions did.</span></span>  
  
<a name="LongRunning"></a>   
### <a name="long-running-tasks"></a><span data-ttu-id="ead8f-144">Tareas de ejecución prolongada</span><span class="sxs-lookup"><span data-stu-id="ead8f-144">Long-running tasks</span></span>  
 <span data-ttu-id="ead8f-145">Tal vez le interese evitar explícitamente que una tarea se coloque en una cola local.</span><span class="sxs-lookup"><span data-stu-id="ead8f-145">You may want to explicitly prevent a task from being put on a local queue.</span></span> <span data-ttu-id="ead8f-146">Por ejemplo, puede saber que un elemento de trabajo determinado se ejecutará durante un tiempo relativamente largo y es probable que bloquee el resto de los elementos de trabajo de la cola local.</span><span class="sxs-lookup"><span data-stu-id="ead8f-146">For example, you may know that a particular work item will run for a relatively long time and is likely to block all other work items on the local queue.</span></span> <span data-ttu-id="ead8f-147">En este caso, puede especificar la opción <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType>, que proporciona una sugerencia al programador que le indica que tal vez es necesario un subproceso adicional para que la tarea no bloquee el progreso de otros subprocesos o elementos de trabajo de la cola local.</span><span class="sxs-lookup"><span data-stu-id="ead8f-147">In this case, you can specify the <xref:System.Threading.Tasks.TaskCreationOptions?displayProperty=nameWithType> option, which provides a hint to the scheduler that an additional thread might be required for the task so that it does not block the forward progress of other threads or work items on the local queue.</span></span> <span data-ttu-id="ead8f-148">Con esta opción evita el grupo de subprocesos por completo, incluidas las colas globales y locales.</span><span class="sxs-lookup"><span data-stu-id="ead8f-148">By using this option you avoid the thread pool completely, including the global and local queues.</span></span>  
  
<a name="Inlining"></a>   
### <a name="task-inlining"></a><span data-ttu-id="ead8f-149">Inclusión de tareas</span><span class="sxs-lookup"><span data-stu-id="ead8f-149">Task inlining</span></span>  
 <span data-ttu-id="ead8f-150">En algunos casos, cuando un <xref:System.Threading.Tasks.Task> se esperando, se puede ejecutar sincrónicamente en el subproceso que realiza la operación de espera.</span><span class="sxs-lookup"><span data-stu-id="ead8f-150">In some cases when a <xref:System.Threading.Tasks.Task> is waited on, it may be executed synchronously on the thread that is performing the wait operation.</span></span> <span data-ttu-id="ead8f-151">Esto mejora el rendimiento evitando la necesidad de un subproceso adicional y en su lugar utilizando el subproceso existente, que en caso contrario, se habría bloqueado.</span><span class="sxs-lookup"><span data-stu-id="ead8f-151">This enhances performance by preventing the need for an additional thread and instead using the existing thread, which would have blocked otherwise.</span></span> <span data-ttu-id="ead8f-152">Para evitar errores debidos a la entrada reiterada, inclusión de tareas solo se produce cuando se encuentra el destino de la espera en cola local del subproceso pertinente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-152">To prevent errors due to re-entrancy, task inlining only occurs when the wait target is found in the relevant thread's local queue.</span></span>  
  
<a name="Sync"></a>   
## <a name="specifying-a-synchronization-context"></a><span data-ttu-id="ead8f-153">Especifica un contexto de sincronización</span><span class="sxs-lookup"><span data-stu-id="ead8f-153">Specifying a synchronization context</span></span>  
 <span data-ttu-id="ead8f-154">Puede utilizar el método <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> para especificar que una tarea se debería programar para ejecutarse en un subproceso determinado.</span><span class="sxs-lookup"><span data-stu-id="ead8f-154">You can use the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method to specify that a task should be scheduled to run on a particular thread.</span></span> <span data-ttu-id="ead8f-155">Esto es útil en marcos como Windows Forms y Windows Presentation Foundation, donde el acceso a los objetos de interfaz de usuario está restringido a menudo para el código que se está ejecutando en el mismo subproceso en el que se creó el objeto UI.</span><span class="sxs-lookup"><span data-stu-id="ead8f-155">This is useful in frameworks such as Windows Forms and Windows Presentation Foundation where access to user interface objects is often restricted to code that is running on the same thread on which the UI object was created.</span></span>  
  
 <span data-ttu-id="ead8f-156">En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> método en una aplicación de Windows Presentation Foundation (WPF) para programar una tarea en el mismo subproceso donde se creó el control de interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="ead8f-156">The following example uses the <xref:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext%2A?displayProperty=nameWithType> method in a Windows Presentation Foundation (WPF) app to schedule a task on the same thread that the user interface (UI) control was created on.</span></span>   <span data-ttu-id="ead8f-157">En el ejemplo se crea un mosaico de imágenes que se seleccionan aleatoriamente de un directorio especificado.</span><span class="sxs-lookup"><span data-stu-id="ead8f-157">The example creates a mosaic of images that are randomly selected from a specified directory.</span></span> <span data-ttu-id="ead8f-158">Los objetos de WPF se usan para cargar y cambiar el tamaño de las imágenes.</span><span class="sxs-lookup"><span data-stu-id="ead8f-158">The WPF objects are used to load and resize the images.</span></span> <span data-ttu-id="ead8f-159">Los píxeles sin procesar, a continuación, se pasan a una tarea que usa un <xref:System.Threading.Tasks.Parallel.For%2A> bucle para escribir los datos de píxeles en una matriz grande de un byte.</span><span class="sxs-lookup"><span data-stu-id="ead8f-159">The raw pixels are then passed to a task that uses a <xref:System.Threading.Tasks.Parallel.For%2A> loop to write the pixel data into a large single-byte array.</span></span> <span data-ttu-id="ead8f-160">Se necesita ninguna sincronización porque no hay dos iconos ocupan los mismos elementos de matriz.</span><span class="sxs-lookup"><span data-stu-id="ead8f-160">No synchronization is required because no two tiles occupy the same array elements.</span></span> <span data-ttu-id="ead8f-161">Los iconos también se pueden escribir en cualquier orden porque su posición se calcula independientemente de cualquier otro icono.</span><span class="sxs-lookup"><span data-stu-id="ead8f-161">The tiles can also be written in any order because their position is calculated independently of any other tile.</span></span> <span data-ttu-id="ead8f-162">La matriz de gran tamaño, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario, donde se cargan los datos de píxeles en un control de imagen.</span><span class="sxs-lookup"><span data-stu-id="ead8f-162">The large array is then passed to a task that runs on the UI thread, where the pixel data is loaded into an Image control.</span></span>  
  
 <span data-ttu-id="ead8f-163">El ejemplo mueve los datos fuera del subproceso de interfaz de usuario, lo modifica mediante el uso de bucles paralelos y <xref:System.Threading.Tasks.Task> objetos y, a continuación, se pasa a una tarea que se ejecuta en el subproceso de interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="ead8f-163">The example moves data off the UI thread, modifies it by using parallel loops and <xref:System.Threading.Tasks.Task> objects, and then passes it back to a task that runs on the UI thread.</span></span> <span data-ttu-id="ead8f-164">Este enfoque es útil cuando tiene que usar la biblioteca TPL para realizar operaciones que no son compatibles con la API de WPF, o que no son lo suficientemente rápido.</span><span class="sxs-lookup"><span data-stu-id="ead8f-164">This approach is useful when you have to use the Task Parallel Library to perform operations that either are not supported by the WPF API, or are not sufficiently fast.</span></span> <span data-ttu-id="ead8f-165">Otra forma de crear un mosaico de la imagen en WPF es usar un <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> controlar y agregar imágenes a él.</span><span class="sxs-lookup"><span data-stu-id="ead8f-165">Another way to create an image mosaic in WPF is to use a <xref:System.Windows.Controls.WrapPanel?displayProperty=nameWithType> control and add images to it.</span></span> <span data-ttu-id="ead8f-166">El <xref:System.Windows.Controls.WrapPanel> controla el trabajo de colocar los iconos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-166">The <xref:System.Windows.Controls.WrapPanel> handles the work of positioning the tiles.</span></span> <span data-ttu-id="ead8f-167">Sin embargo, este trabajo solo puede realizarse en el subproceso de interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="ead8f-167">However, this work can only be performed on the UI thread.</span></span>  
  
 [!code-csharp[TPL_SyncContext#01](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_synccontext/cs/mainwindow.xaml.cs#01)]
 [!code-vb[TPL_SyncContext#01](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_synccontext/vb/MainWindow.xaml.vb#01)]  
  
 <span data-ttu-id="ead8f-168">Para crear el ejemplo, cree un proyecto de aplicación de WPF en Visual Studio y asígnele un nombre de su elección.</span><span class="sxs-lookup"><span data-stu-id="ead8f-168">To create the example, create a WPF application project in Visual Studio and assign it a name of your choice.</span></span> <span data-ttu-id="ead8f-169">A continuación, haga lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="ead8f-169">Then do the following:</span></span>  
  
1.  <span data-ttu-id="ead8f-170">En la vista Diseño, arrastre un <xref:System.Windows.Controls.Image> controlar desde la **cuadro de herramientas** a la superficie de diseño.</span><span class="sxs-lookup"><span data-stu-id="ead8f-170">In design view, drag an <xref:System.Windows.Controls.Image> control from the **Toolbox** to the design surface.</span></span> <span data-ttu-id="ead8f-171">En la vista XAML, especificar la alineación horizontal como "Left".</span><span class="sxs-lookup"><span data-stu-id="ead8f-171">In XAML view, specify the horizontal alignment as "Left."</span></span> <span data-ttu-id="ead8f-172">El tamaño no importa porque el control se ajustará dinámicamente en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ead8f-172">The size does not matter because the control is be dynamically resized at run time.</span></span> <span data-ttu-id="ead8f-173">Acepte el nombre predeterminado, "la imagen".</span><span class="sxs-lookup"><span data-stu-id="ead8f-173">Accept the default name, "image".</span></span>  
  
2.  <span data-ttu-id="ead8f-174">Arrastre un <xref:System.Windows.Controls.Button> controlar desde la **cuadro de herramientas** a la parte inferior izquierda de la ventana de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="ead8f-174">Drag a <xref:System.Windows.Controls.Button> control from the **Toolbox** to the lower left part of the application window.</span></span> <span data-ttu-id="ead8f-175">Haga doble clic en el botón para agregar un <xref:System.Windows.Controls.Primitives.ButtonBase.Click> controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-175">Double-click the button to add a <xref:System.Windows.Controls.Primitives.ButtonBase.Click> event handler.</span></span> <span data-ttu-id="ead8f-176">En la vista XAML, especifique el <xref:System.Windows.Controls.ContentControl.Content%2A> propiedad del botón como "Make un mosaico" y especifique la alineación horizontal como "Left".</span><span class="sxs-lookup"><span data-stu-id="ead8f-176">In XAML view, specify the <xref:System.Windows.Controls.ContentControl.Content%2A> property of the button as "Make a Mosaic" and specify its horizontal alignment as "Left".</span></span> <span data-ttu-id="ead8f-177">Acepte el nombre predeterminado, "button".</span><span class="sxs-lookup"><span data-stu-id="ead8f-177">Accept the default name, "button".</span></span>  
  
3.  <span data-ttu-id="ead8f-178">Reemplace todo el contenido del archivo MainWindow.xaml.cs o MainWindow.xaml.vb por el código de este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-178">Replace the entire contents of the MainWindow.xaml.cs or MainWindow.xaml.vb file with the code from this example.</span></span> <span data-ttu-id="ead8f-179">Asegúrese de que el nombre del área de trabajo coincide con el nombre del proyecto.</span><span class="sxs-lookup"><span data-stu-id="ead8f-179">Make sure that the name of the workspace matches the project name.</span></span>  
  
4.  <span data-ttu-id="ead8f-180">El ejemplo lee las imágenes JPEG de un directorio denominado C:\Users\Public\Pictures\Sample Pictures\\.</span><span class="sxs-lookup"><span data-stu-id="ead8f-180">The example reads JPEG images from a directory named C:\Users\Public\Pictures\Sample Pictures\\.</span></span> <span data-ttu-id="ead8f-181">Cree el directorio y coloque algunas imágenes en ella o cambiar la ruta de acceso para hacer referencia a otro directorio que contiene imágenes.</span><span class="sxs-lookup"><span data-stu-id="ead8f-181">Either create the directory and place some images in it, or change the path to refer to some other directory that contains images.</span></span>  
  
 <span data-ttu-id="ead8f-182">En este ejemplo tiene algunas limitaciones.</span><span class="sxs-lookup"><span data-stu-id="ead8f-182">This example has some limitations.</span></span> <span data-ttu-id="ead8f-183">Por ejemplo, se admiten imágenes de sólo 32-bits por píxel; las imágenes en otros formatos están dañadas por la <xref:System.Windows.Media.Imaging.BitmapImage> objeto durante la operación de cambio de tamaño.</span><span class="sxs-lookup"><span data-stu-id="ead8f-183">For example, only 32-bits-per-pixel images are supported; images in other formats are corrupted by the <xref:System.Windows.Media.Imaging.BitmapImage> object during the resizing operation.</span></span> <span data-ttu-id="ead8f-184">Además, las imágenes de origen deben mayores que el tamaño del mosaico.</span><span class="sxs-lookup"><span data-stu-id="ead8f-184">Also, the source images must all be larger than the tile size.</span></span> <span data-ttu-id="ead8f-185">Como ejercicio adicional, puede agregar funcionalidad para controlar varios formatos de píxel y tamaños de archivo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-185">As a further exercise, you can add functionality to handle multiple pixel formats and file sizes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ead8f-186">En el siguiente ejemplo se toma de la [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) en el sitio Web de MSDN Code Gallery.</span><span class="sxs-lookup"><span data-stu-id="ead8f-186">The following example is taken from the [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717) on the MSDN Code Gallery Web site.</span></span>  <span data-ttu-id="ead8f-187">Crea a un programador de tareas personalizado que limita el número de subprocesos usados por la aplicación.</span><span class="sxs-lookup"><span data-stu-id="ead8f-187">It creates a custom task scheduler that limits the number of threads used by the app.</span></span> <span data-ttu-id="ead8f-188">A continuación, inicia dos conjuntos de tareas y muestra información acerca de la tarea y el subproceso en que se ejecuta la tarea.</span><span class="sxs-lookup"><span data-stu-id="ead8f-188">It then launches two sets of tasks and displays information about the task and the thread on which the task is executing.</span></span>  
  
 [!code-csharp[TPL_Schedulers#02](~/samples/snippets/csharp/VS_Snippets_Misc/tpl_schedulers/cs/limitex1.cs#02)]
 [!code-vb[TPL_Schedulers#02](~/samples/snippets/visualbasic/VS_Snippets_Misc/tpl_schedulers/vb/module2.vb#02)]  
  
 <span data-ttu-id="ead8f-189">Además, varios programadores de tareas de ejemplo están disponibles en la Galería de código: [ejemplos de programación en paralelo con .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span><span class="sxs-lookup"><span data-stu-id="ead8f-189">In addition, several sample task schedulers are available on Code Gallery: [Samples for Parallel Programming with the .NET Framework 4](http://go.microsoft.com/fwlink/?LinkID=165717).</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="ead8f-190">Todos los miembros de la abstracta <see cref="T:System.Threading.Tasks.TaskScheduler" /> tipo son seguros para subprocesos y se pueden usar desde varios subprocesos simultáneamente.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ead8f-190">All members of the abstract <see cref="T:System.Threading.Tasks.TaskScheduler" /> type are thread-safe and may be used from multiple threads concurrently.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; TaskScheduler();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-191">Inicializa el <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-191">Initializes the <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Current" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Current" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Current As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Current { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-192">Obtiene el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-192">Gets the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ead8f-193">Devuelve el objeto <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado a la tarea que se está ejecutando actualmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-193">Returns the <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the currently executing task.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-194">Cuando no se llama desde dentro de una tarea, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> devolverá el <xref:System.Threading.Tasks.TaskScheduler.Default%2A> programador.</span><span class="sxs-lookup"><span data-stu-id="ead8f-194">When not called from within a task, <xref:System.Threading.Tasks.TaskScheduler.Current%2A> will return the <xref:System.Threading.Tasks.TaskScheduler.Default%2A> scheduler.</span></span>  
  
 <span data-ttu-id="ead8f-195">Para obtener más información, vea <xref:System.Threading.Tasks.TaskScheduler>.</span><span class="sxs-lookup"><span data-stu-id="ead8f-195">For more information, see <xref:System.Threading.Tasks.TaskScheduler>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Tasks.TaskScheduler Default" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Tasks::TaskScheduler ^ Default { System::Threading::Tasks::TaskScheduler ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-196">Obtiene la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" /> proporcionada por .NET Framework.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-196">Gets the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance that is provided by the .NET Framework.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ead8f-197">Devuelve la instancia predeterminada de <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-197">Returns the default <see cref="T:System.Threading.Tasks.TaskScheduler" /> instance.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-198">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-198">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TaskScheduler ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TaskScheduler ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="taskScheduler.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FromCurrentSynchronizationContext">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Tasks.TaskScheduler FromCurrentSynchronizationContext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromCurrentSynchronizationContext () As TaskScheduler" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::TaskScheduler ^ FromCurrentSynchronizationContext();" />
      <MemberSignature Language="F#" Value="static member FromCurrentSynchronizationContext : unit -&gt; System.Threading.Tasks.TaskScheduler" Usage="System.Threading.Tasks.TaskScheduler.FromCurrentSynchronizationContext " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.TaskScheduler</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-199">Crea un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociado con el <see cref="T:System.Threading.SynchronizationContext" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-199">Creates a <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ead8f-200">Un <see cref="T:System.Threading.Tasks.TaskScheduler" /> asociados con el <see cref="T:System.Threading.SynchronizationContext" /> actual, según lo determinado por <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-200">A <see cref="T:System.Threading.Tasks.TaskScheduler" /> associated with the current <see cref="T:System.Threading.SynchronizationContext" />, as determined by <see cref="P:System.Threading.SynchronizationContext.Current" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-201">Todos los <xref:System.Threading.Tasks.Task> instancias en cola para el valor devuelto se ejecutará el programador mediante una llamada a la <xref:System.Threading.SynchronizationContext.Post%2A> método en ese contexto.</span><span class="sxs-lookup"><span data-stu-id="ead8f-201">All <xref:System.Threading.Tasks.Task> instances queued to the returned scheduler will be executed through a call to the <xref:System.Threading.SynchronizationContext.Post%2A> method on that context.</span></span>  
  
 <span data-ttu-id="ead8f-202">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-202">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ead8f-203">El SynchronizationContext actual no puede usarse como TaskScheduler.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-203">The current SynchronizationContext may not be used as a TaskScheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetScheduledTasks">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt; GetScheduledTasks ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerable`1&lt;class System.Threading.Tasks.Task&gt; GetScheduledTasks() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.GetScheduledTasks" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetScheduledTasks () As IEnumerable(Of Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerable&lt;System::Threading::Tasks::Task ^&gt; ^ GetScheduledTasks();" />
      <MemberSignature Language="F#" Value="abstract member GetScheduledTasks : unit -&gt; seq&lt;System.Threading.Tasks.Task&gt;" Usage="taskScheduler.GetScheduledTasks " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Threading.Tasks.Task&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-204">Solo por compatibilidad con el depurador, genera un enumerable de las instancias de <see cref="T:System.Threading.Tasks.Task" /> que se encuentran actualmente en la cola del programador a la espera de ser ejecutadas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-204">For debugger support only, generates an enumerable of <see cref="T:System.Threading.Tasks.Task" /> instances currently queued to the scheduler waiting to be executed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ead8f-205">Enumerable que permite a un depurador atravesar las tareas que se encuentran actualmente en la cola de este programador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-205">An enumerable that allows a debugger to traverse the tasks currently queued to this scheduler.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-206">Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para admitir la integración con los depuradores.</span><span class="sxs-lookup"><span data-stu-id="ead8f-206">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method in order to support integration with debuggers.</span></span> <span data-ttu-id="ead8f-207">.NET Framework solo invocará este método cuando el depurador solicita acceso a los datos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-207">This method will only be invoked by the .NET Framework when the debugger requests access to the data.</span></span> <span data-ttu-id="ead8f-208">El enumerable devuelto se puede atravesar por las utilidades para tener acceso a las tareas de depuración actualmente en la cola de este programador, habilitar el depurador para proporcionar una representación de esta información en la interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="ead8f-208">The enumerable returned will be traversed by debugging utilities to access the tasks currently queued to this scheduler, enabling the debugger to provide a representation of this information in the user interface.</span></span>  
  
 <span data-ttu-id="ead8f-209">Es importante tener en cuenta que, cuando se llama a este método, se bloquearán todos los otros subprocesos del proceso.</span><span class="sxs-lookup"><span data-stu-id="ead8f-209">It is important to note that, when this method is called, all other threads in the process will be frozen.</span></span> <span data-ttu-id="ead8f-210">Por lo tanto, es importante evitar la sincronización con otros subprocesos que puede dar lugar al bloqueo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-210">Therefore, it's important to avoid synchronization with other threads that may lead to blocking.</span></span> <span data-ttu-id="ead8f-211">Si la sincronización es necesaria y no puede adquirir el bloqueo en este método, debe producir una excepción para que el depurador no se bloquea.</span><span class="sxs-lookup"><span data-stu-id="ead8f-211">If synchronization is necessary, and you are unable to acquire the lock in this method, then you should throw an exception so that the debugger does not hang.</span></span> <span data-ttu-id="ead8f-212">El ejemplo siguiente muestra un posible enfoque en C#:</span><span class="sxs-lookup"><span data-stu-id="ead8f-212">The following example shows one possible approach in C#:</span></span>  
  
```  
protected override IEnumerable<Task> GetScheduledTasks()  
{  
    bool lockTaken = false;  
    try  
    {  
        Monitor.TryEnter(_syncObj, ref lockTaken);  
        if (lockTaken)  
        {  
            return _tasks.ToArray();  
        }  
        else throw new NotSupportedException();  
    }  
    finally  
    {  
    if (lockTaken) Monitor.Exit(_syncObj);  
    }}  
```  
  
 <span data-ttu-id="ead8f-213">Además, este método y el enumerable devuelto no debe modificar cualquier estado visible globalmente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-213">Additionally, this method and the enumerable returned must not modify any globally visible state.</span></span>  
  
 <span data-ttu-id="ead8f-214">El enumerable no devuelto nunca debería ser null.</span><span class="sxs-lookup"><span data-stu-id="ead8f-214">The returned enumerable should never be null.</span></span> <span data-ttu-id="ead8f-215">Si no hay actualmente ninguna tarea en cola, se debe devolver en su lugar un enumerable vacío.</span><span class="sxs-lookup"><span data-stu-id="ead8f-215">If there are currently no queued tasks, an empty enumerable should be returned instead.</span></span>  
  
 <span data-ttu-id="ead8f-216">Los desarrolladores que están implementando los depuradores personalizados no debe llamar a este método directamente, pero debe usar el método de contenedor interna `GetScheduledTasksForDebugger` en su lugar: `internal Task[] GetScheduledTasksForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="ead8f-216">Developers who are implementing custom debuggers shouldn't call this method directly, but should use the internal wrapper method `GetScheduledTasksForDebugger` instead: `internal Task[] GetScheduledTasksForDebugger()`.</span></span> <span data-ttu-id="ead8f-217">Este método contenedor devuelve una matriz de tareas en lugar de una colección enumerable.</span><span class="sxs-lookup"><span data-stu-id="ead8f-217">This wrapper method returns an array of tasks instead of an enumerable.</span></span> <span data-ttu-id="ead8f-218">Para recuperar una lista de programadores activos, utilice el método interno `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span><span class="sxs-lookup"><span data-stu-id="ead8f-218">To retrieve a list of active schedulers, use the internal method `internal static TaskScheduler[] GetTaskSchedulersForDebugger()`.</span></span> <span data-ttu-id="ead8f-219">Este método estático devuelve una matriz de todos los activos <xref:System.Threading.Tasks.TaskScheduler> instancias.</span><span class="sxs-lookup"><span data-stu-id="ead8f-219">This static method returns an array of all active <xref:System.Threading.Tasks.TaskScheduler> instances.</span></span> <span data-ttu-id="ead8f-220">A continuación, puede usar `GetScheduledTasksForDebugger` en cada instancia del programador para recuperar su lista de tareas programadas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-220">You can then use `GetScheduledTasksForDebugger` on each scheduler instance to retrieve its list of scheduled tasks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ead8f-221">Este programador no puede generar una lista de tareas en cola en este momento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-221">This scheduler is unable to generate a list of queued tasks at this time.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.Threading.Tasks.TaskScheduler.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-222">Obtiene el identificador único de este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-222">Gets the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ead8f-223">Devuelve el identificador único de este objeto <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-223">Returns the unique ID for this <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-224">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-224">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaximumConcurrencyLevel">
      <MemberSignature Language="C#" Value="public virtual int MaximumConcurrencyLevel { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 MaximumConcurrencyLevel" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property MaximumConcurrencyLevel As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int MaximumConcurrencyLevel { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaximumConcurrencyLevel : int" Usage="System.Threading.Tasks.TaskScheduler.MaximumConcurrencyLevel" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-225">Indica el nivel de simultaneidad máximo admitido por este <see cref="T:System.Threading.Tasks.TaskScheduler" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-225">Indicates the maximum concurrency level this <see cref="T:System.Threading.Tasks.TaskScheduler" /> is able to support.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ead8f-226">Devuelve un entero que representa el nivel máximo de simultaneidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-226">Returns an integer that represents the maximum concurrency level.</span>
          </span>
          <span data-ttu-id="ead8f-227">El programador predeterminado devuelve <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-227">The default scheduler returns <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-228">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-228">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="QueueTask">
      <MemberSignature Language="C#" Value="protected internal abstract void QueueTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void QueueTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.QueueTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; abstract void QueueTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member QueueTask : System.Threading.Tasks.Task -&gt; unit" Usage="taskScheduler.QueueTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="ead8f-229">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a poner en la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-229">The <see cref="T:System.Threading.Tasks.Task" /> to be queued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ead8f-230">Pone un objeto <see cref="T:System.Threading.Tasks.Task" /> en la cola del programador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-230">Queues a <see cref="T:System.Threading.Tasks.Task" /> to the scheduler.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-231">Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa este método para aceptar tareas que se programan en el programador.</span><span class="sxs-lookup"><span data-stu-id="ead8f-231">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this method to accept tasks being scheduled on the scheduler.</span></span>  
  
 <span data-ttu-id="ead8f-232">Una implementación típica almacenaría la tarea en una estructura de datos interna, que podría ser reparada por subprocesos que ejecutarían esas tareas en algún momento en el futuro.</span><span class="sxs-lookup"><span data-stu-id="ead8f-232">A typical implementation would store the task in an internal data structure, which would be serviced by threads that would execute those tasks at some time in the future.</span></span>  
  
 <span data-ttu-id="ead8f-233">Este método solo está pensado para ser llamado por .NET Framework y no debe llamarse directamente por la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="ead8f-233">This method is only meant to be called by the .NET Framework and should not be called directly by the derived class.</span></span> <span data-ttu-id="ead8f-234">Esto es necesario para mantener la coherencia del sistema.</span><span class="sxs-lookup"><span data-stu-id="ead8f-234">This is necessary for maintaining the consistency of the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ead8f-235">El argumento <paramref name="task" /> es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-235">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryDequeue">
      <MemberSignature Language="C#" Value="protected internal virtual bool TryDequeue (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance bool TryDequeue(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryDequeue(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual bool TryDequeue(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="abstract member TryDequeue : System.Threading.Tasks.Task -&gt; bool&#xA;override this.TryDequeue : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryDequeue task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="ead8f-236">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a quitar de la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-236">The <see cref="T:System.Threading.Tasks.Task" /> to be dequeued.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ead8f-237">Intenta quitar un objeto <see cref="T:System.Threading.Tasks.Task" /> de la cola de este programador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-237">Attempts to dequeue a <see cref="T:System.Threading.Tasks.Task" /> that was previously queued to this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ead8f-238">Valor booleano que indica si el argumento <paramref name="task" /> se quitó correctamente de la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-238">A Boolean denoting whether the <paramref name="task" /> argument was successfully dequeued.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-239">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-239">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 <span data-ttu-id="ead8f-240">Este método se puede ejecutar en un bloque finally; por lo tanto, debe devolver tan pronto como sea posible hasta que cualquier recursos como <xref:System.Threading.CancellationTokenRegistration> objetos puedan eliminar de manera oportuna.</span><span class="sxs-lookup"><span data-stu-id="ead8f-240">This method may execute in a finally block; therefore it should return as quickly as possible so that any resources such as <xref:System.Threading.CancellationTokenRegistration> objects can be disposed of in a timely manner.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ead8f-241">El argumento <paramref name="task" /> es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-241">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTask">
      <MemberSignature Language="C#" Value="protected bool TryExecuteTask (System.Threading.Tasks.Task task);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance bool TryExecuteTask(class System.Threading.Tasks.Task task) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTask(System.Threading.Tasks.Task)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; bool TryExecuteTask(System::Threading::Tasks::Task ^ task);" />
      <MemberSignature Language="F#" Value="member this.TryExecuteTask : System.Threading.Tasks.Task -&gt; bool" Usage="taskScheduler.TryExecuteTask task" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="ead8f-242">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-242">A <see cref="T:System.Threading.Tasks.Task" /> object to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ead8f-243">Intenta ejecutar el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado en este programador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-243">Attempts to execute the provided <see cref="T:System.Threading.Tasks.Task" /> on this scheduler.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ead8f-244">Valor booleano que es true si <paramref name="task" /> se ejecutó correctamente; de lo contrario, es false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-244">A Boolean that is true if <paramref name="task" /> was successfully executed, false if it was not.</span>
          </span>
          <span data-ttu-id="ead8f-245">Normalmente, los errores de ejecución son debidos a que la tarea ya se ha ejecutado anteriormente o está a punto de ser ejecutada por otro subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-245">A common reason for execution failure is that the task had previously been executed or is in the process of being executed by another thread.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-246">Las implementaciones del programador se proporcionan con <xref:System.Threading.Tasks.Task> instancias que se ejecutará a través la <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método o la <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ead8f-246">Scheduler implementations are provided with <xref:System.Threading.Tasks.Task> instances to be executed through either the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method or the <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline%2A> method.</span></span> <span data-ttu-id="ead8f-247">Cuando el programador considere adecuado para ejecutar la tarea proporcionada, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> debe usarse para hacerlo.</span><span class="sxs-lookup"><span data-stu-id="ead8f-247">When the scheduler deems it appropriate to run the provided task, <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> should be used to do so.</span></span> <span data-ttu-id="ead8f-248">TryExecuteTask controla todos los aspectos de la ejecución de una tarea, incluida la invocación de acción, control de excepciones, administración de Estados y control del ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="ead8f-248">TryExecuteTask handles all aspects of executing a task, including action invocation, exception handling, state management, and lifecycle control.</span></span>  
  
 <span data-ttu-id="ead8f-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> solo debe usarse para las tareas proporcionadas a este programador por la infraestructura de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="ead8f-249"><xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> must only be used for tasks provided to this scheduler by the .NET Framework infrastructure.</span></span> <span data-ttu-id="ead8f-250">No debe usarse para ejecutar tareas arbitrarias obtenidas a través de mecanismos personalizados.</span><span class="sxs-lookup"><span data-stu-id="ead8f-250">It should not be used to execute arbitrary tasks obtained through custom mechanisms.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ead8f-251">La <paramref name="task" /> no está asociada a este programador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-251">The <paramref name="task" /> is not associated with this scheduler.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryExecuteTaskInline">
      <MemberSignature Language="C#" Value="protected abstract bool TryExecuteTaskInline (System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryExecuteTaskInline(class System.Threading.Tasks.Task task, bool taskWasPreviouslyQueued) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.TaskScheduler.TryExecuteTaskInline(System.Threading.Tasks.Task,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryExecuteTaskInline(System::Threading::Tasks::Task ^ task, bool taskWasPreviouslyQueued);" />
      <MemberSignature Language="F#" Value="abstract member TryExecuteTaskInline : System.Threading.Tasks.Task * bool -&gt; bool" Usage="taskScheduler.TryExecuteTaskInline (task, taskWasPreviouslyQueued)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="task" Type="System.Threading.Tasks.Task" />
        <Parameter Name="taskWasPreviouslyQueued" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="task">
          <span data-ttu-id="ead8f-252">Objeto <see cref="T:System.Threading.Tasks.Task" /> que se va a ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-252">The <see cref="T:System.Threading.Tasks.Task" /> to be executed.</span>
          </span>
        </param>
        <param name="taskWasPreviouslyQueued">
          <span data-ttu-id="ead8f-253">Valor booleano que indica si la tarea se ha puesto anteriormente en la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-253">A Boolean denoting whether or not task has previously been queued.</span>
          </span>
          <span data-ttu-id="ead8f-254">Si este parámetro es True, la tarea se ha puesto en la cola (programado) anteriormente; si su valor es False, la tarea no se ha puesto anteriormente en la cola y esta llamada se realiza para ejecutar la tarea insertada sin ponerla en la cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-254">If this parameter is True, then the task may have been previously queued (scheduled); if False, then the task is known not to have been queued, and this call is being made in order to execute the task inline without queuing it.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ead8f-255">Determina si el objeto <see cref="T:System.Threading.Tasks.Task" /> especificado puede ejecutarse sincrónicamente en esta llamada y, en caso afirmativo, lo ejecuta.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-255">Determines whether the provided <see cref="T:System.Threading.Tasks.Task" /> can be executed synchronously in this call, and if it can, executes it.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ead8f-256">Valor booleano que indica si se ejecutó la tarea alineada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-256">A Boolean value indicating whether the task was executed inline.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-257">Una clase derivada de <xref:System.Threading.Tasks.TaskScheduler> implementa esta función para admitir la ejecución en línea de una tarea en un subproceso que inicia una espera en ese objeto de tarea.</span><span class="sxs-lookup"><span data-stu-id="ead8f-257">A class derived from <xref:System.Threading.Tasks.TaskScheduler> implements this function to support inline execution of a task on a thread that initiates a wait on that task object.</span></span> <span data-ttu-id="ead8f-258">Ejecución insertada es opcional y se puede rechazar la solicitud y devuelve false.</span><span class="sxs-lookup"><span data-stu-id="ead8f-258">Inline execution is optional, and the request may be rejected by returning false.</span></span> <span data-ttu-id="ead8f-259">Sin embargo, las tareas más que pueden insertarse, mejor será el programador se escalará.</span><span class="sxs-lookup"><span data-stu-id="ead8f-259">However, the more tasks that can be inlined, the better the scheduler will scale.</span></span> <span data-ttu-id="ead8f-260">De hecho, un programador que inlines demasiado poco puedan ser propensas a interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="ead8f-260">In fact, a scheduler that inlines too little may be prone to deadlocks.</span></span> <span data-ttu-id="ead8f-261">Debe asegurarse de que una solicitud que se ejecuta bajo las directivas que se garantiza que el programador correctamente puede insertar una implementación apropiada.</span><span class="sxs-lookup"><span data-stu-id="ead8f-261">A proper implementation should ensure that a request executing under the policies guaranteed by the scheduler can successfully inline.</span></span> <span data-ttu-id="ead8f-262">Por ejemplo, si un programador utiliza un subproceso dedicado para ejecutar tareas, las solicitudes de inserción desde ese subproceso deberían realizarse correctamente.</span><span class="sxs-lookup"><span data-stu-id="ead8f-262">For example, if a scheduler uses a dedicated thread to execute tasks, any inlining requests from that thread should succeed.</span></span>  
  
 <span data-ttu-id="ead8f-263">Si un programador decide llevar a cabo la ejecución en línea, deberá hacerlo mediante una llamada a la TaskScheduler base <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> método con el objeto de tarea proporcionado, propagando el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="ead8f-263">If a scheduler decides to perform the inline execution, it should do so by calling to the base TaskScheduler's <xref:System.Threading.Tasks.TaskScheduler.TryExecuteTask%2A> method with the provided task object, propagating the return value.</span></span> <span data-ttu-id="ead8f-264">También puede ser adecuado para el programador quitar una tarea insertada de sus estructuras de datos internas si decide aceptar la solicitud de inserción.</span><span class="sxs-lookup"><span data-stu-id="ead8f-264">It may also be appropriate for the scheduler to remove an inlined task from its internal data structures if it decides to honor the inlining request.</span></span> <span data-ttu-id="ead8f-265">Sin embargo, tenga en cuenta que en algunas circunstancias un programador puede que se pida a una tarea que no se proporcionó anteriormente a él con el <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ead8f-265">Note, however, that under some circumstances a scheduler may be asked to inline a task that was not previously provided to it with the <xref:System.Threading.Tasks.TaskScheduler.QueueTask%2A> method.</span></span>  
  
 <span data-ttu-id="ead8f-266">El programador derivado es responsabilidad suya asegurarse de que el subproceso de llamada es adecuado para ejecutar la tarea determinada en cuanto a su propia programación y se refiere a las directivas de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ead8f-266">The derived scheduler is responsible for making sure that the calling thread is suitable for executing the given task as far as its own scheduling and execution policies are concerned.</span></span>  
  
 <span data-ttu-id="ead8f-267">Para obtener más información, consulte [TaskScheduler](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span><span class="sxs-lookup"><span data-stu-id="ead8f-267">For more information, see [Task Schedulers](http://msdn.microsoft.com/library/638f8ea5-21db-47a2-a934-86e1e961bf65).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ead8f-268">El argumento <paramref name="task" /> es null.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-268">The <paramref name="task" /> argument is null.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="ead8f-269">La <paramref name="task" /> ya se ejecutó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-269">The <paramref name="task" /> was already executed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UnobservedTaskException">
      <MemberSignature Language="C#" Value="public static event EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; UnobservedTaskException" />
      <MemberSignature Language="DocId" Value="E:System.Threading.Tasks.TaskScheduler.UnobservedTaskException" />
      <MemberSignature Language="VB.NET" Value="Public Shared Custom Event UnobservedTaskException As EventHandler(Of UnobservedTaskExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static event EventHandler&lt;System::Threading::Tasks::UnobservedTaskExceptionEventArgs ^&gt; ^ UnobservedTaskException;" />
      <MemberSignature Language="F#" Value="member this.UnobservedTaskException : EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " Usage="member this.UnobservedTaskException : System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Threading.Tasks.UnobservedTaskExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ead8f-270">Se produce cuando la excepción no observada de un error de la tarea está a punto de desencadenar la directiva de escalado de excepción que, de forma predeterminada, finalizaría el proceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ead8f-270">Occurs when a faulted task's unobserved exception is about to trigger exception escalation policy, which, by default, would terminate the process.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ead8f-271">Este evento de todo el dominio de aplicación proporciona un mecanismo para evitar que la directiva de elevación de excepciones (que, de forma predeterminada, finaliza el proceso) de desencadenamiento.</span><span class="sxs-lookup"><span data-stu-id="ead8f-271">This application domain-wide event provides a mechanism to prevent exception escalation policy (which, by default, terminates the process) from triggering.</span></span>  
  
 <span data-ttu-id="ead8f-272">Para facilitar a los desarrolladores escribir código asincrónico basado en tareas, el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] cambia el comportamiento de excepción predeterminado para las excepciones no observadas.</span><span class="sxs-lookup"><span data-stu-id="ead8f-272">To make it easier for developers to write asynchronous code based on tasks, the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] changes the default exception behavior for unobserved exceptions.</span></span> <span data-ttu-id="ead8f-273">Aunque todavía excepciones no observadas elevar el <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> excepción, el proceso no finaliza de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="ead8f-273">Although unobserved exceptions still raise the <xref:System.Threading.Tasks.TaskScheduler.UnobservedTaskException> exception, the process does not terminate by default.</span></span> <span data-ttu-id="ead8f-274">En su lugar, el tiempo de ejecución se controla la excepción después de que se genera el evento, independientemente de si un controlador de eventos observa la excepción.</span><span class="sxs-lookup"><span data-stu-id="ead8f-274">Instead, the exception is handled by the runtime after the event is raised, regardless of whether an event handler observes the exception.</span></span> <span data-ttu-id="ead8f-275">Este comportamiento se puede configurar.</span><span class="sxs-lookup"><span data-stu-id="ead8f-275">This behavior can be configured.</span></span> <span data-ttu-id="ead8f-276">A partir de la [!INCLUDE[net_v45](~/includes/net-v45-md.md)], puede usar el elemento de configuración para revertir al comportamiento de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] y terminar el proceso:</span><span class="sxs-lookup"><span data-stu-id="ead8f-276">Starting with the [!INCLUDE[net_v45](~/includes/net-v45-md.md)], you can use the  configuration element to revert to the behavior of the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] and terminate the process:</span></span>  
  
```xml  
<configuration>   
   <runtime>   
      <ThrowUnobservedTaskExceptions enabled="true"/>   
   </runtime>   
</configuration>  
  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>