<Type Name="Parallel" FullName="System.Threading.Tasks.Parallel">
  <Metadata><Meta Name="ms.openlocfilehash" Value="53ac17ab6443b9650b8e9acf8ee50cc6bf4113af" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58683083" /></Metadata><TypeSignature Language="C#" Value="public static class Parallel" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Parallel extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Parallel" />
  <TypeSignature Language="VB.NET" Value="Public Class Parallel" />
  <TypeSignature Language="C++ CLI" Value="public ref class Parallel abstract sealed" />
  <TypeSignature Language="F#" Value="type Parallel = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="31ecd-101">Proporciona compatibilidad con regiones y bucles paralelos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-101">Provides support for parallel loops and regions.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-102">La <xref:System.Threading.Tasks.Parallel> clase proporciona reemplazos en paralelo de datos basados en la biblioteca para operaciones comunes como bucles, para cada bucles y la ejecución de un conjunto de instrucciones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-102">The <xref:System.Threading.Tasks.Parallel> class provides library-based data parallel replacements for common operations such as for loops, for each loops, and execution of a set of statements.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-103">Este ejemplo muestra varios enfoques para implementar un bucle paralelo mediante varias construcciones de lenguaje.</span><span class="sxs-lookup"><span data-stu-id="31ecd-103">This example demonstrates several approaches to implementing a parallel loop using multiple language constructs.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#07](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelintro.cs#07)]
 [!code-vb[System.Threading.Tasks.Parallel#07](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelintro.vb#07)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="31ecd-104">Todos los miembros públicos y protegidos de <see cref="T:System.Threading.Tasks.Parallel" /> son seguros para subprocesos y se pueden usar simultáneamente desde varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-104">All public and protected members of <see cref="T:System.Threading.Tasks.Parallel" /> are thread-safe and may be used concurrently from multiple threads.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/parallel-programming/data-parallelism-task-parallel-library.md"><span data-ttu-id="31ecd-105">Paralelismo de datos (biblioteca TPL)</span><span class="sxs-lookup"><span data-stu-id="31ecd-105">Data Parallelism (Task Parallel Library)</span></span></related>
    <related type="ExternalDocumentation" href="https://code.msdn.microsoft.com/Samples-for-Parallel-b4b76364"><span data-ttu-id="31ecd-106">Ejemplos de programación paralela con .NET Framework</span><span class="sxs-lookup"><span data-stu-id="31ecd-106">Samples for Parallel Programming with the .NET Framework</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="For">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31ecd-107">Ejecuta un bucle <see langword="for" /> en el que es posible ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-107">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-108">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-108">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-109">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-109">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-110">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-110">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-111">Ejecuta una bucle <see langword="for" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-111">Executes a <see langword="for" /> loop in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-112">Estructura que contiene información sobre la parte del bucle que se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-112">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-113">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-113">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-114">Se proporciona con dos argumentos:</span><span class="sxs-lookup"><span data-stu-id="31ecd-114">It is provided with two arguments:</span></span>  
  
-   <span data-ttu-id="31ecd-115">Un <xref:System.Int32> valor que representa el número de iteraciones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-115">An <xref:System.Int32> value that represents the iteration count.</span></span>  
  
-   <span data-ttu-id="31ecd-116">Un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede usarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-116">A <xref:System.Threading.Tasks.ParallelLoopState> instance that can be used to break out of the loop prematurely.</span></span> <span data-ttu-id="31ecd-117">El <xref:System.Threading.Tasks.ParallelLoopState> el compilador crea el objeto; no se puede crear una instancia en el código de usuario.</span><span class="sxs-lookup"><span data-stu-id="31ecd-117">The <xref:System.Threading.Tasks.ParallelLoopState> object is created by the compiler; it cannot be instantiated in user code.</span></span>  
  
 <span data-ttu-id="31ecd-118">Una llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informa al método el `for` operación que iteraciones después del actual no tienen que ejecutar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-118">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to execute.</span></span> <span data-ttu-id="31ecd-119">Sin embargo, todas las iteraciones antes de la actual uno todavía tendrá que será ejecutada si no lo han hecho ya.</span><span class="sxs-lookup"><span data-stu-id="31ecd-119">However, all iterations before the current one will still have to be executed if they haven't already.</span></span>  
  
 <span data-ttu-id="31ecd-120">Por lo tanto, una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> es similar al uso de una operación de salto dentro de un convencional `for` bucle en un lenguaje como C#, pero no es un sustituto perfecto: Por ejemplo, no hay ninguna garantía de que las iteraciones después actual no se ejecutará sin duda.</span><span class="sxs-lookup"><span data-stu-id="31ecd-120">Therefore, calling <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="31ecd-121">Si la ejecución de todas las iteraciones antes de que el actual no es necesario, use la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método en lugar de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="31ecd-121">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="31ecd-122">Una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa a la `for` bucle que puede abandonar todas las restantes iteraciones, independientemente de si antes o después de la iteración actual, dado que todos los necesarios ya se habrá cumplimentado trabajo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-122">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="31ecd-123">Sin embargo, como con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, no hay ninguna garantía con respecto a que no se ejecutarán otras iteraciones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-123">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="31ecd-124">Si un bucle finaliza prematuramente, el <xref:System.Threading.Tasks.ParallelLoopResult> estructura devuelta contendrá información relevante acerca de la finalización del bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-124">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="31ecd-125">Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-125">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-126">El ejemplo siguiente ejecuta hasta 100 iteraciones de un bucle en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-126">The following example executes up to 100 iterations of a loop in parallel.</span></span> <span data-ttu-id="31ecd-127">Cada iteración se pausa durante un intervalo aleatorio entre 1 y 1000 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-127">Each iteration pauses for a random interval from 1 to 1,000 milliseconds.</span></span> <span data-ttu-id="31ecd-128">Un valor generado aleatoriamente que se determina en qué iteración del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="31ecd-128">A randomly generated value determines on which iteration of the loop the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="31ecd-129">Como la salida muestra el ejemplo, no hay iteraciones cuyo índice es mayor que el <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> inicio del valor de propiedad después de llamar a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="31ecd-129">As the output from the example shows, no iterations whose index is greater than the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property value start after the call to the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/cs/break1.cs#2)]
 [!code-vb[System.Threading.Tasks.ParallelLoopState#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallelloopstate/vb/break1.vb#2)]  
  
 <span data-ttu-id="31ecd-130">Porque todavía es posible que se ejecuta cuando las iteraciones del bucle el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> se llama al método, las llamadas de cada iteración del <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> propiedad para comprobar si se llama otra iteración el <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="31ecd-130">Because iterations of the loop are still likely to be executing when the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method is called, each iteration calls the <xref:System.Threading.Tasks.ParallelLoopState.ShouldExitCurrentIteration%2A?displayProperty=nameWithType> property to check whether another iteration has called the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="31ecd-131">Si el valor de propiedad es `true`, la iteración comprueba el valor de la <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> propiedad y, si es mayor que el valor de índice de la iteración actual, se devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-131">If  the property value is `true`, the iteration checks the value of the <xref:System.Threading.Tasks.ParallelLoopState.LowestBreakIteration%2A?displayProperty=nameWithType> property and, if it is greater than the current iteration's index value, returns immediately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-132">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-132">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-133">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-133">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <altmember cref="T:System.Threading.Tasks.ParallelLoopState" />
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-134">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-134">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Action{System.Int32})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Integer, toExclusive As Integer, body As Action(Of Integer)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-135">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-135">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-136">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-136">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-137">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-137">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-138">Ejecuta un bucle <see langword="for" /> en el que es posible ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-138">Executes a <see langword="for" /> loop in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="31ecd-139">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-139">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-140">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-140">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-141">Se proporciona con el número de iteraciones (<xref:System.Int32>) como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-141">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="31ecd-142">Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-142">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-143">En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Parallel.For%2A> método las 100 invocaciones de un delegado que genera los bytes aleatorios de los valores y calcula su suma.</span><span class="sxs-lookup"><span data-stu-id="31ecd-143">The following example uses the <xref:System.Threading.Tasks.Parallel.For%2A> method for 100 invocations of a delegate that generates random byte values and computes their sum.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/cs/for1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.For#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.for/vb/for1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-144">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-144">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-145">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-145">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-146">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-146">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-147">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-147">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-148">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-148">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-149">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-149">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-150">Ejecuta un bucle <see langword="for" /> con índices de 64 bits en el que es posible ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-150">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-151">Estructura <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> que contiene información sobre la parte completada del bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-151">A <see cref="T:System.Threading.Tasks.ParallelLoopResult" /> structure that contains information on what portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-152">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-152">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-153">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-153">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="31ecd-154">Una llamada a la <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> informa al método el `for` operación que iteraciones después del actual no tienen que ejecutarse, pero hacer todas las iteraciones antes del actual.</span><span class="sxs-lookup"><span data-stu-id="31ecd-154">Calling the <xref:System.Threading.Tasks.ParallelLoopState.Break%2A> method informs the `for` operation that iterations after the current one don't have to be executed, but all iterations before the current one do.</span></span>  
  
 <span data-ttu-id="31ecd-155">Por lo tanto, llamar a Break es similar al uso de una operación de salto dentro de un convencional `for` bucle en un lenguaje como C#, pero no es un sustituto perfecto: Por ejemplo, no hay ninguna garantía de que las iteraciones después actual no se ejecutará sin duda.</span><span class="sxs-lookup"><span data-stu-id="31ecd-155">Therefore, calling Break is similar to using a break operation within a conventional `for` loop in a language like C#, but it is not a perfect substitute: For example, there is no guarantee that iterations after the current one will definitely not execute.</span></span>  
  
 <span data-ttu-id="31ecd-156">Si la ejecución de todas las iteraciones antes de que el actual no es necesario, use la <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> método en lugar de usar <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span><span class="sxs-lookup"><span data-stu-id="31ecd-156">If executing all iterations before the current one is not necessary, use the <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> method instead of using <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>.</span></span> <span data-ttu-id="31ecd-157">Una llamada a <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informa a la `for` bucle que puede abandonar todas las restantes iteraciones, independientemente de si antes o después de la iteración actual, dado que todos los necesarios ya se habrá cumplimentado trabajo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-157">Calling <xref:System.Threading.Tasks.ParallelLoopState.Stop%2A> informs the `for` loop that it may abandon all remaining iterations, regardless of whether they're before or after the current iteration, because all required work will have already been completed.</span></span> <span data-ttu-id="31ecd-158">Sin embargo, como con <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, no hay ninguna garantía con respecto a que no se ejecutarán otras iteraciones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-158">However, as with <xref:System.Threading.Tasks.ParallelLoopState.Break%2A>, there are no guarantees regarding which other iterations will not execute.</span></span>  
  
 <span data-ttu-id="31ecd-159">Si un bucle finaliza prematuramente, el <xref:System.Threading.Tasks.ParallelLoopResult> estructura devuelta contendrá información relevante acerca de la finalización del bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-159">If a loop is ended prematurely, the <xref:System.Threading.Tasks.ParallelLoopResult> structure that is returned will contain relevant information about the loop's completion.</span></span>  
  
 <span data-ttu-id="31ecd-160">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-160">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-161">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-161">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-162">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-162">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-163">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-163">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Action{System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For (fromInclusive As Long, toExclusive As Long, body As Action(Of Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-164">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-164">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-165">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-165">The end index, exclusive.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-166">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-166">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-167">Ejecuta un bucle <see langword="for" /> con índices 64 bits en el que se pueden ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-167">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="31ecd-168">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-168">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-169">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-169">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-170">Se proporciona con el número de iteraciones (<xref:System.Int64>) como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-170">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="31ecd-171">Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-171">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-172">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-172">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-173">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-173">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-174">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-174">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int32, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-175">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-175">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-176">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-176">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-177">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-177">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-178">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-178">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-179">Ejecuta un bucle <see langword="for" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-179">Executes a <see langword="for" /> loop in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-180">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-180">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-181">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-181">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-182">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-182">It is provided with the following parameters: the iteration count (<xref:System.Int32>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="31ecd-183">Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-183">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-184"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-184">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-185">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-185">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-186">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-186">-or-</span></span> 
<span data-ttu-id="31ecd-187">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-187">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-188">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-188">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-189">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-189">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-190">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-190">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;int&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int32&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Action{System.Int32})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;int&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Action&lt;int&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int32&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-191">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-191">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-192">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-192">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-193">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-193">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-194">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-194">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-195">Ejecuta un bucle <see langword="for" /> en el que se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-195">Executes a <see langword="for" /> loop in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="31ecd-196">Estructura que contiene información sobre la parte del bucle que se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-196">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-197">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-197">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-198">Se proporciona con el número de iteraciones (<xref:System.Int32>) como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-198">It is provided with the iteration count (<xref:System.Int32>) as a parameter.</span></span>  
  
 <span data-ttu-id="31ecd-199">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-199">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-200">El ejemplo siguiente muestra cómo cancelar un bucle paralelo:</span><span class="sxs-lookup"><span data-stu-id="31ecd-200">The following example shows how to cancel a parallel loop:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#05](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforcancel.cs#05)]
 [!code-vb[System.Threading.Tasks.Parallel#05](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforcancel.vb#05)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-201"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-201">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-202">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-202">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-203">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-203">-or-</span></span> 
<span data-ttu-id="31ecd-204">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-204">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-205">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-205">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-206">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-206">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-207">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-207">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;int64, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-208">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-208">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-209">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-209">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-210">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-210">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-211">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-211">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-212">Ejecuta un bucle <see langword="for" /> con índices de 64 bits en el que es posible ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-212">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-213">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-213">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-214">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-214">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-215">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>) y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-215">It is provided with the following parameters: the iteration count (<xref:System.Int64>), and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 <span data-ttu-id="31ecd-216">Si `fromInclusive` es mayor o igual que `toExclusive`, el método vuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-216">If `fromInclusive` is greater than or equal to `toExclusive`, the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-217">El ejemplo siguiente muestra cómo usar el <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método con un <xref:System.Threading.Tasks.ParallelOptions> objeto:</span><span class="sxs-lookup"><span data-stu-id="31ecd-217">The following example shows how to use the <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method with a <xref:System.Threading.Tasks.ParallelOptions> object:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelfor.cs#03)]
 [!code-vb[System.Threading.Tasks.Parallel#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelfor.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-218"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-218">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-219">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-219">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-220">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-220">-or-</span></span> 
<span data-ttu-id="31ecd-221">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-221">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-222">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-222">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-223">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-223">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-224">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-224">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Action{System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Action&lt;int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;System.Int64&gt;" />
      </Parameters>
      <Docs>
        <param name="fromInclusive"><span data-ttu-id="31ecd-225">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-225">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-226">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-226">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-227">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-227">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-228">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-228">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-229">Ejecuta un bucle <see langword="for" /> con índices de 64 bits en el que se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-229">Executes a <see langword="for" /> loop with 64-bit indexes in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="31ecd-230">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-230">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-231">Admite índices de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="31ecd-231">Supports 64-bit indexes.</span></span> <span data-ttu-id="31ecd-232">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-232">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-233">Se proporciona con el número de iteraciones (<xref:System.Int64>) como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-233">It is provided with the iteration count (<xref:System.Int64>) as a parameter.</span></span>  
  
 <span data-ttu-id="31ecd-234">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-234">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-235">El ejemplo siguiente muestra cómo usar <xref:System.Threading.Tasks.ParallelOptions> para especificar un programador de tareas personalizado:</span><span class="sxs-lookup"><span data-stu-id="31ecd-235">The following example shows how to use <xref:System.Threading.Tasks.ParallelOptions> to specify a custom task scheduler:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#06](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforwithscheduler.cs#06)]
 [!code-vb[System.Threading.Tasks.Parallel#06](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforwithscheduler.vb#06)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-236"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-236">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-237">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-237">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-238">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-238">-or-</span></span> 
<span data-ttu-id="31ecd-239">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-239">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-240">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-240">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-241">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-241">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-242">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-242">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Integer, toExclusive As Integer, localInit As Func(Of TLocal), body As Func(Of Integer, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-243">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-243">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="31ecd-244">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-244">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-245">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-245">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-246">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-246">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-247">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-247">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-248">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-248">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-249">Ejecuta un bucle <see langword="for" /> con datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-249">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-250">Estructura que contiene información sobre la parte del bucle que se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-250">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-251">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-251">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-252">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-252">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-253">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-253">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-254">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-254">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-255">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-255">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-256">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-256">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-257">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-257">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-258">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-258">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-259">El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-259">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-260">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-260">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="31ecd-261">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-261">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="31ecd-262">Para obtener un ejemplo que usa este método, vea [Cómo: Escribir un bucle Parallel.For con variables locales de subproceso](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-262">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-263">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-263">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-264">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-264">-or-</span></span> 
<span data-ttu-id="31ecd-265">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-265">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-266">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-266">-or-</span></span> 
<span data-ttu-id="31ecd-267">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-267">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-268">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-268">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-269">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-269">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function For(Of TLocal) (fromInclusive As Long, toExclusive As Long, localInit As Func(Of TLocal), body As Func(Of Long, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-270">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-270">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="31ecd-271">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-271">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-272">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-272">The end index, exclusive.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-273">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-273">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-274">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-274">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-275">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-275">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-276">Ejecuta un bucle <see langword="for" /> con índices de 64 bits y datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-276">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-277">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-277">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-278">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-278">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-279">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en la misma tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-279">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="31ecd-280">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-280">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-281">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-281">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-282">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-282">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-283">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-283">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-284">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-284">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-285">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-285">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-286">El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-286">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-287">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-287">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="31ecd-288">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-288">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 <span data-ttu-id="31ecd-289">Para obtener un ejemplo que usa este método, vea [Cómo: Escribir un bucle Parallel.For con variables locales de subproceso](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-289">For an example that uses this method, see [How to: Write a Parallel.For Loop with Thread-Local Variables](~/docs/standard/parallel-programming/how-to-write-a-parallel-for-loop-with-thread-local-variables.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-290">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-290">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-291">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-291">-or-</span></span> 
<span data-ttu-id="31ecd-292">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-292">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-293">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-293">-or-</span></span> 
<span data-ttu-id="31ecd-294">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-294">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-295">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-295">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-296">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-296">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (int fromInclusive, int toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;int,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int32 fromInclusive, int32 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int32, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int32,System.Int32,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int32,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(int fromInclusive, int toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;int, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int * int * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int32" />
        <Parameter Name="toExclusive" Type="System.Int32" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int32,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-297">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-297">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="31ecd-298">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-298">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-299">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-299">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-300">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-300">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-301">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-301">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-302">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-302">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-303">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-303">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-304">Ejecuta un bucle <see langword="for" /> con datos locales del subproceso en que es posible ejecutar iteraciones en paralelo, se pueden configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-304">Executes a <see langword="for" /> loop with thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-305">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-305">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-306">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-306">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-307">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int32>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en la misma tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-307">It is provided with the following parameters: the iteration count (<xref:System.Int32>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same task.</span></span>  
  
 <span data-ttu-id="31ecd-308">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-308">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-309">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-309">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-310">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-310">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-311">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-311">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-312">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-312">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-313">Este delegado se puede invocar simultáneamente en varios subprocesos; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-313">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-314">El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-314">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-315">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-315">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="31ecd-316">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-316">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-317">El ejemplo siguiente utiliza variables locales de subproceso para calcular la suma de los resultados de muchas operaciones largas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-317">The following example uses thread-local variables to compute the sum of the results of many lengthy operations.</span></span> <span data-ttu-id="31ecd-318">Este ejemplo limita el grado de paralelismo a cuatro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-318">This example limits the degree of parallelism to four.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#04](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/threadlocalforwithoptions.cs#04)]
 [!code-vb[System.Threading.Tasks.Parallel#04](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/threadlocalforwithoptions.vb#04)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-319">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-319">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-320">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-320">-or-</span></span> 
<span data-ttu-id="31ecd-321">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-321">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-322">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-322">-or-</span></span> 
<span data-ttu-id="31ecd-323">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-323">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-324">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-324">-or-</span></span> 
<span data-ttu-id="31ecd-325">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-325">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-326"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-326">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-327">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-327">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-328">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-328">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-329">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-329">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="For&lt;TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt; (long fromInclusive, long toExclusive, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;long,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult For&lt;TLocal&gt;(int64 fromInclusive, int64 toExclusive, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;int64, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.For``1(System.Int64,System.Int64,System.Threading.Tasks.ParallelOptions,System.Func{``0},System.Func{System.Int64,System.Threading.Tasks.ParallelLoopState,``0,``0},System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult For(long fromInclusive, long toExclusive, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;long, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member For : int64 * int64 * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;int64, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.For (fromInclusive, toExclusive, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="fromInclusive" Type="System.Int64" />
        <Parameter Name="toExclusive" Type="System.Int64" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;System.Int64,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-330">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-330">The type of the thread-local data.</span></span></typeparam>
        <param name="fromInclusive"><span data-ttu-id="31ecd-331">Índice inicial, inclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-331">The start index, inclusive.</span></span></param>
        <param name="toExclusive"><span data-ttu-id="31ecd-332">Índice final, exclusivo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-332">The end index, exclusive.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-333">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-333">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-334">Delegado de función que devuelve el estado inicial de los datos locales de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-334">The function delegate that returns the initial state of the local data for each thread.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-335">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-335">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-336">Delegado que realiza una acción final en el estado local de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-336">The delegate that performs a final action on the local state of each thread.</span></span></param>
        <summary><span data-ttu-id="31ecd-337">Ejecuta un bucle <see langword="for" /> con índices de 64 bits y datos locales del subproceso en el que es posible ejecutar iteraciones en paralelo, se pueden configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-337">Executes a <see langword="for" /> loop with 64-bit indexes and thread-local data in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-338">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-338">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-339">El `body` delegado se invoca una vez para cada valor en el intervalo de iteración (`fromInclusive`, `toExclusive`).</span><span class="sxs-lookup"><span data-stu-id="31ecd-339">The `body` delegate is invoked once for each value in the iteration range (`fromInclusive`, `toExclusive`).</span></span> <span data-ttu-id="31ecd-340">Se proporciona con los siguientes parámetros: el número de iteraciones (<xref:System.Int64>), un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-340">It is provided with the following parameters: the iteration count (<xref:System.Int64>), a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-341">El `localInit` delegado se invoca una vez para cada subproceso que participa en la ejecución del bucle y devuelve el estado local inicial para cada uno de esos subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-341">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those threads.</span></span> <span data-ttu-id="31ecd-342">Estos estados iniciales se pasan a la primera `body` invocaciones en cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-342">These initial states are passed to the first `body` invocations on each thread.</span></span> <span data-ttu-id="31ecd-343">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-343">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-344">Por último, la última invocación de cuerpo en cada subproceso devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-344">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-345">El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-345">The `localFinally` delegate is invoked once per thread to perform a final action on each thread's local state.</span></span> <span data-ttu-id="31ecd-346">Este delegado se puede invocar simultáneamente en varios subprocesos; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-346">This delegate might be invoked concurrently on multiple threads; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-347">El <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-347">The <xref:System.Threading.Tasks.Parallel.For%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-348">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-348">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 <span data-ttu-id="31ecd-349">Si `fromInclusive` es mayor o igual que `toExclusive`, a continuación, el método devuelve inmediatamente sin realizar ninguna iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-349">If `fromInclusive` is greater than or equal to `toExclusive`, then the method returns immediately without performing any iterations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-350">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-350">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-351">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-351">-or-</span></span> 
<span data-ttu-id="31ecd-352">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-352">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-353">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-353">-or-</span></span> 
<span data-ttu-id="31ecd-354">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-354">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-355">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-355">-or-</span></span> 
<span data-ttu-id="31ecd-356">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-356">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-357"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-357">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-358">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-358">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-359">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-359">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-360">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-360">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ForEach&lt;TSource&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31ecd-361">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each " /> en Visual Basic) en la que es posible ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-361">Executes a <see langword="foreach" /> (<see langword="For Each " /> in Visual Basic) operation in which iterations may run in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As OrderablePartitioner(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-362">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-362">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-363">El particionador ordenable que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-363">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-364">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-364">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-365">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-365">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-366">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-366">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-367">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-367">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-368">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-368">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-369">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-369">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-370">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-370">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-371">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-371">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-372">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-372">-or-</span></span> 
<span data-ttu-id="31ecd-373">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-373">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-374">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-374">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-375">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-375">-or-</span></span> 
<span data-ttu-id="31ecd-376">La propiedad <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> del particionador ordenable de origen devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-376">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the source orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-377">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-377">-or-</span></span> 
<span data-ttu-id="31ecd-378">Cualquier método en el particionador ordenable de origen devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-378">Any methods in the source orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-379">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-379">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-380">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-380">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-381">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-381">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-382">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-382">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-383">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-383">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-384">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-384">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-385">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-385">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-386">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-386">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-387">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-387">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-388">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-388">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-389">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-389">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-390">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-390">-or-</span></span> 
<span data-ttu-id="31ecd-391">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-391">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-392">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-392">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-393">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-393">-or-</span></span> 
<span data-ttu-id="31ecd-394">Un método del particionador <paramref name="source" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-394">A method in the <paramref name="source" /> partitioner returns <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-395">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-395">-or-</span></span> 
<span data-ttu-id="31ecd-396">El método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> del particionador <paramref name="source" /> no devuelve el número correcto de particiones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-396">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-397">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-397">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As Partitioner(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-398">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-398">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-399">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-399">The partitioner that contains the original data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-400">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-400">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-401">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" />, en la que es posible ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-401">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="31ecd-402">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-402">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-403">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-403">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-404">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-404">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-405">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-405">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-406">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-406">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-407">El ejemplo siguiente muestra cómo implementar un particionador de rango para su uso con <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span><span class="sxs-lookup"><span data-stu-id="31ecd-407">The following example shows how to implement a range partitioner for use with <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType>:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/cs/rangepartitioner.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel_RangePartitioners#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel_rangepartitioners/vb/rangepart.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-408">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-408">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-409">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-409">-or-</span></span> 
<span data-ttu-id="31ecd-410">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-410">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-411">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-411">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-412">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-412">-or-</span></span> 
<span data-ttu-id="31ecd-413">La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-413">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-414">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-414">-or-</span></span> 
<span data-ttu-id="31ecd-415">El método <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> del particionador <paramref name="source" /> no devuelve el número correcto de particiones.</span><span class="sxs-lookup"><span data-stu-id="31ecd-415">The <see cref="M:System.Collections.Concurrent.Partitioner`1.GetPartitions(System.Int32)" /> method in the <paramref name="source" /> partitioner does not return the correct number of partitions.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-416">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-416">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState, Long)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-417">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-417">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-418">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-418">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-419">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-419">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-420">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-420">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-421">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-421">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-422">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-422">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-423">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y el índice del elemento actual (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="31ecd-423">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-424">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-424">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-425">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-425">-or-</span></span> 
<span data-ttu-id="31ecd-426">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-426">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-427">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-427">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-428">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-428">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource, ParallelLoopState)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-429">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-429">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-430">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-430">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-431">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-431">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-432">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-432">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-433">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-433">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-434">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-434">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-435">Se proporciona con los siguientes parámetros: el elemento actual y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-435">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-436">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-436">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-437">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-437">-or-</span></span> 
<span data-ttu-id="31ecd-438">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-438">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-439">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-439">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-440">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-440">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource) (source As IEnumerable(Of TSource), body As Action(Of TSource)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-441">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-441">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-442">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-442">An enumerable data source.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-443">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-443">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-444">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" />, en la que es posible ejecutar iteraciones en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-444">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel.</span></span></summary>
        <returns><span data-ttu-id="31ecd-445">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-445">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-446">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-446">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-447">Se proporciona con el elemento actual como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-447">It is provided with the current element as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-448">En el ejemplo siguiente se usa el <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> método para contar el número de caracteres que no sea un espacio en blanco en un archivo de texto y de las vocales.</span><span class="sxs-lookup"><span data-stu-id="31ecd-448">The following example uses the <xref:System.Threading.Tasks.Parallel.ForEach%60%601%28System.Collections.Generic.IEnumerable%7B%60%600%7D%2CSystem.Action%7B%60%600%7D%29> method to count the number of vowels and non-white-space characters in a text file.</span></span> <span data-ttu-id="31ecd-449">En este caso, el <xref:System.Threading.Tasks.ParallelLoopResult> se omite el valor devuelto por el método.</span><span class="sxs-lookup"><span data-stu-id="31ecd-449">In this case, the <xref:System.Threading.Tasks.ParallelLoopResult> value returned by the method is ignored.</span></span> <span data-ttu-id="31ecd-450">Tenga en cuenta que, dado que las operaciones se pueden ejecutar en paralelo, debe asegurarse de que incrementar las variables de contador es una operación atómica, y que varios subprocesos no intentan acceder a las variables de contador simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-450">Note that, because operations can run in parallel, you must ensure that incrementing the counter variables is an atomic operation, and that multiple threads do not attempt to access the counter variables simultaneously.</span></span> <span data-ttu-id="31ecd-451">Para este propósito, el ejemplo se usa el `lock` instrucción (en C#) y el `SyncLock` instrucción (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="31ecd-451">For this purpose, the example uses the `lock` statement (in C#) and the `SyncLock` statement (in Visual Basic).</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/cs/foreach1.cs#1)]
 [!code-vb[System.Threading.Tasks.Parallel.ForEach#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel.foreach/vb/foreach1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-452">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-452">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-453">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-453">-or-</span></span> 
<span data-ttu-id="31ecd-454">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-454">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-455">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-455">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-456">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-456">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-457">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-457">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-458">El particionador ordenable que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-458">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-459">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-459">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-460">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-460">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-461">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-461">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-462">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-462">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-463">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-463">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-464">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-464">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-465">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-465">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-466">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-466">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-467"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</span><span class="sxs-lookup"><span data-stu-id="31ecd-467">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-468">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-468">The <paramref name="source" /> argument is  <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-469">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-469">-or-</span></span> 
<span data-ttu-id="31ecd-470">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-470">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-471">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-471">-or-</span></span> 
<span data-ttu-id="31ecd-472">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-472">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-473">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-473">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-474">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-474">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-475">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-475">-or-</span></span> 
<span data-ttu-id="31ecd-476">La propiedad <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> del particionador ordenable <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-476">The <see cref="P:System.Collections.Concurrent.OrderablePartitioner`1.KeysNormalized" /> property in the <paramref name="source" /> orderable partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-477">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-477">-or-</span></span> 
<span data-ttu-id="31ecd-478">La excepción que se produce cuando cualquier método del particionador ordenable <paramref name="source" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-478">The exception that is thrown when any methods in the <paramref name="source" /> orderable partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-479">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-479">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-480">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-480">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-481">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-481">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-482">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-482">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-483">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-483">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-484">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-484">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-485">Estructura que contiene información sobre la parte del bucle que se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-485">A  structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-486">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-486">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-487">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-487">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-488">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-488">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-489">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-489">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-490"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-490">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-491">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-491">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-492">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-492">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-493">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-493">-or-</span></span> 
<span data-ttu-id="31ecd-494">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-494">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-495">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-495">-or-</span></span> 
<span data-ttu-id="31ecd-496">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-496">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-497">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-497">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-498">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-498">-or-</span></span> 
<span data-ttu-id="31ecd-499">La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-499">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-500">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-500">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-501">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-501">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-502">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-502">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-503">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-503">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-504">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-504">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-505">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-505">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="31ecd-506">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-506">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-507">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-507">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-508">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-508">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-509">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-509">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-510">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-510">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-511"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-511">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-512">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-512">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-513">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-513">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-514">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-514">-or-</span></span> 
<span data-ttu-id="31ecd-515">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-515">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-516">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-516">-or-</span></span> 
<span data-ttu-id="31ecd-517">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-517">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-518">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> del particionador <paramref name="source" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-518">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /> partitioner returns <see langword="false" />.</span></span>  
  
<span data-ttu-id="31ecd-519">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-519">-or-</span></span> 
<span data-ttu-id="31ecd-520">La excepción que se produce cuando cualquier método del particionador <paramref name="source" /> devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-520">The exception that is thrown when any methods in the <paramref name="source" /> partitioner return <see langword="null" />.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-521">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-521">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,long&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`3&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState,System.Int64})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-522">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-522">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-523">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-523">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-524">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-524">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-525">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-525">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-526">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) con índices de 64 bits en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-526">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-527">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-527">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-528">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-528">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-529">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y el índice del elemento actual (<xref:System.Int64>).</span><span class="sxs-lookup"><span data-stu-id="31ecd-529">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and the current element's index (<xref:System.Int64>).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-530"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</span><span class="sxs-lookup"><span data-stu-id="31ecd-530">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-531">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-531">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-532">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-532">-or-</span></span> 
<span data-ttu-id="31ecd-533">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-533">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-534">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-534">-or-</span></span> 
<span data-ttu-id="31ecd-535">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-535">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-536">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-536">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-537">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-537">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-538">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-538">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`2&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0,System.Threading.Tasks.ParallelLoopState})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource, System::Threading::Tasks::ParallelLoopState ^&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source, System.Threading.Tasks.ParallelLoopState&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource,System.Threading.Tasks.ParallelLoopState&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-539">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-539">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-540">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-540">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-541">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-541">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-542">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-542">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-543">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-543">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-544">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-544">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-545">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-545">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-546">Se proporciona con los siguientes parámetros: el elemento actual y un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para interrumpir el bucle prematuramente.</span><span class="sxs-lookup"><span data-stu-id="31ecd-546">It is provided with the following parameters: the current element, and a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-547"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</span><span class="sxs-lookup"><span data-stu-id="31ecd-547">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-548">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-548">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-549">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-549">-or-</span></span> 
<span data-ttu-id="31ecd-550">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-550">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-551">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-551">-or-</span></span> 
<span data-ttu-id="31ecd-552">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-552">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-553">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-553">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-554">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-554">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-555">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-555">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Action&lt;TSource&gt; body);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action`1&lt;!!TSource&gt; body) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``1(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Action{``0})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Action&lt;TSource&gt; ^ body);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Action&lt;'Source&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, body)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="body" Type="System.Action&lt;TSource&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-556">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-556">The type of the data in the source.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-557">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-557">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-558">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-558">An object that configures the behavior of this operation.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-559">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-559">The delegate that is invoked once per iteration.</span></span></param>
        <summary><span data-ttu-id="31ecd-560">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar las opciones de bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-560">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and loop options can be configured.</span></span></summary>
        <returns><span data-ttu-id="31ecd-561">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-561">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-562">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-562">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-563">Se proporciona con el elemento actual como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="31ecd-563">It is provided with the current element as a parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-564"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela</span><span class="sxs-lookup"><span data-stu-id="31ecd-564">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-565">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-565">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-566">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-566">-or-</span></span> 
<span data-ttu-id="31ecd-567">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-567">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-568">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-568">-or-</span></span> 
<span data-ttu-id="31ecd-569">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-569">The <paramref name="body" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-570">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-570">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-571">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-571">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-572">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-572">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As OrderablePartitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-573">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-573">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-574">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-574">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-575">El particionador ordenable que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-575">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-576">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-576">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-577">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-577">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-578">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-578">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-579">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-579">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-580">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-580">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-581">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-581">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-582">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-582">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-583">El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-583">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-584">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-584">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="31ecd-585">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-585">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-586">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-586">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-587">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-587">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-588">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-588">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-589">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-589">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-590">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-590">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-591">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-591">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-592">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-592">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-593">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-593">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-594">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-594">-or-</span></span> 
<span data-ttu-id="31ecd-595">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-595">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-596">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-596">-or-</span></span> 
<span data-ttu-id="31ecd-597">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-597">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-598">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-598">-or-</span></span> 
<span data-ttu-id="31ecd-599">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-599">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-600">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-600">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-601">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-601">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-602">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-602">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As Partitioner(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-603">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-603">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-604">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-604">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-605">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-605">The partitioner that contains the original data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-606">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-606">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-607">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-607">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-608">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-608">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-609">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-609">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-610">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-610">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-611">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-611">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-612">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-612">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-613">El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-613">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-614">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-614">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="31ecd-615">El `localInit` delegado se invoca una vez para cada subproceso que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-615">The `localInit` delegate is invoked once for each thread that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-616">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-616">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-617">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-617">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-618">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-618">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-619">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-619">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-620">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-620">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-621">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-621">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-622">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-622">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-623">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-623">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-624">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-624">-or-</span></span> 
<span data-ttu-id="31ecd-625">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-625">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-626">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-626">-or-</span></span> 
<span data-ttu-id="31ecd-627">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-627">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-628">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-628">-or-</span></span> 
<span data-ttu-id="31ecd-629">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-629">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-630">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-630">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-631">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-631">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-632">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-632">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, Long, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-633">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-633">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-634">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-634">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-635">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-635">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-636">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-636">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-637">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-637">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-638">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-638">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-639">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-639">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-640">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-640">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-641">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-641">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-642">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente, el índice del elemento actual (<xref:System.Int64>) y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-642">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-643">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-643">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-644">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-644">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-645">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-645">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-646">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-646">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-647">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-647">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-648">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-648">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-649">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-649">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-650">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-650">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-651">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-651">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-652">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-652">-or-</span></span> 
<span data-ttu-id="31ecd-653">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-653">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-654">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-654">-or-</span></span> 
<span data-ttu-id="31ecd-655">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-655">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-656">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-656">-or-</span></span> 
<span data-ttu-id="31ecd-657">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-657">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-658">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-658">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-659">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-659">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ForEach(Of TSource, TLocal) (source As IEnumerable(Of TSource), localInit As Func(Of TLocal), body As Func(Of TSource, ParallelLoopState, TLocal, TLocal), localFinally As Action(Of TLocal)) As ParallelLoopResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-660">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-660">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-661">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-661">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-662">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-662">An enumerable data source.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-663">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-663">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-664">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-664">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-665">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-665">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-666">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-666">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-667">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-667">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-668">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-668">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-669">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-669">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-670">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-670">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-671">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-671">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-672">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-672">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-673">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-673">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-674">El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-674">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-675">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-675">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-676">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-676">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-677">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-677">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-678">El ejemplo siguiente muestra cómo usar un <xref:System.Threading.Tasks.Parallel.ForEach%2A> método con el estado local:</span><span class="sxs-lookup"><span data-stu-id="31ecd-678">The following example shows how to use a <xref:System.Threading.Tasks.Parallel.ForEach%2A> method with local state:</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelforeach.cs#02)]
 [!code-vb[System.Threading.Tasks.Parallel#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelforeach.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-679">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-679">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-680">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-680">-or-</span></span> 
<span data-ttu-id="31ecd-681">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-681">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-682">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-682">-or-</span></span> 
<span data-ttu-id="31ecd-683">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-683">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-684">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-684">-or-</span></span> 
<span data-ttu-id="31ecd-685">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-685">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-686">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-686">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-687">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-687">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.OrderablePartitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.OrderablePartitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::OrderablePartitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.OrderablePartitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.OrderablePartitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-688">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-688">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-689">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-689">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-690">El particionador ordenable que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-690">The orderable partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-691">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-691">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-692">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-692">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-693">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-693">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-694">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-694">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-695">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-695">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with 64-bit indexes and  with thread-local data on a <see cref="T:System.Collections.Concurrent.OrderablePartitioner`1" /> in which iterations may run in parallel , loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-696">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-696">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-697">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-697">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-698">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-698">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-699">El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-699">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-700">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-700">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="31ecd-701">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-701">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-702">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-702">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-703">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-703">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-704">Por último, la última invocación de cuerpo en cada subproceso devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-704">Finally, the last body invocation on each thread returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-705">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-705">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-706">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-706">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-707">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-707">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-708">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-708">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-709">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-709">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-710">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-710">-or-</span></span> 
<span data-ttu-id="31ecd-711">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-711">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-712">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-712">-or-</span></span> 
<span data-ttu-id="31ecd-713">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-713">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-714">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-714">-or-</span></span> 
<span data-ttu-id="31ecd-715">El argumento <paramref name="localInit" /> o <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-715">The <paramref name="localInit" /> or <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-716">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-716">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-717">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-717">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-718"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-718">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-719">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-719">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-720">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-720">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Concurrent.Partitioner&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Concurrent.Partitioner`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Concurrent.Partitioner{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Concurrent::Partitioner&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : System.Collections.Concurrent.Partitioner&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Concurrent.Partitioner&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-721">Tipo de los elementos de <paramref name="source" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-721">The type of the elements in <paramref name="source" />.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-722">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-722">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-723">Particionador que contiene el origen de datos original.</span><span class="sxs-lookup"><span data-stu-id="31ecd-723">The partitioner that contains the original data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-724">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-724">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-725">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-725">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-726">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-726">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-727">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-727">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-728">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.Concurrent.Partitioner" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-728">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation  with thread-local data on a <see cref="T:System.Collections.Concurrent.Partitioner" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-729">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-729">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-730">Esta sobrecarga se proporciona para escenarios donde desea invalidar el valor predeterminado de esquema de partición.</span><span class="sxs-lookup"><span data-stu-id="31ecd-730">This overload is provided for scenarios where you want to override the default partitioning scheme.</span></span> <span data-ttu-id="31ecd-731">Por ejemplo, cuerpos de bucle pequeños podrían beneficiarse del particionamiento del intervalo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-731">For example, small loop bodies might benefit from partitioning the range.</span></span> <span data-ttu-id="31ecd-732">El <xref:System.Threading.Tasks.Parallel.ForEach%2A> método espera particionadores personalizados para admitir la creación de particiones dinámica.</span><span class="sxs-lookup"><span data-stu-id="31ecd-732">The <xref:System.Threading.Tasks.Parallel.ForEach%2A> method expects custom partitioners to support dynamic partitioning.</span></span> <span data-ttu-id="31ecd-733">Esta sobrecarga se proporciona para escenarios con cuerpos de bucle pequeños que podrían beneficiarse del particionamiento de intervalo estático.</span><span class="sxs-lookup"><span data-stu-id="31ecd-733">This overload is provided for scenarios with small loop bodies that might benefit from static range partitioning.</span></span> <span data-ttu-id="31ecd-734">Los particionadores debe admitir las particiones dinámicas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-734">Partitioners must support dynamic partitions.</span></span>  <span data-ttu-id="31ecd-735">Para obtener más información, consulte [particionadores personalizados para PLINQ y TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) y [Cómo: Implementar las particiones dinámicas](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-735">For more information, see [Custom Partitioners for PLINQ and TPL](~/docs/standard/parallel-programming/custom-partitioners-for-plinq-and-tpl.md) and [How to: Implement Dynamic Partitions](~/docs/standard/parallel-programming/how-to-implement-dynamic-partitions.md).</span></span>  
  
 <span data-ttu-id="31ecd-736">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-736">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-737">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-737">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-738">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-738">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-739">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-739">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-740">El `localFinally` delegado se invoca una vez por cada tarea para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-740">The `localFinally` delegate is invoked once per task to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-741">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-741">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-742">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-742">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-743">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-743">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-744">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-744">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-745">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-745">-or-</span></span> 
<span data-ttu-id="31ecd-746">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-746">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-747">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-747">-or-</span></span> 
<span data-ttu-id="31ecd-748">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-748">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-749">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-749">-or-</span></span> 
<span data-ttu-id="31ecd-750">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-750">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-751">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-751">-or-</span></span> 
<span data-ttu-id="31ecd-752">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-752">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="31ecd-753">La propiedad <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> de <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> devuelve <see langword="false" /> o el particionador devuelve particiones <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-753">The <see cref="P:System.Collections.Concurrent.Partitioner`1.SupportsDynamicPartitions" /> property in the <paramref name="source" /><see cref="T:System.Collections.Concurrent.Partitioner" /> returns <see langword="false" /> or the partitioner returns <see langword="null" /> partitions.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-754">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-754">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-755"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-755">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-756">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-756">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-757">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-757">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,long,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`5&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, int64, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,System.Int64,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, long, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, int64, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,System.Int64,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-758">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-758">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-759">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-759">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-760">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-760">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-761">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-761">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-762">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-762">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-763">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-763">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-764">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-764">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-765">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con índices de 64 bits y datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-765">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data and 64-bit indexes on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-766">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-766">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-767">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-767">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-768">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente, el índice del elemento actual (<xref:System.Int64>) y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-768">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, the current element's index (<xref:System.Int64>), and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-769">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-769">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-770">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-770">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-771">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-771">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-772">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-772">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-773">El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-773">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-774">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-774">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-775">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-775">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-776">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-776">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-777">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-777">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-778">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-778">-or-</span></span> 
<span data-ttu-id="31ecd-779">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-779">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-780">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-780">-or-</span></span> 
<span data-ttu-id="31ecd-781">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-781">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-782">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-782">-or-</span></span> 
<span data-ttu-id="31ecd-783">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-783">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-784">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-784">-or-</span></span> 
<span data-ttu-id="31ecd-785">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-785">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-786"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-786">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-787">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-787">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-788">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-788">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-789">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-789">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ForEach&lt;TSource,TLocal&gt;">
      <MemberSignature Language="C#" Value="public static System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource,TLocal&gt; (System.Collections.Generic.IEnumerable&lt;TSource&gt; source, System.Threading.Tasks.ParallelOptions parallelOptions, Func&lt;TLocal&gt; localInit, Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt; body, Action&lt;TLocal&gt; localFinally);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Threading.Tasks.ParallelLoopResult ForEach&lt;TSource, TLocal&gt;(class System.Collections.Generic.IEnumerable`1&lt;!!TSource&gt; source, class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Func`1&lt;!!TLocal&gt; localInit, class System.Func`4&lt;!!TSource, class System.Threading.Tasks.ParallelLoopState, !!TLocal, !!TLocal&gt; body, class System.Action`1&lt;!!TLocal&gt; localFinally) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.ForEach``2(System.Collections.Generic.IEnumerable{``0},System.Threading.Tasks.ParallelOptions,System.Func{``1},System.Func{``0,System.Threading.Tasks.ParallelLoopState,``1,``1},System.Action{``1})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TSource, typename TLocal&gt;&#xA; static System::Threading::Tasks::ParallelLoopResult ForEach(System::Collections::Generic::IEnumerable&lt;TSource&gt; ^ source, System::Threading::Tasks::ParallelOptions ^ parallelOptions, Func&lt;TLocal&gt; ^ localInit, Func&lt;TSource, System::Threading::Tasks::ParallelLoopState ^, TLocal, TLocal&gt; ^ body, Action&lt;TLocal&gt; ^ localFinally);" />
      <MemberSignature Language="F#" Value="static member ForEach : seq&lt;'Source&gt; * System.Threading.Tasks.ParallelOptions * Func&lt;'Local&gt; * Func&lt;'Source, System.Threading.Tasks.ParallelLoopState, 'Local, 'Local&gt; * Action&lt;'Local&gt; -&gt; System.Threading.Tasks.ParallelLoopResult" Usage="System.Threading.Tasks.Parallel.ForEach (source, parallelOptions, localInit, body, localFinally)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.ParallelLoopResult</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TSource" />
        <TypeParameter Name="TLocal" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="source" Type="System.Collections.Generic.IEnumerable&lt;TSource&gt;" />
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="localInit" Type="System.Func&lt;TLocal&gt;" />
        <Parameter Name="body" Type="System.Func&lt;TSource,System.Threading.Tasks.ParallelLoopState,TLocal,TLocal&gt;" />
        <Parameter Name="localFinally" Type="System.Action&lt;TLocal&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="TSource"><span data-ttu-id="31ecd-790">El tipo de los datos del origen.</span><span class="sxs-lookup"><span data-stu-id="31ecd-790">The type of the data in the source.</span></span></typeparam>
        <typeparam name="TLocal"><span data-ttu-id="31ecd-791">Tipo de los datos locales de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-791">The type of the thread-local data.</span></span></typeparam>
        <param name="source"><span data-ttu-id="31ecd-792">Origen de datos enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-792">An enumerable data source.</span></span></param>
        <param name="parallelOptions"><span data-ttu-id="31ecd-793">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-793">An object that configures the behavior of this operation.</span></span></param>
        <param name="localInit"><span data-ttu-id="31ecd-794">Delegado de función que devuelve el estado inicial de los datos locales de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-794">The function delegate that returns the initial state of the local data for each task.</span></span></param>
        <param name="body"><span data-ttu-id="31ecd-795">Delegado que se invoca una vez por cada iteración.</span><span class="sxs-lookup"><span data-stu-id="31ecd-795">The delegate that is invoked once per iteration.</span></span></param>
        <param name="localFinally"><span data-ttu-id="31ecd-796">Delegado que realiza una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-796">The delegate that performs a final action on the local state of each task.</span></span></param>
        <summary><span data-ttu-id="31ecd-797">Ejecuta una operación <see langword="foreach" /> (<see langword="For Each" /> en Visual Basic) con datos locales del subproceso en <see cref="T:System.Collections.IEnumerable" /> donde se pueden ejecutar iteraciones en paralelo y configurar opciones de bucle, y el estado del bucle se puede supervisar y manipular.</span><span class="sxs-lookup"><span data-stu-id="31ecd-797">Executes a <see langword="foreach" /> (<see langword="For Each" /> in Visual Basic) operation with thread-local data on an <see cref="T:System.Collections.IEnumerable" /> in which iterations may run in parallel, loop options can be configured, and the state of the loop can be monitored and manipulated.</span></span></summary>
        <returns><span data-ttu-id="31ecd-798">Estructura que contiene información sobre qué parte del bucle se ha completado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-798">A structure that contains information about which portion of the loop completed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-799">El `body` delegado se invoca una vez para cada elemento de la `source` enumerable.</span><span class="sxs-lookup"><span data-stu-id="31ecd-799">The `body` delegate is invoked once for each element in the `source` enumerable.</span></span> <span data-ttu-id="31ecd-800">Se proporciona con los siguientes parámetros: el elemento actual, un <xref:System.Threading.Tasks.ParallelLoopState> instancia que puede utilizarse para salir del bucle prematuramente y algún estado local, que se puede compartir entre las iteraciones que se ejecutan en el mismo subproceso.</span><span class="sxs-lookup"><span data-stu-id="31ecd-800">It is provided with the following parameters: the current element, a <xref:System.Threading.Tasks.ParallelLoopState> instance that may be used to break out of the loop prematurely, and some local state that may be shared amongst iterations that execute on the same thread.</span></span>  
  
 <span data-ttu-id="31ecd-801">El `localInit` delegado se invoca una vez para cada tarea que participa en la ejecución del bucle y devuelve el estado local inicial para cada una de esas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-801">The `localInit` delegate is invoked once for each task that participates in the loop's execution and returns the initial local state for each of those tasks.</span></span> <span data-ttu-id="31ecd-802">Estos estados iniciales se pasan a la primera `body` las invocaciones de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-802">These initial states are passed to the first `body` invocations on each task.</span></span> <span data-ttu-id="31ecd-803">A continuación, cada invocación de cuerpo subsiguiente devuelve un valor de estado posiblemente modificado que se pasa a la siguiente invocación de cuerpo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-803">Then, every subsequent body invocation returns a possibly modified state value that is passed to the next body invocation.</span></span> <span data-ttu-id="31ecd-804">Por último, la última invocación de cuerpo en cada tarea devuelve un valor de estado que se pasa a la `localFinally` delegar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-804">Finally, the last body invocation on each task returns a state value that is passed to the `localFinally` delegate.</span></span> <span data-ttu-id="31ecd-805">El `localFinally` delegado se invoca una vez por subproceso para realizar una acción final en el estado local de cada tarea.</span><span class="sxs-lookup"><span data-stu-id="31ecd-805">The `localFinally` delegate is invoked once per thread to perform a final action on each task's local state.</span></span> <span data-ttu-id="31ecd-806">Este delegado se podría invocar simultáneamente en varias tareas; por lo tanto, se debe sincronizar el acceso a cualquier variable compartida.</span><span class="sxs-lookup"><span data-stu-id="31ecd-806">This delegate might be invoked concurrently on multiple tasks; therefore, you must synchronize access to any shared variables.</span></span>  
  
 <span data-ttu-id="31ecd-807">El <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> método puede usar más tareas que los subprocesos durante la vigencia de su ejecución, como las tareas existentes completadas y se reemplazan con nuevas tareas.</span><span class="sxs-lookup"><span data-stu-id="31ecd-807">The <xref:System.Threading.Tasks.Parallel.ForEach%2A?displayProperty=nameWithType> method may use more tasks than threads over the lifetime of its execution, as existing tasks complete and are replaced by new tasks.</span></span> <span data-ttu-id="31ecd-808">Esto proporciona subyacente <xref:System.Threading.Tasks.TaskScheduler> objeto la oportunidad de agregar, cambiar o quitar los subprocesos que dan servicio el bucle.</span><span class="sxs-lookup"><span data-stu-id="31ecd-808">This gives the underlying <xref:System.Threading.Tasks.TaskScheduler> object the chance to add, change, or remove threads that service the loop.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-809">El argumento <paramref name="source" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-809">The <paramref name="source" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-810">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-810">-or-</span></span> 
<span data-ttu-id="31ecd-811">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-811">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-812">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-812">-or-</span></span> 
<span data-ttu-id="31ecd-813">El argumento <paramref name="body" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-813">The <paramref name="body" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-814">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-814">-or-</span></span> 
<span data-ttu-id="31ecd-815">El argumento <paramref name="localInit" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-815">The <paramref name="localInit" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-816">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-816">-or-</span></span> 
<span data-ttu-id="31ecd-817">El argumento <paramref name="localFinally" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-817">The <paramref name="localFinally" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-818"><see cref="T:System.Threading.CancellationToken" /> en el argumento <paramref name="parallelOptions" /> se cancela.</span><span class="sxs-lookup"><span data-stu-id="31ecd-818">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> argument is canceled.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-819">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-819">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-820">La excepción que contiene todas las excepciones individuales producidas en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31ecd-820">The exception that contains all the individual exceptions thrown on all threads.</span></span></exception>
        <related type="Article" href="https://docs.microsoft.com/previous-versions/msp-n-p/ff963552(v=pandp.10)"><span data-ttu-id="31ecd-821">Bucles paralelos</span><span class="sxs-lookup"><span data-stu-id="31ecd-821">Parallel Loops</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Invoke">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="31ecd-822">Ejecuta cada una de las acciones proporcionadas, posiblemente en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-822">Executes each of the provided actions, possibly in parallel.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Action[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Invoke (ParamArray actions As Action())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke actions" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="actions"><span data-ttu-id="31ecd-823">Matriz de <see cref="T:System.Action" /> que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-823">An array of <see cref="T:System.Action" /> to execute.</span></span></param>
        <summary><span data-ttu-id="31ecd-824">Ejecuta cada una de las acciones proporcionadas, posiblemente en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-824">Executes each of the provided actions, possibly in parallel.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-825">Este método puede utilizarse para ejecutar un conjunto de operaciones, potencialmente en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-825">This method can be used to execute a set of operations, potentially in parallel.</span></span>  
  
 <span data-ttu-id="31ecd-826">Hay ninguna garantía sobre el orden en que se ejecutan las operaciones o si se ejecutan en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-826">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="31ecd-827">Este método no devuelve hasta que se ha completado cada una de las operaciones proporcionadas, independientemente de si se produce la finalización debido a la terminación normal o excepcional.</span><span class="sxs-lookup"><span data-stu-id="31ecd-827">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="31ecd-828">Para más información, consulte [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md) (Usar Parallel.Invoke para ejecutar operaciones paralelas).</span><span class="sxs-lookup"><span data-stu-id="31ecd-828">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31ecd-829">Este ejemplo muestra cómo usar el <xref:System.Threading.Tasks.Parallel.Invoke%2A> método con otros métodos, delegados anónimos y expresiones lambda.</span><span class="sxs-lookup"><span data-stu-id="31ecd-829">This example demonstrates how to use the <xref:System.Threading.Tasks.Parallel.Invoke%2A> method with other methods, anonymous delegates, and lambda expressions.</span></span>  
  
 [!code-csharp[System.Threading.Tasks.Parallel#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.tasks.parallel/cs/parallelinvoke.cs#01)]
 [!code-vb[System.Threading.Tasks.Parallel#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.tasks.parallel/vb/parallelinvoke.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-830">El argumento <paramref name="actions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-830">The <paramref name="actions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-831">La excepción que se produce cuando cualquier acción de la matriz <paramref name="actions" /> produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="31ecd-831">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31ecd-832">La matriz <paramref name="actions" /> contiene un elemento <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-832">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public static void Invoke (System.Threading.Tasks.ParallelOptions parallelOptions, params Action[] actions);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Invoke(class System.Threading.Tasks.ParallelOptions parallelOptions, class System.Action[] actions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Parallel.Invoke(System.Threading.Tasks.ParallelOptions,System.Action[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Invoke(System::Threading::Tasks::ParallelOptions ^ parallelOptions, ... cli::array &lt;Action ^&gt; ^ actions);" />
      <MemberSignature Language="F#" Value="static member Invoke : System.Threading.Tasks.ParallelOptions * Action[] -&gt; unit" Usage="System.Threading.Tasks.Parallel.Invoke (parallelOptions, actions)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Parallel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parallelOptions" Type="System.Threading.Tasks.ParallelOptions" />
        <Parameter Name="actions" Type="System.Action[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-uwp-10.0">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="parallelOptions"><span data-ttu-id="31ecd-833">Objeto que configura el comportamiento de esta operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-833">An object that configures the behavior of this operation.</span></span></param>
        <param name="actions"><span data-ttu-id="31ecd-834">Matriz de acciones que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="31ecd-834">An array of actions to execute.</span></span></param>
        <summary><span data-ttu-id="31ecd-835">Ejecuta todas las acciones proporcionadas, posiblemente en paralelo, a menos que el usuario cancele la operación.</span><span class="sxs-lookup"><span data-stu-id="31ecd-835">Executes each of the provided actions, possibly in parallel, unless the operation is cancelled by the user.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31ecd-836">Este método puede utilizarse para ejecutar un conjunto de operaciones, potencialmente en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-836">This method can be used to execute a set of operations, potentially in parallel.</span></span> <span data-ttu-id="31ecd-837">El token de cancelación pasado con la <xref:System.Threading.Tasks.ParallelOptions> estructura permite que el llamador cancelar la operación completa.</span><span class="sxs-lookup"><span data-stu-id="31ecd-837">The cancellation token passed in with the <xref:System.Threading.Tasks.ParallelOptions> structure enables the caller to cancel the entire operation.</span></span> <span data-ttu-id="31ecd-838">Para más información, consulte el tema sobre la [cancelación en subprocesos administrados](~/docs/standard/threading/cancellation-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="31ecd-838">For more information, see [Cancellation in Managed Threads](~/docs/standard/threading/cancellation-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="31ecd-839">Hay ninguna garantía sobre el orden en que se ejecutan las operaciones o si se ejecutan en paralelo.</span><span class="sxs-lookup"><span data-stu-id="31ecd-839">No guarantees are made about the order in which the operations execute or whether they execute in parallel.</span></span> <span data-ttu-id="31ecd-840">Este método no devuelve hasta que se ha completado cada una de las operaciones proporcionadas, independientemente de si se produce la finalización debido a la terminación normal o excepcional.</span><span class="sxs-lookup"><span data-stu-id="31ecd-840">This method does not return until each of the provided operations has completed, regardless of whether completion occurs due to normal or exceptional termination.</span></span>  
  
 <span data-ttu-id="31ecd-841">Para más información, consulte [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md) (Usar Parallel.Invoke para ejecutar operaciones paralelas).</span><span class="sxs-lookup"><span data-stu-id="31ecd-841">For more information, see [How to: Use Parallel.Invoke to Execute Parallel Operations](~/docs/standard/parallel-programming/how-to-use-parallel-invoke-to-execute-parallel-operations.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OperationCanceledException"><span data-ttu-id="31ecd-842"><see cref="T:System.Threading.CancellationToken" /> en el estado <paramref name="parallelOptions" /> está establecido.</span><span class="sxs-lookup"><span data-stu-id="31ecd-842">The <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> is set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="31ecd-843">El argumento <paramref name="actions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-843">The <paramref name="actions" /> argument is <see langword="null" />.</span></span>  
  
<span data-ttu-id="31ecd-844">O bien</span><span class="sxs-lookup"><span data-stu-id="31ecd-844">-or-</span></span> 
<span data-ttu-id="31ecd-845">El argumento <paramref name="parallelOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-845">The <paramref name="parallelOptions" /> argument is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AggregateException"><span data-ttu-id="31ecd-846">La excepción que se produce cuando cualquier acción de la matriz <paramref name="actions" /> produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="31ecd-846">The exception that is thrown when any action in the <paramref name="actions" /> array throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="31ecd-847">La matriz <paramref name="actions" /> contiene un elemento <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="31ecd-847">The <paramref name="actions" /> array contains a <see langword="null" /> element.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="31ecd-848">El objeto <see cref="T:System.Threading.CancellationTokenSource" /> asociado a <see cref="T:System.Threading.CancellationToken" /> en el <paramref name="parallelOptions" /> se ha desechado.</span><span class="sxs-lookup"><span data-stu-id="31ecd-848">The <see cref="T:System.Threading.CancellationTokenSource" /> associated with the <see cref="T:System.Threading.CancellationToken" /> in the <paramref name="parallelOptions" /> has been disposed.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>