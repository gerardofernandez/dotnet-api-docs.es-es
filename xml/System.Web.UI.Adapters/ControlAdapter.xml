<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="12b7cdc33437e3ecb53d715e213ce9bb8138c4e0" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39930834" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Personaliza la representación del control derivado al que está asociado el adaptador, para modificar el marcado o el comportamiento predeterminados para exploradores concretos, y es la clase base de la que heredan todos los adaptadores de control.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los adaptadores de control son componentes que invalidación determinados <xref:System.Web.UI.Control> clase métodos y eventos de su ciclo de vida de ejecución para permitir que un control específico del marcado o explorador. .NET Framework asigna un adaptador de control derivada solo un <xref:System.Web.UI.Control> objeto para cada solicitud de cliente.  
  
 Un adaptador modifica un control para un explorador específico o una clase de exploradores o actúa como filtro arbitrario en alguna función. Normalmente, el adaptador se define mediante el lenguaje de marcado que utiliza el explorador (por ejemplo, XHTML o HTML 3.2). Gran parte de la adaptabilidad del comportamiento de representación se puede encapsular en las clases especializadas que se derivan de la <xref:System.Web.UI.HtmlTextWriter> clase. Por lo tanto, es probable que un único adaptador puede usarse para un número de comportamientos de clase de explorador o que su inclusión de la adaptabilidad de la <xref:System.Web.UI.HtmlTextWriter> clases podrían hacer que el uso de un adaptador de control innecesario.  
  
 Un adaptador para una clase de control se aplica a todos los controles que heredan de esa clase, a menos que estén presentes adaptadores más especializados. Por ejemplo, un adaptador para la <xref:System.Web.UI.WebControls.BaseValidator> clase puede utilizarse para todos los `Validator` objetos.  
  
 Los adaptadores normalmente no heredan directamente de la <xref:System.Web.UI.Adapters.ControlAdapter> (clase), pero desde el uno del adaptador específico del destino de las clases que proporcionan funcionalidad adicional específica del explorador de control de tipo y de destino base o la representación particular requerida.  
  
 Los propios controles no requieren necesariamente un adaptador. Si los controles se extienden a través de composición, generalmente son suficientes los adaptadores de control secundario.  
  
 Cada control tiene asignaciones explícitas a adaptadores a través de los archivos de definición .browser. Por lo tanto, cualquier acceso a la <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> propiedad usa el <xref:System.Web.HttpBrowserCapabilities> objeto extraído de los archivos de definición de explorador para realizar la búsqueda para la asignación del adaptador al control.  
  
 Durante el procesamiento, .NET Framework intercepta las llamadas a los métodos reemplazables de un control que podría ser específico del destino. Si está conectado a un adaptador de control, .NET Framework llama a los métodos de adaptador asociado.  
  
 El adaptador realiza la representación del control a través de la <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método. Si se reemplaza, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potencialmente no debe llamar a la implementación de la clase base ya que realiza una llamada de vuelta en el <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método. Esto podría provocar la representación que se produzcan dos veces, una vez por el adaptador y una vez por el control.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> basar las llamadas a métodos en el <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método del control. Por lo tanto, si invalida <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, no debe llamar a la implementación de la clase base a menos que la representación que implemente a la que se proporciona por <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> del control.  
  
 Debe asegurarse de que .NET Framework realiza interceptación para los adaptadores de los controles secundarios. Puede hacerlo mediante una llamada a la <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> basar el método que llama el <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> método del control, desde su <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> invalidar.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> llama a métodos del control inmediatamente antes y después (respectivamente) en el control llama el <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método. Si previas y posteriores a la representación sólo explorador específico del procesan las tareas necesarias, usar <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> pueden hacer necesario invalidar <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>. El comportamiento predeterminado de la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> métodos consiste en llamar a los métodos correspondientes de la <xref:System.Web.UI.HtmlTextWriter>.  
  
 Para mantener su propia información de estado, un adaptador de control puede invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos. <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> se llama cuando se guardan los Estados de control y vista privados y se carga, respectivamente.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base llamada de métodos en la correspondiente <xref:System.Web.UI.Control> métodos de la clase. Por lo tanto, cualquiera de estos <xref:System.Web.UI.Adapters.ControlAdapter> métodos que son reemplazados deben llamar a sus métodos base; de lo contrario, el evento asociado con el <xref:System.Web.UI.Control> no se generará el método de clase.  
  
 Opcionalmente, puede implementan controles y los adaptadores del <xref:System.Web.UI.IPostBackDataHandler> y <xref:System.Web.UI.IPostBackEventHandler> interfaces. .NET Framework determina si existe un adaptador y si el adaptador implementa estas interfaces. Si es así, el adaptador debe reemplazar el <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, y <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> métodos, según sea necesario. Si no se reconocen los datos de postback en el adaptador, debe llamar a atrás en el control para procesarlo. Controladores de eventos subsiguientes también deben volver a llamar el control.  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), un control que requiere la funcionalidad del adaptador general debe tener un adaptador correspondiente de la clase con nombre en el patrón de base <paramref name="ControlType" /><see langword="Adapter" /> (por ejemplo, <see langword="TextBoxAdapter" />). Como mínimo, el adaptador debería devolver una instancia fuertemente tipada del control a través de su <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> propiedad.  1.  Adaptadores de controles para un lenguaje de marcado y de tipo de control determinado debe tener un nombre en el patrón de <paramref name="MarkupControlType" /><see langword="Adapter" /> (por ejemplo, <see langword="XhtmlTextBoxAdapter" />). Los adaptadores de control deben implementarse en un <see langword="Adapters" /> subespacio.  Adaptadores de control deben heredar de la clase base adecuada y siga el mismo modelo de herencia que el control. Por ejemplo, un adaptador para un control que hereda de la <see cref="T:System.Web.UI.Control" /> debería heredar la clase base desde la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase o la correspondiente <paramref name="ControlType" /><see langword="Adapter" /> clase.  Los adaptadores especializados deben definirse para el control especializado en todos los nodos de dispositivo .browser en archivos de configuración.  Un control correctamente implementado no debe suponer que un adaptador está conectado o que el adaptador asociado implementa una interfaz específica. En su lugar, debe comprobar estas antes de llamar a.  Es posible simular invalidar los métodos de evento protegido en el control, como el <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método de la <see cref="T:System.Web.UI.WebControls.LinkButton" />. En primer lugar, cree una clase de adaptador con una <c>OnClick</c> método. A continuación, cree un nuevo control derivado de <see cref="T:System.Web.UI.WebControls.LinkButton" /> e invalidar la <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método. La reemplazada <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> llamadas al método el <c>OnClick</c> método del adaptador. El objeto de adaptador está disponible a través de protegido <see cref="P:System.Web.UI.Control.Adapter" /> propiedad de la <see cref="T:System.Web.UI.Control" /> clase. El <see cref="P:System.Web.UI.Control.Adapter" /> es propiedad del control <see langword="null" /> cuando no hay ningún adaptador asociado, por lo que cualquier código debe comprobar esa condición antes de llamar a métodos del adaptador.</para>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 .NET Framework crea internamente este adaptador al crear la correspondiente <xref:System.Web.UI.Control> objeto.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que contiene los métodos para representar el resultado específico del destino.</param>
        <summary>Se le llama antes de la representación de un control. En una clase de adaptador derivada, genera etiquetas de apertura requeridas por un destino concreto pero que no son necesarias para los exploradores de HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> se llama al método justo antes del <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método y se usa para realizar el preprocesamiento específico del destino antes de la representación del control.  
  
 Use la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método junto con el <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> para garantizar la coherencia de la etiqueta a la apertura y cierre.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> basar las llamadas al método el <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> método. Por lo tanto, invalidaciones de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> debe llamar al método el <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> método base solo si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> método.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a las posibilidades del explorador del cliente que realiza la solicitud HTTP actual.</summary>
        <value>Un <see cref="T:System.Web.HttpBrowserCapabilities" /> que especifica las funciones del explorador del cliente y de marcado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Un <xref:System.Web.UI.Adapters.ControlAdapter> objeto determina las funciones del explorador cliente desde el <xref:System.Web.HttpBrowserCapabilities> objeto devuelto por la <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propiedad. Esto permite la <xref:System.Web.UI.Adapters.ControlAdapter> objeto para representar el marcado específico del explorador o modificar el comportamiento de la <xref:System.Web.UI.Control>.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propiedad para tener acceso a los detalles del explorador solicitante. En este ejemplo, el código se comprueba para determinar si el explorador es compatible con JavaScript y, a continuación, permite al desarrollador representar el resultado personalizado en ese caso.  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al control al que está asociado este adaptador de control.</summary>
        <value>Propiedad <see cref="T:System.Web.UI.Control" /> a la que está asociado el objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un adaptador de control derivado está asociado a un control, .NET Framework llama a ciertos miembros del adaptador en lugar de los miembros del control.  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo derivar un control personalizado de la <xref:System.Web.UI.Control> clase y, a continuación, crear un adaptador correspondiente que hereda de la <xref:System.Web.UI.Adapters.ControlAdapter> clase. El adaptador reemplaza el <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> propiedad y devuelve una referencia fuertemente tipada al control.  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), como mínimo, debe implementar un <see langword="Control" /> propiedad para devolver una instancia fuertemente tipada del control, como se muestra en la sección ejemplo.</para>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Crea los controles secundarios específicos del destino para un control compuesto.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un adaptador de control derivada se adjunta a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> se invalida el método, se llama a la invalidación en lugar de la <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> método. Por lo tanto, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> puede usarse para crear un conjunto de controles secundarios específicos del destino.  
  
 Para obtener más información sobre la combinación de controles para crear un nuevo control, vea [controles compuestos](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Si crea una clase heredera y reemplaza el <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> método, no la llamada al método base a menos que desee agregar controles a los creados por el método base. En caso contrario, podría crear dos conjuntos secundarios controles.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que contiene los métodos para representar el resultado específico del destino.</param>
        <summary>Se le llama después de la representación de un control. En una clase de adaptador derivada, genera etiquetas de cierre requeridas por un destino concreto pero que no son necesarias para los exploradores de HTML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> se llama al método justo después de la <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método y se usa para realizar el procesamiento posterior específico del destino después de la representación del control.  
  
 Use la <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método junto con el <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> para garantizar la coherencia de la etiqueta a la apertura y cierre.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> basar las llamadas al método el <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> método. Por lo tanto, invalidaciones de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> debe llamar al método el <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> método base solo si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> método.</para>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Un objeto <see cref="T:System.Object" /> que contiene la información de estado de los controles del adaptador como <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carga información de estado del control de adaptador, guardada por <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> durante una solicitud anterior, en la página donde reside el control asociado a este adaptador de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de control es la información de estado esencial necesaria incluso si se deshabilita el estado de vista. Cuando un adaptador necesita mantener su propia información de estado de control, puede invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> métodos.  
  
 Un adaptador podría necesitar mantener información de estado de control cuando hay características que necesitan tener mantener el estado entre las solicitudes, independientemente del estado del control asociado. Por ejemplo, un control compuesto que consta de una pantalla de texto grande y un grupo de <xref:System.Web.UI.WebControls.RadioButton> controles pueden representar como una vista única en exploradores de equipos de escritorio. En otros exploradores, su representación podría dividirse: una vista para la presentación textual y otra para el grupo de botones de radio. El adaptador necesitará mantener su propia información específica de destino acerca de la vista activa actualmente.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> se llama al método inmediatamente después de la <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> método, en el `LoadState` fase del ciclo de vida. El estado de control de adaptador es independiente y, además del estado de control del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <see cref="T:System.Object" /> que contiene la información de estado de la vista del adaptador como <see cref="T:System.Web.UI.StateBag" />.</param>
        <summary>Carga información del estado de la vista del adaptador, guardada por <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> durante una solicitud anterior, en la página donde reside el control asociado a este adaptador de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un adaptador necesita mantener su propia información de estado de vista, puede reemplazar el <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> métodos.  
  
 Un adaptador necesita mantener información de estado de vista cuando hay datos que deben mantenerse en todas las solicitudes, independientemente del estado de vista del control asociado. Por ejemplo, un control de cuadrícula en exploradores de equipos de escritorio podría representarse como una vista única de filas y columnas de valores. En otros exploradores, su representación en varias vistas distintas, como una lista de filas y los detalles de una sola fila podría dividirse. El adaptador necesitará mantener los datos de las vistas que no están activos actualmente en estado de vista.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> se llama al método inmediatamente antes de la <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> método en el `LoadState` fase del ciclo de vida. El estado de vista del adaptador es independiente y además del estado de vista del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Reemplaza el método <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> para el control asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> método.  
  
 Invalidar <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> para realizar el procesamiento específico del destino en el `Initialize` fase del ciclo de vida del control. Normalmente, estas son las funciones que se llevan a cabo cuando se crea un control.  
  
   
  
## Examples  
 El siguiente ejemplo de código deriva de un adaptador de control personalizado desde la <xref:System.Web.UI.Adapters.ControlAdapter> clase. A continuación, reemplaza el <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> método para establecer una propiedad del control asociado y llamar al método base para completar la inicialización del control.  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama a la <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> método. Si el <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> no invoca el método, el <see cref="E:System.Web.UI.Control.Init" /> no se producirá el evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Reemplaza el método <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> para el control asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> método.  
  
 Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> método para realizar el procesamiento específico del destino en el `Load` fase del ciclo de vida del control. Normalmente, estas son las funciones que deben realizarse para cada solicitud de cliente.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama a la <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> método. Si <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> no se llama, el <see cref="E:System.Web.UI.Control.Load" /> no se producirá el evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Reemplaza el método <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> para el control asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> método.  
  
 Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> método para realizar el procesamiento específico del destino en el `PreRender` fase del ciclo de vida del control. Normalmente, son funciones que preceden inmediatamente a la representación del resultado del control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama a la <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> método. Si el <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> no invoca el método, el <see cref="E:System.Web.UI.Control.PreRender" /> no se producirá el evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</param>
        <summary>Reemplaza el método <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> para el control asociado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> método.  
  
 Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> método para realizar el procesamiento específico del destino el `Unload` fase del ciclo de vida del control. Normalmente, estas son las funciones de limpieza que preceden a la eliminación del control.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama a la <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> método. Si <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> no se llama, el <see cref="E:System.Web.UI.Control.Unload" /> no se producirá el evento.</para>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia a la página donde reside el control asociado a este adaptador.</summary>
        <value>Un <see cref="T:System.Web.UI.Page" /> que proporciona acceso a la instancia de la página donde se encuentra el control asociado.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> propiedad proporciona acceso a la <xref:System.Web.UI.Page?displayProperty=nameWithType> objeto donde se encuentra el control.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una referencia al adaptador de la página donde reside el control asociado.</summary>
        <value>
          <see cref="T:System.Web.UI.Adapters.PageAdapter" /> para la página donde se encuentra el control asociado al <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> actual.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propiedad proporciona acceso a la <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> de objeto para el <xref:System.Web.UI.Page> objeto donde el <xref:System.Web.UI.Control> objeto asociado con el actual <xref:System.Web.UI.Adapters.ControlAdapter> se encuentra el objeto.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propiedad puede utilizarse para tener acceso a otros elementos en el nivel de adaptador de página, como las funciones específicas del destino comunes que pueden aplicarse a varios tipos de control en la página.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que se utiliza para representar el resultado específico del destino.</param>
        <summary>Genera el marcado específico del destino para el control al que está asociado el adaptador de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método para generar el marcado específico del destino que se envía al explorador del cliente. El <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> se llama al método en lugar de la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método si un <xref:System.Web.UI.Adapters.ControlAdapter> objeto se asocia a un <xref:System.Web.UI.Control> objeto.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> basar las llamadas al método el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método. Por lo tanto, invalidaciones de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> debe llamar al método el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método base solo si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método.  Para un control compuesto, el desarrollador de adaptadores debe asegurarse de que se representan los controles secundarios. Si el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> hace que el elemento secundario controla para procesarse, pero no genera el marcado de método, podría ser adecuado para el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para llamar a su método base. Si es necesaria específico del destino de representación de los controles secundarios, el adaptador debe implementar la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método y llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método desde el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <see cref="T:System.Web.UI.HtmlTextWriter" /> que se utiliza para representar el resultado específico del destino.</param>
        <summary>Genera el marcado específico del destino para los controles secundarios en un control compuesto al que está asociado el adaptador de control.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> método cuando es necesario generar el marcado específico del destino para el conjunto de controles secundarios de un control compuesto, además en el marcado para los controles secundarios individuales.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), para un control compuesto, el desarrollador de adaptadores debe asegurarse de que se representan los controles secundarios. Si el adaptador reemplaza el <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método, debe llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método desde un reemplazo del <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.  Si el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> hace que el elemento secundario controla para procesarse, pero sí mismo no genera el marcado de método, podría ser adecuado para el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para llamar a su método base, que llama el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método, en lugar de implementar una invalidación para el <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método.</para>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda información de estado de control para el adaptador de control.</summary>
        <returns>Un objeto <see cref="T:System.Object" /> que contiene la información de estado de los controles del adaptador como <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Estado de control es la información de estado esencial necesaria incluso si se deshabilita el estado de vista. Cuando un adaptador necesita mantener su propia información de estado de control, puede invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> métodos.  
  
 Un adaptador podría necesitar mantener información de estado de control cuando hay características que necesitan tener mantener el estado entre las solicitudes, independientemente del estado del control asociado. Por ejemplo, un control compuesto que consta de una pantalla de texto grande y un grupo de <xref:System.Web.UI.WebControls.RadioButton> controles pueden representar como una vista única en exploradores de equipos de escritorio. En otros exploradores, su representación podría dividirse: una vista para la presentación textual y otra para el grupo de botones de radio. El adaptador necesitará mantener su propia información específica de destino acerca de la vista activa actualmente.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> se llama al método inmediatamente después de la <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> método en el `SaveState` fase del ciclo de vida. El estado de control de adaptador es independiente y, además del estado de control del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Guarda información del estado de vista para el adaptador de control.</summary>
        <returns>
          <see cref="T:System.Object" /> que contiene la información de estado de la vista del adaptador como <see cref="T:System.Web.UI.StateBag" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cuando un adaptador necesita mantener su propia información de estado de vista, puede reemplazar el <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos.  
  
 Un adaptador necesita mantener la información de estado de vista cuando hay datos que deben mantenerse en todas las solicitudes, independientemente del estado de vista asociada del control. Por ejemplo, un control de cuadrícula en exploradores de equipos de escritorio podría representarse como una vista única de filas y columnas de valores. En otros exploradores, su representación en varias vistas distintas, como una lista de filas y los detalles de una sola fila podría dividirse. El adaptador necesitará mantener los datos de las vistas que no están activos actualmente en estado de vista.  
  
 El <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> se llama al método inmediatamente antes de la <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> método en el `SaveState` fase del ciclo de vida. El estado de vista del adaptador es independiente y además del estado de vista del control.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>