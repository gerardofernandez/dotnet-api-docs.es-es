<Type Name="ControlAdapter" FullName="System.Web.UI.Adapters.ControlAdapter">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="92d5994d2f6188d664ca43f6b7dc75d96c4d81fd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36394658" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ControlAdapter" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ControlAdapter extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Web.UI.Adapters.ControlAdapter" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ControlAdapter" />
  <TypeSignature Language="C++ CLI" Value="public ref class ControlAdapter abstract" />
  <TypeSignature Language="F#" Value="type ControlAdapter = class" />
  <AssemblyInfo>
    <AssemblyName>System.Web</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="14879-101">Personaliza la representación del control derivado al que está asociado el adaptador, para modificar el marcado o el comportamiento predeterminados para exploradores concretos, y es la clase base de la que heredan todos los adaptadores de control.</span>
      <span class="sxs-lookup">
        <span data-stu-id="14879-101">Customizes rendering for the derived control to which the adapter is attached, to modify the default markup or behavior for specific browsers, and is the base class from which all control adapters inherit.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-102">Adaptadores de control son componentes que reemplazan ciertos <xref:System.Web.UI.Control> clase métodos y eventos de su ciclo de vida de ejecución para permitir el explorador o un control específico del marcado.</span><span class="sxs-lookup"><span data-stu-id="14879-102">Control adapters are components that override certain <xref:System.Web.UI.Control> class methods and events in its execution lifecycle to allow browser or markup-specific handling.</span></span> <span data-ttu-id="14879-103">.NET Framework asigna un adaptador de control derivado solo un <xref:System.Web.UI.Control> objeto para cada solicitud de cliente.</span><span class="sxs-lookup"><span data-stu-id="14879-103">The .NET Framework maps a single derived control adapter to a <xref:System.Web.UI.Control> object for each client request.</span></span>  
  
 <span data-ttu-id="14879-104">Un adaptador modifica un control para un explorador específico o una clase de exploradores o actúa como filtro arbitrario en alguna función.</span><span class="sxs-lookup"><span data-stu-id="14879-104">An adapter modifies a control for a specific browser or class of browsers or acts as an arbitrary filter on some capability.</span></span> <span data-ttu-id="14879-105">Normalmente, el adaptador se define mediante el lenguaje de marcado que utiliza el explorador (por ejemplo, XHTML o HTML 3.2).</span><span class="sxs-lookup"><span data-stu-id="14879-105">Typically the adapter is defined by the markup language that the browser uses (for example, XHTML or HTML 3.2).</span></span> <span data-ttu-id="14879-106">Gran parte de la adaptabilidad del comportamiento de representación se puede encapsular en las clases especializadas que se derivan de la <xref:System.Web.UI.HtmlTextWriter> clase.</span><span class="sxs-lookup"><span data-stu-id="14879-106">Much of the adaptability in rendering behavior can be encapsulated in the specialized classes that derive from the <xref:System.Web.UI.HtmlTextWriter> class.</span></span> <span data-ttu-id="14879-107">Por lo tanto, es probable que un único adaptador puede utilizarse para un número de comportamientos de clase de explorador o que inclusión de la adaptabilidad en el <xref:System.Web.UI.HtmlTextWriter> clases podrían hacer que el uso de un adaptador de control innecesario.</span><span class="sxs-lookup"><span data-stu-id="14879-107">Therefore, it is likely that a single adapter can be used for a number of browser class behaviors or that inclusion of the adaptability in the <xref:System.Web.UI.HtmlTextWriter> classes could make the use of a control adapter unnecessary.</span></span>  
  
 <span data-ttu-id="14879-108">Un adaptador para una clase de control se aplica a todos los controles que heredan de esa clase, a menos que estén presentes adaptadores más especializados.</span><span class="sxs-lookup"><span data-stu-id="14879-108">An adapter for a control class applies to all controls that inherit from that class, unless more specialized adapters are present.</span></span> <span data-ttu-id="14879-109">Por ejemplo, un adaptador para la <xref:System.Web.UI.WebControls.BaseValidator> clase puede usarse en todas las `Validator` objetos.</span><span class="sxs-lookup"><span data-stu-id="14879-109">For example, an adapter for the <xref:System.Web.UI.WebControls.BaseValidator> class can be used for all `Validator` objects.</span></span>  
  
 <span data-ttu-id="14879-110">Adaptadores normalmente no heredan directamente de la <xref:System.Web.UI.Adapters.ControlAdapter> (clase), pero desde uno de los adaptadores específicas del destino basar las clases que proporcionan funcionalidad adicional específica para el Explorador de control de tipo y de destino o la representación particular necesarias.</span><span class="sxs-lookup"><span data-stu-id="14879-110">Adapters typically do not inherit directly from the <xref:System.Web.UI.Adapters.ControlAdapter> class, but from one of the target-specific adapter base classes that provide additional functionality specific to the control type and target browser or the particular rendering required.</span></span>  
  
 <span data-ttu-id="14879-111">Controles por sí mismos no requieren necesariamente un adaptador.</span><span class="sxs-lookup"><span data-stu-id="14879-111">Controls themselves do not necessarily require an adapter.</span></span> <span data-ttu-id="14879-112">Si los controles se extienden a través de composición, generalmente son suficientes los adaptadores de control secundario.</span><span class="sxs-lookup"><span data-stu-id="14879-112">If controls are extended through composition, generally the child control adapters are sufficient.</span></span>  
  
 <span data-ttu-id="14879-113">Cada control tiene asignaciones explícitas a adaptadores a través de los archivos de definición de Browser.</span><span class="sxs-lookup"><span data-stu-id="14879-113">Each control has explicit mappings to adapters through the .browser definition files.</span></span> <span data-ttu-id="14879-114">Por lo tanto, cualquier acceso a la <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> propiedad utiliza la <xref:System.Web.HttpBrowserCapabilities> objeto extraído de los archivos de definición de explorador para realizar la búsqueda para la asignación del adaptador al control.</span><span class="sxs-lookup"><span data-stu-id="14879-114">Thus, any access to the <xref:System.Web.UI.Control.Adapter%2A?displayProperty=nameWithType> property uses the <xref:System.Web.HttpBrowserCapabilities> object extracted from the browser definition files to perform the lookup for the mapping of the adapter to control.</span></span>  
  
 <span data-ttu-id="14879-115">Durante el procesamiento, .NET Framework intercepta las llamadas a los métodos reemplazables de un control que podría ser específico del destino.</span><span class="sxs-lookup"><span data-stu-id="14879-115">During processing, the .NET Framework intercepts calls to the overridable methods of a control that could be target-specific.</span></span> <span data-ttu-id="14879-116">Si se adjunta un adaptador de control, .NET Framework llama a los métodos de adaptador asociado.</span><span class="sxs-lookup"><span data-stu-id="14879-116">If a control adapter is attached, the .NET Framework calls the associated adapter methods.</span></span>  
  
 <span data-ttu-id="14879-117">El adaptador realiza la representación del control a través de la <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14879-117">The adapter performs rendering for the control through the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="14879-118">Si se reemplaza, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potencialmente no debe llamar a la implementación de la clase base ya que realiza una llamada a la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-118">If overridden, <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> potentially should not call the base class implementation because that performs a call back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="14879-119">Esto puede provocar la representación se repitiera dos veces, una vez por el adaptador y una vez por el control.</span><span class="sxs-lookup"><span data-stu-id="14879-119">This might cause the rendering to occur twice, once by the adapter and once by the control.</span></span>  
  
 <span data-ttu-id="14879-120">El <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> base llamadas a métodos en el <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> al método del control.</span><span class="sxs-lookup"><span data-stu-id="14879-120">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> base method calls back on the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method of the control.</span></span> <span data-ttu-id="14879-121">Por lo tanto, si invalida <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, no debería llamar a la implementación de la clase base a menos que la representación que implemente a la que se proporciona por <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> del control.</span><span class="sxs-lookup"><span data-stu-id="14879-121">Thus, if you override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>, you should not call the base class implementation unless the rendering you implement is in addition to that provided by <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> of the control.</span></span>  
  
 <span data-ttu-id="14879-122">Debe asegurarse de que .NET Framework realice la interceptación para los adaptadores de los controles secundarios.</span><span class="sxs-lookup"><span data-stu-id="14879-122">You must ensure that the .NET Framework performs interception for adapters of the child controls.</span></span> <span data-ttu-id="14879-123">Puede hacerlo mediante una llamada a la <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base método, que llama a la <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> método del control, desde su <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> invalidar.</span><span class="sxs-lookup"><span data-stu-id="14879-123">You can do this by calling the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> base method, which calls the <xref:System.Web.UI.Control.RenderChildren%2A?displayProperty=nameWithType> method of the control, from your <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> override.</span></span>  
  
 <span data-ttu-id="14879-124">El <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> el control llama a métodos inmediatamente antes y después (respectivamente) en las llamadas de control el <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método.</span><span class="sxs-lookup"><span data-stu-id="14879-124">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods are called by the control immediately before and after (respectively) the control calls the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method.</span></span> <span data-ttu-id="14879-125">Si previas y posteriores a la representación se solo explorador específico del procesamiento de las tareas necesarias, mediante <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> pueden hacer necesario invalidar <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>.</span><span class="sxs-lookup"><span data-stu-id="14879-125">If pre- and post-rendering are the only browser-specific processing tasks required, using <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> might make it unnecessary to override <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A>.</span></span> <span data-ttu-id="14879-126">El comportamiento predeterminado de la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> métodos consiste en llamar a los métodos correspondientes de la <xref:System.Web.UI.HtmlTextWriter>.</span><span class="sxs-lookup"><span data-stu-id="14879-126">The default behavior of the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> methods is to call the corresponding methods of the <xref:System.Web.UI.HtmlTextWriter>.</span></span>  
  
 <span data-ttu-id="14879-127">Para mantener su propia información de estado, un adaptador de control puede invalidar la <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="14879-127">To maintain its own state information, a control adapter can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span> <span data-ttu-id="14879-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> se llama cuando los Estados de vista y control privados se guardan y se cargan, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="14879-128"><xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> are called when the private control and view states are saved and loaded, respectively.</span></span>  
  
 <span data-ttu-id="14879-129">El <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, y <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base llamada de métodos en la correspondiente <xref:System.Web.UI.Control> métodos de la clase.</span><span class="sxs-lookup"><span data-stu-id="14879-129">The <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A>, <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A>, and <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> base methods call back on the corresponding <xref:System.Web.UI.Control> class methods.</span></span> <span data-ttu-id="14879-130">Por lo tanto, cualquiera de estas <xref:System.Web.UI.Adapters.ControlAdapter> métodos que son reemplazados deben llamar a sus métodos base; en caso contrario, el evento asociado con el <xref:System.Web.UI.Control> no se generará el método de clase.</span><span class="sxs-lookup"><span data-stu-id="14879-130">Thus, any of these <xref:System.Web.UI.Adapters.ControlAdapter> methods that are overridden must call their base methods; otherwise, the event associated with the <xref:System.Web.UI.Control> class method will not be raised.</span></span>  
  
 <span data-ttu-id="14879-131">Controles y adaptadores, opcionalmente, implementan el <xref:System.Web.UI.IPostBackDataHandler> y <xref:System.Web.UI.IPostBackEventHandler> interfaces.</span><span class="sxs-lookup"><span data-stu-id="14879-131">Controls and adapters optionally implement the <xref:System.Web.UI.IPostBackDataHandler> and <xref:System.Web.UI.IPostBackEventHandler> interfaces.</span></span> <span data-ttu-id="14879-132">.NET Framework determina si existe un adaptador y si el adaptador implementa estas interfaces.</span><span class="sxs-lookup"><span data-stu-id="14879-132">The .NET Framework determines whether an adapter exists and whether the adapter implements these interfaces.</span></span> <span data-ttu-id="14879-133">Si lo hace, el adaptador debe reemplazar el <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, y <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> métodos, según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="14879-133">If it does, the adapter should override the <xref:System.Web.UI.IPostBackDataHandler.LoadPostData%2A>, <xref:System.Web.UI.IPostBackDataHandler.RaisePostDataChangedEvent%2A>, and <xref:System.Web.UI.IPostBackEventHandler.RaisePostBackEvent%2A> methods, as necessary.</span></span> <span data-ttu-id="14879-134">Si los datos de devolución no se reconocen en el adaptador, debe volver a llamar el control para que lo procese.</span><span class="sxs-lookup"><span data-stu-id="14879-134">If the postback data is not recognized in the adapter, it must call back on the control to process it.</span></span> <span data-ttu-id="14879-135">Controladores de eventos subsiguientes también deben volver a llamar el control.</span><span class="sxs-lookup"><span data-stu-id="14879-135">Subsequent event handlers also must call back on the control.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="14879-136">
        <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), un control que requiere la funcionalidad del adaptador general debe tener un adaptador correspondiente de la clase con el nombre en el modelo de base <paramref name="ControlType" /><see langword="Adapter" /> (por ejemplo, <see langword="TextBoxAdapter" />). Como mínimo, el adaptador debería devolver una instancia fuertemente tipado del control a través de su <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> propiedad.  1.  Adaptadores de control para un lenguaje de marcado y el tipo de control determinado debe tener un nombre en el patrón de <paramref name="MarkupControlType" /><see langword="Adapter" /> (por ejemplo, <see langword="XhtmlTextBoxAdapter" />). Los adaptadores de control deben implementarse en un <see langword="Adapters" /> subespacio.  Adaptadores de control deben heredar de la clase base adecuada y siga el mismo modelo de herencia que el control. Por ejemplo, un adaptador para un control heredando de la <see cref="T:System.Web.UI.Control" /> debe heredar la clase base desde la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase o la correspondiente <paramref name="ControlType" /><see langword="Adapter" /> clase.  Los adaptadores especializados deben definirse para el control especializado bajo todos los nodos de dispositivo Browser en archivos de configuración.  Un control correctamente implementado no debe suponer que un adaptador está conectado o que el adaptador asociado implementa una interfaz específica. En su lugar, debe comprobar estas ediciones antes de que realiza la llamada.  Es posible simular el reemplazo de métodos de evento protegidos en el control, como el <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método de la <see cref="T:System.Web.UI.WebControls.LinkButton" />. En primer lugar, cree una clase de adaptador con un <c>OnClick</c> método. A continuación, cree un nuevo control derivado de <see cref="T:System.Web.UI.WebControls.LinkButton" /> e invalide el <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> método. La reemplazada <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> llamadas al método el <c>OnClick</c> método del adaptador. El objeto adaptador está disponible a través de la protegido <see cref="P:System.Web.UI.Control.Adapter" /> propiedad de la <see cref="T:System.Web.UI.Control" /> clase. El <see cref="P:System.Web.UI.Control.Adapter" /> es propiedad del control <see langword="null" /> cuando no hay ningún adaptador asociado, por lo que cualquier código debe comprobar para esa condición antes de llamar a métodos del adaptador.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="14879-136">
          <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, a control that requires general adapter functionality should have a corresponding adapter base class, named in the pattern <paramref name="ControlType" /><see langword="Adapter" /> (for example, <see langword="TextBoxAdapter" />). The adapter should at a minimum return a strongly-typed instance of the control through its <see cref="P:System.Web.UI.Adapters.ControlAdapter.Control" /> property.  1.  Control adapters for a given control type and markup language should be named in the pattern <paramref name="MarkupControlType" /><see langword="Adapter" /> (for example, <see langword="XhtmlTextBoxAdapter" />). Adapters for a control should be implemented in an <see langword="Adapters" /> subnamespace.  Control adapters should inherit from the appropriate base class and follow the same inheritance model as the control. For example, an adapter for a control inheriting from the <see cref="T:System.Web.UI.Control" /> base class should inherit from either the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class or the relevant <paramref name="ControlType" /><see langword="Adapter" /> class.  Any specialized adapters should be defined for the specialized control under all of the device nodes in configuration .browser files.  A properly implemented control should not assume that an adapter is attached, or that the attached adapter implements a specific interface. Instead, it should check for these before calling.  It is possible to simulate overriding protected event methods in the control, such as the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method of the <see cref="T:System.Web.UI.WebControls.LinkButton" />. First, create an adapter class with an <c>OnClick</c> method. Then create a new control derived from <see cref="T:System.Web.UI.WebControls.LinkButton" /> and override the <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method. The overriden <see cref="M:System.Web.UI.WebControls.LinkButton.OnClick(System.EventArgs)" /> method calls the <c>OnClick</c> method of the adapter. The adapter object is available through the protected <see cref="P:System.Web.UI.Control.Adapter" /> property of the <see cref="T:System.Web.UI.Control" /> class. The <see cref="P:System.Web.UI.Control.Adapter" /> property of the control is <see langword="null" /> when there is no associated adapter, so any code should check for that condition before calling methods of the adapter.</para>
        </span>
      </span>
    </block>
    <altmember cref="T:System.Web.UI.Control" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ControlAdapter ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ControlAdapter();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14879-137">Inicializa una nueva instancia de la clase <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-137">Initializes a new instance of the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-138">.NET Framework construye internamente este adaptador cuando se crea el correspondiente <xref:System.Web.UI.Control> objeto.</span><span class="sxs-lookup"><span data-stu-id="14879-138">The .NET Framework internally constructs this adapter when it creates the corresponding <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="BeginRender">
      <MemberSignature Language="C#" Value="protected internal virtual void BeginRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void BeginRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub BeginRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void BeginRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.BeginRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.BeginRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="14879-139">
            <see cref="T:System.Web.UI.HtmlTextWriter" /> que contiene los métodos para representar el resultado específico del destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-139">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-140">Se le llama antes de la representación de un control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-140">Called prior to the rendering of a control.</span>
          </span>
          <span data-ttu-id="14879-141">En una clase de adaptador derivada, genera etiquetas de apertura requeridas por un destino concreto pero que no son necesarias para los exploradores de HTML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-141">In a derived adapter class, generates opening tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-142">El <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método se llama justo antes del <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método y se usa para realizar el preprocesamiento específico del destino antes de la representación del control.</span><span class="sxs-lookup"><span data-stu-id="14879-142">The <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method is called just before the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific preprocessing before the rendering of the control.</span></span>  
  
 <span data-ttu-id="14879-143">Use la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método en combinación con la <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método para asegurarse de apertura y cierre la coherencia entre las etiquetas.</span><span class="sxs-lookup"><span data-stu-id="14879-143">Use the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-144">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base llamadas al método el <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> método. Por lo tanto, se invalida de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> método debe llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base método únicamente si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> (método).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-144">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.BeginRender" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.BeginRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Browser">
      <MemberSignature Language="C#" Value="protected System.Web.HttpBrowserCapabilities Browser { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.HttpBrowserCapabilities Browser" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Browser As HttpBrowserCapabilities" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::HttpBrowserCapabilities ^ Browser { System::Web::HttpBrowserCapabilities ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Browser : System.Web.HttpBrowserCapabilities" Usage="System.Web.UI.Adapters.ControlAdapter.Browser" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Web.HttpBrowserCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14879-145">Obtiene una referencia a las posibilidades del explorador del cliente que realiza la solicitud HTTP actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-145">Gets a reference to the browser capabilities of the client making the current HTTP request.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14879-146">Un <see cref="T:System.Web.HttpBrowserCapabilities" /> que especifica las funciones del explorador del cliente y de marcado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-146">An <see cref="T:System.Web.HttpBrowserCapabilities" /> specifying client browser and markup capabilities.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-147">A <xref:System.Web.UI.Adapters.ControlAdapter> objeto determina las funciones del explorador de cliente desde el <xref:System.Web.HttpBrowserCapabilities> objeto devuelto por la <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="14879-147">A <xref:System.Web.UI.Adapters.ControlAdapter> object determines the client browser capabilities from the <xref:System.Web.HttpBrowserCapabilities> object that is returned by the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property.</span></span> <span data-ttu-id="14879-148">Esto permite la <xref:System.Web.UI.Adapters.ControlAdapter> objeto para representar el marcado específico del explorador o bien modificar el comportamiento de la <xref:System.Web.UI.Control>.</span><span class="sxs-lookup"><span data-stu-id="14879-148">This enables the <xref:System.Web.UI.Adapters.ControlAdapter> object to render browser-specific markup or otherwise modify the behavior of the <xref:System.Web.UI.Control>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14879-149">En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> propiedad para tener acceso a los detalles del explorador que lo solicitado.</span><span class="sxs-lookup"><span data-stu-id="14879-149">The following code example shows how to use the <xref:System.Web.UI.Adapters.ControlAdapter.Browser%2A> property to access the details of the requesting browser.</span></span> <span data-ttu-id="14879-150">En este ejemplo, el código se comprueba para determinar si el explorador es compatible con JavaScript y, a continuación, permite al desarrollador representar el resultado personalizado en ese caso.</span><span class="sxs-lookup"><span data-stu-id="14879-150">In this example, the code checks to determine whether the browser is compatible with JavaScript, and then allows the developer to render customized output in that case.</span></span>  
  
 [!code-cpp[ControlAdapter_Browser#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_Browser/CPP/controladapter_browser.cpp#1)]
 [!code-csharp[ControlAdapter_Browser#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_Browser/CS/controladapter_browser.cs#1)]
 [!code-vb[ControlAdapter_Browser#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_Browser/VB/controladapter_browser.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="T:System.Web.HttpBrowserCapabilities" />
        <altmember cref="T:System.Web.Configuration.HttpCapabilitiesBase" />
      </Docs>
    </Member>
    <Member MemberName="Control">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Control Control { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Control Control" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Control As Control" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Control ^ Control { System::Web::UI::Control ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Control : System.Web.UI.Control" Usage="System.Web.UI.Adapters.ControlAdapter.Control" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Control</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14879-151">Obtiene una referencia al control al que está asociado este adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-151">Gets a reference to the control to which this control adapter is attached.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14879-152">Propiedad <see cref="T:System.Web.UI.Control" /> a la que está asociado el objeto <see cref="T:System.Web.UI.Adapters.ControlAdapter" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-152">The <see cref="T:System.Web.UI.Control" /> to which this <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is attached.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-153">Cuando un adaptador de control derivado se adjunta a un control, .NET Framework llama a ciertos miembros del adaptador en lugar de los miembros del control.</span><span class="sxs-lookup"><span data-stu-id="14879-153">When a derived control adapter is attached to a control, the .NET Framework calls certain adapter members instead of the control members.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14879-154">En el ejemplo de código siguiente se muestra cómo derivar un control personalizado de la <xref:System.Web.UI.Control> clase y, a continuación, crear un adaptador correspondiente que hereda de la <xref:System.Web.UI.Adapters.ControlAdapter> clase.</span><span class="sxs-lookup"><span data-stu-id="14879-154">The following code example shows how to derive a custom control from the <xref:System.Web.UI.Control> class, and then create a corresponding adapter that inherits from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="14879-155">El adaptador reemplaza el <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> propiedad y devuelve una referencia fuertemente tipada al control.</span><span class="sxs-lookup"><span data-stu-id="14879-155">The adapter overrides the <xref:System.Web.UI.Adapters.ControlAdapter.Control%2A> property and returns a strongly-typed reference to the control.</span></span>  
  
 [!code-cpp[ControlAdapter.Control#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter.Control/CPP/controladapter.control.cpp#1)]
 [!code-csharp[ControlAdapter.Control#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter.Control/CS/controladapter.control.cs#1)]
 [!code-vb[ControlAdapter.Control#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter.Control/VB/controladapter.control.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-156">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), como mínimo, debe implementar un <see langword="Control" /> propiedad para devolver una instancia fuertemente tipado del control, tal como se muestra en la sección ejemplo.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-156">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, at a minimum, you should implement a <see langword="Control" /> property to return a strongly-typed instance of the control, as shown in the Example section.</para>
            </span>
          </span>
        </block>
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="CreateChildControls">
      <MemberSignature Language="C#" Value="protected internal virtual void CreateChildControls ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void CreateChildControls() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub CreateChildControls ()" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void CreateChildControls();" />
      <MemberSignature Language="F#" Value="abstract member CreateChildControls : unit -&gt; unit&#xA;override this.CreateChildControls : unit -&gt; unit" Usage="controlAdapter.CreateChildControls " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14879-157">Crea los controles secundarios específicos del destino para un control compuesto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-157">Creates the target-specific child controls for a composite control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-158">Si no hay un adaptador de control derivado conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> se invalida el método, se llama a la invalidación en lugar de la <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-158">If there is a derived control adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> method is overridden, the override is called instead of the <xref:System.Web.UI.Control.CreateChildControls%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="14879-159">Por lo tanto, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> puede utilizarse para crear un conjunto de controles secundarios específico del destino.</span><span class="sxs-lookup"><span data-stu-id="14879-159">Thus, <xref:System.Web.UI.Adapters.ControlAdapter.CreateChildControls%2A> can be used to create a target-specific child control set.</span></span>  
  
 <span data-ttu-id="14879-160">Para obtener más información sobre la combinación de controles para crear un nuevo control, vea [controles compuestos](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).</span><span class="sxs-lookup"><span data-stu-id="14879-160">For more information about combining controls to create a new control, see [Composite Controls](http://msdn.microsoft.com/library/fb174677-d845-467c-8bf3-cc096b2490b0).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-161">
            <para>Si crea una clase heredera y reemplaza el <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> método, realice no llamada al método base a menos que desee agregar controles a los creados por el método base. En caso contrario, puede crear dos conjuntos de secundarios controles.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-161">
              <para>If you create an inheriting class and override the <see cref="M:System.Web.UI.Adapters.ControlAdapter.CreateChildControls" /> method, do not call the base method unless you want to add controls to those created by the base method. Otherwise you could create two sets of child controls.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Web.UI.Control.CreateChildControls" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="EndRender">
      <MemberSignature Language="C#" Value="protected internal virtual void EndRender (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void EndRender(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub EndRender (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void EndRender(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member EndRender : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.EndRender : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.EndRender writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="14879-162">
            <see cref="T:System.Web.UI.HtmlTextWriter" /> que contiene los métodos para representar el resultado específico del destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-162">The <see cref="T:System.Web.UI.HtmlTextWriter" /> containing methods to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-163">Se le llama después de la representación de un control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-163">Called after the rendering of a control.</span>
          </span>
          <span data-ttu-id="14879-164">En una clase de adaptador derivada, genera etiquetas de cierre requeridas por un destino concreto pero que no son necesarias para los exploradores de HTML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-164">In a derived adapter class, generates closing tags that are required by a specific target but not needed by HTML browsers.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-165">El <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método se llama justo después de la <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> (método) y se usa para realizar secuencias específico del destino posterior a la representación del control.</span><span class="sxs-lookup"><span data-stu-id="14879-165">The <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method is called just after the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method, and is used to perform target-specific postprocessing after the rendering of the control.</span></span>  
  
 <span data-ttu-id="14879-166">Use la <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> método en combinación con la <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> método para asegurarse de apertura y cierre la coherencia entre las etiquetas.</span><span class="sxs-lookup"><span data-stu-id="14879-166">Use the <xref:System.Web.UI.Adapters.ControlAdapter.EndRender%2A> method in combination with the <xref:System.Web.UI.Adapters.ControlAdapter.BeginRender%2A> method to ensure opening and closing tag consistency.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-167">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base llamadas al método el <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> método. Por lo tanto, se invalida de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> método debe llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base método únicamente si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> (método).</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-167">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.EndRender(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.HtmlTextWriter.EndRender" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Web.UI.HtmlTextWriter.EndRender" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.BeginRender(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.HtmlTextWriter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterControlState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterControlState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterControlState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterControlState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterControlState : obj -&gt; unit&#xA;override this.LoadAdapterControlState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterControlState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="14879-168">Un objeto <see cref="T:System.Object" /> que contiene la información de estado de los controles del adaptador como <see cref="T:System.Web.UI.StateBag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-168">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-169">Carga información de estado del control de adaptador, guardada por <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> durante una solicitud anterior, en la página donde reside el control asociado a este adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-169">Loads adapter control state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-170">Estado del control es la información de estado esencial necesaria incluso si se deshabilita el estado de vista.</span><span class="sxs-lookup"><span data-stu-id="14879-170">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="14879-171">Cuando un adaptador necesita mantener su propia información de estado de control, puede invalidar la <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="14879-171">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="14879-172">Un adaptador podría necesitar mantener información de estado de control cuando hay características que necesitan tener mantener el estado entre las solicitudes, independientemente del estado del control asociado.</span><span class="sxs-lookup"><span data-stu-id="14879-172">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="14879-173">Por ejemplo, un control compuesto que consta de una presentación textual grande y un grupo de <xref:System.Web.UI.WebControls.RadioButton> controles podrían representarse como una vista única en exploradores de equipos de escritorio.</span><span class="sxs-lookup"><span data-stu-id="14879-173">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="14879-174">En otros exploradores, su representación podría dividirse: una vista para la presentación textual y otra para el grupo de botones de radio.</span><span class="sxs-lookup"><span data-stu-id="14879-174">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="14879-175">El adaptador tendría que mantener su propia información específica de destino acerca de la vista activa.</span><span class="sxs-lookup"><span data-stu-id="14879-175">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="14879-176">El <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> método se llama inmediatamente después de la <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> método, en la `LoadState` fase del ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="14879-176">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.LoadControlState%2A?displayProperty=nameWithType> method, in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="14879-177">El estado del control de adaptador es independiente y además el estado del control del control.</span><span class="sxs-lookup"><span data-stu-id="14879-177">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadControlState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="LoadAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual void LoadAdapterViewState (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void LoadAdapterViewState(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub LoadAdapterViewState (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void LoadAdapterViewState(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member LoadAdapterViewState : obj -&gt; unit&#xA;override this.LoadAdapterViewState : obj -&gt; unit" Usage="controlAdapter.LoadAdapterViewState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">
          <span data-ttu-id="14879-178">
            <see cref="T:System.Object" /> que contiene la información de estado de la vista del adaptador como <see cref="T:System.Web.UI.StateBag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-178">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-179">Carga información del estado de la vista del adaptador, guardada por <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> durante una solicitud anterior, en la página donde reside el control asociado a este adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-179">Loads adapter view state information that was saved by <see cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" /> during a previous request to the page where the control associated with this control adapter resides.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-180">Cuando un adaptador necesita mantener su propia información de estado de vista, puede invalidar la <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="14879-180">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="14879-181">Un adaptador necesita mantener información de estado de vista cuando hay datos que deben mantenerse entre las solicitudes, independientemente del estado de vista del control asociado.</span><span class="sxs-lookup"><span data-stu-id="14879-181">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the view state of the associated control.</span></span> <span data-ttu-id="14879-182">Por ejemplo, un control de cuadrícula en exploradores de equipos de escritorio podría representarse como una vista única de filas y columnas de valores.</span><span class="sxs-lookup"><span data-stu-id="14879-182">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="14879-183">En otros exploradores, su representación en varias vistas distintas, como una lista de filas y los detalles de una sola fila podría dividirse.</span><span class="sxs-lookup"><span data-stu-id="14879-183">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="14879-184">El adaptador tendría que mantener los datos de las vistas que no están activas actualmente en estado de vista.</span><span class="sxs-lookup"><span data-stu-id="14879-184">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="14879-185">El <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> método se llama inmediatamente antes del <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> método en el `LoadState` fase del ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="14879-185">The <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.LoadViewState%2A?displayProperty=nameWithType> method in the `LoadState` lifecycle stage.</span></span> <span data-ttu-id="14879-186">El estado de vista de adaptador es independiente y además el estado de vista del control.</span><span class="sxs-lookup"><span data-stu-id="14879-186">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.LoadViewState(System.Object)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
    <Member MemberName="OnInit">
      <MemberSignature Language="C#" Value="protected internal virtual void OnInit (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnInit(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnInit (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnInit(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnInit : EventArgs -&gt; unit&#xA;override this.OnInit : EventArgs -&gt; unit" Usage="controlAdapter.OnInit e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="14879-187">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-187">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-188">Reemplaza el método <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> para el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-188">Overrides the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-189">Si no hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-189">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnInit%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="14879-190">Invalidar <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> para realizar el procesamiento específico del destino en la `Initialize` fase del ciclo de vida de control.</span><span class="sxs-lookup"><span data-stu-id="14879-190">Override <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> to perform target-specific processing in the `Initialize` stage of the control lifecycle.</span></span> <span data-ttu-id="14879-191">Normalmente, estas son funciones que se llevan a cabo cuando se crea un control.</span><span class="sxs-lookup"><span data-stu-id="14879-191">Typically, these are functions that are performed when a control is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="14879-192">El ejemplo de código siguiente deriva un adaptador de control personalizado de la <xref:System.Web.UI.Adapters.ControlAdapter> clase.</span><span class="sxs-lookup"><span data-stu-id="14879-192">The following code sample derives a custom control adapter from the <xref:System.Web.UI.Adapters.ControlAdapter> class.</span></span> <span data-ttu-id="14879-193">A continuación, reemplaza el <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> método para establecer una propiedad en el control asociado y llamar al método base para completar la inicialización del control.</span><span class="sxs-lookup"><span data-stu-id="14879-193">It then overrides the <xref:System.Web.UI.Adapters.ControlAdapter.OnInit%2A> method to set a property on the associated control and call the base method to complete the control initialization.</span></span>  
  
 [!code-cpp[ControlAdapter_OnInit#1](~/samples/snippets/cpp/VS_Snippets_WebNet/ControlAdapter_OnInit/CPP/controladapter_oninit.cpp#1)]
 [!code-csharp[ControlAdapter_OnInit#1](~/samples/snippets/csharp/VS_Snippets_WebNet/ControlAdapter_OnInit/CS/controladapter_oninit.cs#1)]
 [!code-vb[ControlAdapter_OnInit#1](~/samples/snippets/visualbasic/VS_Snippets_WebNet/ControlAdapter_OnInit/VB/controladapter_oninit.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-194">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama el <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> método. Si el <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> no se llama el método, el <see cref="E:System.Web.UI.Control.Init" /> no se producen eventos.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-194">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnInit(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method. If the <see cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.Init" /> event will not be raised.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Web.UI.Control.Init" />
        <altmember cref="M:System.Web.UI.Control.OnInit(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnLoad">
      <MemberSignature Language="C#" Value="protected internal virtual void OnLoad (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnLoad(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnLoad (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnLoad(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnLoad : EventArgs -&gt; unit&#xA;override this.OnLoad : EventArgs -&gt; unit" Usage="controlAdapter.OnLoad e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="14879-195">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-195">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-196">Reemplaza el método <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> para el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-196">Overrides the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-197">Si no hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-197">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnLoad%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="14879-198">Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> método para realizar el procesamiento específico del destino en la `Load` fase del ciclo de vida de control.</span><span class="sxs-lookup"><span data-stu-id="14879-198">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnLoad%2A> method to perform target-specific processing in the `Load` stage of the control lifecycle.</span></span> <span data-ttu-id="14879-199">Normalmente, estas son funciones que se deben realizar para cada solicitud de cliente.</span><span class="sxs-lookup"><span data-stu-id="14879-199">Typically, these are functions that should be performed for each client request.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-200">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama el <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> método. Si <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> no se llama, el <see cref="E:System.Web.UI.Control.Load" /> no se producen eventos.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-200">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnLoad(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> method. If <see cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Load" /> event will not be raised.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Web.UI.Control.Load" />
        <altmember cref="M:System.Web.UI.Control.OnLoad(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnPreRender">
      <MemberSignature Language="C#" Value="protected internal virtual void OnPreRender (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnPreRender(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnPreRender (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnPreRender(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnPreRender : EventArgs -&gt; unit&#xA;override this.OnPreRender : EventArgs -&gt; unit" Usage="controlAdapter.OnPreRender e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="14879-201">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-201">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-202">Reemplaza el método <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> para el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-202">Overrides the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-203">Si no hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-203">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnPreRender%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="14879-204">Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> método para realizar el procesamiento específico del destino en la `PreRender` fase del ciclo de vida de control.</span><span class="sxs-lookup"><span data-stu-id="14879-204">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnPreRender%2A> method to perform target-specific processing in the `PreRender` stage of the control lifecycle.</span></span> <span data-ttu-id="14879-205">Normalmente, estas son funciones que precedan inmediatamente a la representación de los resultados del control.</span><span class="sxs-lookup"><span data-stu-id="14879-205">Typically, these are functions that immediately precede rendering of the control output.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-206">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama el <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> método. Si el <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> no se llama el método, el <see cref="E:System.Web.UI.Control.PreRender" /> no se producen eventos.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-206">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnPreRender(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method. If the <see cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" /> method is not called, the <see cref="E:System.Web.UI.Control.PreRender" /> event will not be raised.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Web.UI.Control.PreRender" />
        <altmember cref="M:System.Web.UI.Control.OnPreRender(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="OnUnload">
      <MemberSignature Language="C#" Value="protected internal virtual void OnUnload (EventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void OnUnload(class System.EventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub OnUnload (e As EventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void OnUnload(EventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnUnload : EventArgs -&gt; unit&#xA;override this.OnUnload : EventArgs -&gt; unit" Usage="controlAdapter.OnUnload e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.EventArgs" />
      </Parameters>
      <Docs>
        <param name="e">
          <span data-ttu-id="14879-207">Objeto <see cref="T:System.EventArgs" /> que contiene los datos del evento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-207">An <see cref="T:System.EventArgs" /> that contains the event data.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-208">Reemplaza el método <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> para el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-208">Overrides the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method for the associated control.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-209">Si no hay un adaptador conectado a un <xref:System.Web.UI.Control> objeto y el <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> se invalida el método, se llama al método de invalidación en lugar de la <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="14879-209">If there is an adapter attached to a <xref:System.Web.UI.Control> object and the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method is overridden, the override method is called instead of the <xref:System.Web.UI.Control.OnUnload%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="14879-210">Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> método para realizar el procesamiento específico del destino la `Unload` fase del ciclo de vida de control.</span><span class="sxs-lookup"><span data-stu-id="14879-210">Override the <xref:System.Web.UI.Adapters.ControlAdapter.OnUnload%2A> method to do target-specific processing in the `Unload` stage of the control lifecycle.</span></span> <span data-ttu-id="14879-211">Normalmente, estas son las funciones de limpieza que preceden a la eliminación del control.</span><span class="sxs-lookup"><span data-stu-id="14879-211">Typically, these are cleanup functions that precede disposition of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-212">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> clase y las invalidaciones de adaptador el <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> método, el adaptador debe llamar al método de clase base correspondiente, que a su vez llama el <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> método. Si <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> no se llama, el <see cref="E:System.Web.UI.Control.Unload" /> no se producen eventos.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-212">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class and the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.OnUnload(System.EventArgs)" /> method, the adapter must call the corresponding base class method, which in turn calls the <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> method. If <see cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" /> is not called, the <see cref="E:System.Web.UI.Control.Unload" /> event will not be raised.</para>
            </span>
          </span>
        </block>
        <altmember cref="E:System.Web.UI.Control.Unload" />
        <altmember cref="M:System.Web.UI.Control.OnUnload(System.EventArgs)" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Page">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Page Page { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Page Page" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Page As Page" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Page ^ Page { System::Web::UI::Page ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Page : System.Web.UI.Page" Usage="System.Web.UI.Adapters.ControlAdapter.Page" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Page</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14879-213">Obtiene una referencia a la página donde reside el control asociado a este adaptador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-213">Gets a reference to the page where the control associated with this adapter resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14879-214">Un <see cref="T:System.Web.UI.Page" /> que proporciona acceso a la instancia de la página donde se encuentra el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-214">A <see cref="T:System.Web.UI.Page" /> that provides access to the page instance where the associated control is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-215">El <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> propiedad proporciona acceso a la <xref:System.Web.UI.Page?displayProperty=nameWithType> objeto donde se encuentra el control.</span><span class="sxs-lookup"><span data-stu-id="14879-215">The <xref:System.Web.UI.Adapters.ControlAdapter.Page%2A> property provides access to the <xref:System.Web.UI.Page?displayProperty=nameWithType> object where the control is situated.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Page" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="PageAdapter">
      <MemberSignature Language="C#" Value="protected System.Web.UI.Adapters.PageAdapter PageAdapter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Web.UI.Adapters.PageAdapter PageAdapter" />
      <MemberSignature Language="DocId" Value="P:System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property PageAdapter As PageAdapter" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Web::UI::Adapters::PageAdapter ^ PageAdapter { System::Web::UI::Adapters::PageAdapter ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PageAdapter : System.Web.UI.Adapters.PageAdapter" Usage="System.Web.UI.Adapters.ControlAdapter.PageAdapter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.Browsable(false)</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Web.UI.Adapters.PageAdapter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="14879-216">Obtiene una referencia al adaptador de la página donde reside el control asociado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-216">Gets a reference to the page adapter for the page where the associated control resides.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="14879-217">
            <see cref="T:System.Web.UI.Adapters.PageAdapter" /> para la página donde se encuentra el control asociado al <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-217">A <see cref="T:System.Web.UI.Adapters.PageAdapter" /> for the page where the control associated with the current <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> is situated.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-218">El <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propiedad proporciona acceso a la <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> de objeto para el <xref:System.Web.UI.Page> objeto donde el <xref:System.Web.UI.Control> objeto asociado con el actual <xref:System.Web.UI.Adapters.ControlAdapter> se encuentra el objeto.</span><span class="sxs-lookup"><span data-stu-id="14879-218">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property provides access to the <xref:System.Web.UI.Adapters.PageAdapter?displayProperty=nameWithType> object for the <xref:System.Web.UI.Page> object where the <xref:System.Web.UI.Control> object associated with the current <xref:System.Web.UI.Adapters.ControlAdapter> object is situated.</span></span>  
  
 <span data-ttu-id="14879-219">El <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> propiedad puede utilizarse para tener acceso a otros elementos en el nivel de adaptador de página, como funciones específicas del destino comunes que pueden aplicarse a varios tipos de control en la página.</span><span class="sxs-lookup"><span data-stu-id="14879-219">The <xref:System.Web.UI.Adapters.ControlAdapter.PageAdapter%2A> property can be used to access other items at the page adapter level, such as common target-specific functions that could apply to several control types on the page.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Web.UI.Adapters.PageAdapter" />
        <altmember cref="T:System.Web.UI.Control" />
      </Docs>
    </Member>
    <Member MemberName="Render">
      <MemberSignature Language="C#" Value="protected internal virtual void Render (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance void Render(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Sub Render (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual void Render(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member Render : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.Render : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.Render writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="14879-220">
            <see cref="T:System.Web.UI.HtmlTextWriter" /> que se utiliza para representar el resultado específico del destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-220">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-221">Genera el marcado específico del destino para el control al que está asociado el adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-221">Generates the target-specific markup for the control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-222">Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método para generar el marcado específico del destino que se envía al explorador del cliente.</span><span class="sxs-lookup"><span data-stu-id="14879-222">Override the <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method to generate target-specific markup to send to the client browser.</span></span> <span data-ttu-id="14879-223">El <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> método se llama en lugar de la <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> método si un <xref:System.Web.UI.Adapters.ControlAdapter> objeto está asociado a un <xref:System.Web.UI.Control> objeto.</span><span class="sxs-lookup"><span data-stu-id="14879-223">The <xref:System.Web.UI.Adapters.ControlAdapter.Render%2A> method is called in place of the <xref:System.Web.UI.Control.Render%2A?displayProperty=nameWithType> method if a <xref:System.Web.UI.Adapters.ControlAdapter> object is attached to a <xref:System.Web.UI.Control> object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-224">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base llamadas al método el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método. Por lo tanto, se invalida de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método debe llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base método únicamente si su procesamiento es además, en lugar de en lugar de la <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> (método).  Para un control compuesto, el desarrollador de adaptadores debe garantizar que se representan los controles secundarios. Si el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> causas de método controla para representar el elemento secundario, pero no genera el marcado, puede que sea adecuado para el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para llamar a su método base. Si es necesaria específico del destino de representación de los controles secundarios, el adaptador debe implementar la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método y llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método desde el <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-224">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method. Thus, overrides of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> base method only if its processing is in addition to, rather than instead of, the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method.  For a composite control, the adapter developer must ensure that the child controls are rendered. If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method. If target-specific rendering of the child controls is necessary, the adapter should implement the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method and call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.RenderControl(System.Web.UI.HtmlTextWriter,System.Web.UI.Adapters.ControlAdapter)" />
      </Docs>
    </Member>
    <Member MemberName="RenderChildren">
      <MemberSignature Language="C#" Value="protected virtual void RenderChildren (System.Web.UI.HtmlTextWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void RenderChildren(class System.Web.UI.HtmlTextWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub RenderChildren (writer As HtmlTextWriter)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void RenderChildren(System::Web::UI::HtmlTextWriter ^ writer);" />
      <MemberSignature Language="F#" Value="abstract member RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit&#xA;override this.RenderChildren : System.Web.UI.HtmlTextWriter -&gt; unit" Usage="controlAdapter.RenderChildren writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Web.UI.HtmlTextWriter" />
      </Parameters>
      <Docs>
        <param name="writer">
          <span data-ttu-id="14879-225">
            <see cref="T:System.Web.UI.HtmlTextWriter" /> que se utiliza para representar el resultado específico del destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-225">The <see cref="T:System.Web.UI.HtmlTextWriter" /> to use to render the target-specific output.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="14879-226">Genera el marcado específico del destino para los controles secundarios en un control compuesto al que está asociado el adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-226">Generates the target-specific markup for the child controls in a composite control to which the control adapter is attached.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-227">Invalidar el <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> método cuando es necesario generar el marcado específico del destino para el conjunto de controles secundarios de un control compuesto, además en el marcado de los controles secundarios individuales.</span><span class="sxs-lookup"><span data-stu-id="14879-227">Override the <xref:System.Web.UI.Adapters.ControlAdapter.RenderChildren%2A> method when it is necessary to generate target-specific markup for the child control set of a composite control, in addition to the markup for the individual child controls.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="14879-228">
            <para>Al heredar de la <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> (clase), para un control compuesto, el desarrollador de adaptadores debe garantizar que se representan los controles secundarios. Si el adaptador reemplaza el <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método, debe llamar a la <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método desde un reemplazo de la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método.  Si el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> causas de método controla para representar el elemento secundario, pero sí no genera marcado, puede que sea adecuado para la <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> método para llamar a su método base, que llama el <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> método, en lugar de implementar una invalidación para el <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> método.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-228">
              <para>When you inherit from the <see cref="T:System.Web.UI.Adapters.ControlAdapter" /> class, for a composite control, the adapter developer must ensure that the child controls are rendered. If the adapter overrides the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method, it should call the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method from an override of the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method.  If the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method causes the child controls to be rendered but itself does not generate markup, it might be appropriate for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" /> method to call its base method, which calls the <see cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" /> method, instead of implementing an override for the <see cref="M:System.Web.UI.Adapters.ControlAdapter.RenderChildren(System.Web.UI.HtmlTextWriter)" /> method.</para>
            </span>
          </span>
        </block>
        <altmember cref="M:System.Web.UI.Control.RenderChildren(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.Render(System.Web.UI.HtmlTextWriter)" />
        <altmember cref="M:System.Web.UI.Control.Render(System.Web.UI.HtmlTextWriter)" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterControlState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterControlState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterControlState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterControlState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterControlState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterControlState : unit -&gt; obj&#xA;override this.SaveAdapterControlState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterControlState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14879-229">Guarda información de estado de control para el adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-229">Saves control state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14879-230">Un objeto <see cref="T:System.Object" /> que contiene la información de estado de los controles del adaptador como <see cref="T:System.Web.UI.StateBag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-230">An <see cref="T:System.Object" /> that contains the adapter's control state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-231">Estado del control es la información de estado esencial necesaria incluso si se deshabilita el estado de vista.</span><span class="sxs-lookup"><span data-stu-id="14879-231">Control state is the essential state information needed even if view state is disabled.</span></span> <span data-ttu-id="14879-232">Cuando un adaptador necesita mantener su propia información de estado de control, puede invalidar la <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="14879-232">When an adapter needs to maintain its own control state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState%2A> methods.</span></span>  
  
 <span data-ttu-id="14879-233">Un adaptador podría necesitar mantener información de estado de control cuando hay características que necesitan tener mantener el estado entre las solicitudes, independientemente del estado del control asociado.</span><span class="sxs-lookup"><span data-stu-id="14879-233">An adapter might need to maintain control state information when there are features that need to have state maintained across requests, independent from the state of the associated control.</span></span> <span data-ttu-id="14879-234">Por ejemplo, un control compuesto que consta de una presentación textual grande y un grupo de <xref:System.Web.UI.WebControls.RadioButton> controles podrían representarse como una vista única en exploradores de equipos de escritorio.</span><span class="sxs-lookup"><span data-stu-id="14879-234">For example, a composite control consisting of a large textual display and a group of <xref:System.Web.UI.WebControls.RadioButton> controls might render as a single view on desktop computer browsers.</span></span> <span data-ttu-id="14879-235">En otros exploradores, su representación podría dividirse: una vista para la presentación textual y otra para el grupo de botones de radio.</span><span class="sxs-lookup"><span data-stu-id="14879-235">On other browsers, it might split its rendering—one view for the textual display and the other for the radio button group.</span></span> <span data-ttu-id="14879-236">El adaptador tendría que mantener su propia información específica de destino acerca de la vista activa.</span><span class="sxs-lookup"><span data-stu-id="14879-236">The adapter would need to maintain its own target-specific information about the currently active view.</span></span>  
  
 <span data-ttu-id="14879-237">El <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> método se llama inmediatamente después de la <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> método en el `SaveState` fase del ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="14879-237">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState%2A> method is called immediately after the <xref:System.Web.UI.Control.SaveControlState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="14879-238">El estado del control de adaptador es independiente y además el estado del control del control.</span><span class="sxs-lookup"><span data-stu-id="14879-238">The adapter control state is separate and in addition to the control state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveControlState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterControlState(System.Object)" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      </Docs>
    </Member>
    <Member MemberName="SaveAdapterViewState">
      <MemberSignature Language="C#" Value="protected internal virtual object SaveAdapterViewState ();" />
      <MemberSignature Language="ILAsm" Value=".method familyorassemblyhidebysig newslot virtual instance object SaveAdapterViewState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState" />
      <MemberSignature Language="VB.NET" Value="Protected Friend Overridable Function SaveAdapterViewState () As Object" />
      <MemberSignature Language="C++ CLI" Value="protected public:&#xA; virtual System::Object ^ SaveAdapterViewState();" />
      <MemberSignature Language="F#" Value="abstract member SaveAdapterViewState : unit -&gt; obj&#xA;override this.SaveAdapterViewState : unit -&gt; obj" Usage="controlAdapter.SaveAdapterViewState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Web</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="14879-239">Guarda información del estado de vista para el adaptador de control.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-239">Saves view state information for the control adapter.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="14879-240">
            <see cref="T:System.Object" /> que contiene la información de estado de la vista del adaptador como <see cref="T:System.Web.UI.StateBag" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="14879-240">An <see cref="T:System.Object" /> that contains the adapter view state information as a <see cref="T:System.Web.UI.StateBag" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="14879-241">Cuando un adaptador necesita mantener su propia información de estado de vista, puede invalidar la <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> y <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="14879-241">When an adapter needs to maintain its own view state information, it can override the <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> and <xref:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState%2A> methods.</span></span>  
  
 <span data-ttu-id="14879-242">Un adaptador necesita mantener información de estado de vista cuando hay datos que deben mantenerse entre las solicitudes, independientemente del estado de vista asociada del control.</span><span class="sxs-lookup"><span data-stu-id="14879-242">An adapter needs to maintain view state information when there is data that must be maintained across requests, independent from the associated view state of the control.</span></span> <span data-ttu-id="14879-243">Por ejemplo, un control de cuadrícula en exploradores de equipos de escritorio podría representarse como una vista única de filas y columnas de valores.</span><span class="sxs-lookup"><span data-stu-id="14879-243">For example, a grid control on desktop computer browsers might render as a single view of rows and columns of values.</span></span> <span data-ttu-id="14879-244">En otros exploradores, su representación en varias vistas distintas, como una lista de filas y los detalles de una sola fila podría dividirse.</span><span class="sxs-lookup"><span data-stu-id="14879-244">On other browsers, it might split its rendering into multiple separate views, such as a list of rows and details of a single row.</span></span> <span data-ttu-id="14879-245">El adaptador tendría que mantener los datos de las vistas que no están activas actualmente en estado de vista.</span><span class="sxs-lookup"><span data-stu-id="14879-245">The adapter would need to maintain the data for the views that are not currently active in view state.</span></span>  
  
 <span data-ttu-id="14879-246">El <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> método se llama inmediatamente antes del <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> método en el `SaveState` fase del ciclo de vida.</span><span class="sxs-lookup"><span data-stu-id="14879-246">The <xref:System.Web.UI.Adapters.ControlAdapter.SaveAdapterViewState%2A> method is called immediately before the <xref:System.Web.UI.Control.SaveViewState%2A?displayProperty=nameWithType> method in the `SaveState` lifecycle stage.</span></span> <span data-ttu-id="14879-247">El estado de vista de adaptador es independiente y además el estado de vista del control.</span><span class="sxs-lookup"><span data-stu-id="14879-247">The adapter view state is separate and in addition to the view state of the control.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Web.UI.Control.SaveViewState" />
        <altmember cref="T:System.Web.UI.Control" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.SaveAdapterControlState" />
        <altmember cref="M:System.Web.UI.Adapters.ControlAdapter.LoadAdapterViewState(System.Object)" />
        <altmember cref="P:System.Web.UI.Control.ViewState" />
      </Docs>
    </Member>
  </Members>
</Type>