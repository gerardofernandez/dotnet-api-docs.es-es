<Type Name="FileSystem" FullName="Microsoft.VisualBasic.FileSystem">
  <Metadata><Meta Name="ms.openlocfilehash" Value="934f06896ded78a1be250bb2062ad8017ce8cb49" /><Meta Name="ms.sourcegitcommit" Value="4ee26ac79338b0bf99fa1e0913e8a06b21994d8e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/26/2019" /><Meta Name="ms.locfileid" Value="58462104" /></Metadata><TypeSignature Language="C#" Value="public sealed class FileSystem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit FileSystem extends System.Object" />
  <TypeSignature Language="DocId" Value="T:Microsoft.VisualBasic.FileSystem" />
  <TypeSignature Language="VB.NET" Value="Public Module FileSystem" />
  <TypeSignature Language="C++ CLI" Value="public ref class FileSystem sealed" />
  <TypeSignature Language="F#" Value="type FileSystem = class" />
  <AssemblyInfo>
    <AssemblyName>Microsoft.VisualBasic</AssemblyName>
    <AssemblyVersion>7.0.5000.0</AssemblyVersion>
    <AssemblyVersion>8.0.0.0</AssemblyVersion>
    <AssemblyVersion>10.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>Microsoft.VisualBasic.CompilerServices.StandardModule</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="a0362-101">El módulo <see langword="FileSystem" /> contiene los procedimientos utilizados para realizar operaciones con archivos, directorios o carpetas y del sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-101">The <see langword="FileSystem" /> module contains the procedures that are used to perform file, directory or folder, and system operations.</span></span> <span data-ttu-id="a0362-102">La característica <see langword="My" /> proporciona mayor productividad y rendimiento en las operaciones de E/S con archivos que el módulo <see langword="FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-102">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than using the <see langword="FileSystem" /> module.</span></span> <span data-ttu-id="a0362-103">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-103">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-104">Este módulo admite las palabras clave del lenguaje Visual Basic y miembros de la biblioteca de tiempo de ejecución que tienen acceso a archivos y carpetas.</span><span class="sxs-lookup"><span data-stu-id="a0362-104">This module supports the Visual Basic language keywords and run-time library members that access files and folders.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-105">Este ejemplo se usa el `GetAttr` función para determinar los atributos de un archivo, directorio o carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-105">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/directories-and-files-summary.md"><span data-ttu-id="a0362-106">Resumen de archivos y directorios</span><span class="sxs-lookup"><span data-stu-id="a0362-106">Directories and Files Summary</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/input-and-output-summary.md"><span data-ttu-id="a0362-107">Resumen de entrada y salida</span><span class="sxs-lookup"><span data-stu-id="a0362-107">Input and Output Summary</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/keywords/index.md"><span data-ttu-id="a0362-108">Palabras clave de Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-108">Keywords (Visual Basic)</span></span></related>
    <related type="Article" href="~/docs/visual-basic/language-reference/runtime-library-members.md"><span data-ttu-id="a0362-109">Miembros de la biblioteca de tiempo de ejecución de Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-109">Visual Basic Run-Time Library Members</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ChDir">
      <MemberSignature Language="C#" Value="public static void ChDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member ChDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a0362-110">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-110">Required.</span></span> <span data-ttu-id="a0362-111">Expresión de cadena que identifica el directorio o la carpeta que se convierte en el nuevo directorio predeterminado o la nueva carpeta predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a0362-111">A string expression that identifies which directory or folder becomes the new default directory or folder.</span></span> <span data-ttu-id="a0362-112"><paramref name="Path" /> puede incluir la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-112"><paramref name="Path" /> may include the drive.</span></span> <span data-ttu-id="a0362-113">Si no se especifica ninguna unidad, <see langword="ChDir" /> cambia el directorio predeterminado o la carpeta predeterminada en la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-113">If no drive is specified, <see langword="ChDir" /> changes the default directory or folder on the current drive.</span></span></param>
        <summary><span data-ttu-id="a0362-114">Cambia el directorio o la carpeta actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-114">Changes the current directory or folder.</span></span> <span data-ttu-id="a0362-115">La característica <see langword="My" /> proporciona mayor productividad y rendimiento que la función <see langword="ChDir" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-115">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than the <see langword="ChDir" /> function.</span></span> <span data-ttu-id="a0362-116">Para obtener más información, consulta <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-116">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-117">El `ChDir` función cambia el directorio predeterminado, pero no la unidad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a0362-117">The `ChDir` function changes the default directory, but not the default drive.</span></span> <span data-ttu-id="a0362-118">Por ejemplo, si la unidad predeterminada es C, la instrucción siguiente cambia el directorio predeterminado en la unidad D, pero C sigue siendo la unidad predeterminada:</span><span class="sxs-lookup"><span data-stu-id="a0362-118">For example, if the default drive is C, the following statement changes the default directory on drive D, but C remains the default drive:</span></span>  
  
 [!code-vb[VbVbalrCatRef#39](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#39)]  
  
 <span data-ttu-id="a0362-119">Puede convertir en relativo es cambios de directorio, escriba dos puntos, como se indica a continuación:</span><span class="sxs-lookup"><span data-stu-id="a0362-119">You can make relative directory changes is by typing two periods, as follows:</span></span>  
  
 [!code-vb[VbVbalrCatRef#40](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#40)]  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-120">El `ChDir` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="a0362-120">The `ChDir` function requires unmanaged code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a0362-121">Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y.</span><span class="sxs-lookup"><span data-stu-id="a0362-121">For more information, see <xref:System.Security.Permissions.SecurityPermission> and .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-122">Este ejemplo se usa el `ChDir` función puede cambiar el directorio actual o la carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-122">This example uses the `ChDir` function to change the current directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#41](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-123"><paramref name="Path" /> está vacía.</span><span class="sxs-lookup"><span data-stu-id="a0362-123"><paramref name="Path" /> is empty.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-124">Se ha especificado una unidad no válida o la unidad no está disponible.</span><span class="sxs-lookup"><span data-stu-id="a0362-124">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-parse-file-paths.md"><span data-ttu-id="a0362-125">Cómo: Analizar rutas de acceso a archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-125">How to: Parse File Paths in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/creating-deleting-and-moving-files-and-directories.md"><span data-ttu-id="a0362-126">Crear, eliminar y mover archivos y directorios en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-126">Creating, Deleting, and Moving Files and Directories in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="ChDrive">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-127">Cambia la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-127">Changes the current drive.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(char Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : char -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a0362-128">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-128">Required.</span></span> <span data-ttu-id="a0362-129">Expresión de cadena que especifica una unidad existente.</span><span class="sxs-lookup"><span data-stu-id="a0362-129">String expression that specifies an existing drive.</span></span> <span data-ttu-id="a0362-130">Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia.</span><span class="sxs-lookup"><span data-stu-id="a0362-130">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="a0362-131">Si el argumento <paramref name="Drive" /> es una cadena de varios caracteres, <see langword="ChDrive" /> utiliza sólo la primera letra.</span><span class="sxs-lookup"><span data-stu-id="a0362-131">If the <paramref name="Drive" /> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="a0362-132">Cambia la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-132">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-133">El `ChDrive` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="a0362-133">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a0362-134">Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a0362-134">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-135">Este ejemplo se usa el `ChDrive` función puede cambiar la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-135">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="a0362-136">La función produce una excepción si la unidad no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-136">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-137">Se ha especificado una unidad no válida o la unidad no está disponible.</span><span class="sxs-lookup"><span data-stu-id="a0362-137">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-138">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-138">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ChDrive">
      <MemberSignature Language="C#" Value="public static void ChDrive (string Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static void ChDrive(string Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.ChDrive(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ChDrive (Drive As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ChDrive(System::String ^ Drive);" />
      <MemberSignature Language="F#" Value="static member ChDrive : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.ChDrive Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a0362-139">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-139">Required.</span></span> <span data-ttu-id="a0362-140">Expresión de cadena que especifica una unidad existente.</span><span class="sxs-lookup"><span data-stu-id="a0362-140">String expression that specifies an existing drive.</span></span> <span data-ttu-id="a0362-141">Si se proporciona una cadena de longitud cero (""), la unidad actual no cambia.</span><span class="sxs-lookup"><span data-stu-id="a0362-141">If you supply a zero-length string (""), the current drive does not change.</span></span> <span data-ttu-id="a0362-142">Si el argumento <paramref name="Drive" /> es una cadena de varios caracteres, <see langword="ChDrive" /> utiliza sólo la primera letra.</span><span class="sxs-lookup"><span data-stu-id="a0362-142">If the <paramref name="Drive" /> argument is a multiple-character string, <see langword="ChDrive" /> uses only the first letter.</span></span></param>
        <summary><span data-ttu-id="a0362-143">Cambia la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-143">Changes the current drive.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-144">El `ChDrive` función requiere el permiso de código no administrado, lo que puede afectar a su ejecución en situaciones de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="a0362-144">The `ChDrive` function requires unmanaged-code permission, which may affect its execution in partial-trust situations.</span></span> <span data-ttu-id="a0362-145">Para obtener más información, consulte <xref:System.Security.Permissions.SecurityPermission> y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a0362-145">For more information, see <xref:System.Security.Permissions.SecurityPermission> and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-146">Este ejemplo se usa el `ChDrive` función puede cambiar la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-146">This example uses the `ChDrive` function to change the current drive.</span></span> <span data-ttu-id="a0362-147">La función produce una excepción si la unidad no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-147">The function throws an exception if the drive does not exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#32](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-148">Se ha especificado una unidad no válida o la unidad no está disponible.</span><span class="sxs-lookup"><span data-stu-id="a0362-148">Invalid drive is specified, or drive is unavailable.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Dir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-149">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-149">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CurDir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-150">Devuelve una cadena que representa la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-150">Returns a string representing the current path.</span></span> <span data-ttu-id="a0362-151">El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-151">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a0362-152">Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-152">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir();" />
      <MemberSignature Language="F#" Value="static member CurDir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0362-153">Devuelve una cadena que representa la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-153">Returns a string representing the current path.</span></span> <span data-ttu-id="a0362-154">El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-154">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a0362-155">Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-155">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-156">Una cadena que representa la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-156">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0362-157">Este ejemplo se usa el `CurDir` función para devolver la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-157">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <Member MemberName="CurDir">
      <MemberSignature Language="C#" Value="public static string CurDir (char Drive);" />
      <MemberSignature Language="ILAsm" Value=".method public static string CurDir(char Drive) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.CurDir(System.Char)" />
      <MemberSignature Language="VB.NET" Value="Public Function CurDir (Drive As Char) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CurDir(char Drive);" />
      <MemberSignature Language="F#" Value="static member CurDir : char -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.CurDir Drive" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Drive" Type="System.Char" />
      </Parameters>
      <Docs>
        <param name="Drive"><span data-ttu-id="a0362-158">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-158">Optional.</span></span> <span data-ttu-id="a0362-159">Expresión de tipo <see langword="Char" /> que especifica una unidad existente.</span><span class="sxs-lookup"><span data-stu-id="a0362-159"><see langword="Char" /> expression that specifies an existing drive.</span></span> <span data-ttu-id="a0362-160">Si no se especifica ninguna unidad o si <paramref name="Drive" /> es una cadena de longitud cero (""), <see langword="CurDir" /> devuelve la ruta de acceso a la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-160">If no drive is specified, or if <paramref name="Drive" /> is a zero-length string (""), <see langword="CurDir" /> returns the path for the current drive.</span></span></param>
        <summary><span data-ttu-id="a0362-161">Devuelve una cadena que representa la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-161">Returns a string representing the current path.</span></span> <span data-ttu-id="a0362-162">El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="CurDir" /> en las operaciones de E/S de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-162">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="CurDir" />.</span></span> <span data-ttu-id="a0362-163">Para obtener más información, vea <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-163">For more information, see <see cref="P:Microsoft.VisualBasic.FileIO.FileSystem.CurrentDirectory" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-164">Una cadena que representa la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-164">A string representing the current path.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0362-165">Este ejemplo se usa el `CurDir` función para devolver la ruta de acceso actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-165">This example uses the `CurDir` function to return the current path.</span></span>  
  
 [!code-vb[VbVbalrCatRef#65](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#65)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.ArgumentException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dir">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-166">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-166">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a0362-167">El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-167">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a0362-168">Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-168">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir ();" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ Dir();" />
      <MemberSignature Language="F#" Value="static member Dir : unit -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0362-169">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-169">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a0362-170">El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-170">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a0362-171">Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-171">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a0362-172">Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-172">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-173">El `Dir` función admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-173">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a0362-174">`VbVolume` Devuelve la etiqueta de volumen para la unidad en lugar de un nombre de archivo específico.</span><span class="sxs-lookup"><span data-stu-id="a0362-174">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="a0362-175">Debe proporcionar un `PathName` la primera vez que se llama a la `Dir` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-175">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="a0362-176">Para recuperar el elemento siguiente, puede realizar las llamadas posteriores a la `Dir` función sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="a0362-176">To retrieve the next item, you can make subsequent calls to the `Dir` function without parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-177">Para ejecutar correctamente, el `Dir` función requiere el <xref:System.Security.Permissions.FileIOPermissionAccess.Read> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a0362-177">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a0362-178">Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a0362-178">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="a0362-179">El `Attributes` valores de enumeración del argumento son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-179">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a0362-180">Valor</span><span class="sxs-lookup"><span data-stu-id="a0362-180">Value</span></span>|<span data-ttu-id="a0362-181">Constante</span><span class="sxs-lookup"><span data-stu-id="a0362-181">Constant</span></span>|<span data-ttu-id="a0362-182">Descripción</span><span class="sxs-lookup"><span data-stu-id="a0362-182">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="a0362-183">Predeterminado</span><span class="sxs-lookup"><span data-stu-id="a0362-183">Default.</span></span> <span data-ttu-id="a0362-184">Especifica los archivos sin atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-184">Specifies files without attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a0362-185">Especifica los archivos de solo lectura y también los archivos sin atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-185">Specifies read-only files, and also files without attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a0362-186">Especifica los archivos ocultos y también archivos sin atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-186">Specifies hidden files, and also files without attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a0362-187">Especifica los archivos del sistema y también los archivos sin atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-187">Specifies system files, and also files without attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a0362-188">Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, `vbVolume` se omite.</span><span class="sxs-lookup"><span data-stu-id="a0362-188">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a0362-189">Especifica los directorios o carpetas y también los archivos sin atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-189">Specifies directories or folders, and also files without attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a0362-190">El archivo ha cambiado desde que se realizó la última copia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a0362-190">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a0362-191">El archivo tiene un nombre diferente.</span><span class="sxs-lookup"><span data-stu-id="a0362-191">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a0362-192">Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden utilizarse en cualquier parte del código en lugar de los valores reales.</span><span class="sxs-lookup"><span data-stu-id="a0362-192">These enumerations are specified by the Visual Basic language and can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-193">Este ejemplo se usa el `Dir` función para comprobar si existen determinados archivos y directorios.</span><span class="sxs-lookup"><span data-stu-id="a0362-193">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="Dir">
      <MemberSignature Language="C#" Value="public static string Dir (string Pathname, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string Dir(string Pathname, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (Pathname As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C#" Value="public static string Dir (string PathName, Microsoft.VisualBasic.FileAttribute Attributes = Microsoft.VisualBasic.FileAttribute.Normal);" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="ILAsm" Value=".method public static string Dir(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="VB.NET" Value="Public Function Dir (PathName As String, Optional Attributes As FileAttribute = Microsoft.VisualBasic.FileAttribute.Normal) As String" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Dir(System.String,Microsoft.VisualBasic.FileAttribute)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberSignature Language="F#" Value="static member Dir : string * Microsoft.VisualBasic.FileAttribute -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.Dir (PathName, Attributes)" FrameworkAlternate="netframework-2.0;netframework-1.1" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Pathname" Type="System.String" Index="0" FrameworkAlternate="netframework-1.1" />
        <Parameter Name="PathName" Type="System.String" Index="0" FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" Index="1" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-194">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-194">Optional.</span></span> <span data-ttu-id="a0362-195">Expresión de cadena que especifica un nombre de archivo, directorio o carpeta, o bien, la etiqueta de volumen de la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-195">A string expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="a0362-196">Si no se encuentra <paramref name="PathName" />, se devuelve una cadena de longitud cero (<see langword="&quot;&quot;" />).</span><span class="sxs-lookup"><span data-stu-id="a0362-196">A zero-length string (<see langword="&quot;&quot;" />) is returned if <paramref name="PathName" /> is not found.</span></span></param>
        <param name="Pathname"><span data-ttu-id="a0362-197">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-197">Optional.</span></span> <span data-ttu-id="a0362-198">Expresión de cadena que especifica un nombre de archivo, directorio o carpeta, o bien, la etiqueta de volumen de la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-198">A string expression that specifies a file name, directory or folder name, or drive volume label.</span></span> <span data-ttu-id="a0362-199">Si no se encuentra <paramref name="Pathname" />, se devuelve una cadena de longitud cero (<see langword="&quot;&quot;" />).</span><span class="sxs-lookup"><span data-stu-id="a0362-199">A zero-length string (<see langword="&quot;&quot;" />) is returned if <paramref name="Pathname" /> is not found.</span></span></param>
        <param name="Attributes"><span data-ttu-id="a0362-200">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-200">Optional.</span></span> <span data-ttu-id="a0362-201">Enumeración o expresión numérica cuyo valor especifica los atributos de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-201">Enumeration or numeric expression whose value specifies file attributes.</span></span> <span data-ttu-id="a0362-202">Si se omite, <see langword="Dir" /> devuelve archivos que coinciden con <paramref name="Pathname" /> pero que no tienen ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="a0362-202">If omitted, <see langword="Dir" /> returns files that match <paramref name="Pathname" /> but have no attributes.</span></span></param>
        <summary><span data-ttu-id="a0362-203">Devuelve una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-203">Returns a string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span> <span data-ttu-id="a0362-204">El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="Dir" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-204">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="Dir" /> function.</span></span> <span data-ttu-id="a0362-205">Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-205">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetDirectoryInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a0362-206">Una cadena que representa el nombre de un archivo, un directorio o una carpeta que coincide con un atributo de archivo o modelo especificado, o la etiqueta de volumen de una unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-206">A string representing the name of a file, directory, or folder that matches a specified pattern or file attribute, or the volume label of a drive.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-207">El `Dir` función admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-207">The `Dir` function supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a0362-208">`VbVolume` Devuelve la etiqueta de volumen para la unidad en lugar de un nombre de archivo específico.</span><span class="sxs-lookup"><span data-stu-id="a0362-208">`VbVolume` returns the volume label for the drive instead of a specific file name.</span></span>  
  
 <span data-ttu-id="a0362-209">Debe proporcionar un `PathName` la primera vez que se llama a la `Dir` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-209">You must supply a `PathName` the first time that you call the `Dir` function.</span></span> <span data-ttu-id="a0362-210">Para recuperar el elemento siguiente, puede realizar las llamadas posteriores a la `Dir` función sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="a0362-210">To retrieve the next item, you can make subsequent calls to the `Dir` function with no parameters.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-211">Para ejecutar correctamente, el `Dir` función requiere el <xref:System.Security.Permissions.FileIOPermissionAccess.Read> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a0362-211">To run correctly, the `Dir` function requires the <xref:System.Security.Permissions.FileIOPermissionAccess.Read> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery> flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a0362-212">Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, y [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span><span class="sxs-lookup"><span data-stu-id="a0362-212">For more information, see <xref:System.Security.Permissions.FileIOPermission>, <xref:System.Security.SecurityException>, and [Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675).</span></span>  
  
 <span data-ttu-id="a0362-213">El `Attributes` valores de enumeración del argumento son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-213">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a0362-214">Valor</span><span class="sxs-lookup"><span data-stu-id="a0362-214">Value</span></span>|<span data-ttu-id="a0362-215">Constante</span><span class="sxs-lookup"><span data-stu-id="a0362-215">Constant</span></span>|<span data-ttu-id="a0362-216">Descripción</span><span class="sxs-lookup"><span data-stu-id="a0362-216">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbnormal`|<span data-ttu-id="a0362-217">Predeterminado</span><span class="sxs-lookup"><span data-stu-id="a0362-217">Default.</span></span> <span data-ttu-id="a0362-218">Especifica los archivos que no tienen atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-218">Specifies files that have no attributes.</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a0362-219">Especifica los archivos de solo lectura, además de los archivos que no tienen atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-219">Specifies read-only files, in addition to files that have no attributes.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a0362-220">Especifica los archivos ocultos, además de los archivos que no tienen atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-220">Specifies hidden files, in addition to files that have no attributes.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a0362-221">Especifica los archivos del sistema, además de los archivos que no tienen atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-221">Specifies system files, in addition to files that have no attributes.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a0362-222">Especifica la etiqueta de volumen. Si se especifica cualquier otro atributo, `vbVolume` se omite.</span><span class="sxs-lookup"><span data-stu-id="a0362-222">Specifies volume label; if any other attribute is specified, `vbVolume` is ignored.</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a0362-223">Especifica los directorios o carpetas, además de los archivos que no tienen atributos.</span><span class="sxs-lookup"><span data-stu-id="a0362-223">Specifies directories or folders, in addition to files that have no attributes.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a0362-224">El archivo ha cambiado desde que se realizó la última copia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a0362-224">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a0362-225">El archivo tiene un nombre diferente.</span><span class="sxs-lookup"><span data-stu-id="a0362-225">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a0362-226">Estas enumeraciones se especifican mediante el lenguaje Visual Basic y pueden utilizarse en cualquier parte del código en lugar de los valores reales.</span><span class="sxs-lookup"><span data-stu-id="a0362-226">These enumerations are specified by the Visual Basic language and can be used anywhere in your code in place of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-227">Este ejemplo se usa el `Dir` función para comprobar si existen determinados archivos y directorios.</span><span class="sxs-lookup"><span data-stu-id="a0362-227">This example uses the `Dir` function to check if certain files and directories exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#3](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.ChDrive" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
      </Docs>
    </Member>
    <Member MemberName="EOF">
      <MemberSignature Language="C#" Value="public static bool EOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static bool EOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EOF (FileNumber As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool EOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member EOF : int -&gt; bool" Usage="Microsoft.VisualBasic.FileSystem.EOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-228">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-228">Required.</span></span> <span data-ttu-id="a0362-229"><see langword="Integer" /> que contiene cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-229">An <see langword="Integer" /> that contains any valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-230">Devuelve un valor booleano o <see langword="True" /> cuando se alcanza el final de un archivo abierto para <see langword="Random" /> o <see langword="Input" /> secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-230">Returns a Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></summary>
        <returns><span data-ttu-id="a0362-231">Valor booleano o <see langword="True" /> cuando se alcanza el final de un archivo abierto para <see langword="Random" /> o <see langword="Input" /> secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-231">A Boolean value <see langword="True" /> when the end of a file opened for <see langword="Random" /> or sequential <see langword="Input" /> has been reached.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-232">Use `EOF` para evitar el error generado al intentar obtener datos más allá del final de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-232">Use `EOF` to avoid the error generated by attempting to get input past the end of a file.</span></span>  
  
 <span data-ttu-id="a0362-233">El `EOF` función devuelve `False` hasta que se alcanzó el final del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-233">The `EOF` function returns `False` until the end of the file has been reached.</span></span> <span data-ttu-id="a0362-234">Con los archivos abiertos para `Random` o `Binary` acceso, `EOF` devuelve `False` hasta que ejecute la última `FileGet` función no puede leer un registro completo.</span><span class="sxs-lookup"><span data-stu-id="a0362-234">With files opened for `Random` or `Binary` access, `EOF` returns `False` until the last executed `FileGet` function is unable to read a whole record.</span></span>  
  
 <span data-ttu-id="a0362-235">Con los archivos abiertos para `Binary` tener acceso a un intento de leer el archivo mediante el `Input` función hasta `EOF` devuelve `True` genera un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-235">With files opened for `Binary` access, an attempt to read through the file using the `Input` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="a0362-236">Utilice la `LOF` y `Loc` funciones en lugar de `EOF` al leer archivos binarios con `Input`, o use `Get` cuando se usa el `EOF` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-236">Use the `LOF` and `Loc` functions instead of `EOF` when reading binary files with `Input`, or use `Get` when using the `EOF` function.</span></span> <span data-ttu-id="a0362-237">Con los archivos abiertos para `Output`, `EOF` siempre devuelve `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-237">With files opened for `Output`, `EOF` always returns `True`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-238">Este ejemplo se usa el `EOF` función para detectar el final de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-238">This example uses the `EOF` function to detect the end of a file.</span></span> <span data-ttu-id="a0362-239">En este ejemplo se da por supuesto que `Testfile` es un archivo de texto que contiene varias líneas de texto.</span><span class="sxs-lookup"><span data-stu-id="a0362-239">This example assumes that `Testfile` is a text file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#62](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#62)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-240">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-240">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <Member MemberName="FileAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.OpenMode FileAttr (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.OpenMode FileAttr(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileAttr (FileNumber As Integer) As OpenMode" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::OpenMode FileAttr(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member FileAttr : int -&gt; Microsoft.VisualBasic.OpenMode" Usage="Microsoft.VisualBasic.FileSystem.FileAttr FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.OpenMode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-241">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-241">Required.</span></span> <span data-ttu-id="a0362-242"><see langword="Integer" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-242"><see langword="Integer" />.</span></span> <span data-ttu-id="a0362-243">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-243">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-244">Devuelve una enumeración que representa el modo de archivo de los archivos abiertos mediante la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-244">Returns an enumeration representing the file mode for files opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-245">El <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> proporciona más productividad y rendimiento que la función <see langword="FileAttr" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-245">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than the <see langword="FileAttr" /> function.</span></span> <span data-ttu-id="a0362-246">Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-246">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /> for more information.</span></span></summary>
        <returns><span data-ttu-id="a0362-247">Los siguientes valores de enumeración indican el modo de acceso al archivo:</span><span class="sxs-lookup"><span data-stu-id="a0362-247">The following enumeration values indicate the file access mode:</span></span> 
 <list type="table"><item><term> <span data-ttu-id="a0362-248">Valor</span><span class="sxs-lookup"><span data-stu-id="a0362-248">Value</span></span> 
 </term><description> <span data-ttu-id="a0362-249">Modo</span><span class="sxs-lookup"><span data-stu-id="a0362-249">Mode</span></span> 
 </description></item><item><term> <span data-ttu-id="a0362-250">1</span><span class="sxs-lookup"><span data-stu-id="a0362-250">1</span></span> 
 </term><description><see langword="OpenMode.Input" /></description></item><item><term> <span data-ttu-id="a0362-251">2</span><span class="sxs-lookup"><span data-stu-id="a0362-251">2</span></span> 
 </term><description><see langword="OpenMode.Output" /></description></item><item><term> <span data-ttu-id="a0362-252">4</span><span class="sxs-lookup"><span data-stu-id="a0362-252">4</span></span> 
 </term><description><see langword="OpenMode.Random" /></description></item><item><term> <span data-ttu-id="a0362-253">8</span><span class="sxs-lookup"><span data-stu-id="a0362-253">8</span></span> 
 </term><description><see langword="OpenMode.Append" /></description></item><item><term> <span data-ttu-id="a0362-254">32</span><span class="sxs-lookup"><span data-stu-id="a0362-254">32</span></span> 
 </term><description><see langword="OpenMode.Binary" /></description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-255">Esta función devuelve una enumeración que representa el modo de archivo para los archivos abiertos con el `FileOpen` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-255">This function returns an enumeration representing the file mode for files opened using the `FileOpen` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-256">Este ejemplo se usa el `FileAttr` función para devolver el modo de archivo de un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-256">This example uses the `FileAttr` function to return the file mode of an open file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#46](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#46)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-257">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-257">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileClose">
      <MemberSignature Language="C#" Value="public static void FileClose (params int[] FileNumbers);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileClose(int32[] FileNumbers) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileClose (ParamArray FileNumbers As Integer())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileClose(... cli::array &lt;int&gt; ^ FileNumbers);" />
      <MemberSignature Language="F#" Value="static member FileClose : int[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileClose FileNumbers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumbers" Type="System.Int32[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumbers"><span data-ttu-id="a0362-258">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-258">Optional.</span></span> <span data-ttu-id="a0362-259">Matriz de parámetros de 0 o más canales que se van a cerrar.</span><span class="sxs-lookup"><span data-stu-id="a0362-259">Parameter array of 0 or more channels to be closed.</span></span></param>
        <summary><span data-ttu-id="a0362-260">Concluye las operaciones de entrada/salida (E/S) en un archivo abierto con la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-260">Concludes input/output (I/O) to a file opened using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-261">El objeto <see langword="My" /> proporciona más productividad y rendimiento en las operaciones de E/S de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-261"><see langword="My" /> gives you better productivity and performance in file I/O operations.</span></span> <span data-ttu-id="a0362-262">Vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-262">See <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-263">El `FileClose` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-263">The `FileClose` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-264">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-264">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-265">Para obtener más información, vea [Cómo: Leer texto de archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [Cómo: Escribir texto en archivos con StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), y [Tutorial: Manipular archivos y directorios en Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-265">For more information, see [How to: Read Text from Files with a StreamReader](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-read-text-from-files-with-a-streamreader.md), [How to: Write Text to Files with a StreamWriter](~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md), and [Walkthrough: Manipulating Files and Directories in Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/walkthrough-manipulating-files-and-directories.md).</span></span>  
  
 <span data-ttu-id="a0362-266">Si se omite `FileNumbers`, todos los archivos activos abiertos por el `FileOpen` función están cerrados.</span><span class="sxs-lookup"><span data-stu-id="a0362-266">If you omit `FileNumbers`, all active files opened by the `FileOpen` function are closed.</span></span>  
  
 <span data-ttu-id="a0362-267">Al cerrar los archivos que se abrieron para `Output` o `Append`, el último búfer de salida se escribe en el búfer del sistema operativo de ese archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-267">When you close files that were opened for `Output` or `Append`, the final buffer of output is written to the operating system buffer for that file.</span></span> <span data-ttu-id="a0362-268">Todos los asociados cerrado de espacio en búfer se libera el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-268">All buffer space associated with the closed file is released.</span></span>  
  
 <span data-ttu-id="a0362-269">Cuando el `FileClose` se ejecuta la función, la asociación de un archivo con su archivo de número de extremos.</span><span class="sxs-lookup"><span data-stu-id="a0362-269">When the `FileClose` function is executed, the association of a file with its file number ends.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-270">Este ejemplo se usa el `FileClose` función para cerrar un archivo abierto para `Input`.</span><span class="sxs-lookup"><span data-stu-id="a0362-270">This example uses the `FileClose` function to close a file opened for `Input`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#69](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#69)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-271"><paramref name="FileNumber" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-271"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Reset" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md"><span data-ttu-id="a0362-272">End (Instrucción)</span><span class="sxs-lookup"><span data-stu-id="a0362-272">End Statement</span></span></related>
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/stop-statement.md"><span data-ttu-id="a0362-273">Stop (Instrucción, Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-273">Stop Statement (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-274">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-274">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileCopy">
      <MemberSignature Language="C#" Value="public static void FileCopy (string Source, string Destination);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileCopy(string Source, string Destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileCopy(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileCopy (Source As String, Destination As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileCopy(System::String ^ Source, System::String ^ Destination);" />
      <MemberSignature Language="F#" Value="static member FileCopy : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileCopy (Source, Destination)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Source" Type="System.String" />
        <Parameter Name="Destination" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Source"><span data-ttu-id="a0362-275">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-275">Required.</span></span> <span data-ttu-id="a0362-276">Expresión de cadena que especifica el nombre del archivo que se va a copiar.</span><span class="sxs-lookup"><span data-stu-id="a0362-276">A string expression that specifies the name of the file to be copied.</span></span> <span data-ttu-id="a0362-277"><paramref name="Source" /> puede incluir el directorio o la carpeta así como la unidad del archivo de origen.</span><span class="sxs-lookup"><span data-stu-id="a0362-277"><paramref name="Source" /> may include the directory or folder, and drive, of the source file.</span></span></param>
        <param name="Destination"><span data-ttu-id="a0362-278">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-278">Required.</span></span> <span data-ttu-id="a0362-279">Expresión de cadena que especifica el nombre del archivo de destino.</span><span class="sxs-lookup"><span data-stu-id="a0362-279">A string expression that specifies the destination file name.</span></span> <span data-ttu-id="a0362-280"><paramref name="Destination" /> puede incluir el directorio o la carpeta así como la unidad del archivo de destino.</span><span class="sxs-lookup"><span data-stu-id="a0362-280"><paramref name="Destination" /> may include the directory or folder, and drive, of the destination file.</span></span></param>
        <summary><span data-ttu-id="a0362-281">Copia un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-281">Copies a file.</span></span> <span data-ttu-id="a0362-282">El objeto <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> ofrece más productividad y rendimiento que <see langword="FileCopy" /> en las operaciones de E/S de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-282">The <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> gives you better productivity and performance in file I/O operations than <see langword="FileCopy" />.</span></span> <span data-ttu-id="a0362-283">Vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="a0362-283">See <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CopyFile(System.String,System.String)" /> for more information.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-284">Si intenta usar el `FileCopy` funcionan en un archivo abierto actualmente, se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-284">If you try to use the `FileCopy` function on a currently open file, an error occurs.</span></span>  
  
 <span data-ttu-id="a0362-285">`FileCopy` requiere plena confianza para que funcione en la unidad local.</span><span class="sxs-lookup"><span data-stu-id="a0362-285">`FileCopy` requires full trust to work on the local drive.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-286">Este ejemplo se usa el `FileCopy` función para copiar un archivo a otro.</span><span class="sxs-lookup"><span data-stu-id="a0362-286">This example uses the `FileCopy` function to copy one file to another.</span></span> <span data-ttu-id="a0362-287">Para fines de este ejemplo, suponga que `SrcFile` es un archivo que contiene los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-287">For purposes of this example, assume that `SrcFile` is a file that contains data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#2](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-288"><paramref name="Source" /> o <paramref name="Destination" /> no son válidos o no se especifican.</span><span class="sxs-lookup"><span data-stu-id="a0362-288"><paramref name="Source" /> or <paramref name="Destination" /> is invalid or not specified.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-289">El archivo ya está abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-289">File is already open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-290">No existe el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-290">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-a-different-directory.md"><span data-ttu-id="a0362-291">Cómo: Crear una copia de un archivo en un directorio diferente en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-291">How to: Create a Copy of a File in a Different Directory in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-copy-of-a-file-in-the-same-directory.md"><span data-ttu-id="a0362-292">Cómo: Crear una copia de un archivo en el mismo directorio en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-292">How to: Create a Copy of a File in the Same Directory in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-copy-a-directory-to-another-directory.md"><span data-ttu-id="a0362-293">Cómo: Copiar un directorio en otro directorio en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-293">How to: Copy a Directory to Another Directory in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileDateTime">
      <MemberSignature Language="C#" Value="public static DateTime FileDateTime (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype System.DateTime FileDateTime(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileDateTime (PathName As String) As DateTime" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static DateTime FileDateTime(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileDateTime : string -&gt; DateTime" Usage="Microsoft.VisualBasic.FileSystem.FileDateTime PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTime</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-294">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-294">Required.</span></span> <span data-ttu-id="a0362-295">Expresión de cadena que especifica un nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-295">A string expression that specifies a file name.</span></span> <span data-ttu-id="a0362-296"><paramref name="PathName" /> puede incluir el directorio o carpeta y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-296"><paramref name="PathName" /> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a0362-297">Devuelve un valor de tipo <see langword="Date" /> que indica la fecha y hora en que se escribió un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-297">Returns a <see langword="Date" /> value that indicates the date and time a file was written to.</span></span> <span data-ttu-id="a0362-298">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileDateTime" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-298">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileDateTime" />.</span></span> <span data-ttu-id="a0362-299">Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span><span class="sxs-lookup"><span data-stu-id="a0362-299">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" /></span></span></summary>
        <returns><span data-ttu-id="a0362-300">Valor de tipo <see langword="Date" /> que indica la fecha y hora de creación o de la última modificación de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-300"><see langword="Date" /> value that indicates the date and time a file was created or last modified.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0362-301">Este ejemplo se usa el `FileDateTime` función para determinar la fecha y la hora de un archivo se creó o modificó por última vez.</span><span class="sxs-lookup"><span data-stu-id="a0362-301">This example uses the `FileDateTime` function to determine the date and time a file was created or last modified.</span></span> <span data-ttu-id="a0362-302">El formato de fecha y hora que se muestra se basa en la configuración regional del sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-302">The format of the date and time displayed is based on the locale settings of the system.</span></span>  
  
 [!code-vb[VbVbalrCatRef#34](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#34)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-303"><paramref name="PathName" /> no es válido o contiene caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="a0362-303"><paramref name="PathName" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-304">El archivo de destino no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-304">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-305">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-305">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FileGet">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-306">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-306">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-307">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-307">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-308">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-308">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, bool&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Boolean@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-309">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-309">Required.</span></span> <span data-ttu-id="a0362-310">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-310">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-311">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-311">Required.</span></span> <span data-ttu-id="a0362-312">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-312">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-313">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-313">Optional.</span></span> <span data-ttu-id="a0362-314">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-314">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-315">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-315">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-316">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-316">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-317">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span><span class="sxs-lookup"><span data-stu-id="a0362-317">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /></span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-318">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-318">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-319">Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-319">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-320">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-320">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-321">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-321">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-322">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-322">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-323">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-323">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-324">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-324">Random Mode</span></span>  
 <span data-ttu-id="a0362-325">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-325">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-326">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-326">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-327">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-327">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-328">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-328">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-329">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-329">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-330">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-330">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-331">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-331">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-332">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-332">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-333">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-333">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-334">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-334">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-335">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-335">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-336">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-336">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-337">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-337">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-338">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-338">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-339">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-339">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-340">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-340">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-341">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-341">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-342">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-342">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-343">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-343">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-344">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-344">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-345">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-345">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-346">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-346">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-347">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-347">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-348">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-348">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-349">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-349">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-350">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-350">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-351">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-351">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-352">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-352">Binary Mode</span></span>  
 <span data-ttu-id="a0362-353">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-353">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-354">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-354">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-355">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-355">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-356">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-356">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-357">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-357">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-358">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-358">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-359">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-359">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-360">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-360">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-361">Leer un archivo mediante el uso de la`FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-361">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-362"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-362"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-363">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-363">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-364">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-364">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-365">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-365">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, unsigned int8&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Byte@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-366">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-366">Required.</span></span> <span data-ttu-id="a0362-367">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-367">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-368">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-368">Required.</span></span> <span data-ttu-id="a0362-369">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-369">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-370">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-370">Optional.</span></span> <span data-ttu-id="a0362-371">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-371">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-372">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-372">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-373">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-373">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-374">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-374">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-375">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-375">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-376">Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-376">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-377">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-377">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-378">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-378">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-379">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-379">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-380">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-380">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-381">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-381">Random Mode</span></span>  
 <span data-ttu-id="a0362-382">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-382">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-383">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-383">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-384">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-384">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-385">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-385">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-386">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-386">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-387">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-387">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-388">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-388">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-389">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-389">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-390">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-390">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-391">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-391">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-392">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-392">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-393">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-393">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-394">Si no se utiliza el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-394">If the descriptor is not used.</span></span> <span data-ttu-id="a0362-395">El tamaño y los límites de la matriz que se pasó a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-395">Then the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-396">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-396">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-397">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-397">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-398">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-398">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-399">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-399">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-400">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-400">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-401">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-401">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-402">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-402">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-403">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-403">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-404">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-404">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-405">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-405">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-406">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-406">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-407">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-407">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-408">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-408">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-409">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-409">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-410">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-410">Binary Mode</span></span>  
 <span data-ttu-id="a0362-411">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-411">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-412">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-412">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-413">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-413">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-414">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-414">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-415">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-415">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-416">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-416">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-417">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-417">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-418">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-418">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-419">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-419">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-420"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-420"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-421">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-421">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-422">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-422">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-423">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-423">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, char&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Char@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-424">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-424">Required.</span></span> <span data-ttu-id="a0362-425">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-425">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-426">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-426">Required.</span></span> <span data-ttu-id="a0362-427">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-427">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-428">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-428">Optional.</span></span> <span data-ttu-id="a0362-429">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-429">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-430">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-430">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-431">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-431">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-432">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-432">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-433">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-433">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-434">Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-434">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-435">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-435">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-436">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-436">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-437">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-437">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-438">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-438">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-439">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-439">Random Mode</span></span>  
 <span data-ttu-id="a0362-440">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-440">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-441">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-441">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-442">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-442">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-443">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-443">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-444">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-444">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-445">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-445">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-446">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-446">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-447">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-447">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-448">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-448">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-449">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-449">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-450">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-450">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-451">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-451">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-452">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-452">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-453">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-453">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-454">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-454">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-455">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-455">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-456">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-456">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-457">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-457">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-458">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-458">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-459">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-459">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-460">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-460">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-461">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-461">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-462">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-462">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-463">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-463">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-464">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-464">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-465">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-465">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-466">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-466">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-467">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-467">Binary Mode</span></span>  
 <span data-ttu-id="a0362-468">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-468">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-469">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-469">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-470">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-470">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-471">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-471">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-472">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-472">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-473">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-473">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-474">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-474">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-475">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-475">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-476">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-476">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-477"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-477"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-478">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-478">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-479">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-479">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-480">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-480">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.DateTime&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.DateTime@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-481">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-481">Required.</span></span> <span data-ttu-id="a0362-482">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-482">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-483">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-483">Required.</span></span> <span data-ttu-id="a0362-484">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-484">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-485">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-485">Optional.</span></span> <span data-ttu-id="a0362-486">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-486">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-487">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-487">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-488">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-488">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-489">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-489">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-490">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-490">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-491">Los datos leídos con `FileGet` se escriben normalmente en un archivo con `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-491">Data read with `FileGet` is usually written to a file with `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-492">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-492">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-493">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-493">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-494">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-494">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-495">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-495">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-496">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-496">Random Mode</span></span>  
 <span data-ttu-id="a0362-497">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-497">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-498">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función,`FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-498">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function,`FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-499">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-499">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-500">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-500">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-501">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-501">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-502">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-502">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-503">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-503">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-504">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-504">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-505">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-505">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-506">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-506">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-507">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-507">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-508">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-508">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-509">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-509">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-510">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-510">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-511">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-511">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-512">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-512">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-513">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-513">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-514">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-514">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-515">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-515">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-516">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-516">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-517">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-517">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-518">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-518">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-519">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-519">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-520">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-520">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-521">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-521">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-522">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-522">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-523">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-523">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-524">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-524">Binary Mode</span></span>  
 <span data-ttu-id="a0362-525">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-525">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-526">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-526">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-527">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-527">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-528">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-528">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-529">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-529">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-530">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-530">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-531">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-531">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-532">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-532">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-533">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-533">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-534"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-534"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-535">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-535">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-536">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-536">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-537">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-537">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, valuetype System.Decimal&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Decimal@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-538">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-538">Required.</span></span> <span data-ttu-id="a0362-539">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-539">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-540">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-540">Required.</span></span> <span data-ttu-id="a0362-541">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-541">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-542">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-542">Optional.</span></span> <span data-ttu-id="a0362-543">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-543">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-544">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-544">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-545">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-545">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-546">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-546">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-547">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-547">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-548">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-548">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-549">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-549">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-550">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-550">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-551">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-551">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-552">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-552">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-553">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-553">Random Mode</span></span>  
 <span data-ttu-id="a0362-554">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-554">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-555">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-555">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-556">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-556">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-557">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-557">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-558">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-558">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-559">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-559">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-560">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-560">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-561">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-561">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-562">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-562">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-563">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-563">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-564">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-564">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-565">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-565">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-566">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-566">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-567">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-567">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-568">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-568">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-569">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-569">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-570">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-570">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-571">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-571">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-572">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-572">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-573">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-573">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-574">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-574">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-575">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-575">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-576">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-576">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-577">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-577">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-578">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-578">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-579">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-579">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-580">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-580">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-581">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-581">Binary Mode</span></span>  
 <span data-ttu-id="a0362-582">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-582">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-583">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-583">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-584">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-584">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-585">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-585">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-586">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-586">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-587">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-587">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-588">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-588">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-589">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-589">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-590">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-590">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-591"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-591"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-592">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-592">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-593">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-593">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-594">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-594">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Double@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-595">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-595">Required.</span></span> <span data-ttu-id="a0362-596">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-596">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-597">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-597">Required.</span></span> <span data-ttu-id="a0362-598">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-598">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-599">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-599">Optional.</span></span> <span data-ttu-id="a0362-600">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-600">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-601">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-601">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-602">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-602">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-603">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-603">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-604">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-604">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-605">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-605">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-606">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-606">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-607">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-607">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-608">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-608">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-609">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-609">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-610">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-610">Random Mode</span></span>  
 <span data-ttu-id="a0362-611">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-611">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-612">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-612">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-613">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-613">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-614">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-614">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-615">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-615">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-616">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-616">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-617">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-617">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-618">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-618">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-619">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-619">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-620">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-620">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-621">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-621">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-622">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-622">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-623">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-623">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-624">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-624">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-625">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-625">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-626">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-626">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-627">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-627">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-628">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-628">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-629">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-629">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-630">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-630">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-631">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-631">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-632">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-632">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-633">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-633">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-634">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-634">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-635">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-635">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-636">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-636">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-637">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-637">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-638">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-638">Binary Mode</span></span>  
 <span data-ttu-id="a0362-639">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-639">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-640">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-640">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-641">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-641">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-642">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-642">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-643">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-643">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-644">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-644">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-645">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-645">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-646">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-646">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-647">Leer un archivo mediante el uso de la`FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-647">Reading from a file by using the`FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-648"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-648"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-649">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-649">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-650">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-650">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-651">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-651">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int16&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int16@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-652">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-652">Required.</span></span> <span data-ttu-id="a0362-653">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-653">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-654">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-654">Required.</span></span> <span data-ttu-id="a0362-655">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-655">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-656">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-656">Optional.</span></span> <span data-ttu-id="a0362-657">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-657">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-658">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-658">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-659">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-660">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-661">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-661">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-662">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-662">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-663">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-663">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-664">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-664">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-665">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-665">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-666">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-666">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-667">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-667">Random Mode</span></span>  
 <span data-ttu-id="a0362-668">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-668">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-669">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-669">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-670">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-670">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-671">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-671">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-672">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-672">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-673">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-673">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-674">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-674">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-675">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-675">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-676">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-676">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-677">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-677">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-678">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-678">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-679">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-679">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-680">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-680">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-681">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-681">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-682">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-682">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-683">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-683">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-684">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-684">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-685">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-685">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-686">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-686">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-687">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-687">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-688">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-688">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-689">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-690">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-690">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-691">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-691">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-692">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-692">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-693">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-693">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-694">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-694">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-695">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-695">Binary Mode</span></span>  
 <span data-ttu-id="a0362-696">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-696">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-697">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-697">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-698">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-698">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-699">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-699">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-700">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-700">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-701">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-701">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-702">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-702">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-703">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-703">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-704">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-704">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-705"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-705"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-706">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-706">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-707">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-707">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-708">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-708">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int32@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-709">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-709">Required.</span></span> <span data-ttu-id="a0362-710">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-710">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-711">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-711">Required.</span></span> <span data-ttu-id="a0362-712">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-712">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-713">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-713">Optional.</span></span> <span data-ttu-id="a0362-714">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-714">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-715">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-715">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-716">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-716">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-717">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-717">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-718">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-718">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-719">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-719">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-720">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-720">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-721">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-721">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-722">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-722">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-723">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-723">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-724">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-724">Random Mode</span></span>  
 <span data-ttu-id="a0362-725">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-725">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-726">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-726">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-727">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-727">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-728">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-728">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-729">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-729">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-730">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-730">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-731">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-731">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-732">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-732">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-733">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-733">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-734">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-734">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-735">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-735">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-736">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-736">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-737">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-737">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-738">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-738">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-739">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-739">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-740">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-741">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-741">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-742">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-742">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-743">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-743">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-744">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-744">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-745">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-745">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-746">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-746">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-747">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-747">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-748">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-748">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-749">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-750">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-750">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-751">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-751">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-752">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-752">Binary Mode</span></span>  
 <span data-ttu-id="a0362-753">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-753">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-754">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-754">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-755">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-755">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-756">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-756">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-757">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-757">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-758">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-758">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-759">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-759">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-760">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-760">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-761">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-761">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-762"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-762"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-763">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-763">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-764">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-764">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-765">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-765">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, int64&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-766">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-766">Required.</span></span> <span data-ttu-id="a0362-767">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-767">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-768">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-768">Required.</span></span> <span data-ttu-id="a0362-769">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-769">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-770">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-770">Optional.</span></span> <span data-ttu-id="a0362-771">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-771">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-772">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-772">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-773">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-773">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-774">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-774">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-775">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-775">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-776">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-776">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-777">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-777">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-778">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-778">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-779">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-779">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-780">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-780">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-781">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-781">Random Mode</span></span>  
 <span data-ttu-id="a0362-782">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-782">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-783">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-783">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-784">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-784">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-785">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-785">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-786">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-786">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-787">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-787">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-788">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-788">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-789">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-789">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-790">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-790">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-791">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-791">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-792">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-792">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-793">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-793">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-794">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-794">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-795">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-795">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-796">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-796">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-797">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-797">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-798">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-798">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-799">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-799">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-800">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-800">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-801">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-801">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-802">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-802">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-803">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-803">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-804">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-804">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-805">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-805">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-806">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-806">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-807">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-807">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-808">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-808">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-809">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-809">Binary Mode</span></span>  
 <span data-ttu-id="a0362-810">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-810">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-811">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-811">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-812">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-812">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-813">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-813">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-814">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-814">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-815">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-815">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-816">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-816">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-817">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-817">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-818">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-818">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-819"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-819"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-820">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-820">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-821">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-821">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-822">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-822">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, float32&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Single@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-823">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-823">Required.</span></span> <span data-ttu-id="a0362-824">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-824">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-825">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-825">Required.</span></span> <span data-ttu-id="a0362-826">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-826">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-827">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-827">Optional.</span></span> <span data-ttu-id="a0362-828">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-828">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-829">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-829">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-830">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-830">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-831">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-831">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-832">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-832">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-833">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-833">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-834">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-834">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-835">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-835">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-836">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-836">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-837">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-837">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-838">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-838">Random Mode</span></span>  
 <span data-ttu-id="a0362-839">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-839">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-840">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-840">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-841">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-841">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-842">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-842">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-843">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-843">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-844">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-844">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-845">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-845">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-846">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-846">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-847">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-847">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-848">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-848">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-849">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-849">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-850">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-850">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-851">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-851">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-852">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-852">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-853">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-853">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-854">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-854">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-855">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-855">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-856">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-856">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-857">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-857">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-858">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-858">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-859">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-859">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-860">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-860">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-861">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-861">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-862">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-862">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-863">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-863">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-864">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-864">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-865">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-865">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-866">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-866">Binary Mode</span></span>  
 <span data-ttu-id="a0362-867">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-867">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-868">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-868">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-869">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-869">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-870">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-870">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-871">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-871">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-872">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-872">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-873">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-873">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-874">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-874">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-875">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-875">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-876"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-876"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-877">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-877">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-878">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-878">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-879">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-879">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.ValueType&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.ValueType@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-880">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-880">Required.</span></span> <span data-ttu-id="a0362-881">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-881">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-882">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-882">Required.</span></span> <span data-ttu-id="a0362-883">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-883">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-884">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-884">Optional.</span></span> <span data-ttu-id="a0362-885">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-885">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-886">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-886">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-887">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-887">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-888">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-888">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-889">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-889">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-890">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-890">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-891">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-891">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-892">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-892">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-893">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-893">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-894">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-894">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-895">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-895">Random Mode</span></span>  
 <span data-ttu-id="a0362-896">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-896">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-897">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-897">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-898">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-898">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-899">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-899">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-900">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-900">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-901">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-901">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-902">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-902">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-903">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-903">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-904">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-904">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-905">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-905">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-906">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-906">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-907">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-907">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-908">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-908">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-909">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-909">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-910">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-910">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-911">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-911">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-912">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-912">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-913">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-913">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-914">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-914">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-915">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-915">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-916">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-916">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-917">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-917">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-918">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-918">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-919">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-919">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-920">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-920">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-921">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-921">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-922">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-922">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-923">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-923">Binary Mode</span></span>  
 <span data-ttu-id="a0362-924">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-924">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-925">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-925">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-926">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-926">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-927">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-927">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-928">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-928">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-929">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-929">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-930">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-930">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-931">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-931">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-932">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-932">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-933"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-933"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-934">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-934">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-935">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-935">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-936">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-936">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, string&amp; Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.String@,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-937">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-937">Required.</span></span> <span data-ttu-id="a0362-938">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-938">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-939">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-939">Required.</span></span> <span data-ttu-id="a0362-940">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-940">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-941">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-941">Optional.</span></span> <span data-ttu-id="a0362-942">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-942">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a0362-943">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-943">Optional.</span></span> <span data-ttu-id="a0362-944">Se aplica sólo al escribir una cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-944">Applies only when writing a string.</span></span> <span data-ttu-id="a0362-945">Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-945">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="a0362-946">De manera predeterminada, es <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-946">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a0362-947">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-947">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-948">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-948">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-949">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-949">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-950">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-950">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-951">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-951">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-952">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-952">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-953">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-953">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-954">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-954">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-955">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-955">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-956">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-956">Random Mode</span></span>  
 <span data-ttu-id="a0362-957">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-957">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-958">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-958">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-959">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-959">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-960">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-960">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-961">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-961">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-962">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-962">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-963">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-963">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-964">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-964">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-965">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-965">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-966">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-966">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-967">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-967">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-968">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-968">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-969">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-969">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-970">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-970">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-971">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-971">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-972">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-972">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-973">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-973">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-974">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-974">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-975">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-975">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-976">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-976">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-977">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-977">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-978">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-978">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-979">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-979">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-980">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-980">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-981">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-981">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-982">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-982">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-983">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-983">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-984">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-984">Binary Mode</span></span>  
 <span data-ttu-id="a0362-985">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-985">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-986">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-986">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-987">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-987">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-988">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-988">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-989">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-989">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-990">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-990">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-991">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-991">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-992">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-992">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-993">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-993">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-994"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-994"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-995">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-995">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-996">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-996">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-997">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-997">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGet">
      <MemberSignature Language="C#" Value="public static void FileGet (int FileNumber, ref Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGet(int32 FileNumber, class System.Array&amp; Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGet(System.Int32,System.Array@,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGet (FileNumber As Integer, ByRef Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FileGet : int *  * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGet (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-998">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-998">Required.</span></span> <span data-ttu-id="a0362-999">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-999">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1000">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1000">Required.</span></span> <span data-ttu-id="a0362-1001">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1001">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1002">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1002">Optional.</span></span> <span data-ttu-id="a0362-1003">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1003">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="a0362-1004">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1004">Optional.</span></span> <span data-ttu-id="a0362-1005">Sólo se aplica al escribir una matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1005">Applies only when writing an array.</span></span> <span data-ttu-id="a0362-1006">Especifica si la matriz debe tratarse como una matriz dinámica y si es necesario un descriptor que describa el tamaño y los límites de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1006">Specifies whether the array is to be treated as dynamic and whether an array descriptor describing the size and bounds of the array is necessary.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a0362-1007">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1007">Optional.</span></span> <span data-ttu-id="a0362-1008">Se aplica sólo al escribir una cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1008">Applies only when writing a string.</span></span> <span data-ttu-id="a0362-1009">Especifica si se va a escribir un descriptor de 2 bytes para la cadena que describe la longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-1009">Specifies whether to write a two-byte descriptor for the string that describes the length.</span></span> <span data-ttu-id="a0362-1010">De manera predeterminada, es <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1010">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a0362-1011">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1011">Reads data from an open disk file into a variable.</span></span> <span data-ttu-id="a0362-1012">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGet" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1012">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGet" />.</span></span> <span data-ttu-id="a0362-1013">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1013">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1014">`FileGet` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1014">`FileGet` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1015">Los datos leídos con `FileGet` se escriben normalmente en un archivo mediante el uso de `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1015">Data read with `FileGet` is usually written to a file by using `FilePut`.</span></span>  
  
 <span data-ttu-id="a0362-1016">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1016">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1017">Si se omite `RecordNumber`, el siguiente registro o byte que sigue a la última `FileGet` o `FilePut` función (o apunta a la última `Seek` función) se lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-1017">If you omit `RecordNumber`, the next record or byte following the last `FileGet` or `FilePut` function (or pointed to by the last `Seek` function) is read.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-1018">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1018">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-1019">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-1019">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1020">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1020">Random Mode</span></span>  
 <span data-ttu-id="a0362-1021">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1021">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1022">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGet` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1022">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGet` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1023">El espacio entre el final de un registro y el inicio del registro siguiente se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1023">The space between the end of one record and the starting of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1024">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1024">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-1025">De forma predeterminada, si la variable que se está leyendo es una cadena, `FileGet` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1025">By default, if the variable being read into is a string, `FileGet` reads a two-byte descriptor that contains the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1026">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1026">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1027">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija; Cuando se coloca en un archivo, no se escribe el descriptor de longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-1027">Visual Basic 6.0 and earlier versions support fixed-length strings; when put to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-1028">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1028">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1029">Si la variable que se está leyendo es una matriz, puede elegir si desea leer un descriptor para el tamaño y la dimensión de la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1029">If the variable being read into is an array, you can choose whether to read a descriptor for the size and dimension of the array.</span></span> <span data-ttu-id="a0362-1030">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1030">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1031">Al leer la matriz, se tiene que coincidir con la forma en que se escribió la matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1031">When reading the array, you have to match the way the array was written.</span></span> <span data-ttu-id="a0362-1032">Si se escribió con el descriptor, debe leer el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1032">If it was written with the descriptor, you have to read the descriptor.</span></span> <span data-ttu-id="a0362-1033">Si no se utiliza el descriptor, el tamaño y los límites de la matriz se pasan a `FileGet` determinar lo que debe leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1033">If the descriptor is not used, the size and bounds of the array passed into `FileGet` determine what to read.</span></span>  
  
     <span data-ttu-id="a0362-1034">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1034">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1035">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1035">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1036">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1036">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1037">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1037">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#21](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#21)]  
  
     <span data-ttu-id="a0362-1038">Los bytes 218 se distribuyen como sigue:</span><span class="sxs-lookup"><span data-stu-id="a0362-1038">The 218 bytes are distributed as follows:</span></span>  
  
    -   <span data-ttu-id="a0362-1039">18 bytes para el descriptor de: (2 + 8 \* 2)</span><span class="sxs-lookup"><span data-stu-id="a0362-1039">18 bytes for the descriptor: (2 + 8 \* 2)</span></span>  
  
    -   <span data-ttu-id="a0362-1040">200 bytes para los datos: (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-1040">200 bytes for the data: (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-1041">Si la variable que se está leyendo es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FileGet` lee sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1041">If the variable being read into is any other type of variable (not a variable-length string or an object), `FileGet` reads only the variable data.</span></span> <span data-ttu-id="a0362-1042">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1042">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-1043">`FileGet` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1043">`FileGet` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-1044">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePut`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1044">On disk, a dynamic array in a user-defined type (written with `FilePut`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1045">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales.</span><span class="sxs-lookup"><span data-stu-id="a0362-1045">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements.</span></span> <span data-ttu-id="a0362-1046">Esto incluye las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-1046">This includes any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-1047">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de una cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1047">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of a string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1048">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1048">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1049">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1049">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1050">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1050">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1051">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1051">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1052">`FileGet` lee todas las variables del disco de forma contigua; es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1052">`FileGet` reads all variables from disk contiguously; that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1053">Para cualquier matriz que no sea una matriz en una estructura, `FileGet` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1053">For any array other than an array in a structure, `FileGet` reads only the data.</span></span> <span data-ttu-id="a0362-1054">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1054">No descriptor is read.</span></span>  
  
-   <span data-ttu-id="a0362-1055">`FileGet` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1055">`FileGet` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1056">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1056">The number of bytes read equals the number of characters already in the string.</span></span>  
  
    > [!IMPORTANT]
    >  <span data-ttu-id="a0362-1057">Leer un archivo mediante el uso de la `FileGet` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1057">Reading from a file by using the `FileGet` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1058"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1058"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1059">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1059">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-1060">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1060">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1061">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1061">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileGetObject">
      <MemberSignature Language="C#" Value="public static void FileGetObject (int FileNumber, ref object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileGetObject(int32 FileNumber, object&amp; Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileGetObject (FileNumber As Integer, ByRef Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FileGetObject : int *  * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileGetObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1062">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1062">Required.</span></span> <span data-ttu-id="a0362-1063">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1063">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1064">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1064">Required.</span></span> <span data-ttu-id="a0362-1065">Nombre de variable válido en la que se leen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1065">Valid variable name into which data is read.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1066">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1066">Optional.</span></span> <span data-ttu-id="a0362-1067">Número de registro (archivos en modo <see langword="Random" />) o el número de bytes (archivos en modo <see langword="Binary" />) en el que comienza la lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1067">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which reading starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1068">Lee datos de un archivo de disco abierto en una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1068">Reads data from an open disk file into a variable.</span></span>  <span data-ttu-id="a0362-1069">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileGetObject" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1069">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileGetObject" />.</span></span> <span data-ttu-id="a0362-1070">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1070">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1071">El `FileGetObject` función se utiliza en lugar de `FileGet` para evitar ambigüedades en tiempo de compilación si tipo `Object` se devuelve en lugar de otro tipo, como `Integer`, `Long`, `Short`, y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1071">The `FileGetObject` function is used instead of `FileGet` to avoid ambiguities at compile time if type `Object` is returned instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="a0362-1072">Si va a escribir el `Variant` tipo, `FileGetObject` es necesario.</span><span class="sxs-lookup"><span data-stu-id="a0362-1072">If you intend to write out the `Variant` type, `FileGetObject` is required.</span></span> <span data-ttu-id="a0362-1073">En caso de duda, si está utilizando un objeto para el segundo parámetro, se recomienda siempre que utilice `FilePutObject` y `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1073">When in doubt, if you are using an object for the second parameter, it is always suggested that you use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a0362-1074">`FileGetObject` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1074">`FileGetObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1075">Los datos leídos con `FileGetObject` normalmente se escriben con `FilePutObject`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1075">Data read with `FileGetObject` is usually written with `FilePutObject`.</span></span>  
  
 <span data-ttu-id="a0362-1076">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1076">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1077">Si se omite `RecordNumber`, `FileGetObject` lee el registro o byte después del último `FileGetObject` o `FilePutObject` función (o apunta a la última `Seek` función).</span><span class="sxs-lookup"><span data-stu-id="a0362-1077">If you omit `RecordNumber`, `FileGetObject` reads the record or byte after the last `FileGetObject` or `FilePutObject` function (or pointed to by the last `Seek` function).</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1078">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1078">Random Mode</span></span>  
 <span data-ttu-id="a0362-1079">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1079">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1080">Si la longitud de los datos que se está leyendo es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FileGetObject` leerá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1080">If the length of the data being read is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FileGetObject` reads subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1081">El espacio entre el final de un registro y el principio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1081">The space between the end of one record and the beginning of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1082">Dado que no se puede determinar con exactitud la cantidad de datos de relleno, es una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1082">Because the amount of padding data cannot be precisely determined, it is a good idea to have the record length match the length of the data being read.</span></span>  
  
-   <span data-ttu-id="a0362-1083">Si la variable que se está leyendo es una cadena, de forma predeterminada `FileGetObject` lee un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, lee los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1083">If the variable being read into is a string, by default `FileGetObject` reads a two-byte descriptor containing the string length and then reads the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1084">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula de la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1084">Therefore, the record length specified by the `RecordLength` clause of the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1085">Visual Basic 6.0 y versiones anteriores admiten cadenas de longitud fija y cuando se leen en un archivo, el descriptor de longitud no se escribe.</span><span class="sxs-lookup"><span data-stu-id="a0362-1085">Visual Basic 6.0 and earlier versions support fixed-length strings and when read to a file, the length descriptor is not written.</span></span> <span data-ttu-id="a0362-1086">Si desea leer una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1086">If you want to read a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1087">Si la variable que se va a leer en es una matriz y, a continuación, la longitud de registro especificado por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1087">If the variable being read into is an array, then the record length specified by the `RecordLength` parameter in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1088">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1088">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1089">Su longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="a0362-1089">Its length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span>  
  
     <span data-ttu-id="a0362-1090">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco:</span><span class="sxs-lookup"><span data-stu-id="a0362-1090">For example, the following array declaration requires 218 bytes when the array is written to disk:</span></span>  
  
     [!code-vb[VbVbalrCatRef#27](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#27)]  
  
     <span data-ttu-id="a0362-1091">Los bytes 218 se distribuyen como sigue: 18 bytes para el descriptor (2 + 8 \* 2) y 100 bytes para los datos (5 \* 10 \* 4).</span><span class="sxs-lookup"><span data-stu-id="a0362-1091">The 218 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 \* 2), and 100 bytes for the data (5 \* 10 \* 4).</span></span>  
  
-   <span data-ttu-id="a0362-1092">`FileGetObject` lee elementos de estructuras como si cada una se que se leyeron individualmente, salvo que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1092">`FileGetObject` reads elements of structures as if each were being read individually, except that there is no padding between elements.</span></span> <span data-ttu-id="a0362-1093">En el disco, una dinámica de matriz en un tipo definido por el usuario (escritas con `FilePutObject`) viene precedida por un descriptor cuya longitud es igual a 2 más 8 veces el número de dimensiones: 2 + 8 \* NumberOfDimensions.</span><span class="sxs-lookup"><span data-stu-id="a0362-1093">On disk, a dynamic array in a user-defined type (written with `FilePutObject`) is prefixed by a descriptor whose length equals 2 plus 8 times the number of dimensions: 2 + 8 \* NumberOfDimensions.</span></span> <span data-ttu-id="a0362-1094">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para leer los elementos individuales, incluidas las matrices y sus descriptores.</span><span class="sxs-lookup"><span data-stu-id="a0362-1094">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to read the individual elements, including any arrays and their descriptors.</span></span> <span data-ttu-id="a0362-1095">La <xref:Microsoft.VisualBasic.VBFixedStringAttribute> clase puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1095">The <xref:Microsoft.VisualBasic.VBFixedStringAttribute> class can be applied to string fields in the structures to indicate the size of string when written to disk.</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1096">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1096">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1097">De los archivos abiertos en `Binary` modo, todos los `Random` reglas se aplican, con las siguientes excepciones:</span><span class="sxs-lookup"><span data-stu-id="a0362-1097">For files opened in `Binary` mode, all of the `Random` rules apply, with these exceptions:</span></span>  
  
-   <span data-ttu-id="a0362-1098">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1098">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1099">`FileGetObject` lee todas las variables desde el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1099">`FileGetObject` reads all variables from disk contiguously, that is, with no padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1100">Para cualquier matriz que no sea una matriz en una estructura, `FileGetObject` lee sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1100">For any array other than an array in a structure, `FileGetObject` reads only the data.</span></span> <span data-ttu-id="a0362-1101">No se lee ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1101">No descriptor is read.</span></span>  
  
 <span data-ttu-id="a0362-1102">`FileGetObject` lee las cadenas de longitud variable que no sean elementos de estructuras sin esperar el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1102">`FileGetObject` reads variable-length strings that are not elements of structures without expecting the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1103">El número de bytes leídos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1103">The number of bytes read equals the number of characters already in the string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-1104">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1104">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-1105">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-1105">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1106">El ejemplo siguiente lee un registro en un archivo de prueba y, a continuación, lo recupera.</span><span class="sxs-lookup"><span data-stu-id="a0362-1106">The following example reads a record into a test file and then retrieves it.</span></span>  
  
 [!code-vb[VbVbalrCatRef#26](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#26)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-1107">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1107">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1108">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1108">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileLen">
      <MemberSignature Language="C#" Value="public static long FileLen (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 FileLen(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function FileLen (PathName As String) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long FileLen(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member FileLen : string -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.FileLen PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-1109">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1109">Required.</span></span> <span data-ttu-id="a0362-1110">Expresión de cadena que especifica un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1110">A string expression that specifies a file.</span></span> <span data-ttu-id="a0362-1111"><paramref name="PathName" /> puede incluir el directorio o carpeta y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-1111"><paramref name="PathName" /> may include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a0362-1112">Devuelve un valor que especifica la longitud de un archivo en bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1112">Returns a value that specifies the length of a file in bytes.</span></span> <span data-ttu-id="a0362-1113">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileLen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1113">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileLen" />.</span></span> <span data-ttu-id="a0362-1114">Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1114">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.GetFileInfo(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-1115">Longitud de un archivo en bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1115">The length of a file in bytes.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1116">Si el archivo especificado está abierto cuando el `FileLen` se llama a la función, el valor devuelto representa el tamaño del archivo en el momento en que se abrió.</span><span class="sxs-lookup"><span data-stu-id="a0362-1116">If the specified file is open when the `FileLen` function is called, the value returned represents the size of the file at the time it was opened.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-1117">Para obtener la longitud actual de un archivo abierto, use el `LOF` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1117">To obtain the current length of an open file, use the `LOF` function.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1118">Este ejemplo se usa el `FileLen` función para devolver la longitud de un archivo en bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1118">This example uses the `FileLen` function to return the length of a file in bytes.</span></span> <span data-ttu-id="a0362-1119">Para fines de este ejemplo, suponga que `TestFile` es un archivo que contiene algunos datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1119">For purposes of this example, assume that `TestFile` is a file that contains some data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#1](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-1120">No existe el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1120">File does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileDateTime(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-1121">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1121">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileOpen">
      <MemberSignature Language="C#" Value="public static void FileOpen (int FileNumber, string FileName, Microsoft.VisualBasic.OpenMode Mode, Microsoft.VisualBasic.OpenAccess Access = Microsoft.VisualBasic.OpenAccess.Default, Microsoft.VisualBasic.OpenShare Share = Microsoft.VisualBasic.OpenShare.Default, int RecordLength = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileOpen(int32 FileNumber, string FileName, valuetype Microsoft.VisualBasic.OpenMode Mode, valuetype Microsoft.VisualBasic.OpenAccess Access, valuetype Microsoft.VisualBasic.OpenShare Share, int32 RecordLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileOpen (FileNumber As Integer, FileName As String, Mode As OpenMode, Optional Access As OpenAccess = Microsoft.VisualBasic.OpenAccess.Default, Optional Share As OpenShare = Microsoft.VisualBasic.OpenShare.Default, Optional RecordLength As Integer = -1)" />
      <MemberSignature Language="F#" Value="static member FileOpen : int * string * Microsoft.VisualBasic.OpenMode * Microsoft.VisualBasic.OpenAccess * Microsoft.VisualBasic.OpenShare * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileOpen (FileNumber, FileName, Mode, Access, Share, RecordLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FileName" Type="System.String" />
        <Parameter Name="Mode" Type="Microsoft.VisualBasic.OpenMode" />
        <Parameter Name="Access" Type="Microsoft.VisualBasic.OpenAccess" />
        <Parameter Name="Share" Type="Microsoft.VisualBasic.OpenShare" />
        <Parameter Name="RecordLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1122">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1122">Required.</span></span> <span data-ttu-id="a0362-1123">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1123">Any valid file number.</span></span> <span data-ttu-id="a0362-1124">Utilice la función <see langword="FreeFile" /> para obtener el siguiente número de archivo disponible.</span><span class="sxs-lookup"><span data-stu-id="a0362-1124">Use the <see langword="FreeFile" /> function to obtain the next available file number.</span></span></param>
        <param name="FileName"><span data-ttu-id="a0362-1125">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1125">Required.</span></span> <span data-ttu-id="a0362-1126">Expresión de cadena que especifica un nombre de archivo y que puede incluir el directorio o la carpeta, y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-1126">A string expression that specifies a file name - may include directory or folder, and drive.</span></span></param>
        <param name="Mode"><span data-ttu-id="a0362-1127">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1127">Required.</span></span> <span data-ttu-id="a0362-1128">Enumeración que especifica el modo de archivo: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" /> o <see langword="Random" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1128">Enumeration specifying the file mode: <see langword="Append" />, <see langword="Binary" />, <see langword="Input" />, <see langword="Output" />, or <see langword="Random" />.</span></span> <span data-ttu-id="a0362-1129">Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenMode" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1129">For more information, see <see cref="T:Microsoft.VisualBasic.OpenMode" /> .</span></span></param>
        <param name="Access"><span data-ttu-id="a0362-1130">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1130">Optional.</span></span> <span data-ttu-id="a0362-1131">Enumeración que especifica las operaciones permitidas en el archivo abierto: <see langword="Read" />, <see langword="Write" /> o <see langword="ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1131">Enumeration specifying the operations permitted on the open file: <see langword="Read" />, <see langword="Write" />, or <see langword="ReadWrite" />.</span></span> <span data-ttu-id="a0362-1132">Tiene como valor predeterminado <see langword="ReadWrite" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1132">Defaults to <see langword="ReadWrite" />.</span></span> <span data-ttu-id="a0362-1133">Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenAccess" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1133">For more information, see <see cref="T:Microsoft.VisualBasic.OpenAccess" /> .</span></span></param>
        <param name="Share"><span data-ttu-id="a0362-1134">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1134">Optional.</span></span> <span data-ttu-id="a0362-1135">Enumeración que especifica las operaciones no permitidas en el archivo abierto por otros procesos: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" /> y <see langword="Lock Read Write" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1135">Enumeration specifying the operations not permitted on the open file by other processes: <see langword="Shared" />, <see langword="Lock Read" />, <see langword="Lock Write" />, and <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="a0362-1136">Tiene como valor predeterminado <see langword="Lock Read Write" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1136">Defaults to <see langword="Lock Read Write" />.</span></span> <span data-ttu-id="a0362-1137">Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.OpenShare" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1137">For more information, see <see cref="T:Microsoft.VisualBasic.OpenShare" /> .</span></span></param>
        <param name="RecordLength"><span data-ttu-id="a0362-1138">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1138">Optional.</span></span> <span data-ttu-id="a0362-1139">Número menor o igual que 32.767 (bytes).</span><span class="sxs-lookup"><span data-stu-id="a0362-1139">Number less than or equal to 32,767 (bytes).</span></span> <span data-ttu-id="a0362-1140">En el caso de los archivos abiertos para el acceso aleatorio, este valor es la longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1140">For files opened for random access, this value is the record length.</span></span> <span data-ttu-id="a0362-1141">En el caso de los archivos secuenciales, este valor es el número de caracteres almacenados en búfer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1141">For sequential files, this value is the number of characters buffered.</span></span></param>
        <summary><span data-ttu-id="a0362-1142">Abre un archivo para operaciones de entrada o salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-1142">Opens a file for input or output.</span></span> <span data-ttu-id="a0362-1143">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1143">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileOpen" />.</span></span> <span data-ttu-id="a0362-1144">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1144">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1145">El `FileOpen` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-1145">The `FileOpen` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-1146">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-1146">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-1147">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-1147">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-1148">Debe abrir un archivo antes de poder realizar cualquier operación de E/S en él.</span><span class="sxs-lookup"><span data-stu-id="a0362-1148">You must open a file before any I/O operation can be performed on it.</span></span> <span data-ttu-id="a0362-1149">`FileOpen` asigna un búfer de E/S al archivo y determina el modo de acceso para usar con el búfer.</span><span class="sxs-lookup"><span data-stu-id="a0362-1149">`FileOpen` allocates a buffer for I/O to the file and determines the mode of access to use with the buffer.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-1150">Al escribir en un archivo, puede tener una aplicación crear un archivo, si no existe el archivo al que está intentando escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1150">When writing to a file, an application may have to create a file, if the file to which it is trying to write does not exist.</span></span> <span data-ttu-id="a0362-1151">Para ello, necesita permiso para el directorio en el que se creará el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1151">To do so, it needs permission for the directory in which the file is to be created.</span></span> <span data-ttu-id="a0362-1152">Sin embargo, si el archivo especificado por `FileName` existe, la aplicación necesita `Write` permiso solo para el propio archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1152">However, if the file specified by `FileName` does exist, the application needs `Write` permission only to the file itself.</span></span> <span data-ttu-id="a0362-1153">Siempre que sea posible, para ayudar a mejorar la seguridad, crear el archivo durante la implementación y conceder `Write` permiso a dicho archivo únicamente, en lugar de a todo el directorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1153">Wherever possible, to help improve security, create the file during deployment and grant `Write` permission to that file only, instead of to the whole directory.</span></span> <span data-ttu-id="a0362-1154">Para ayudar a mejorar la seguridad, escribir datos en los directorios de usuario en lugar de en el directorio raíz o el directorio de archivos de programa.</span><span class="sxs-lookup"><span data-stu-id="a0362-1154">To help improve security, write data to user directories instead of to the root directory or the Program Files directory.</span></span>  
  
 <span data-ttu-id="a0362-1155">Puede encontrar el canal para abrir mediante el `FreeFile()` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1155">The channel to open can be found by using the `FreeFile()` function.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-1156">El `FileOpen` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración, que puede afectar a su ejecución en situaciones de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="a0362-1156">The `FileOpen` function requires `Read` access from the `FileIOPermissionAccess` enumeration, which may affect its execution in partial trust situations.</span></span> <span data-ttu-id="a0362-1157">Para obtener más información, consulte <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1157">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1158">En este ejemplo se muestra varios usos de la `FileOpen` función para habilitar la entrada y salida a un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1158">This example illustrates various uses of the `FileOpen` function to enable input and output to a file.</span></span>  
  
 <span data-ttu-id="a0362-1159">El código siguiente abre el archivo `TestFile` en `Input` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1159">The following code opens the file `TestFile` in `Input` mode.</span></span>  
  
 [!code-vb[VbVbalrCatRef#5](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#5)]  
  
 <span data-ttu-id="a0362-1160">Este ejemplo abre el archivo en `Binary` modo para solo operaciones de escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1160">This example opens the file in `Binary` mode for writing operations only.</span></span>  
  
 [!code-vb[VbVbalrCatRef#6](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#6)]  
  
 <span data-ttu-id="a0362-1161">El ejemplo siguiente abre el archivo en `Random` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1161">The following example opens the file in `Random` mode.</span></span> <span data-ttu-id="a0362-1162">El archivo contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1162">The file contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#7](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#7)]  
  
 <span data-ttu-id="a0362-1163">Este ejemplo de código abre el archivo en `Output` modo; cualquier proceso puede leer o escribir en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1163">This code example opens the file in `Output` mode; any process can read or write to file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#8](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#8)]  
  
 <span data-ttu-id="a0362-1164">Este ejemplo de código abre el archivo en `Binary` modo para lectura; otros procesos no pueden leer el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1164">This code example opens the file in `Binary` mode for reading; other processes cannot read file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#9](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1165">La longitud del registro es negativa (y no es igual a ‑1).</span><span class="sxs-lookup"><span data-stu-id="a0362-1165">Record length is negative (and not equal to -1).</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1166"><paramref name="FileName" /> ya está abierto o <paramref name="FileName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1166"><paramref name="FileName" /> is already open, or <paramref name="FileName" /> is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-1167">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1167">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1168">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1168">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="FilePut">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-1169">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1169">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1170">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1170">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1171">Para obtener más información, vea la clase <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1171">F For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, bool Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, bool Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Boolean,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Boolean, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * bool * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1172">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1172">Required.</span></span> <span data-ttu-id="a0362-1173">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1173">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1174">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1174">Required.</span></span> <span data-ttu-id="a0362-1175">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1175">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1176">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1176">Optional.</span></span> <span data-ttu-id="a0362-1177">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1177">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1178">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1178">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1179">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1179">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1180">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1180">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1181">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1181">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1182">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1182">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1183">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1183">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1184">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1184">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1185">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1185">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1186">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1186">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1187">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1187">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1188">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1188">Random Mode</span></span>  
 <span data-ttu-id="a0362-1189">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1189">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1190">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1190">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1191">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1191">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1192">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1192">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1193">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1193">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1194">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1194">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1195">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1195">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1196">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1196">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1197">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1197">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1198">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1198">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1199">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1199">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1200">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1200">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1201">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1201">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1202">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1202">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1203">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1203">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1204">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1204">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1205">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1205">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1206">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1206">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1207">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1207">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1208">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1208">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1209">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1209">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1210">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1210">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1211">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1211">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1212">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1212">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1213">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1213">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1214">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1214">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1215">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1215">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1216">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1216">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1217">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1217">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1218">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1218">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1219">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1219">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1220">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1220">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1221">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1221">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1222">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1222">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1223">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1223">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1224">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1224">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1225">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1225">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1226">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1226">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1227">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1227">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1228">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1228">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1229"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1229"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1230">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1230">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1231">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1231">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, byte Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, unsigned int8 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Byte,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Byte, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * byte * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1232">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1232">Required.</span></span> <span data-ttu-id="a0362-1233">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1233">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1234">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1234">Required.</span></span> <span data-ttu-id="a0362-1235">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1235">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1236">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1236">Optional.</span></span> <span data-ttu-id="a0362-1237">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1237">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1238">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1238">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1239">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1239">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1240">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1240">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1241">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1241">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1242">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1242">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1243">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1243">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1244">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1244">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1245">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1245">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1246">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1246">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1247">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1247">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1248">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1248">Random Mode</span></span>  
 <span data-ttu-id="a0362-1249">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1249">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1250">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1250">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1251">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1251">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1252">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1252">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1253">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1253">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1254">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1254">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1255">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1255">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1256">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1256">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1257">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1257">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1258">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1258">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1259">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1259">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1260">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1260">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1261">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1261">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1262">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1262">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1263">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1263">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1264">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1264">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1265">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1265">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1266">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1266">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1267">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1267">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1268">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1268">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1269">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1269">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1270">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1270">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1271">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1271">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1272">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1272">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1273">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1273">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1274">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1274">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1275">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1275">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1276">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1276">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1277">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1277">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1278">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1278">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1279">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1279">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1280">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1280">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1281">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1281">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1282">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1282">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1283">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1283">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1284">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1284">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1285">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1285">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1286">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1286">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1287">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1287">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1288">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1288">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1289"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1289"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1290">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1290">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1291">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1291">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, char Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, char Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Char,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Char, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * char * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1292">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1292">Required.</span></span> <span data-ttu-id="a0362-1293">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1293">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1294">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1294">Required.</span></span> <span data-ttu-id="a0362-1295">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1295">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1296">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1296">Optional.</span></span> <span data-ttu-id="a0362-1297">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1297">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1298">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1298">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1299">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1299">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1300">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1300">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1301">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1301">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1302">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1302">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1303">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1303">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1304">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1304">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1305">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1305">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1306">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1306">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1307">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1307">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1308">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1308">Random Mode</span></span>  
 <span data-ttu-id="a0362-1309">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1309">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1310">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1310">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1311">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1311">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1312">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1312">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1313">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1313">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1314">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1314">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1315">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1315">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1316">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1316">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1317">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1317">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1318">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1318">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1319">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1319">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1320">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1320">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1321">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1321">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1322">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1322">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1323">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1323">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1324">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1324">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1325">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1325">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1326">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1326">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1327">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1327">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1328">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1328">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1329">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1329">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1330">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1330">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1331">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1331">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1332">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1332">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1333">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1333">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1334">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1334">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1335">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1335">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1336">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1336">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1337">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1337">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1338">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1338">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1339">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1339">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1340">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1340">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1341">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1341">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1342">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1342">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1343">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1343">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1344">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1344">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1345">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1345">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1346">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1346">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1347">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1347">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1348">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1348">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1349"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1349"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1350">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1350">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1351">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1351">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, DateTime Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.DateTime Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.DateTime,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As DateTime, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * DateTime * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1352">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1352">Required.</span></span> <span data-ttu-id="a0362-1353">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1353">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1354">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1354">Required.</span></span> <span data-ttu-id="a0362-1355">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1355">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1356">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1356">Optional.</span></span> <span data-ttu-id="a0362-1357">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1357">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1358">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1358">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1359">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1359">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1360">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1360">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1361">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1361">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1362">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1362">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1363">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1363">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1364">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1364">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1365">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1365">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1366">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1366">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1367">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1367">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1368">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1368">Random Mode</span></span>  
 <span data-ttu-id="a0362-1369">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1369">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1370">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1370">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1371">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1371">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1372">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1372">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1373">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1373">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1374">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1374">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1375">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1375">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1376">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1376">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1377">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1377">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1378">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1378">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1379">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1379">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1380">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1380">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1381">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1381">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1382">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1382">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1383">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1383">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1384">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1384">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1385">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1385">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1386">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1386">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1387">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1387">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1388">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1388">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1389">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1389">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1390">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1390">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1391">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1391">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1392">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1392">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1393">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1393">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1394">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1394">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1395">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1395">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1396">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1396">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1397">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1397">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1398">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1398">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1399">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1399">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1400">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1400">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1401">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1401">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1402">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1402">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1403">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1403">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1404">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1404">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1405">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1405">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1406">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1406">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1407">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1407">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1408">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1408">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1409"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1409"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1410">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1410">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1411">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1411">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, decimal Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, valuetype System.Decimal Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Decimal,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Decimal, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * decimal * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1412">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1412">Required.</span></span> <span data-ttu-id="a0362-1413">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1413">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1414">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1414">Required.</span></span> <span data-ttu-id="a0362-1415">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1415">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1416">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1416">Optional.</span></span> <span data-ttu-id="a0362-1417">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1417">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1418">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1418">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1419">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1419">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1420">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1420">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1421">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1421">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1422">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1422">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1423">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1423">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1424">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1424">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1425">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1425">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1426">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1426">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1427">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1427">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1428">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1428">Random Mode</span></span>  
 <span data-ttu-id="a0362-1429">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1429">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1430">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1430">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1431">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1431">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1432">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1432">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1433">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1433">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1434">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1434">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1435">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1435">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1436">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1436">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1437">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1437">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1438">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1438">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1439">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1439">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1440">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1440">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1441">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1441">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1442">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1442">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1443">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1443">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1444">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1444">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1445">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1445">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1446">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1446">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1447">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1447">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1448">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1448">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1449">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1449">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1450">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1450">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1451">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1451">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1452">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1452">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1453">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1453">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1454">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1454">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1455">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1455">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1456">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1456">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1457">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1457">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1458">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1458">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1459">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1459">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1460">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1460">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1461">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1461">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1462">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1462">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1463">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1463">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1464">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1464">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1465">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1465">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1466">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1466">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1467">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1467">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1468">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1468">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1469"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1469"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1470">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1470">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1471">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1471">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, double Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Double,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Double, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * double * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1472">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1472">Required.</span></span> <span data-ttu-id="a0362-1473">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1473">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1474">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1474">Required.</span></span> <span data-ttu-id="a0362-1475">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1475">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1476">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1476">Optional.</span></span> <span data-ttu-id="a0362-1477">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1477">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1478">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1478">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1479">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1479">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1480">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1480">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1481">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1481">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1482">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1482">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1483">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1483">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1484">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1484">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1485">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1485">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1486">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1486">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1487">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1487">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1488">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1488">Random Mode</span></span>  
 <span data-ttu-id="a0362-1489">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1489">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1490">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1490">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1491">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1491">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1492">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1492">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1493">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1493">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1494">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1494">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1495">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1495">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1496">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1496">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1497">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1497">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1498">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1498">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1499">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1499">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1500">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1500">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1501">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1501">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1502">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1502">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1503">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1503">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1504">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1504">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1505">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1505">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1506">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1506">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1507">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1507">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1508">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1508">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1509">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1509">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1510">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1510">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1511">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1511">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1512">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1512">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1513">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1513">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1514">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1514">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1515">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1515">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1516">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1516">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1517">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1517">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1518">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1518">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1519">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1519">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1520">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1520">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1521">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1521">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1522">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1522">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1523">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1523">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1524">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1524">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1525">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1525">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1526">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1526">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1527">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1527">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1528">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1528">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1529"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1529"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1530">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1530">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1531">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1531">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, short Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int16 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int16,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Short, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int16 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1532">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1532">Required.</span></span> <span data-ttu-id="a0362-1533">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1533">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1534">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1534">Required.</span></span> <span data-ttu-id="a0362-1535">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1535">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1536">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1536">Optional.</span></span> <span data-ttu-id="a0362-1537">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1537">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1538">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1538">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1539">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1539">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1540">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1540">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1541">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1541">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1542">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1542">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1543">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1543">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1544">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1544">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1545">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1545">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1546">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1546">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1547">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1547">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1548">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1548">Random Mode</span></span>  
 <span data-ttu-id="a0362-1549">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1549">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1550">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1550">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1551">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1551">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1552">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1552">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1553">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1553">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1554">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1554">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1555">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1555">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1556">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1556">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1557">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1557">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1558">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1558">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1559">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el`VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1559">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the`VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1560">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1560">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1561">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1561">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1562">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1562">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1563">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1563">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1564">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1564">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1565">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1565">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1566">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1566">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1567">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1567">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1568">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1568">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1569">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1569">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1570">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1570">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1571">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1571">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1572">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1572">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1573">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1573">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1574">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1574">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1575">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1575">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1576">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1576">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1577">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1577">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1578">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1578">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1579">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1579">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1580">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1580">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1581">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1581">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1582">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1582">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1583">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1583">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1584">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1584">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1585">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1585">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1586">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1586">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1587">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1587">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1588">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1588">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1589"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1589"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1590">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1590">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1591">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1591">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, int Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Integer, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1592">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1592">Required.</span></span> <span data-ttu-id="a0362-1593">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1593">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1594">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1594">Required.</span></span> <span data-ttu-id="a0362-1595">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1595">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1596">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1596">Optional.</span></span> <span data-ttu-id="a0362-1597">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1597">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1598">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1598">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1599">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1599">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1600">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1600">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1601">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1601">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1602">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1602">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1603">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1603">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1604">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1604">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1605">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1605">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1606">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1606">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1607">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1607">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1608">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1608">Random Mode</span></span>  
 <span data-ttu-id="a0362-1609">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1609">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1610">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1610">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1611">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1611">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1612">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1612">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1613">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1613">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1614">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1614">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1615">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1615">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1616">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1616">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1617">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1617">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1618">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1618">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1619">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1619">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1620">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1620">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1621">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1621">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1622">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1622">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1623">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1623">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1624">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1624">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1625">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1625">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1626">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1626">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1627">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1627">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1628">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1628">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1629">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1629">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1630">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1630">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1631">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1631">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1632">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1632">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1633">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1633">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1634">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1634">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1635">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1635">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1636">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1636">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1637">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1637">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1638">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1638">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1639">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1639">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1640">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1640">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1641">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1641">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1642">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1642">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1643">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1643">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1644">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1644">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1645">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1645">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1646">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1646">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1647">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1647">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1648">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1648">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1649"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1649"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1650">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1650">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1651">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1651">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, long Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, int64 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Long, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1652">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1652">Required.</span></span> <span data-ttu-id="a0362-1653">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1653">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1654">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1654">Required.</span></span> <span data-ttu-id="a0362-1655">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1655">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1656">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1656">Optional.</span></span> <span data-ttu-id="a0362-1657">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1657">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1658">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1658">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1659">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1659">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1660">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1660">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1661">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1661">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1662">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1662">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1663">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1663">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1664">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1664">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1665">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1665">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1666">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1666">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1667">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1667">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1668">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1668">Random Mode</span></span>  
 <span data-ttu-id="a0362-1669">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1669">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1670">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1670">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1671">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1671">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1672">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1672">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1673">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1673">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1674">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1674">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1675">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1675">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1676">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1676">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1677">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1677">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1678">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1678">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1679">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1679">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1680">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1680">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1681">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1681">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1682">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1682">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1683">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1683">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1684">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1684">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1685">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1685">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1686">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1686">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1687">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1687">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1688">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1688">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1689">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1689">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1690">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1690">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1691">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1691">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1692">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1692">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1693">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1693">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1694">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1694">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1695">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1695">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1696">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1696">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1697">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1697">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1698">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1698">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1699">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1699">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1700">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1700">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1701">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1701">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1702">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1702">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1703">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1703">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1704">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1704">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1705">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1705">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1706">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1706">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1707">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1707">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1708">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1708">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1709"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1709"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1710">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1710">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1711">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1711">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, float Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, float32 Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Single,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Single, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * single * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1712">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1712">Required.</span></span> <span data-ttu-id="a0362-1713">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1713">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1714">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1714">Required.</span></span> <span data-ttu-id="a0362-1715">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1715">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1716">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1716">Optional.</span></span> <span data-ttu-id="a0362-1717">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1717">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1718">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1718">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1719">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1719">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1720">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1720">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1721">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1721">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1722">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1722">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1723">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1723">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1724">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1724">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1725">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1725">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1726">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1726">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1727">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1727">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1728">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1728">Random Mode</span></span>  
 <span data-ttu-id="a0362-1729">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1729">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1730">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1730">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1731">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1731">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1732">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1732">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1733">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1733">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1734">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1734">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1735">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1735">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1736">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1736">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1737">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1737">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1738">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1738">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1739">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1739">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1740">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1740">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1741">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1741">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1742">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1742">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1743">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1743">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1744">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1744">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1745">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1745">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1746">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1746">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1747">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1747">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1748">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1748">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1749">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1749">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1750">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1750">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1751">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1751">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1752">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1752">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1753">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1753">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1754">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1754">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1755">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1755">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1756">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1756">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1757">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1757">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1758">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1758">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1759">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1759">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1760">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1760">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1761">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1761">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1762">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1762">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1763">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1763">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1764">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1764">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1765">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1765">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1766">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1766">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1767">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1767">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1768">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1768">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1769"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1769"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1770">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1770">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1771">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1771">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, ValueType Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.ValueType Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.ValueType,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As ValueType, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * ValueType * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.ValueType" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1772">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1772">Required.</span></span> <span data-ttu-id="a0362-1773">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1773">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1774">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1774">Required.</span></span> <span data-ttu-id="a0362-1775">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1775">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1776">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1776">Optional.</span></span> <span data-ttu-id="a0362-1777">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1777">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1778">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1778">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1779">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1779">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1780">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1780">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1781">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1781">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1782">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1782">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1783">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1783">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1784">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1784">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1785">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1785">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1786">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1786">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1787">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1787">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1788">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1788">Random Mode</span></span>  
 <span data-ttu-id="a0362-1789">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1789">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1790">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el`RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1790">If the length of the data being written is less than the length specified in the`RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1791">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1791">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1792">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1792">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1793">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1793">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1794">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1794">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1795">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1795">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1796">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1796">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1797">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1797">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1798">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1798">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1799">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1799">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1800">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1800">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1801">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1801">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1802">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1802">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1803">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1803">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1804">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1804">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1805">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1805">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1806">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1806">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1807">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1807">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1808">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1808">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1809">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1809">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1810">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1810">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1811">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1811">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1812">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1812">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1813">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1813">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1814">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1814">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1815">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1815">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1816">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1816">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1817">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1817">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1818">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1818">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1819">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1819">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1820">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1820">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1821">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1821">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1822">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1822">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1823">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1823">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1824">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1824">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1825">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1825">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1826">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1826">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1827">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1827">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1828">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1828">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1829"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1829"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1830">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1830">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1831">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1831">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (object FileNumber, object Value, object RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(object FileNumber, object Value, object RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Object,System.Object,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Object, Value As Object, Optional RecordNumber As Object = -1)" />
      <MemberSignature Language="F#" Value="static member FilePut : obj * obj * obj -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This member has been deprecated. Please use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use FilePutObject to write Object types, or coerce FileNumber and RecordNumber to Integer for writing non-Object types")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Object" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1832">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1832">Required.</span></span> <span data-ttu-id="a0362-1833">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1833">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1834">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1834">Required.</span></span> <span data-ttu-id="a0362-1835">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1835">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1836">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1836">Optional.</span></span> <span data-ttu-id="a0362-1837">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1837">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-1838">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1838">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1839">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1839">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1840">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1840">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1841">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1841">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1842">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1842">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1843">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1843">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1844">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1844">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1845">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1845">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1846">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1846">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1847">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1847">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1848">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1848">Random Mode</span></span>  
 <span data-ttu-id="a0362-1849">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1849">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1850">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1850">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1851">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1851">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1852">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1852">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1853">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1853">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1854">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1854">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1855">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1855">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1856">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1856">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1857">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1857">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1858">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1858">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1859">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1859">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1860">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1860">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1861">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1861">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1862">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1862">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1863">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1863">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1864">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1864">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1865">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1865">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1866">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1866">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1867">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1867">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1868">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1868">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1869">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1869">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1870">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1870">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1871">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1871">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1872">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1872">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1873">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1873">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1874">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1874">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1875">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1875">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1876">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1876">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1877">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1877">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1878">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1878">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1879">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1879">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1880">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1880">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1881">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1881">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1882">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1882">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1883">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1883">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1884">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1884">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1885">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1885">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1886">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1886">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1887">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1887">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1888">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1888">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1889"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1889"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1890">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1890">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1891">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1891">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, string Value, long RecordNumber = -1, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, string Value, int64 RecordNumber, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.String,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As String, Optional RecordNumber As Long = -1, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * string * int64 * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1892">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1892">Required.</span></span> <span data-ttu-id="a0362-1893">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1893">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1894">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1894">Required.</span></span> <span data-ttu-id="a0362-1895">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1895">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1896">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1896">Optional.</span></span> <span data-ttu-id="a0362-1897">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1897">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a0362-1898">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1898">Optional.</span></span> <span data-ttu-id="a0362-1899">Se aplica sólo al escribir una cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1899">Applies only when writing a string.</span></span> <span data-ttu-id="a0362-1900">Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1900">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="a0362-1901">De manera predeterminada, es <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1901">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a0362-1902">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1902">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1903">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1903">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1904">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1904">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1905">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1905">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1906">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1906">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1907">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1907">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1908">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1908">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1909">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1909">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1910">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1910">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1911">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1911">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1912">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1912">Random Mode</span></span>  
 <span data-ttu-id="a0362-1913">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1913">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1914">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1914">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1915">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1915">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1916">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1916">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1917">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1917">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1918">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1918">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1919">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1919">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1920">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1920">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1921">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1921">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1922">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1922">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1923">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1923">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1924">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1924">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1925">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1925">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1926">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1926">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1927">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1927">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1928">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1928">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1929">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1929">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1930">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1930">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1931">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1931">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1932">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1932">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-1933">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1933">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-1934">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1934">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-1935">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1935">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-1936">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1936">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-1937">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1937">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-1938">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1938">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-1939">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-1939">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-1940">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-1940">Binary Mode</span></span>  
 <span data-ttu-id="a0362-1941">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-1941">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-1942">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-1942">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-1943">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-1943">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-1944">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-1944">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-1945">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1945">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-1946">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1946">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-1947">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1947">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-1948">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1948">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-1949">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-1949">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-1950">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-1950">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-1951">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1951">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-1952">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1952">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-1953"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-1953"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-1954">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1954">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-1955">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-1955">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePut">
      <MemberSignature Language="C#" Value="public static void FilePut (int FileNumber, Array Value, long RecordNumber = -1, bool ArrayIsDynamic = false, bool StringIsFixedLength = false);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePut(int32 FileNumber, class System.Array Value, int64 RecordNumber, bool ArrayIsDynamic, bool StringIsFixedLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePut(System.Int32,System.Array,System.Int64,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePut (FileNumber As Integer, Value As Array, Optional RecordNumber As Long = -1, Optional ArrayIsDynamic As Boolean = false, Optional StringIsFixedLength As Boolean = false)" />
      <MemberSignature Language="F#" Value="static member FilePut : int * Array * int64 * bool * bool -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePut (FileNumber, Value, RecordNumber, ArrayIsDynamic, StringIsFixedLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Array" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
        <Parameter Name="ArrayIsDynamic" Type="System.Boolean" />
        <Parameter Name="StringIsFixedLength" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-1956">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1956">Required.</span></span> <span data-ttu-id="a0362-1957">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-1957">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-1958">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-1958">Required.</span></span> <span data-ttu-id="a0362-1959">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1959">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-1960">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1960">Optional.</span></span> <span data-ttu-id="a0362-1961">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-1961">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <param name="ArrayIsDynamic"><span data-ttu-id="a0362-1962">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1962">Optional.</span></span> <span data-ttu-id="a0362-1963">Sólo se aplica al escribir una matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-1963">Applies only when writing an array.</span></span> <span data-ttu-id="a0362-1964">Especifica si la matriz se va a tratar como una matriz dinámica y si se va a escribir un descriptor de matriz para la cadena que describe la longitud.</span><span class="sxs-lookup"><span data-stu-id="a0362-1964">Specifies whether the array is to be treated as dynamic, and whether to write an array descriptor for the string that describes the length.</span></span></param>
        <param name="StringIsFixedLength"><span data-ttu-id="a0362-1965">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-1965">Optional.</span></span> <span data-ttu-id="a0362-1966">Se aplica sólo al escribir una cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1966">Applies only when writing a string.</span></span> <span data-ttu-id="a0362-1967">Especifica si se va a escribir un descriptor de longitud de cadena de 2 bytes para la cadena en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1967">Specifies whether to write a two-byte string length descriptor for the string to the file.</span></span> <span data-ttu-id="a0362-1968">De manera predeterminada, es <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1968">The default is <see langword="False" />.</span></span></param>
        <summary><span data-ttu-id="a0362-1969">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-1969">Writes data from a variable to a disk file.</span></span> <span data-ttu-id="a0362-1970">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePut" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1970">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePut" />.</span></span> <span data-ttu-id="a0362-1971">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-1971">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-1972">`FilePut` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1972">`FilePut` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-1973">Los datos escritos con `FilePut` normalmente se leen desde un archivo mediante `FileGet`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1973">Data written with `FilePut` is usually read from a file by using `FileGet`.</span></span>  
  
 <span data-ttu-id="a0362-1974">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-1974">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-1975">Si se omite `RecordNumber`, el siguiente registro o byte después del último `FileGet` o `FilePut` función o apunta a la última `Seek` se escribe la función.</span><span class="sxs-lookup"><span data-stu-id="a0362-1975">If you omit `RecordNumber`, the next record or byte after the last `FileGet` or `FilePut` function or pointed to by the last `Seek` function is written.</span></span>  
  
 <span data-ttu-id="a0362-1976">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1976">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-1977">`FilePut` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1977">`FilePut` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-1978">Si usas `StringIsFixedLength`  =  `True` con `FilePut`, tendrá que hacer lo mismo con `FileGet`, y tiene que asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-1978">If you use `StringIsFixedLength` = `True` with `FilePut`, you have to do the same with `FileGet`, and you have to make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-1979">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-1979">Random Mode</span></span>  
 <span data-ttu-id="a0362-1980">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-1980">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-1981">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePut` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-1981">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePut` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-1982">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1982">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-1983">Como la cantidad de datos de relleno no se puede determinar con certeza, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-1983">Because the amount of padding data cannot be determined with any certainty, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-1984">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se producirá una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-1984">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception will be thrown.</span></span>  
  
-   <span data-ttu-id="a0362-1985">Si la variable que se está escribiendo es una cadena, `FilePut` escribe un descriptor de dos bytes que contiene la longitud de cadena y, a continuación, escribe los datos que entrarán en la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1985">If the variable being written is a string, `FilePut` writes a two-byte descriptor that contains the string length, and then writes the data that goes into the variable.</span></span> <span data-ttu-id="a0362-1986">Por lo tanto, la longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1986">Therefore, the record length specified by the `RecordLength` clause in the `FileOpen` function must be at least two bytes greater than the actual length of the string.</span></span>  
  
-   <span data-ttu-id="a0362-1987">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePut` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-1987">If the variable being written is an object that contains a numeric type, `FilePut` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-1988">Por ejemplo, al escribir un objeto que contiene un entero, `FilePut` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-1988">For example, when writing an object that contains an integer, `FilePut` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-1989">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1989">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-1990">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePut` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-1990">If the variable being written is an object that contains a string, `FilePut` writes a two byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-1991">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-1991">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-1992">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-1992">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-1993">Si la variable que se escribe es una matriz, tendrá la opción si desea escribir un descriptor para el tamaño y las dimensiones de la matriz o no.</span><span class="sxs-lookup"><span data-stu-id="a0362-1993">If the variable being written is an array, you have a choice as to whether or not to write a descriptor for the size and dimensions of the array.</span></span> <span data-ttu-id="a0362-1994">Visual Basic 6.0 y versiones anteriores escriben el descriptor de archivo para una matriz dinámica pero no para una matriz de tamaño fijo.</span><span class="sxs-lookup"><span data-stu-id="a0362-1994">Visual Basic 6.0 and earlier versions write the file descriptor for a dynamic array but not for a fixed-size array.</span></span> <span data-ttu-id="a0362-1995">De forma predeterminada, Visual Basic 2005 no escribe el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1995">Visual Basic 2005 defaults to not writing the descriptor.</span></span> <span data-ttu-id="a0362-1996">Para escribir el descriptor, establezca el `ArrayIsDynamic` parámetro `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-1996">To write the descriptor, set the `ArrayIsDynamic` parameter to `True`.</span></span> <span data-ttu-id="a0362-1997">Al escribir la matriz, se tiene que coincidir con la forma en que se leerá la matriz; Si se va a leer con el descriptor, tendrá que escribir el descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-1997">When writing the array, you have to match the way the array will be read; if it will be read with the descriptor, you have to write the descriptor.</span></span> <span data-ttu-id="a0362-1998">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-1998">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-1999">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-1999">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span> <span data-ttu-id="a0362-2000">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2000">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-2001">Por ejemplo, la siguiente declaración de matriz requiere 218 bytes cuando se escribe la matriz en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2001">For example, the following array declaration requires 218 bytes when the array is written to disk.</span></span>  
  
     [!code-vb[VbVbalrCatRef#43](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#43)]  
  
-   <span data-ttu-id="a0362-2002">Si la variable que se escribe es cualquier otro tipo de variable (no una cadena de longitud variable o un objeto), `FilePut` escribe sólo los datos de la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-2002">If the variable being written is any other type of variable (not a variable-length string or an object), `FilePut` writes only the variable data.</span></span> <span data-ttu-id="a0362-2003">La longitud de registro especificada por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual que la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-2003">The record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the length of the data being written.</span></span>  
  
-   <span data-ttu-id="a0362-2004">`FilePut` escribe elementos de estructuras como si cada uno se escribieron individualmente, excepto que no hay ningún relleno entre los elementos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2004">`FilePut` writes elements of structures as if each were written individually, except there is no padding between elements.</span></span> <span data-ttu-id="a0362-2005">El `VBFixedString` atributo puede aplicarse a campos de cadena de las estructuras para indicar el tamaño de la cadena cuando se escribe en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2005">The `VBFixedString` attribute can be applied to string fields in the structures to indicate the size of the string when written to disk.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="a0362-2006">Cadena de los campos que tienen más bytes que el especificado por el `VBFixedString` atributo se truncan cuando se escribe en el disco,</span><span class="sxs-lookup"><span data-stu-id="a0362-2006">String fields that have more bytes than specified by the `VBFixedString` attribute are truncated when written to disk,</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-2007">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-2007">Binary Mode</span></span>  
 <span data-ttu-id="a0362-2008">De los archivos abiertos en `Binary` modo, la mayoría de los `Random` se aplican las reglas de modo, con algunas excepciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2008">For files opened in `Binary` mode, most of the `Random` mode rules apply, with some exceptions.</span></span> <span data-ttu-id="a0362-2009">Las siguientes reglas para los archivos abiertos en `Binary` modo difieren de las reglas para `Random` modo:</span><span class="sxs-lookup"><span data-stu-id="a0362-2009">The following rules for files opened in `Binary` mode differ from the rules for `Random` mode:</span></span>  
  
-   <span data-ttu-id="a0362-2010">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2010">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-2011">`FilePut` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-2011">`FilePut` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
-   <span data-ttu-id="a0362-2012">Para cualquier matriz que no sea una matriz en una estructura, `FilePut` escribe sólo los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2012">For any array other than an array in a structure, `FilePut` writes only the data.</span></span> <span data-ttu-id="a0362-2013">No se escribe ningún descriptor.</span><span class="sxs-lookup"><span data-stu-id="a0362-2013">No descriptor is written.</span></span>  
  
-   <span data-ttu-id="a0362-2014">`FilePut` Escribe cadenas de longitud variable que no sean elementos de estructuras sin el descriptor de longitud de dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2014">`FilePut` writes variable-length strings that are not elements of structures without the two-byte length descriptor.</span></span> <span data-ttu-id="a0362-2015">El número de bytes escritos es igual al número de caracteres de la cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-2015">The number of bytes written equals the number of characters in the string.</span></span> <span data-ttu-id="a0362-2016">Por ejemplo, las siguientes instrucciones escriben 11 bytes en el archivo número 1:</span><span class="sxs-lookup"><span data-stu-id="a0362-2016">For example, the following statements write 11 bytes to file number 1:</span></span>  
  
     [!code-vb[VbVbalrCatRef#44](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#44)]  
  
-   <span data-ttu-id="a0362-2017">Escribir en un archivo mediante el uso de la `FilePut` función requiere `Write` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2017">Writing to a file by using the `FilePut` function requires `Write` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2018">Este ejemplo se usa el `FilePut` función para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2018">This example uses the `FilePut` function to write data to a file.</span></span> <span data-ttu-id="a0362-2019">Cinco registros de la estructura `Person` se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2019">Five records of the structure `Person` are written to the file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#42](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#42)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2020"><paramref name="RecordNumber" /> &lt; 1 y no es igual a -1.</span><span class="sxs-lookup"><span data-stu-id="a0362-2020"><paramref name="RecordNumber" /> &lt; 1 and not equal to -1.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2021">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2021">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileGetObject(System.Int32,System.Object@,System.Int64)" />
        <altmember cref="T:Microsoft.VisualBasic.VBFixedStringAttribute" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Len(System.UInt16)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2022">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2022">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FilePutObject">
      <MemberSignature Language="C#" Value="public static void FilePutObject (int FileNumber, object Value, long RecordNumber = -1);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FilePutObject(int32 FileNumber, object Value, int64 RecordNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FilePutObject(System.Int32,System.Object,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FilePutObject (FileNumber As Integer, Value As Object, Optional RecordNumber As Long = -1)" />
      <MemberSignature Language="F#" Value="static member FilePutObject : int * obj * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FilePutObject (FileNumber, Value, RecordNumber)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" />
        <Parameter Name="RecordNumber" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2023">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2023">Required.</span></span> <span data-ttu-id="a0362-2024">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2024">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2025">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2025">Required.</span></span> <span data-ttu-id="a0362-2026">Nombre válido de variable que contiene los datos escritos en disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2026">Valid variable name that contains data written to disk.</span></span></param>
        <param name="RecordNumber"><span data-ttu-id="a0362-2027">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2027">Optional.</span></span> <span data-ttu-id="a0362-2028">Número de registro (archivos en modo <see langword="Random" />) o número de byte (archivos en modo <see langword="Binary" />) en el que comienza la escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-2028">Record number (<see langword="Random" /> mode files) or byte number (<see langword="Binary" /> mode files) at which writing starts.</span></span></param>
        <summary><span data-ttu-id="a0362-2029">Escribe los datos de una variable en un archivo de disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2029">Writes data from a variable to a disk file.</span></span>  <span data-ttu-id="a0362-2030">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FilePutObject" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2030">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FilePutObject" />.</span></span> <span data-ttu-id="a0362-2031">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2031">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2032">El `FilePutObject` función se utiliza en lugar de `FilePut` para evitar ambigüedades en tiempo de compilación si tipo `Object` se pasa en lugar de otro tipo, como `Integer`, `Long`, `Short`, y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2032">The `FilePutObject` function is used instead of `FilePut` to avoid ambiguities at compile time if type `Object` is passed instead of another type, such as `Integer`, `Long`, `Short`, and so forth.</span></span>  
  
 <span data-ttu-id="a0362-2033">`FilePutObject` escribe y lee descriptores que describen el objeto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2033">`FilePutObject` writes and reads descriptors that describe the object.</span></span> <span data-ttu-id="a0362-2034">Si va a escribir el `Variant` tipo, `FilePutObject` es necesario.</span><span class="sxs-lookup"><span data-stu-id="a0362-2034">If you intend to write out the `Variant` type, `FilePutObject` is required.</span></span> <span data-ttu-id="a0362-2035">En caso de duda, si está utilizando un objeto para el segundo parámetro, se recomienda usar siempre `FilePutObject` y `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2035">When in doubt, if you are using an object for the second parameter, we recommend that you always use `FilePutObject` and `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a0362-2036">`FilePutObject` solo es válido en `Random` y `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2036">`FilePutObject` is valid only in `Random` and `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-2037">Los datos escritos con `FilePutObject` normalmente se leen desde un archivo mediante `FileGetObject`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2037">Data written with `FilePutObject` is usually read from a file by using `FileGetObject`.</span></span>  
  
 <span data-ttu-id="a0362-2038">El primer registro o byte de un archivo está en la posición 1, el segundo registro o byte en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2038">The first record or byte in a file is at position 1, the second record or byte is at position 2, and so on.</span></span> <span data-ttu-id="a0362-2039">Si se omite `RecordNumber`, `FilePutObject` escribe el siguiente registro o byte después del último `FileGetObject` o `FilePutObject` función (o el registro o byte señalado por la última `Seek` función).</span><span class="sxs-lookup"><span data-stu-id="a0362-2039">If you omit `RecordNumber`, `FilePutObject` writes the next record or byte after the last `FileGetObject` or `FilePutObject` function (or the record or byte pointed to by the last `Seek` function).</span></span>  
  
 <span data-ttu-id="a0362-2040">El `StringIsFixedLength` argumento controla si la función interpreta las cadenas como longitud fija o variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-2040">The `StringIsFixedLength` argument controls whether the function interprets strings as variable or fixed length.</span></span> <span data-ttu-id="a0362-2041">`FilePutObject` no escribe el descriptor de longitud cuando el argumento es `True`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2041">`FilePutObject` does not write the length descriptor when the argument is `True`.</span></span> <span data-ttu-id="a0362-2042">Si usas `StringIsFixedLength`  =  `True` con `FilePutObject`, tendrá que hacer lo mismo con `FileGetObject`, y también debe asegurarse de que la cadena se inicializa con la longitud esperada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2042">If you use `StringIsFixedLength` = `True` with `FilePutObject`, you have to do the same with `FileGetObject`, and you must also make sure that the string is initialized to the length expected.</span></span>  
  
## <a name="random-mode"></a><span data-ttu-id="a0362-2043">Modo aleatorio</span><span class="sxs-lookup"><span data-stu-id="a0362-2043">Random Mode</span></span>  
 <span data-ttu-id="a0362-2044">De los archivos abiertos en `Random` modo, se aplican las reglas siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-2044">For files opened in `Random` mode, the following rules apply:</span></span>  
  
-   <span data-ttu-id="a0362-2045">Si la longitud de los datos que se va a escribir es menor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, `FilePutObject` escribirá los registros posteriores en los límites de longitud de registro.</span><span class="sxs-lookup"><span data-stu-id="a0362-2045">If the length of the data being written is less than the length specified in the `RecordLength` clause of the `FileOpen` function, `FilePutObject` writes subsequent records on record-length boundaries.</span></span> <span data-ttu-id="a0362-2046">El espacio entre el final de un registro y el inicio del siguiente registro se rellena con el contenido existente del búfer del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2046">The space between the end of one record and the start of the next record is padded with the existing contents of the file buffer.</span></span> <span data-ttu-id="a0362-2047">Como no se puede determinar con exactitud la cantidad de datos de relleno, suele ser una buena idea tener la longitud del registro coincide con la longitud de los datos que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="a0362-2047">Because the amount of padding data cannot be precisely determined, it is generally a good idea to have the record length match the length of the data being written.</span></span> <span data-ttu-id="a0362-2048">Si la longitud de los datos que se va a escribir es mayor que la longitud especificada en el `RecordLength` cláusula de la `FileOpen` función, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="a0362-2048">If the length of the data being written is greater than the length specified in the `RecordLength` clause of the `FileOpen` function, an exception is thrown.</span></span>  
  
-   <span data-ttu-id="a0362-2049">Si la variable que se está escribiendo es un objeto que contiene un tipo numérico, `FilePutObject` escribe dos bytes para identificar el `VarType` del objeto y, a continuación, escribe la variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-2049">If the variable being written is an object that contains a numeric type, `FilePutObject` writes two bytes identifying the `VarType` of the object and then writes the variable.</span></span> <span data-ttu-id="a0362-2050">Por ejemplo, al escribir un objeto que contiene un entero, `FilePutObject` escribe seis bytes: dos bytes que identifican el objeto como `VarType(3)` (`Integer`) y cuatro bytes que contienen los datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2050">For example, when writing an object that contains an integer, `FilePutObject` writes six bytes: two bytes that identify the object as `VarType(3)` (`Integer`) and four bytes that contain the data.</span></span> <span data-ttu-id="a0362-2051">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que el número real de bytes necesarios para almacenar la variable al menos dos bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2051">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least two bytes greater than the actual number of bytes required to store the variable.</span></span>  
  
-   <span data-ttu-id="a0362-2052">Si la variable que se está escribiendo es un objeto que contiene una cadena, `FilePutObject` escribe un descriptor de dos bytes que identifica el `VarType(8)` del objeto, un descriptor de dos bytes que indica la longitud de la cadena y, a continuación, escribe los datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="a0362-2052">If the variable being written is an object that contains a string, `FilePutObject` writes a two-byte descriptor identifying the `VarType(8)` of the object, a two-byte descriptor indicating the length of the string, and then writes the string data.</span></span> <span data-ttu-id="a0362-2053">La longitud de registro especificada por el `RecordLength` parámetro en el `FileOpen` función debe ser mayor que la longitud real de la cadena de al menos cuatro bytes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2053">The record length specified by the `RecordLength` parameter in the `FileOpen` function must be at least four bytes greater than the actual length of the string.</span></span> <span data-ttu-id="a0362-2054">Si desea escribir una cadena sin el descriptor, debería pasar `True` a la `StringIsFixedLength` parámetro y la cadena que lea debe tener la longitud correcta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2054">If you want to put a string without the descriptor, you should pass `True` to the `StringIsFixedLength` parameter, and the string you read into should be the correct length.</span></span>  
  
-   <span data-ttu-id="a0362-2055">Si la variable que se escribe es una matriz y, a continuación, la longitud de registro especificado por el `RecordLength` cláusula en la `FileOpen` función debe ser mayor o igual a la suma de todos los bytes necesarios para escribir los datos de matriz y el descriptor de matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2055">If the variable being written is an array, then the record length specified by the `RecordLength` clause in the `FileOpen` function must be greater than or equal to the sum of all the bytes required to write the array data and the array descriptor.</span></span> <span data-ttu-id="a0362-2056">El descriptor especifica el rango de la matriz, el tamaño y los límites inferiores de cada rango.</span><span class="sxs-lookup"><span data-stu-id="a0362-2056">The descriptor specifies the rank of the array, the size, and the lower bounds for each rank.</span></span> <span data-ttu-id="a0362-2057">Su longitud es igual a 2 más 8 veces el número de dimensiones: (2 + 8 \* NumberOfDimensions).</span><span class="sxs-lookup"><span data-stu-id="a0362-2057">Its length equals 2 plus 8 times the number of dimensions: (2 + 8 \* NumberOfDimensions).</span></span>  
  
## <a name="binary-mode"></a><span data-ttu-id="a0362-2058">Modo binario</span><span class="sxs-lookup"><span data-stu-id="a0362-2058">Binary Mode</span></span>  
 <span data-ttu-id="a0362-2059">De archivos abiertos en `Binary` modo, todas las `Random` se aplican las reglas de modo, excepto:</span><span class="sxs-lookup"><span data-stu-id="a0362-2059">For files opened in `Binary` mode, all the `Random` mode rules apply, except:</span></span>  
  
-   <span data-ttu-id="a0362-2060">El `RecordLength` cláusula en la `FileOpen` función no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2060">The `RecordLength` clause in the `FileOpen` function has no effect.</span></span> <span data-ttu-id="a0362-2061">`FilePutObject` escribe todas las variables en el disco de forma contigua, es decir, sin relleno entre los registros.</span><span class="sxs-lookup"><span data-stu-id="a0362-2061">`FilePutObject` writes all variables to disk contiguously, that is, without padding between records.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2062">Este ejemplo se usa el `FilePutObject` función para escribir una cadena en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2062">This example uses the `FilePutObject` function to write a string to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#54](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#54)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2063">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2063">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FileWidth">
      <MemberSignature Language="C#" Value="public static void FileWidth (int FileNumber, int RecordWidth);" />
      <MemberSignature Language="ILAsm" Value=".method public static void FileWidth(int32 FileNumber, int32 RecordWidth) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub FileWidth (FileNumber As Integer, RecordWidth As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FileWidth(int FileNumber, int RecordWidth);" />
      <MemberSignature Language="F#" Value="static member FileWidth : int * int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.FileWidth (FileNumber, RecordWidth)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="RecordWidth" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2064">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2064">Required.</span></span> <span data-ttu-id="a0362-2065">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2065">Any valid file number.</span></span></param>
        <param name="RecordWidth"><span data-ttu-id="a0362-2066">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2066">Required.</span></span> <span data-ttu-id="a0362-2067">Expresión numérica del 0 al 255, inclusive, que indica el número de caracteres que aparecen en una línea antes de que se inicie una nueva línea.</span><span class="sxs-lookup"><span data-stu-id="a0362-2067">Numeric expression in the range 0-255, inclusive, which indicates how many characters appear on a line before a new line is started.</span></span> <span data-ttu-id="a0362-2068">Si el valor de <paramref name="RecordWidth" /> es 0, la longitud de línea no tiene límite.</span><span class="sxs-lookup"><span data-stu-id="a0362-2068">If <paramref name="RecordWidth" /> equals 0, there is no limit to the length of a line.</span></span> <span data-ttu-id="a0362-2069">El valor predeterminado para <paramref name="RecordWidth" /> es 0.</span><span class="sxs-lookup"><span data-stu-id="a0362-2069">The default value for <paramref name="RecordWidth" /> is 0.</span></span></param>
        <summary><span data-ttu-id="a0362-2070">Asigna un ancho de línea de salida a un archivo abierto mediante la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2070">Assigns an output line width to a file opened by using the <see langword="FileOpen" /> function.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="a0362-2071">Este ejemplo se usa el `FileWidth` función para establecer el ancho de línea de salida de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2071">This example uses the `FileWidth` function to set the output line width for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#10](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2072">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2072">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2073">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2073">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FreeFile">
      <MemberSignature Language="C#" Value="public static int FreeFile ();" />
      <MemberSignature Language="ILAsm" Value=".method public static int32 FreeFile() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.FreeFile" />
      <MemberSignature Language="VB.NET" Value="Public Function FreeFile () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int FreeFile();" />
      <MemberSignature Language="F#" Value="static member FreeFile : unit -&gt; int" Usage="Microsoft.VisualBasic.FileSystem.FreeFile " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0362-2074">Devuelve un valor de tipo <see langword="Integer" /> que representa el siguiente número de archivo disponible para la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2074">Returns an <see langword="Integer" /> value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></summary>
        <returns><span data-ttu-id="a0362-2075">Valor entero que representa el siguiente número de archivo disponible para la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2075">An integer value that represents the next file number available for use by the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2076">Use `FreeFile` para proporcionar un número de archivo que ya no se usa.</span><span class="sxs-lookup"><span data-stu-id="a0362-2076">Use `FreeFile` to supply a file number that is not already being used.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2077">Este ejemplo se usa el `FreeFile` función para devolver el siguiente número de archivo disponibles.</span><span class="sxs-lookup"><span data-stu-id="a0362-2077">This example uses the `FreeFile` function to return the next available file number.</span></span> <span data-ttu-id="a0362-2078">Se abren cinco archivos de salida dentro del bucle, y algunos datos de ejemplo se escriben en cada uno.</span><span class="sxs-lookup"><span data-stu-id="a0362-2078">Five files are opened for output within the loop, and some sample data is written to each.</span></span>  
  
 [!code-vb[VbVbalrCatRef#55](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#55)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2079">Hay más de 255 archivos en uso.</span><span class="sxs-lookup"><span data-stu-id="a0362-2079">More than 255 files are in use.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2080">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2080">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAttr">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.FileAttribute GetAttr (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.FileAttribute GetAttr(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAttr (PathName As String) As FileAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::FileAttribute GetAttr(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member GetAttr : string -&gt; Microsoft.VisualBasic.FileAttribute" Usage="Microsoft.VisualBasic.FileSystem.GetAttr PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.FileAttribute</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-2081">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2081">Required.</span></span> <span data-ttu-id="a0362-2082">Expresión de cadena que especifica un nombre de archivo, directorio o carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2082">A string expression that specifies a file, directory, or folder name.</span></span> <span data-ttu-id="a0362-2083"><paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2083"><paramref name="PathName" /> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a0362-2084">Devuelve un valor de <see langword="FileAttribute" /> que representa los atributos de un archivo, un directorio o una carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2084">Returns a <see langword="FileAttribute" /> value that represents the attributes of a file, directory, or folder.</span></span> <span data-ttu-id="a0362-2085">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="FileAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2085">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="FileAttribute" />.</span></span> <span data-ttu-id="a0362-2086">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2086">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-2087">El valor devuelto por <see langword="GetAttr" /> es la suma de los siguientes valores de enumeración:</span><span class="sxs-lookup"><span data-stu-id="a0362-2087">The value returned by <see langword="GetAttr" /> is the sum of the following enumeration values:</span></span> 
 <list type="table"><item><term> <span data-ttu-id="a0362-2088">Valor</span><span class="sxs-lookup"><span data-stu-id="a0362-2088">Value</span></span> 
 </term><description> <span data-ttu-id="a0362-2089">Constante</span><span class="sxs-lookup"><span data-stu-id="a0362-2089">Constant</span></span> 
 </description><description> <span data-ttu-id="a0362-2090">Descripción</span><span class="sxs-lookup"><span data-stu-id="a0362-2090">Description</span></span> 
 </description></item><item><term><see langword="Normal" /></term><description><see langword="vbNormal" /></description><description> <span data-ttu-id="a0362-2091">Normal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2091">Normal.</span></span>  
  
 </description></item><item><term><see langword="ReadOnly" /></term><description><see langword="vbReadOnly" /></description><description> <span data-ttu-id="a0362-2092">Sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-2092">Read-only.</span></span>  
  
 </description></item><item><term><see langword="Hidden" /></term><description><see langword="vbHidden" /></description><description> <span data-ttu-id="a0362-2093">Oculto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2093">Hidden.</span></span>  
  
 </description></item><item><term><see langword="System" /></term><description><see langword="vbSystem" /></description><description> <span data-ttu-id="a0362-2094">Archivo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-2094">System file.</span></span>  
  
 </description></item><item><term><see langword="Directory" /></term><description><see langword="vbDirectory" /></description><description> <span data-ttu-id="a0362-2095">Directorio o carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2095">Directory or folder.</span></span>  
  
 </description></item><item><term><see langword="Archive" /></term><description><see langword="vbArchive" /></description><description> <span data-ttu-id="a0362-2096">El archivo ha cambiado desde que se realizó la última copia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2096">File has changed since last backup.</span></span>  
  
 </description></item><item><term><see langword="Alias" /></term><description><see langword="vbAlias" /></description><description> <span data-ttu-id="a0362-2097">El archivo tiene un nombre diferente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2097">File has a different name.</span></span>  
  
 </description></item></list><block subset="none" type="note"><para>  
 <span data-ttu-id="a0362-2098">El lenguaje de Visual Basic especifica estas enumeraciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2098">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="a0362-2099">Se pueden utilizar los nombres en cualquier lugar del código en vez de los valores reales.</span><span class="sxs-lookup"><span data-stu-id="a0362-2099">The names can be used anywhere in your code in place of the actual values.</span></span>  
  
</para></block></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2100">Para determinar qué atributos se establecen, utilice el `And` operador para realizar una comparación bit a bit del valor devuelto por la `GetAttr` función y el valor del atributo de archivo individuales que desee.</span><span class="sxs-lookup"><span data-stu-id="a0362-2100">To determine which attributes are set, use the `And` operator to perform a bitwise comparison of the value returned by the `GetAttr` function and the value of the individual file attribute you want.</span></span> <span data-ttu-id="a0362-2101">Si el resultado no es cero, ese atributo se establece para el archivo con nombre.</span><span class="sxs-lookup"><span data-stu-id="a0362-2101">If the result is not zero, that attribute is set for the named file.</span></span> <span data-ttu-id="a0362-2102">Por ejemplo, el valor devuelto de los siguientes `And` expresión es cero si el `Archive` no se establece el atributo:</span><span class="sxs-lookup"><span data-stu-id="a0362-2102">For example, the return value of the following `And` expression is zero if the `Archive` attribute is not set:</span></span>  
  
```vb  
Result = GetAttr(FName) And vbArchive  
```  
  
 <span data-ttu-id="a0362-2103">Se devuelve un valor distinto de cero si el `Archive` está establecido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2103">A nonzero value is returned if the `Archive` attribute is set.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2104">Este ejemplo se usa el `GetAttr` función para determinar los atributos de un archivo, directorio o carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2104">This example uses the `GetAttr` function to determine the attributes of a file and directory or folder.</span></span>  
  
 [!code-vb[VbVbalrCatRef#25](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#25)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2105"><paramref name="Pathname" /> no es válido o contiene caracteres comodín.</span><span class="sxs-lookup"><span data-stu-id="a0362-2105"><paramref name="Pathname" /> is invalid or contains wildcards.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-2106">El archivo de destino no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2106">Target file does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/and-operator.md"><span data-ttu-id="a0362-2107">And (Operador, Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2107">And Operator (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2108">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2108">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Input">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-2109">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2109">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref bool Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, bool&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, bool % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2110">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2110">Required.</span></span> <span data-ttu-id="a0362-2111">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2111">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2112">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2112">Required.</span></span> <span data-ttu-id="a0362-2113">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2113">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2114">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2114">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2115">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2115">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2116">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2116">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2117">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2117">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2118">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2118">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2119">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2119">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2120">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2120">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2121">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2121">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2122">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2122">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2123">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2123">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2124">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2124">Data</span></span>|<span data-ttu-id="a0362-2125">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2125">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2126">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2126">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2127">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2127">Empty</span></span>|  
|<span data-ttu-id="a0362-2128">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2128">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2129"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2129">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2130">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2130">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2131">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2131">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2132">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2132">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2133">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2133">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2134">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2134">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2135">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2135">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2136">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2136">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2137">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2137">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2138">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2138">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2139">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2139">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2140">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene algunas líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2140">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2141">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2141">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2142">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2142">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2143">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2143">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2144">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2144">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref byte Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, unsigned int8&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Byte % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2145">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2145">Required.</span></span> <span data-ttu-id="a0362-2146">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2146">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2147">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2147">Required.</span></span> <span data-ttu-id="a0362-2148">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2148">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2149">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2149">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2150">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2150">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2151">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2151">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2152">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2152">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2153">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2153">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2154">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2154">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2155">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2155">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2156">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2156">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2157">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2157">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2158">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2158">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2159">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2159">Data</span></span>|<span data-ttu-id="a0362-2160">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2160">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2161">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2161">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2162">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2162">Empty</span></span>|  
|<span data-ttu-id="a0362-2163">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2163">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2164"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2164">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2165">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2165">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2166">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2166">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2167">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2167">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2168">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2168">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2169">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2169">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2170">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2170">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2171">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2171">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2172">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2172">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2173">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2173">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2174">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2174">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2175">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene algunas líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2175">This example assumes that `TestFile` is a file that has some lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2176">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2176">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2177">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2177">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2178">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2178">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2179">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2179">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref char Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, char&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Char@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Char)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, char % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Char" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2180">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2180">Required.</span></span> <span data-ttu-id="a0362-2181">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2181">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2182">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2182">Required.</span></span> <span data-ttu-id="a0362-2183">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2183">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2184">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2184">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2185">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2185">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2186">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2186">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2187">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2187">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2188">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2188">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2189">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2189">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2190">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2190">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2191">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2191">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2192">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2192">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2193">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2193">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2194">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2194">Data</span></span>|<span data-ttu-id="a0362-2195">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2195">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2196">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2196">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2197">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2197">Empty</span></span>|  
|<span data-ttu-id="a0362-2198">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2198">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2199"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2199">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2200">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2200">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2201">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2201">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2202">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2202">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2203">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2203">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2204">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2204">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2205">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2205">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2206">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2206">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2207">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2207">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2208">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2208">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2209">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2209">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2210">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2210">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2211">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2211">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2212">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2212">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2213">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2213">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2214">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2214">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref DateTime Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.DateTime&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.DateTime@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As DateTime)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, DateTime % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.DateTime" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2215">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2215">Required.</span></span> <span data-ttu-id="a0362-2216">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2216">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2217">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2217">Required.</span></span> <span data-ttu-id="a0362-2218">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2218">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2219">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2219">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2220">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2220">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2221">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2221">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2222">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2222">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2223">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2223">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2224">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2224">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2225">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2225">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2226">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2226">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2227">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2227">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2228">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2228">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2229">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2229">Data</span></span>|<span data-ttu-id="a0362-2230">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2230">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2231">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2231">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2232">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2232">Empty</span></span>|  
|<span data-ttu-id="a0362-2233">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2233">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2234"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2234">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2235">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2235">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2236">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2236">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2237">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2237">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2238">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2238">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2239">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2239">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2240">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2240">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2241">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2241">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2242">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2242">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2243">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2243">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2244">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2244">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2245">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2245">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2246">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2246">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2247">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2247">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2248">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2248">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2249">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2249">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref decimal Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, valuetype System.Decimal&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Decimal@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Decimal % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Decimal" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2250">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2250">Required.</span></span> <span data-ttu-id="a0362-2251">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2251">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2252">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2252">Required.</span></span> <span data-ttu-id="a0362-2253">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2253">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2254">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2254">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2255">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2255">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2256">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2256">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2257">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2257">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2258">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2258">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2259">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2259">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2260">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2260">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2261">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2261">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2262">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2262">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2263">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2263">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2264">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2264">Data</span></span>|<span data-ttu-id="a0362-2265">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2265">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2266">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2266">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2267">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2267">Empty</span></span>|  
|<span data-ttu-id="a0362-2268">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2268">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2269"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2269">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2270">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2270">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2271">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2271">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2272">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2272">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2273">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2273">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2274">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2274">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2275">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2275">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2276">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2276">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2277">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2277">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2278">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2278">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2279">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2279">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2280">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2280">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2281">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2281">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2282">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2282">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2283">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2283">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2284">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2284">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref double Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, double % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2285">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2285">Required.</span></span> <span data-ttu-id="a0362-2286">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2286">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2287">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2287">Required.</span></span> <span data-ttu-id="a0362-2288">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2288">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2289">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2289">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2290">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2290">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2291">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2291">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2292">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2292">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2293">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2293">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2294">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2294">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2295">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2295">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2296">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2296">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2297">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2297">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2298">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2298">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2299">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2299">Data</span></span>|<span data-ttu-id="a0362-2300">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2300">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2301">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2301">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2302">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2302">Empty</span></span>|  
|<span data-ttu-id="a0362-2303">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2303">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2304"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2304">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2305">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2305">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2306">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2306">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2307">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2307">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2308">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2308">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2309">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2309">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2310">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2310">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2311">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2311">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2312">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2312">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2313">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2313">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2314">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2314">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2315">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2315">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2316">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2316">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2317">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2317">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2318">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2318">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2319">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2319">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref short Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int16&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, short % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2320">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2320">Required.</span></span> <span data-ttu-id="a0362-2321">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2321">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2322">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2322">Required.</span></span> <span data-ttu-id="a0362-2323">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2323">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2324">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2324">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2325">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2325">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2326">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2326">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2327">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2327">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2328">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2328">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2329">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2329">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2330">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2330">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2331">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2331">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2332">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2332">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2333">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2333">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2334">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2334">Data</span></span>|<span data-ttu-id="a0362-2335">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2335">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2336">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2336">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2337">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2337">Empty</span></span>|  
|<span data-ttu-id="a0362-2338">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2338">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2339"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2339">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2340">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2340">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2341">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2341">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2342">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2342">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2343">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2343">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2344">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2344">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2345">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2345">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2346">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2346">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2347">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2347">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2348">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2348">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2349">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2349">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2350">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2350">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2351">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2351">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2352">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2352">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2353">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2353">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2354">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2354">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref int Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, int % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2355">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2355">Required.</span></span> <span data-ttu-id="a0362-2356">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2356">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2357">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2357">Required.</span></span> <span data-ttu-id="a0362-2358">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2358">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2359">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2359">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2360">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2360">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2361">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2361">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2362">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2362">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2363">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2363">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2364">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2364">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2365">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2365">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2366">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2366">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2367">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2367">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2368">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2368">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2369">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2369">Data</span></span>|<span data-ttu-id="a0362-2370">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2370">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2371">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2371">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2372">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2372">Empty</span></span>|  
|<span data-ttu-id="a0362-2373">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2373">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2374"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2374">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2375">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2375">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2376">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2376">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2377">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2377">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2378">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2378">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2379">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2379">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2380">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2380">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2381">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, dado que se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2381">For example, in the German version, if you input 3,14159, it returns only 3, since the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2382">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2382">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2383">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2383">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2384">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2384">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2385">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2385">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2386">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2386">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2387">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2387">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2388">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2388">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2389">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2389">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref long Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, int64&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, long % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2390">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2390">Required.</span></span> <span data-ttu-id="a0362-2391">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2391">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2392">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2392">Required.</span></span> <span data-ttu-id="a0362-2393">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2393">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2394">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2394">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2395">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2395">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2396">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2396">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2397">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2397">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2398">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2398">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2399">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2399">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2400">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2400">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2401">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2401">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2402">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2402">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2403">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2403">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2404">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2404">Data</span></span>|<span data-ttu-id="a0362-2405">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2405">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2406">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2406">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2407">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2407">Empty</span></span>|  
|<span data-ttu-id="a0362-2408">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2408">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2409"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2409">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2410">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2410">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2411">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2411">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2412">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2412">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2413">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2413">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2414">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2414">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2415">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2415">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2416">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2416">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2417">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2417">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2418">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2418">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2419">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2419">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2420">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2420">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2421">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2421">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2422">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2422">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2423">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2423">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2424">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2424">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref object Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, object&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::Object ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2425">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2425">Required.</span></span> <span data-ttu-id="a0362-2426">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2426">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2427">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2427">Required.</span></span> <span data-ttu-id="a0362-2428">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2428">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2429">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2429">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2430">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2430">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2431">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2431">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2432">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2432">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2433">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2433">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2434">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2434">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2435">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2435">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2436">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2436">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2437">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2437">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2438">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2438">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2439">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2439">Data</span></span>|<span data-ttu-id="a0362-2440">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2440">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2441">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2441">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2442">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2442">Empty</span></span>|  
|<span data-ttu-id="a0362-2443">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2443">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2444"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2444">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2445">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2445">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2446">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2446">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2447">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2447">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2448">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2448">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2449">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2449">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2450">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2450">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2451">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2451">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2452">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2452">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2453">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2453">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2454">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2454">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2455">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2455">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2456">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2456">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2457">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2457">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2458">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2458">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2459">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2459">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref float Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, float32&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, float % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2460">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2460">Required.</span></span> <span data-ttu-id="a0362-2461">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2461">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2462">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2462">Required.</span></span> <span data-ttu-id="a0362-2463">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2463">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2464">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2464">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2465">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2465">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2466">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2466">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2467">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2467">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2468">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2468">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2469">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2469">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2470">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2470">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2471">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2471">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2472">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2472">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2473">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2473">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2474">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2474">Data</span></span>|<span data-ttu-id="a0362-2475">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2475">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2476">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2476">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2477">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2477">Empty</span></span>|  
|<span data-ttu-id="a0362-2478">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2478">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2479"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2479">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2480">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2480">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2481">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2481">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2482">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2482">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2483">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2483">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2484">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2484">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2485">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2485">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2486">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2486">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2487">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2487">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2488">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2488">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2489">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2489">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2490">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2490">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2491">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2491">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2492">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2492">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2493">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2493">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2494">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2494">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Input">
      <MemberSignature Language="C#" Value="public static void Input (int FileNumber, ref string Value);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Input(int32 FileNumber, string&amp; Value) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Input(System.Int32,System.String@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Input (FileNumber As Integer, ByRef Value As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Input(int FileNumber, System::String ^ % Value);" />
      <MemberSignature Language="F#" Value="static member Input : int *  -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Input (FileNumber, Value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Value" Type="System.String" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2495">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2495">Required.</span></span> <span data-ttu-id="a0362-2496">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2496">Any valid file number.</span></span></param>
        <param name="Value"><span data-ttu-id="a0362-2497">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2497">Required.</span></span> <span data-ttu-id="a0362-2498">Variable a la que se han asignado los valores leídos del archivo; no puede ser una variable de objeto o matriz.</span><span class="sxs-lookup"><span data-stu-id="a0362-2498">Variable that is assigned the values read from the file - cannot be an array or object variable.</span></span></param>
        <summary><span data-ttu-id="a0362-2499">Lee los datos de un archivo secuencial abierto y los asigna a variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2499">Reads data from an open sequential file and assigns the data to variables.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2500">El `Input` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2500">The `Input` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2501">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2501">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2502">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2502">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2503">Los datos leídos con `Input` se escriben normalmente en un archivo mediante el uso de `Write`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2503">Data read with `Input` is usually written to a file by using `Write`.</span></span> <span data-ttu-id="a0362-2504">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2504">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2505">Al leer de archivos, no realice ninguna decisión sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2505">When reading from files, do not make decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2506">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic 2005.</span><span class="sxs-lookup"><span data-stu-id="a0362-2506">For example, a file that is named Form1.vb may not be a Visual Basic 2005 source file.</span></span>  
  
 <span data-ttu-id="a0362-2507">Cuando se leen datos numéricos o cadena estándar se asignan a variables sin modificación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2507">When read, standard string or numeric data is assigned to variables without modification.</span></span> <span data-ttu-id="a0362-2508">En la tabla siguiente se muestra cómo se tratan otros datos de entrada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2508">The following table illustrates how other input data is treated.</span></span>  
  
|<span data-ttu-id="a0362-2509">Datos</span><span class="sxs-lookup"><span data-stu-id="a0362-2509">Data</span></span>|<span data-ttu-id="a0362-2510">Valor asignado a la variable</span><span class="sxs-lookup"><span data-stu-id="a0362-2510">Value assigned to variable</span></span>|  
|-|-|  
|<span data-ttu-id="a0362-2511">Delimitadores de coma o línea en blanco</span><span class="sxs-lookup"><span data-stu-id="a0362-2511">Delimiting comma or blank line</span></span>|<span data-ttu-id="a0362-2512">Empty</span><span class="sxs-lookup"><span data-stu-id="a0362-2512">Empty</span></span>|  
|<span data-ttu-id="a0362-2513">NULL #</span><span class="sxs-lookup"><span data-stu-id="a0362-2513">#NULL#</span></span>|`DBNull`|  
|<span data-ttu-id="a0362-2514"># TRUE o FALSE #</span><span class="sxs-lookup"><span data-stu-id="a0362-2514">#TRUE# or #FALSE#</span></span>|<span data-ttu-id="a0362-2515">`True` o `False`</span><span class="sxs-lookup"><span data-stu-id="a0362-2515">`True` or `False`</span></span>|  
|#`yyyy-mm-dd hh:mm:ss`#|<span data-ttu-id="a0362-2516">La fecha y hora representadas por la expresión</span><span class="sxs-lookup"><span data-stu-id="a0362-2516">The date and/or time represented by the expression</span></span>|  
|<span data-ttu-id="a0362-2517">#ERROR `errornumber`#</span><span class="sxs-lookup"><span data-stu-id="a0362-2517">#ERROR `errornumber`#</span></span>|<span data-ttu-id="a0362-2518">`errornumber` (la variable es un objeto etiquetado como error)</span><span class="sxs-lookup"><span data-stu-id="a0362-2518">`errornumber` (variable is an object tagged as an error)</span></span>|  
  
 <span data-ttu-id="a0362-2519">Si se alcanza el final del archivo mientras se está introduciendo un elemento de datos, la entrada se detiene y se produce un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2519">If you reach the end of the file while you are inputting a data item, the input is stopped and an error occurs.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2520">El `Input` función no está localizada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2520">The `Input` function is not localized.</span></span> <span data-ttu-id="a0362-2521">Por ejemplo, en la versión en alemán, si se escribe 3,14159, devuelve solo 3, porque se trata la coma como separador de variable en lugar de como un separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2521">For example, in the German version, if you input 3,14159, it returns only 3, because the comma is treated as a variable separator instead of as a decimal point.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2522">Leer un archivo mediante el uso de la `Input` función requiere `Read` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2522">Reading from a file by using the `Input` function requires `Read` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2523">Para obtener más información, vea <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2523">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2524">Este ejemplo se usa el `Input` función para leer datos desde un archivo en dos variables.</span><span class="sxs-lookup"><span data-stu-id="a0362-2524">This example uses the `Input` function to read data from a file into two variables.</span></span> <span data-ttu-id="a0362-2525">En este ejemplo se da por supuesto que `TestFile` es un archivo que tiene varias líneas de los datos escritos en él con el `Write` funcione, cada línea que contiene una cadena entre comillas y un número separado por una coma, por ejemplo: ("Hello", 234).</span><span class="sxs-lookup"><span data-stu-id="a0362-2525">This example assumes that `TestFile` is a file that has several lines of data written to it using the `Write` function, each line containing a string in quotations and a number separated by a comma, for example: ("Hello", 234).</span></span>  
  
 [!code-vb[VbVbalrCatRef#35](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#35)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2526">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2526">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2527">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2527">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2528">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2528">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2529">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2529">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="InputString">
      <MemberSignature Language="C#" Value="public static string InputString (int FileNumber, int CharCount);" />
      <MemberSignature Language="ILAsm" Value=".method public static string InputString(int32 FileNumber, int32 CharCount) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.InputString(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function InputString (FileNumber As Integer, CharCount As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ InputString(int FileNumber, int CharCount);" />
      <MemberSignature Language="F#" Value="static member InputString : int * int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.InputString (FileNumber, CharCount)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="CharCount" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2530">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2530">Required.</span></span> <span data-ttu-id="a0362-2531">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2531">Any valid file number.</span></span></param>
        <param name="CharCount"><span data-ttu-id="a0362-2532">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2532">Required.</span></span> <span data-ttu-id="a0362-2533">Cualquier expresión numérica válida que especifique el número de caracteres que se van a leer.</span><span class="sxs-lookup"><span data-stu-id="a0362-2533">Any valid numeric expression specifying the number of characters to read.</span></span></param>
        <summary><span data-ttu-id="a0362-2534">Devuelve un valor de tipo <see langword="String" /> que contiene los caracteres de un archivo abierto en modo <see langword="Input" /> o <see langword="Binary" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2534">Returns <see langword="String" /> value that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="a0362-2535">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2535">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span> <span data-ttu-id="a0362-2536">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2536">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-2537">Cadena que contiene los caracteres de un archivo abierto en modo <see langword="Input" /> o <see langword="Binary" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2537">A string that contains characters from a file opened in <see langword="Input" /> or <see langword="Binary" /> mode.</span></span> <span data-ttu-id="a0362-2538">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="InputString" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2538">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="InputString" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2539">El `InputString` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2539">The `InputString` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2540">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2540">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2541">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2541">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2542">Los datos leídos con el `InputString` función normalmente se escribe en un archivo mediante el uso de `Print` o `FilePut`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2542">Data read with the `InputString` function is usually written to a file by using `Print` or `FilePut`.</span></span> <span data-ttu-id="a0362-2543">Utilice esta función sólo con los archivos abiertos en `Input` o `Binary` modo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2543">Use this function only with files opened in `Input` or `Binary` mode.</span></span>  
  
 <span data-ttu-id="a0362-2544">A diferencia de la `Input` función, el `InputString` función devuelve todos los caracteres que lee.</span><span class="sxs-lookup"><span data-stu-id="a0362-2544">Unlike the `Input` function, the `InputString` function returns all the characters it reads.</span></span> <span data-ttu-id="a0362-2545">Esto incluye comas, retornos de carro, saltos de línea, las comillas y espacios iniciales.</span><span class="sxs-lookup"><span data-stu-id="a0362-2545">This includes commas, carriage returns, line feeds, quotation marks, and leading spaces.</span></span>  
  
 <span data-ttu-id="a0362-2546">Con los archivos abiertos para `Binary` tener acceso a un intento de leer el archivo mediante el uso de la `InputString` función hasta `EOF` devuelve `True` genera un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2546">With files opened for `Binary` access, an attempt to read through the file by using the `InputString` function until `EOF` returns `True` generates an error.</span></span> <span data-ttu-id="a0362-2547">Utilice la `LOF` y `Loc` funciones en lugar de `EOF` al leer archivos binarios mediante `InputString`, o use `FileGet` cuando se usa el `EOF` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-2547">Use the `LOF` and `Loc` functions instead of `EOF` when you read binary files by using `InputString`, or use `FileGet` when you use the `EOF` function.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2548">Al leer de archivos, no tomar decisiones de seguridad sobre el contenido del archivo basándose en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2548">When reading from files, do not make security decisions about the contents of the file based on the file name extension.</span></span> <span data-ttu-id="a0362-2549">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-2549">For example, a file named Form1.vb may not be a Visual Basic source file.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2550">Este ejemplo se usa el `InputString` función para leer un carácter de un archivo al mismo tiempo y para imprimir el `Output` ventana.</span><span class="sxs-lookup"><span data-stu-id="a0362-2550">This example uses the `InputString` function to read one character at a time from a file and print it to the `Output` window.</span></span> <span data-ttu-id="a0362-2551">En este ejemplo se da por supuesto que `MyFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2551">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#33](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#33)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2552"><paramref name="FileNumber" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2552"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2553"><paramref name="CharCount" /> &lt; 0 o &gt; 214.</span><span class="sxs-lookup"><span data-stu-id="a0362-2553"><paramref name="CharCount" /> &lt; 0 or &gt; 214.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2554">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2554">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2555">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2555">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2556">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2556">How to: Write Text to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Kill">
      <MemberSignature Language="C#" Value="public static void Kill (string PathName);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Kill(string PathName) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Kill (PathName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Kill(System::String ^ PathName);" />
      <MemberSignature Language="F#" Value="static member Kill : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Kill PathName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-2557">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2557">Required.</span></span> <span data-ttu-id="a0362-2558">Expresión de cadena que especifica uno o varios nombres de archivo que se van a eliminar.</span><span class="sxs-lookup"><span data-stu-id="a0362-2558">A string expression that specifies one or more file names to be deleted.</span></span> <span data-ttu-id="a0362-2559"><paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2559"><paramref name="PathName" /> can include the directory or folder, and the drive.</span></span></param>
        <summary><span data-ttu-id="a0362-2560">Elimina archivos de un disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2560">Deletes files from a disk.</span></span> <span data-ttu-id="a0362-2561">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Kill" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2561">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Kill" />.</span></span> <span data-ttu-id="a0362-2562">Para obtener más información, consulta <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2562">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" /> .</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2563">`Kill` admite el uso de varios caracteres (`*`) ni un único carácter (`?`) los caracteres comodín para especificar varios archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2563">`Kill` supports the use of multiple-character (`*`) and single-character (`?`) wildcards to specify multiple files.</span></span>  
  
 <span data-ttu-id="a0362-2564">**Nota de seguridad** para poder ejecutarse, el `Kill` función requiere `Read` y `PathDiscovery` marcas de <xref:System.Security.Permissions.FileIOPermission> concederá al código de ejecución.</span><span class="sxs-lookup"><span data-stu-id="a0362-2564">**Security Note** In order to execute, the `Kill` function requires `Read` and `PathDiscovery` flags of <xref:System.Security.Permissions.FileIOPermission> to be granted to the executing code.</span></span> <span data-ttu-id="a0362-2565">Para obtener más información, consulte <xref:System.Security.SecurityException> [permisos de acceso del código](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span><span class="sxs-lookup"><span data-stu-id="a0362-2565">For more information, see <xref:System.Security.SecurityException>[Code Access Permissions](https://msdn.microsoft.com/library/e5ae402f-6dda-4732-bbe8-77296630f675)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2566">Este ejemplo se usa el `Kill` función para eliminar un archivo desde un disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2566">This example uses the `Kill` function to delete a file from a disk.</span></span>  
  
 [!code-vb[VbVbalrCatRef#60](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#60)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2567">El archivo o los archivos de destino están abiertos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2567">Target file(s) open.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-2568">No se encuentra el archivo o los archivos de destino.</span><span class="sxs-lookup"><span data-stu-id="a0362-2568">Target file(s) not found.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a0362-2569">Permiso denegado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2569">Permission denied.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <Member MemberName="LineInput">
      <MemberSignature Language="C#" Value="public static string LineInput (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static string LineInput(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LineInput(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LineInput (FileNumber As Integer) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ LineInput(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LineInput : int -&gt; string" Usage="Microsoft.VisualBasic.FileSystem.LineInput FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2570">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2570">Required.</span></span> <span data-ttu-id="a0362-2571">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2571">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2572">Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <see langword="String" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2572">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></summary>
        <returns><span data-ttu-id="a0362-2573">Lee una sola línea de un archivo secuencial abierto y la asigna a una variable de <see langword="String" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2573">Reads a single line from an open sequential file and assigns it to a <see langword="String" /> variable.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2574">El `LineInput` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2574">The `LineInput` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2575">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2575">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2576">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2576">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2577">Los datos leídos con `LineInput` se escriben normalmente en un archivo mediante el uso de `Print`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2577">Data read with `LineInput` is usually written to a file by using `Print`.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2578">Al leer de archivos, no realice ninguna decisión sobre el contenido de un archivo basado en la extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2578">When reading from files, do not make decisions about the contents of a file based on the file name extension.</span></span> <span data-ttu-id="a0362-2579">Por ejemplo, un archivo denominado Form1.vb no puede ser un archivo de código fuente de Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="a0362-2579">For example, a file that is named Form1.vb may not be a Visual Basic source file.</span></span>  
  
 <span data-ttu-id="a0362-2580">El `LineInput` función lee un carácter de un archivo a la vez hasta que encuentra un retorno de carro (`Chr(13)`) o retorno de carro/línea fuente (`Chr(13) + Chr(10)`) secuencia.</span><span class="sxs-lookup"><span data-stu-id="a0362-2580">The `LineInput` function reads from a file one character at a time until it encounters a carriage return (`Chr(13)`) or carriage return/line feed (`Chr(13) + Chr(10)`) sequence.</span></span> <span data-ttu-id="a0362-2581">Carro retorno estas secuencias se omiten en lugar de anexar a la cadena de caracteres.</span><span class="sxs-lookup"><span data-stu-id="a0362-2581">Carriage return/line feed sequences are skipped instead of appended to the character string.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2582">Leer un archivo mediante el uso de la `LineInput` función requiere `Read` acceso desde el <xref:System.Security.Permissions.FileIOPermissionAccess> enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2582">Reading from a file by using the `LineInput` function requires `Read` access from the <xref:System.Security.Permissions.FileIOPermissionAccess> enumeration.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2583">Este ejemplo se usa el `LineInput` función para leer una línea de un archivo secuencial y asignarlo a una variable.</span><span class="sxs-lookup"><span data-stu-id="a0362-2583">This example uses the `LineInput` function to read a line from a sequential file and assign it to a variable.</span></span> <span data-ttu-id="a0362-2584">En este ejemplo se da por supuesto que `TestFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2584">This example assumes that `TestFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#19](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#19)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.EndOfStreamException"><span data-ttu-id="a0362-2585">Se ha llegado al final del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2585">End of file reached.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2586"><paramref name="FileNumber" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2586"><paramref name="FileNumber" /> does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.Strings.Chr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.ChrW(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2587">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2587">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2588">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2588">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2589">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2589">How to: Write Text to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Loc">
      <MemberSignature Language="C#" Value="public static long Loc (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Loc(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Loc (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Loc(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Loc : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Loc FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2590">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2590">Required.</span></span> <span data-ttu-id="a0362-2591">Cualquier número de archivo válido de tipo <see langword="Integer" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2591">Any valid <see langword="Integer" /> file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2592">Devuelve un valor que especifica la actual posición de lectura y escritura en un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2592">Returns a value that specifies the current read/write position in an open file.</span></span></summary>
        <returns><span data-ttu-id="a0362-2593">Posición de lectura o escritura actual en un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2593">The current read/write position in an open file.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2594">El `Loc` función está basado en cero; se utiliza para recuperar el primer byte de un archivo, devuelve 0.</span><span class="sxs-lookup"><span data-stu-id="a0362-2594">The `Loc` function is zero-based; using it to retrieve the first byte in a file will return 0.</span></span>  
  
 <span data-ttu-id="a0362-2595">El `Loc` función se proporciona por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2595">The `Loc` function is provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2596">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2596">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2597">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2597">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2598">El siguiente describe el valor devuelto para cada modo de acceso de archivo:</span><span class="sxs-lookup"><span data-stu-id="a0362-2598">The following describes the return value for each file access mode:</span></span>  
  
|<span data-ttu-id="a0362-2599">Modo</span><span class="sxs-lookup"><span data-stu-id="a0362-2599">Mode</span></span>|<span data-ttu-id="a0362-2600">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="a0362-2600">Return value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a0362-2601">Número del último registro leído o escrito en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2601">Number of the last record read from or written to the file.</span></span>|  
|`Sequential`|<span data-ttu-id="a0362-2602">Posición de byte actual en el archivo dividido entre 128.</span><span class="sxs-lookup"><span data-stu-id="a0362-2602">Current byte position in the file divided by 128.</span></span> <span data-ttu-id="a0362-2603">Sin embargo, la información devuelta por `Loc` para archivos secuenciales no se utiliza ni necesario.</span><span class="sxs-lookup"><span data-stu-id="a0362-2603">However, information returned by `Loc` for sequential files is neither used nor required.</span></span>|  
|`Binary`|<span data-ttu-id="a0362-2604">Posición del último byte leído o escrito.</span><span class="sxs-lookup"><span data-stu-id="a0362-2604">Position of the last byte read or written.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2605">Este ejemplo se usa el `Loc` función para devolver la posición de lectura/escritura actual en un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2605">This example uses the `Loc` function to return the current read/write position in an open file.</span></span> <span data-ttu-id="a0362-2606">En este ejemplo se da por supuesto que `MyFile` es un archivo de texto que tiene varias líneas de datos de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2606">This example assumes that `MyFile` is a text file that has several lines of sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#17](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#17)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2607">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2607">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Seek" />
        <altmember cref="T:System.IO.IOException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Lock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-2608">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2608">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2609">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2609">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2610">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2610">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Lock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2611">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2611">Required.</span></span> <span data-ttu-id="a0362-2612">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2612">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2613">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2613">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2614">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2614">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2615">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2615">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2616">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2616">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2617">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2617">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2618">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2618">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2619">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2619">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2620">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2620">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2621">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2621">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2622">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2622">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2623">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2623">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2624">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2624">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2625">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2625">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2626">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2626">Required.</span></span> <span data-ttu-id="a0362-2627">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2627">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="a0362-2628">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2628">Optional.</span></span> <span data-ttu-id="a0362-2629">Número del único registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2629">Number of the only record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a0362-2630">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2630">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2631">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2631">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2632">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2632">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2633">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2633">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2634">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2634">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2635">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2635">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2636">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2636">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2637">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2637">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2638">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2638">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2639">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2639">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2640">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2640">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2641">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2641">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2642">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2642">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Lock">
      <MemberSignature Language="C#" Value="public static void Lock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Lock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Lock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Lock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Lock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Lock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Lock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2643">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2643">Required.</span></span> <span data-ttu-id="a0362-2644">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2644">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="a0362-2645">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2645">Optional.</span></span> <span data-ttu-id="a0362-2646">Número del primer registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2646">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="a0362-2647">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2647">Optional.</span></span> <span data-ttu-id="a0362-2648">Número del último registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2648">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a0362-2649">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2649">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2650">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2650">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2651">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2651">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2652">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2652">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2653">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2653">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2654">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2654">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2655">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2655">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2656">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2656">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2657">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2657">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2658">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2658">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2659">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2659">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2660">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2660">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2661">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2661">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="LOF">
      <MemberSignature Language="C#" Value="public static long LOF (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 LOF(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.LOF(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function LOF (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long LOF(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member LOF : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.LOF FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2662">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2662">Required.</span></span> <span data-ttu-id="a0362-2663">Número entero que contiene un número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2663">An integer that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2664">Devuelve el tamaño, en bytes, de un archivo abierto mediante la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2664">Returns the size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2665">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2665">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span> <span data-ttu-id="a0362-2666">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2666">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-2667">Tamaño, en bytes, de un archivo abierto mediante la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2667">The size, in bytes, of a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2668">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="LOF" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2668">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="LOF" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2669">Use el `FileLen` función para obtener la longitud de un archivo que no está abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2669">Use the `FileLen` function to obtain the length of a file that is not open.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2670">Este ejemplo se usa el `LOF` función para determinar el tamaño de un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2670">This example uses the `LOF` function to determine the size of an open file.</span></span> <span data-ttu-id="a0362-2671">En este ejemplo se da por supuesto que `TestFile` es un archivo de texto que contiene datos de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2671">This example assumes that `TestFile` is a text file that contains sample data.</span></span>  
  
 [!code-vb[VbVbalrCatRef#23](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#23)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2672">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2672">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.EOF(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileLen(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-2673">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2673">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2674">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2674">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MkDir">
      <MemberSignature Language="C#" Value="public static void MkDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void MkDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub MkDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MkDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member MkDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.MkDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a0362-2675">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2675">Required.</span></span> <span data-ttu-id="a0362-2676">Expresión de cadena que identifica el directorio que se va a crear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2676">A string expression that identifies the directory to be created.</span></span> <span data-ttu-id="a0362-2677"><paramref name="Path" /> puede incluir la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2677">The <paramref name="Path" /> may include the drive.</span></span> <span data-ttu-id="a0362-2678">Si no hay ninguna unidad especificada, <see langword="MkDir" /> crea el nuevo directorio en la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-2678">If no drive is specified, <see langword="MkDir" /> creates the new directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="a0362-2679">Crea un directorio nuevo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2679">Creates a new directory.</span></span> <span data-ttu-id="a0362-2680">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="MkDir" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2680">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="MkDir" />.</span></span> <span data-ttu-id="a0362-2681">Para obtener más información, vea <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2681">For more information, see <see cref="M:Microsoft.VisualBasic.FileIO.FileSystem.CreateDirectory(System.String)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2682">Esta función crea un nuevo directorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2682">This function creates a new directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2683">Este ejemplo se usa el `MkDir` función para crear un directorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2683">This example uses the `MkDir` function to create a directory.</span></span> <span data-ttu-id="a0362-2684">Si no se especifica la unidad, se crea el nuevo directorio en la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-2684">If the drive is not specified, the new directory is created on the current drive.</span></span>  
  
 [!code-vb[VbVbalrCatRef#38](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#38)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2685"><paramref name="Path" /> no se ha especificado o está vacío.</span><span class="sxs-lookup"><span data-stu-id="a0362-2685"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="a0362-2686">Permiso denegado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2686">Permission denied.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2687">El directorio ya existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2687">Directory already exists.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-create-a-directory.md"><span data-ttu-id="a0362-2688">Cómo: Crear un directorio en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2688">How to: Create a Directory in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Print">
      <MemberSignature Language="C#" Value="public static void Print (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Print(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Print (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Print(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Print : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Print (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2689">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2689">Required.</span></span> <span data-ttu-id="a0362-2690">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2690">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a0362-2691">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2691">Optional.</span></span> <span data-ttu-id="a0362-2692">Cero o más expresiones delimitadas por comas para escribir en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2692">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
<span data-ttu-id="a0362-2693">La configuración del argumento <paramref name="Output" /> es:</span><span class="sxs-lookup"><span data-stu-id="a0362-2693">The <paramref name="Output" /> argument settings are:</span></span> 
 <span data-ttu-id="a0362-2694"><see langword="T:System.IO.IOException" />: El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2694"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="a0362-2695"><see langword="T:System.IO.IOException" />:<paramref name="FileNumber" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2695"><see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="a0362-2696">Escribe los datos con formato de presentación en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-2696">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2697">El `Print` y `PrintLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2697">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2698">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2698">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2699">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2699">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2700">`Print` no incluye una avance de línea al final de una línea; Sin embargo, `PrintLine` incluyen un avance de línea.</span><span class="sxs-lookup"><span data-stu-id="a0362-2700">`Print` does not include a line feed at the end of a line; however, `PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="a0362-2701">Los datos escritos con `Print` normalmente se leen desde un archivo mediante el uso de `LineInput` o `Input`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2701">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="a0362-2702">Si se omite `Output` para `PrintLine`, se imprime una línea en blanco en el archivo; para `Print`, nada es de salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2702">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="a0362-2703">Varias expresiones separadas por comas se alineará en los límites de tabulación, pero la combinación de comas y `TAB` puede causar resultados incoherentes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2703">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="a0362-2704">Para `Boolean` datos, ya sea `True` o `False` se imprime.</span><span class="sxs-lookup"><span data-stu-id="a0362-2704">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="a0362-2705">El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2705">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="a0362-2706">Los datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-2706">Date data is written to the file by using the standard short date format recognized by your system.</span></span> <span data-ttu-id="a0362-2707">Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2707">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="a0362-2708">Si se escribirá nada en el archivo `Output` datos están vacíos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2708">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a0362-2709">Sin embargo, si `Output` datos de la lista están `DBNull`, `Null` se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2709">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="a0362-2710">Para `Error` la salida de datos, aparece como `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2710">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="a0362-2711">El `Error` palabra clave no se traduce, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2711">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="a0362-2712">Todos los datos escritos en el archivo mediante el uso de `Print` son internacionales; es decir, los datos tiene el formato correcto con el separador decimal adecuado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2712">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="a0362-2713">Si el usuario desea generar datos para su uso en varias configuraciones regionales, `Write` debe usarse.</span><span class="sxs-lookup"><span data-stu-id="a0362-2713">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="a0362-2714">Escribir en un archivo mediante el uso de la `Print` o `PrintLine` functions requiere `Write` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2714">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2715">Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2715">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2716">Este ejemplo se usa el `Print` y `PrintLine` funciones para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2716">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2717">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2717">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2718">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2718">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2719">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2719">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PrintLine">
      <MemberSignature Language="C#" Value="public static void PrintLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void PrintLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub PrintLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PrintLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member PrintLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.PrintLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2720">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2720">Required.</span></span> <span data-ttu-id="a0362-2721">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2721">Any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a0362-2722">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2722">Optional.</span></span> <span data-ttu-id="a0362-2723">Cero o más expresiones delimitadas por comas para escribir en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2723">Zero or more comma-delimited expressions to write to a file.</span></span>  
  
<span data-ttu-id="a0362-2724">La configuración del argumento <paramref name="Output" /> es:</span><span class="sxs-lookup"><span data-stu-id="a0362-2724">The <paramref name="Output" /> argument settings are:</span></span> 
 <span data-ttu-id="a0362-2725"><see langword="T:System.IO.IOException" />: El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2725"><see langword="T:System.IO.IOException" />: File mode is invalid.</span></span>  
  
 <span data-ttu-id="a0362-2726"><see langword="T:System.IO.IOException" />:<paramref name="FileNumber" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2726"><see langword="T:System.IO.IOException" />: <paramref name="FileNumber" /> does not exist.</span></span></param>
        <summary><span data-ttu-id="a0362-2727">Escribe los datos con formato de presentación en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-2727">Writes display-formatted data to a sequential file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2728">El `Print` y `PrintLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2728">The `Print` and `PrintLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2729">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2729">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2730">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2730">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2731">`Print` no incluye una avance de línea al final de una línea; Sin embargo,`PrintLine` incluyen un avance de línea.</span><span class="sxs-lookup"><span data-stu-id="a0362-2731">`Print` does not include a line feed at the end of a line; however,`PrintLine` does include a line feed.</span></span>  
  
 <span data-ttu-id="a0362-2732">Los datos escritos con `Print` normalmente se leen desde un archivo mediante el uso de `LineInput` o `Input`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2732">Data written with `Print` is usually read from a file by using `LineInput` or `Input`.</span></span>  
  
 <span data-ttu-id="a0362-2733">Si se omite `Output` para `PrintLine`, se imprime una línea en blanco en el archivo; para `Print`, nada es de salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2733">If you omit `Output` for `PrintLine`, a blank line is printed to the file; for `Print`, nothing is output.</span></span> <span data-ttu-id="a0362-2734">Varias expresiones separadas por comas se alineará en los límites de tabulación, pero la combinación de comas y `TAB` puede causar resultados incoherentes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2734">Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and `TAB` may cause inconsistent results.</span></span>  
  
 <span data-ttu-id="a0362-2735">Para `Boolean` datos, ya sea `True` o `False` se imprime.</span><span class="sxs-lookup"><span data-stu-id="a0362-2735">For `Boolean` data, either `True` or `False` is printed.</span></span> <span data-ttu-id="a0362-2736">El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2736">The `True` and `False` keywords are not translated, regardless of the locale.</span></span>  
  
 <span data-ttu-id="a0362-2737">Los datos de fecha se escriben en el archivo con el formato de fecha corta estándar reconocido por el sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-2737">Date data is written to the file by using the standard short date format recognized by the system.</span></span> <span data-ttu-id="a0362-2738">Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2738">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
 <span data-ttu-id="a0362-2739">Si se escribirá nada en el archivo `Output` datos están vacíos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2739">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a0362-2740">Sin embargo, si `Output` datos de la lista están `DBNull`, `Null` se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2740">However, if `Output` list data is `DBNull`, `Null` is written to the file.</span></span>  
  
 <span data-ttu-id="a0362-2741">Para `Error` la salida de datos, aparece como `Error errorcode`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2741">For `Error` data, the output appears as `Error errorcode`.</span></span> <span data-ttu-id="a0362-2742">El `Error` palabra clave no se traduce, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2742">The `Error` keyword is not translated regardless of the locale.</span></span>  
  
 <span data-ttu-id="a0362-2743">Todos los datos escritos en el archivo mediante el uso de `Print` son internacionales; es decir, los datos tiene el formato correcto con el separador decimal adecuado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2743">All data written to the file by using `Print` is internationally aware; that is, the data is correctly formatted using the appropriate decimal separator.</span></span> <span data-ttu-id="a0362-2744">Si el usuario desea generar datos para su uso en varias configuraciones regionales, `Write` debe usarse.</span><span class="sxs-lookup"><span data-stu-id="a0362-2744">If the user wishes to output data for use by multiple locales, `Write` should be used.</span></span>  
  
 <span data-ttu-id="a0362-2745">Escribir en un archivo mediante el uso de la `Print` o `PrintLine` functions requiere `Write` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-2745">Writing to a file by using the `Print` or `PrintLine` functions requires `Write` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-2746">Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2746">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2747">Este ejemplo se usa el `Print` y `PrintLine` funciones para escribir datos en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2747">This example uses the `Print` and `PrintLine` functions to write data to a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#53](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#53)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2748">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2748">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-2749">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2749">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-2750">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2750">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Rename">
      <MemberSignature Language="C#" Value="public static void Rename (string OldPath, string NewPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Rename(string OldPath, string NewPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Rename(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Rename (OldPath As String, NewPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Rename(System::String ^ OldPath, System::String ^ NewPath);" />
      <MemberSignature Language="F#" Value="static member Rename : string * string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Rename (OldPath, NewPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="OldPath" Type="System.String" />
        <Parameter Name="NewPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="OldPath"><span data-ttu-id="a0362-2751">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2751">Required.</span></span> <span data-ttu-id="a0362-2752">Expresión de cadena que especifica el nombre y la ubicación de archivo existentes.</span><span class="sxs-lookup"><span data-stu-id="a0362-2752">A string expression that specifies the existing file name and location.</span></span> <span data-ttu-id="a0362-2753"><paramref name="OldPath" /> puede incluir el directorio y la unidad del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2753"><paramref name="OldPath" /> may include the directory, and drive, of the file.</span></span></param>
        <param name="NewPath"><span data-ttu-id="a0362-2754">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2754">Required.</span></span> <span data-ttu-id="a0362-2755">Expresión de cadena que especifica el nombre y la ubicación de archivo nuevos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2755">A string expression that specifies the new file name and location.</span></span> <span data-ttu-id="a0362-2756"><paramref name="NewPath" /> puede incluir el directorio y la unidad de la ubicación de destino.</span><span class="sxs-lookup"><span data-stu-id="a0362-2756"><paramref name="NewPath" /> may include directory and drive of the destination location.</span></span> <span data-ttu-id="a0362-2757">El nombre de archivo especificado por <paramref name="NewPath" /> no puede existir.</span><span class="sxs-lookup"><span data-stu-id="a0362-2757">The file name specified by <paramref name="NewPath" /> cannot already exist.</span></span></param>
        <summary><span data-ttu-id="a0362-2758">Cambia el nombre de un archivo o directorio ubicado en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2758">Renames a disk file or directory.</span></span> <span data-ttu-id="a0362-2759">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Rename" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2759">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Rename" />.</span></span> <span data-ttu-id="a0362-2760">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2760">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2761">El`Rename` función cambia el nombre de un archivo y lo mueve a un directorio diferente, si es necesario.</span><span class="sxs-lookup"><span data-stu-id="a0362-2761">The`Rename` function renames a file and moves it to a different directory, if it is required.</span></span> <span data-ttu-id="a0362-2762">El `Rename` función puede mover un archivo a través de unidades, pero solo puede cambiar el nombre un directorio existente cuando ambos `NewPath` y `OldPath` se encuentran en la misma unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2762">The `Rename` function can move a file across drives, but it can only rename an existing directory when both `NewPath` and `OldPath` are located on the same drive.</span></span> <span data-ttu-id="a0362-2763">`Rename` no se puede crear un nuevo archivo o directorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2763">`Rename` cannot create a new file or directory.</span></span>  
  
 <span data-ttu-id="a0362-2764">Mediante el `Rename` función en un archivo abierto genera un error.</span><span class="sxs-lookup"><span data-stu-id="a0362-2764">Using the `Rename` function on an open file produces an error.</span></span> <span data-ttu-id="a0362-2765">Debe cerrar un archivo abierto antes de cambiarle el nombre.</span><span class="sxs-lookup"><span data-stu-id="a0362-2765">You must close an open file before renaming it.</span></span> <span data-ttu-id="a0362-2766">`Rename` argumentos no pueden incluir varios caracteres (\*) y comodines de carácter único (?).</span><span class="sxs-lookup"><span data-stu-id="a0362-2766">`Rename` arguments cannot include multiple-character (\*) and single-character (?) wildcards.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="a0362-2767">Cuando se usa `Rename` para copiar un archivo desde una ubicación no protegida en una ubicación protegida, el archivo conserva los derechos menos restringidos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2767">When using `Rename` to copy a file from an unprotected location to a protected location, the file retains the less restricted rights.</span></span> <span data-ttu-id="a0362-2768">Compruebe para asegurarse de que no presentan un posible riesgo de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2768">Check to make sure that you are not introducing a possible security risk.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2769">Este ejemplo se usa el `Rename` función para cambiar el nombre de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2769">This example uses the `Rename` function to rename a file.</span></span> <span data-ttu-id="a0362-2770">Para fines de este ejemplo, suponga que los directorios especificados ya existen.</span><span class="sxs-lookup"><span data-stu-id="a0362-2770">For purposes of this example, assume that the directories that are specified already exist.</span></span>  
  
 [!code-vb[VbVbalrCatRef#30](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#30)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2771">La ruta de acceso no es válida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2771">Path is invalid.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-2772">El archivo <paramref name="OldPath" /> no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2772"><paramref name="OldPath" /> file does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2773">No se puede cambiar el nombre en un dispositivo diferente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2773">Cannot rename to different device.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-rename-a-file.md"><span data-ttu-id="a0362-2774">Cómo: Cambiar el nombre de un archivo en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2774">How to: Rename a File in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public static void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public static void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Reset();" />
      <MemberSignature Language="F#" Value="static member Reset : unit -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Reset " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0362-2775">Cierra todos los archivos ubicados en el disco que se han abierto mediante la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2775">Closes all disk files opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2776">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Reset" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2776">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Reset" />.</span></span> <span data-ttu-id="a0362-2777">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2777">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2778">El `Reset` función cierra todos los archivos activos abiertos por el `FileOpen` de función y tiene la misma función que `FileClose()` sin ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="a0362-2778">The `Reset` function closes all active files opened by the `FileOpen` function and has the same function as `FileClose()` without any parameters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2779">Este ejemplo se usa el `Reset` función para cerrar todos los archivos abiertos y escribir el contenido de todos los búferes de archivo en el disco.</span><span class="sxs-lookup"><span data-stu-id="a0362-2779">This example uses the `Reset` function to close all open files and write the contents of all file buffers to disk.</span></span> <span data-ttu-id="a0362-2780">Tenga en cuenta el uso de la `Object` variable `FileNumber` como una cadena y un número.</span><span class="sxs-lookup"><span data-stu-id="a0362-2780">Note the use of the `Object` variable `FileNumber` as both a string and a number.</span></span>  
  
 [!code-vb[VbVbalrCatRef#12](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#12)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileClose(System.Int32[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/statements/end-statement.md"><span data-ttu-id="a0362-2781">End (Instrucción)</span><span class="sxs-lookup"><span data-stu-id="a0362-2781">End Statement</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RmDir">
      <MemberSignature Language="C#" Value="public static void RmDir (string Path);" />
      <MemberSignature Language="ILAsm" Value=".method public static void RmDir(string Path) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.RmDir(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RmDir (Path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RmDir(System::String ^ Path);" />
      <MemberSignature Language="F#" Value="static member RmDir : string -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.RmDir Path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="Path"><span data-ttu-id="a0362-2782">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2782">Required.</span></span> <span data-ttu-id="a0362-2783">Expresión de cadena que identifica el directorio o la carpeta que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="a0362-2783">A string expression that identifies the directory or folder to be removed.</span></span> <span data-ttu-id="a0362-2784"><paramref name="Path" /> puede incluir la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2784"><paramref name="Path" /> can include the drive.</span></span> <span data-ttu-id="a0362-2785">Si no hay ninguna unidad especificada, <see langword="RmDir" /> quita el directorio de la unidad actual.</span><span class="sxs-lookup"><span data-stu-id="a0362-2785">If no drive is specified, <see langword="RmDir" /> removes the directory on the current drive.</span></span></param>
        <summary><span data-ttu-id="a0362-2786">Quita un directorio existente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2786">Removes an existing directory.</span></span> <span data-ttu-id="a0362-2787">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="RmDir" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2787">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="RmDir" />.</span></span> <span data-ttu-id="a0362-2788">Para obtener más información, vea <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2788">For more information, see <see cref="Overload:Microsoft.VisualBasic.FileIO.FileSystem.DeleteDirectory" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2789">Se produce un error si intenta usar `RmDir` en un directorio que contiene los archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2789">An error occurs if you try to use `RmDir` on a directory that contains files.</span></span> <span data-ttu-id="a0362-2790">Use el `Kill` función para eliminar todos los archivos antes de intentar quitar un directorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2790">Use the `Kill` function to delete all files before you try to remove a directory.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2791">Este ejemplo se usa el `RmDir` function para quitar un directorio existente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2791">This example uses the `RmDir` function to remove an existing directory.</span></span>  
  
 [!code-vb[VbVbalrCatRef#31](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#31)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2792"><paramref name="Path" /> no se ha especificado o está vacío.</span><span class="sxs-lookup"><span data-stu-id="a0362-2792"><paramref name="Path" /> is not specified or is empty.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2793">El directorio de destino contiene archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2793">Target directory contains files.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a0362-2794">El directorio no existe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2794">Directory does not exist.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.ChDir(System.String)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.CurDir" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Kill(System.String)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.MkDir(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:System.IO.IOException" />
        <altmember cref="T:System.IO.FileNotFoundException" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-2795">Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2795">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2796">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2796">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a0362-2797">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2797">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static long Seek (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static int64 Seek(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Seek (FileNumber As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long Seek(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Seek : int -&gt; int64" Usage="Microsoft.VisualBasic.FileSystem.Seek FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2798">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2798">Required.</span></span> <span data-ttu-id="a0362-2799"><see langword="Integer" /> que contiene un número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2799">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2800">Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2800">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2801">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2801">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a0362-2802">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2802">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <returns><span data-ttu-id="a0362-2803">Valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2803">A <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2804">`Seek` Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 - 1), ambos inclusive.</span><span class="sxs-lookup"><span data-stu-id="a0362-2804">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 - 1), inclusive.</span></span>  
  
 <span data-ttu-id="a0362-2805">El siguiente describe los valores devueltos para cada modo de acceso de archivo:</span><span class="sxs-lookup"><span data-stu-id="a0362-2805">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="a0362-2806">Modo</span><span class="sxs-lookup"><span data-stu-id="a0362-2806">Mode</span></span>|<span data-ttu-id="a0362-2807">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="a0362-2807">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a0362-2808">Número del siguiente registro leídos o escritos</span><span class="sxs-lookup"><span data-stu-id="a0362-2808">Number of the next record read or written</span></span>|  
|<span data-ttu-id="a0362-2809">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="a0362-2809">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="a0362-2810">Posición del byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2810">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2811">Es el primer byte de un archivo en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2811">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2812">Este ejemplo se usa el `Seek` función para devolver la posición actual del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2812">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="a0362-2813">En el ejemplo se da por supuesto `TestFile` es un archivo que contiene registros de la estructura `Record`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2813">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="a0362-2814">De los archivos abiertos en `Random` modo, `Seek` devuelve el número de registro siguiente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2814">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="a0362-2815">Para los archivos abiertos en modos distintos de `Random` modo, `Seek` devuelve la posición de byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2815">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2816">Suponga `TestFile` es un archivo que contiene varias líneas de texto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2816">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="a0362-2817">Este ejemplo se usa el `Seek` función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2817">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="a0362-2818">Para los archivos abiertos en modos distintos de `Random` modo, `Seek` establece la posición de byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2818">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2819">Suponga `TestFile` es un archivo que contiene varias líneas de texto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2819">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2820">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2820">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-2821">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2821">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2822">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2822">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public static void Seek (int FileNumber, long Position);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Seek(int32 FileNumber, int64 Position) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Seek(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (FileNumber As Integer, Position As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Seek(int FileNumber, long Position);" />
      <MemberSignature Language="F#" Value="static member Seek : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Seek (FileNumber, Position)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Position" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2823">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2823">Required.</span></span> <span data-ttu-id="a0362-2824"><see langword="Integer" /> que contiene un número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2824">An <see langword="Integer" /> that contains a valid file number.</span></span></param>
        <param name="Position"><span data-ttu-id="a0362-2825">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2825">Required.</span></span> <span data-ttu-id="a0362-2826">Número del 1 al 2.147.483.647, incluido, que indica dónde debe llevarse a cabo la siguiente operación de lectura o escritura.</span><span class="sxs-lookup"><span data-stu-id="a0362-2826">Number in the range 1-2,147,483,647, inclusive, that indicates where the next read/write operation should occur.</span></span></param>
        <summary><span data-ttu-id="a0362-2827">Devuelve un valor <see langword="Long" /> que especifica la posición actual de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" /> o bien establece la posición de la siguiente operación de lectura o escritura en un archivo abierto con la función <see langword="FileOpen" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2827">Returns a <see langword="Long" /> specifying the current read/write position in a file opened by using the <see langword="FileOpen" /> function, or sets the position for the next read/write operation in a file opened by using the <see langword="FileOpen" /> function.</span></span> <span data-ttu-id="a0362-2828">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="Seek" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2828">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Seek" />.</span></span> <span data-ttu-id="a0362-2829">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2829">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2830">`Seek` Devuelve un valor entre 1 y 2.147.483.647 (equivalente a 2 ^ 31 - 1), ambos inclusive.</span><span class="sxs-lookup"><span data-stu-id="a0362-2830">`Seek` returns a value between 1 and 2,147,483,647 (equivalent to 2^31 - 1), inclusive.</span></span>  
  
 <span data-ttu-id="a0362-2831">El siguiente describe los valores devueltos para cada modo de acceso de archivo:</span><span class="sxs-lookup"><span data-stu-id="a0362-2831">The following describes the return values for each file access mode:</span></span>  
  
|<span data-ttu-id="a0362-2832">Modo</span><span class="sxs-lookup"><span data-stu-id="a0362-2832">Mode</span></span>|<span data-ttu-id="a0362-2833">Valor devuelto</span><span class="sxs-lookup"><span data-stu-id="a0362-2833">Return Value</span></span>|  
|-|-|  
|`Random`|<span data-ttu-id="a0362-2834">Número del siguiente registro leídos o escritos</span><span class="sxs-lookup"><span data-stu-id="a0362-2834">Number of the next record read or written</span></span>|  
|<span data-ttu-id="a0362-2835">`Binary`, `Input`, `Output`, `Append`</span><span class="sxs-lookup"><span data-stu-id="a0362-2835">`Binary`, `Input`, `Output`, `Append`</span></span>|<span data-ttu-id="a0362-2836">Posición del byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2836">Byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2837">Es el primer byte de un archivo en la posición 1, el segundo byte está en la posición 2 y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2837">The first byte in a file is at position 1, the second byte is at position 2, and so on.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2838">Este ejemplo se usa el `Seek` función para devolver la posición actual del archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2838">This example uses the `Seek` function to return the current file position.</span></span> <span data-ttu-id="a0362-2839">En el ejemplo se da por supuesto `TestFile` es un archivo que contiene registros de la estructura `Record`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2839">The example assumes `TestFile` is a file that contains records of the structure `Record`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#47](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#47)]  
  
 <span data-ttu-id="a0362-2840">De los archivos abiertos en `Random` modo, `Seek` devuelve el número de registro siguiente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2840">For files opened in `Random` mode, `Seek` returns the number of next record.</span></span>  
  
 [!code-vb[VbVbalrCatRef#48](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#48)]  
  
 <span data-ttu-id="a0362-2841">Para los archivos abiertos en modos distintos de `Random` modo, `Seek` devuelve la posición de byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2841">For files opened in modes other than `Random` mode, `Seek` returns the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2842">Suponga `TestFile` es un archivo que contiene varias líneas de texto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2842">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#49](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#49)]  
  
 <span data-ttu-id="a0362-2843">Este ejemplo se usa el `Seek` función para establecer la posición de la siguiente operación de lectura o escritura en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2843">This example uses the `Seek` function to set the position for the next read or write in a file.</span></span>  
  
 <span data-ttu-id="a0362-2844">Para los archivos abiertos en modos distintos de `Random` modo, `Seek` establece la posición de byte en el que se produce la siguiente operación.</span><span class="sxs-lookup"><span data-stu-id="a0362-2844">For files opened in modes other than `Random` mode, `Seek` sets the byte position at which the next operation occurs.</span></span> <span data-ttu-id="a0362-2845">Suponga `TestFile` es un archivo que contiene varias líneas de texto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2845">Assume `TestFile` is a file that contains several lines of text.</span></span>  
  
 [!code-vb[VbVbalrCatRef#52](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#52)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2846">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2846">File mode is invalid.</span></span></exception>
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FileGet" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Loc(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.FilePut" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/reading-from-files.md"><span data-ttu-id="a0362-2847">Leer archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2847">Reading from Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/writing-to-files.md"><span data-ttu-id="a0362-2848">Escribir en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2848">Writing to Files in Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAttr">
      <MemberSignature Language="C#" Value="public static void SetAttr (string PathName, Microsoft.VisualBasic.FileAttribute Attributes);" />
      <MemberSignature Language="ILAsm" Value=".method public static void SetAttr(string PathName, valuetype Microsoft.VisualBasic.FileAttribute Attributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SetAttr(System.String,Microsoft.VisualBasic.FileAttribute)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAttr (PathName As String, Attributes As FileAttribute)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetAttr(System::String ^ PathName, Microsoft::VisualBasic::FileAttribute Attributes);" />
      <MemberSignature Language="F#" Value="static member SetAttr : string * Microsoft.VisualBasic.FileAttribute -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.SetAttr (PathName, Attributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="PathName" Type="System.String" />
        <Parameter Name="Attributes" Type="Microsoft.VisualBasic.FileAttribute" />
      </Parameters>
      <Docs>
        <param name="PathName"><span data-ttu-id="a0362-2849">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2849">Required.</span></span> <span data-ttu-id="a0362-2850">Expresión de cadena que especifica un nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2850">A string expression that specifies a file name.</span></span> <span data-ttu-id="a0362-2851"><paramref name="PathName" /> puede incluir el directorio o la carpeta y la unidad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2851"><paramref name="PathName" /> can include directory or folder, and drive.</span></span></param>
        <param name="Attributes"><span data-ttu-id="a0362-2852">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2852">Required.</span></span> <span data-ttu-id="a0362-2853">Constante o expresión numérica, cuya suma especifica los atributos de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2853">Constant or numeric expression, whose sum specifies file attributes.</span></span></param>
        <summary><span data-ttu-id="a0362-2854">Establece la información de atributos de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2854">Sets attribute information for a file.</span></span> <span data-ttu-id="a0362-2855">La característica <see langword="My" /> proporciona una mayor productividad y rendimiento en las operaciones de E/S de archivo que <see langword="SetAttr" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2855">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="SetAttr" />.</span></span> <span data-ttu-id="a0362-2856">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2856">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2857">Se produce un error de tiempo de ejecución si se intenta establecer los atributos de un archivo abierto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2857">A run-time error occurs if you try to set the attributes of an open file.</span></span>  
  
 <span data-ttu-id="a0362-2858">El `Attributes` valores de enumeración del argumento son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="a0362-2858">The `Attributes` argument enumeration values are as follows:</span></span>  
  
|<span data-ttu-id="a0362-2859">Valor</span><span class="sxs-lookup"><span data-stu-id="a0362-2859">Value</span></span>|<span data-ttu-id="a0362-2860">Constante</span><span class="sxs-lookup"><span data-stu-id="a0362-2860">Constant</span></span>|<span data-ttu-id="a0362-2861">Descripción</span><span class="sxs-lookup"><span data-stu-id="a0362-2861">Description</span></span>|  
|-|-|-|  
|`Normal`|`vbNormal`|<span data-ttu-id="a0362-2862">Normal (predeterminado).</span><span class="sxs-lookup"><span data-stu-id="a0362-2862">Normal (default).</span></span>|  
|`ReadOnly`|`vbReadOnly`|<span data-ttu-id="a0362-2863">Sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="a0362-2863">Read-only.</span></span>|  
|`Hidden`|`vbHidden`|<span data-ttu-id="a0362-2864">Oculto.</span><span class="sxs-lookup"><span data-stu-id="a0362-2864">Hidden.</span></span>|  
|`System`|`vbSystem`|<span data-ttu-id="a0362-2865">Archivo de sistema.</span><span class="sxs-lookup"><span data-stu-id="a0362-2865">System file.</span></span>|  
|`Volume`|`vbVolume`|<span data-ttu-id="a0362-2866">Etiqueta de volumen</span><span class="sxs-lookup"><span data-stu-id="a0362-2866">Volume label</span></span>|  
|`Directory`|`vbDirectory`|<span data-ttu-id="a0362-2867">Directorio o carpeta.</span><span class="sxs-lookup"><span data-stu-id="a0362-2867">Directory or folder.</span></span>|  
|`Archive`|`vbArchive`|<span data-ttu-id="a0362-2868">El archivo ha cambiado desde que se realizó la última copia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a0362-2868">File has changed since last backup.</span></span>|  
|`Alias`|`vbAlias`|<span data-ttu-id="a0362-2869">El archivo tiene un nombre diferente.</span><span class="sxs-lookup"><span data-stu-id="a0362-2869">File has a different name.</span></span>|  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2870">El lenguaje de Visual Basic especifica estas enumeraciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2870">These enumerations are specified by the Visual Basic language.</span></span> <span data-ttu-id="a0362-2871">Los nombres se pueden usar en cualquier parte del código en lugar de los valores reales.</span><span class="sxs-lookup"><span data-stu-id="a0362-2871">The names can be used anywhere in your code instead of the actual values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2872">Este ejemplo se usa el `SetAttr` función para establecer los atributos de un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2872">This example uses the `SetAttr` function to set attributes for a file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#14](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#14)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a0362-2873">El tipo de <paramref name="Attribute" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2873"><paramref name="Attribute" /> type is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileAttr(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.GetAttr(System.String)" />
        <altmember cref="T:System.ArgumentException" />
        <altmember cref="T:Microsoft.VisualBasic.FileAttribute" />
        <altmember cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />
      </Docs>
    </Member>
    <Member MemberName="SPC">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.SpcInfo SPC (short Count);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.SpcInfo SPC(int16 Count) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function SPC (Count As Short) As SpcInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::SpcInfo SPC(short Count);" />
      <MemberSignature Language="F#" Value="static member SPC : int16 -&gt; Microsoft.VisualBasic.SpcInfo" Usage="Microsoft.VisualBasic.FileSystem.SPC Count" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.SpcInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Count" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Count"><span data-ttu-id="a0362-2874">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2874">Required.</span></span> <span data-ttu-id="a0362-2875">Número de espacios que se van a insertar antes de mostrar o imprimir la siguiente expresión en una lista.</span><span class="sxs-lookup"><span data-stu-id="a0362-2875">The number of spaces to insert before displaying or printing the next expression in a list.</span></span></param>
        <summary><span data-ttu-id="a0362-2876">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar la salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2876">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></summary>
        <returns><span data-ttu-id="a0362-2877">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar la salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2877">Used with the <see langword="Print" /> or <see langword="PrintLine" /> function to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2878">Si `Count` es menor que el ancho de línea de salida, la siguiente posición de impresión inmediatamente sigue el número de espacios impresos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2878">If `Count` is less than the output line width, the next print position immediately follows the number of spaces printed.</span></span> <span data-ttu-id="a0362-2879">Si`Count` es mayor que el ancho de línea de salida, `SPC` calcula la siguiente posición de impresión mediante la fórmula:</span><span class="sxs-lookup"><span data-stu-id="a0362-2879">If`Count` is greater than the output line width, `SPC` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a0362-2880">`currentprintposition`(+(`Count``Mod``width`))</span><span class="sxs-lookup"><span data-stu-id="a0362-2880">`currentprintposition`(+(`Count``Mod``width`))</span></span>  
  
 <span data-ttu-id="a0362-2881">Por ejemplo, si la posición de impresión actual es 24, el ancho de línea de salida es 80 y se especifica `SPC(90)`, la próxima impresión comenzará en la posición 34 (posición de impresión actual + el resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a0362-2881">For example, if the current print position is 24, the output line width is 80, and you specify `SPC(90)`, the next print will start at position 34 (current print position + the remainder of 90/80).</span></span> <span data-ttu-id="a0362-2882">Si la diferencia entre la actual posición de impresión y el ancho de línea de salida es menor que `Count` (o `Count` `Mod` *ancho*), el `SPC` función salta al principio de la línea siguiente y genera espacios que equivalen a `Count` -(*ancho* - *posiciónDeImpresiónActual*).</span><span class="sxs-lookup"><span data-stu-id="a0362-2882">If the difference between the current print position and the output line width is less than `Count` (or `Count` `Mod` *width*), the `SPC` function skips to the start of the next line and generates spaces equal to `Count` - (*width* - *currentprintposition*).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2883">Asegúrese de que las columnas tabulares sean lo suficientemente ancha para permitir letras anchas.</span><span class="sxs-lookup"><span data-stu-id="a0362-2883">Make sure your tabular columns are wide enough to allow for wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2884">Este ejemplo se usa el `SPC` para colocar el resultado en un archivo y, en función de la **salida** ventana.</span><span class="sxs-lookup"><span data-stu-id="a0362-2884">This example uses the `SPC` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#16](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.TAB" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a0362-2885">Mod (Operador, Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2885">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TAB">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-2886">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2886">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB ();" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB() cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB () As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB();" />
      <MemberSignature Language="F#" Value="static member TAB : unit -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a0362-2887">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2887">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="a0362-2888">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2888">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2889">Si es mayor que la actual posición de impresión en la línea actual `Column`, `TAB` salta al igual que el valor de la columna `Column` en la siguiente línea de salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2889">If the current print position on the current line is larger than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="a0362-2890">Si `Column` es menor que 1, `TAB` mueve la posición de impresión a la columna 1.</span><span class="sxs-lookup"><span data-stu-id="a0362-2890">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="a0362-2891">Si `Column` es mayor que el ancho de línea de salida, `TAB` calcula la siguiente posición de impresión mediante la fórmula:</span><span class="sxs-lookup"><span data-stu-id="a0362-2891">If `Column` is larger than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a0362-2892">Mod ancho de columna</span><span class="sxs-lookup"><span data-stu-id="a0362-2892">Column Mod width</span></span>  
  
 <span data-ttu-id="a0362-2893">Por ejemplo, si *ancho* es 80 y se especifica `TAB(90)`, se iniciará la próxima impresión en la columna 10 (el resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a0362-2893">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="a0362-2894">Si `Column` es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2894">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="a0362-2895">Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comienza en la posición de impresión en la misma línea.</span><span class="sxs-lookup"><span data-stu-id="a0362-2895">If the calculated print position is larger than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="a0362-2896">La posición de impresión más a la izquierda en una línea de salida es siempre 1.</span><span class="sxs-lookup"><span data-stu-id="a0362-2896">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="a0362-2897">Cuando se usa el `Print` o `PrintLine` funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el `FileWidth` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-2897">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="a0362-2898">El `TAB` función también se puede usar con el `WriteLine` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-2898">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="a0362-2899">No se puede usar con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2899">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2900">Asegúrese de que las columnas tabulares sean lo suficientemente amplio para contener letras anchas.</span><span class="sxs-lookup"><span data-stu-id="a0362-2900">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2901">Este ejemplo se usa el `TAB` para colocar el resultado en un archivo y, en función de la **salida** ventana.</span><span class="sxs-lookup"><span data-stu-id="a0362-2901">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a0362-2902">Mod (Operador, Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2902">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TAB">
      <MemberSignature Language="C#" Value="public static Microsoft.VisualBasic.TabInfo TAB (short Column);" />
      <MemberSignature Language="ILAsm" Value=".method public static valuetype Microsoft.VisualBasic.TabInfo TAB(int16 Column) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.TAB(System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Function TAB (Column As Short) As TabInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Microsoft::VisualBasic::TabInfo TAB(short Column);" />
      <MemberSignature Language="F#" Value="static member TAB : int16 -&gt; Microsoft.VisualBasic.TabInfo" Usage="Microsoft.VisualBasic.FileSystem.TAB Column" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>Microsoft.VisualBasic.TabInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="Column" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="Column"><span data-ttu-id="a0362-2903">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2903">Optional.</span></span> <span data-ttu-id="a0362-2904">Número de columna a la que se realiza el desplazamiento antes de mostrar o imprimir la siguiente expresión en una lista.</span><span class="sxs-lookup"><span data-stu-id="a0362-2904">The column number moved to before displaying or printing the next expression in a list.</span></span> <span data-ttu-id="a0362-2905">Si se omite, <see langword="TAB" /> mueve el punto de inserción al principio de la siguiente zona de impresión.</span><span class="sxs-lookup"><span data-stu-id="a0362-2905">If omitted, <see langword="TAB" /> moves the insertion point to the start of the next print zone.</span></span></param>
        <summary><span data-ttu-id="a0362-2906">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2906">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></summary>
        <returns><span data-ttu-id="a0362-2907">Se utiliza con la función <see langword="Print" /> o <see langword="PrintLine" /> para colocar el resultado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2907">Used with the <see langword="Print" /> or <see langword="PrintLine" /> functions to position output.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2908">Si es mayor que la actual posición de impresión en la línea actual `Column`, `TAB` salta al igual que el valor de la columna `Column` en la siguiente línea de salida.</span><span class="sxs-lookup"><span data-stu-id="a0362-2908">If the current print position on the current line is greater than `Column`, `TAB` skips to the column value equal to `Column` on the next output line.</span></span> <span data-ttu-id="a0362-2909">Si `Column` es menor que 1, `TAB` mueve la posición de impresión a la columna 1.</span><span class="sxs-lookup"><span data-stu-id="a0362-2909">If `Column` is less than 1, `TAB` moves the print position to column 1.</span></span> <span data-ttu-id="a0362-2910">Si `Column` es mayor que el ancho de línea de salida, `TAB` calcula la siguiente posición de impresión mediante la fórmula:</span><span class="sxs-lookup"><span data-stu-id="a0362-2910">If `Column` is greater than the output line width, `TAB` calculates the next print position using the formula:</span></span>  
  
 <span data-ttu-id="a0362-2911">Mod ancho de columna</span><span class="sxs-lookup"><span data-stu-id="a0362-2911">Column Mod width</span></span>  
  
 <span data-ttu-id="a0362-2912">Por ejemplo, si *ancho* es 80 y se especifica `TAB(90)`, se iniciará la próxima impresión en la columna 10 (el resto de 90/80).</span><span class="sxs-lookup"><span data-stu-id="a0362-2912">For example, if *width* is 80 and you specify `TAB(90)`, the next print will start at column 10 (the remainder of 90/80).</span></span> <span data-ttu-id="a0362-2913">Si `Column` es menor que la actual posición de impresión, impresión se inicia en la siguiente línea en la posición de impresión calculada.</span><span class="sxs-lookup"><span data-stu-id="a0362-2913">If `Column` is less than the current print position, printing starts on the next line at the calculated print position.</span></span> <span data-ttu-id="a0362-2914">Si la posición de impresión calculada es mayor que la actual posición de impresión, impresión comienza en la posición de impresión en la misma línea.</span><span class="sxs-lookup"><span data-stu-id="a0362-2914">If the calculated print position is greater than the current print position, printing starts at the calculated print position on the same line.</span></span>  
  
 <span data-ttu-id="a0362-2915">La posición de impresión más a la izquierda en una línea de salida es siempre 1.</span><span class="sxs-lookup"><span data-stu-id="a0362-2915">The leftmost print position on an output line is always 1.</span></span> <span data-ttu-id="a0362-2916">Cuando se usa el `Print` o `PrintLine` funciones para imprimir en archivos, la posición de impresión más a la derecha es el ancho actual del archivo de salida, que puede establecer mediante el `FileWidth` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-2916">When you use the `Print` or `PrintLine` functions to print to files, the rightmost print position is the current width of the output file, which you can set using the `FileWidth` function.</span></span>  
  
 <span data-ttu-id="a0362-2917">El `TAB` función también se puede usar con el `WriteLine` función.</span><span class="sxs-lookup"><span data-stu-id="a0362-2917">The `TAB` function can also be used with the `WriteLine` function.</span></span> <span data-ttu-id="a0362-2918">No se puede usar con <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> o <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a0362-2918">It cannot be used with <xref:System.Diagnostics.Debug.WriteLine%2A?displayProperty=nameWithType> or <xref:System.Console.WriteLine%2A?displayProperty=nameWithType>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="a0362-2919">Asegúrese de que las columnas tabulares sean lo suficientemente amplio para contener letras anchas.</span><span class="sxs-lookup"><span data-stu-id="a0362-2919">Make sure your tabular columns are wide enough to contain wide letters.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2920">Este ejemplo se usa el `TAB` para colocar el resultado en un archivo y, en función de la **salida** ventana.</span><span class="sxs-lookup"><span data-stu-id="a0362-2920">This example uses the `TAB` function to position output in a file and in the **Output** window.</span></span>  
  
 [!code-vb[VbVbalrCatRef#37](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#37)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.Strings.Space(System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.SPC(System.Int16)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileWidth(System.Int32,System.Int32)" />
        <related type="Article" href="~/docs/visual-basic/language-reference/operators/mod-operator.md"><span data-ttu-id="a0362-2921">Mod (Operador, Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-2921">Mod Operator (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Unlock">
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="a0362-2922">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2922">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2923">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2923">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2924">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2924">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber);" />
      <MemberSignature Language="F#" Value="static member Unlock : int -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock FileNumber" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2925">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2925">Required.</span></span> <span data-ttu-id="a0362-2926">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2926">Any valid file number.</span></span></param>
        <summary><span data-ttu-id="a0362-2927">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2927">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2928">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2928">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2929">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2929">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2930">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2930">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2931">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2931">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2932">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2932">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2933">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2933">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2934">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2934">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2935">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2935">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2936">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2936">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2937">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2937">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2938">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2938">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2939">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2939">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long Record);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 Record) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, Record As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long Record);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, Record)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Record" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2940">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2940">Required.</span></span> <span data-ttu-id="a0362-2941">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2941">Any valid file number.</span></span></param>
        <param name="Record"><span data-ttu-id="a0362-2942">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2942">Optional.</span></span> <span data-ttu-id="a0362-2943">Número del único registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2943">Number of the only record or byte to lock or unlock</span></span></param>
        <summary><span data-ttu-id="a0362-2944">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2944">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2945">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2945">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2946">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2946">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2947">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2947">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2948">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2948">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2949">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2949">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2950">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2950">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2951">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2951">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2952">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2952">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2953">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2953">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2954">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2954">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2955">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2955">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2956">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2956">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Unlock">
      <MemberSignature Language="C#" Value="public static void Unlock (int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Unlock(int32 FileNumber, int64 FromRecord, int64 ToRecord) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Unlock(System.Int32,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unlock (FileNumber As Integer, FromRecord As Long, ToRecord As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unlock(int FileNumber, long FromRecord, long ToRecord);" />
      <MemberSignature Language="F#" Value="static member Unlock : int * int64 * int64 -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Unlock (FileNumber, FromRecord, ToRecord)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="FromRecord" Type="System.Int64" />
        <Parameter Name="ToRecord" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2957">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2957">Required.</span></span> <span data-ttu-id="a0362-2958">Cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2958">Any valid file number.</span></span></param>
        <param name="FromRecord"><span data-ttu-id="a0362-2959">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2959">Optional.</span></span> <span data-ttu-id="a0362-2960">Número del primer registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2960">Number of the first record or byte to lock or unlock.</span></span></param>
        <param name="ToRecord"><span data-ttu-id="a0362-2961">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2961">Optional.</span></span> <span data-ttu-id="a0362-2962">Número del último registro o byte que se va a bloquear o desbloquear.</span><span class="sxs-lookup"><span data-stu-id="a0362-2962">Number of the last record or byte to lock or unlock.</span></span></param>
        <summary><span data-ttu-id="a0362-2963">Controla el acceso de otros procesos a la totalidad o a una parte de un archivo abierto mediante la función <see langword="Open" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2963">Controls access by other processes to all or part of a file opened by using the <see langword="Open" /> function.</span></span> <span data-ttu-id="a0362-2964">La característica <see langword="My" /> proporciona más productividad y rendimiento que <see langword="Lock" /> y <see langword="Unlock" /> en las operaciones de E/S con archivos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2964">The <see langword="My" /> feature gives you better productivity and performance in file I/O operations than <see langword="Lock" /> and <see langword="Unlock" />.</span></span> <span data-ttu-id="a0362-2965">Para obtener más información, vea <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2965">For more information, see <see cref="T:Microsoft.VisualBasic.FileIO.FileSystem" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2966">El `Lock` y `Unlock` funciones se utilizan en entornos donde varios procesos pueden necesitar acceso al mismo archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2966">The `Lock` and `Unlock` functions are used in environments where several processes might need access to the same file.</span></span>  
  
 <span data-ttu-id="a0362-2967">`Lock` y `Unlock` funciones se usan siempre en pares.</span><span class="sxs-lookup"><span data-stu-id="a0362-2967">`Lock` and `Unlock` functions are always used in pairs.</span></span> <span data-ttu-id="a0362-2968">Los argumentos de `Lock` y `Unlock` deben ser idénticos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2968">The arguments to `Lock` and `Unlock` must be identical.</span></span>  
  
 <span data-ttu-id="a0362-2969">Si `Record`, o `FromRecord` y `ToRecord` no son se proporciona, el bloqueo será todo el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2969">If `Record`, or `FromRecord` and `ToRecord` are not supplied, the lock will be for the whole file.</span></span> <span data-ttu-id="a0362-2970">Si `Record` por sí solo se especifica solo el registro estará bloqueado o desbloqueado.</span><span class="sxs-lookup"><span data-stu-id="a0362-2970">If `Record` alone is specified the single record will be locked/unlocked.</span></span>  
  
 <span data-ttu-id="a0362-2971">Si el archivo se ha abierto para entradas o salidas, secuenciales `Lock` y `Unlock` afectan a todo el archivo, independientemente del intervalo especificado por `FromRecord` y`ToRecord`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2971">If the file has been opened for sequential input or output, `Lock` and `Unlock` affect the whole file, regardless of the range specified by `FromRecord` and`ToRecord`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-2972">En este ejemplo se muestra el uso de la `Lock` y `Unlock` funciones.</span><span class="sxs-lookup"><span data-stu-id="a0362-2972">This example illustrates the use of the `Lock` and `Unlock` functions.</span></span> <span data-ttu-id="a0362-2973">En este ejemplo se da por supuesto que `People.txt` es un archivo que contiene registros de la estructura `Person`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2973">This example assumes that `People.txt` is a file that contains records of the structure `Person`.</span></span>  
  
 [!code-vb[VbVbalrCatRef#13](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-2974">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2974">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="T:System.IO.IOException" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-2975">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-2975">File Access with Visual Basic</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="public static void Write (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void Write(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Write (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Write(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member Write : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.Write (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-2976">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-2976">Required.</span></span> <span data-ttu-id="a0362-2977">Expresión <see langword="Integer" /> que contiene cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-2977">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a0362-2978">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2978">Optional.</span></span> <span data-ttu-id="a0362-2979">Una o más expresiones delimitadas por comas para escribir en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2979">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="a0362-2980">Escribe datos en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-2980">Writes data to a sequential file.</span></span> <span data-ttu-id="a0362-2981">Los datos escritos con <see langword="Write" /> normalmente se leen desde un archivo mediante <see langword="Input" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-2981">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-2982">El `Write` y `WriteLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2982">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-2983">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-2983">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-2984">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-2984">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-2985">Si se omite `Output`, se imprime una línea en blanco en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2985">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="a0362-2986">Varias expresiones se pueden separar con comas.</span><span class="sxs-lookup"><span data-stu-id="a0362-2986">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="a0362-2987">A diferencia de la `Print` función, el `Write` función inserta comas entre los elementos y las cadenas entre comillas, tal como se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2987">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="a0362-2988">No es necesario colocar delimitadores explícitos en la lista.</span><span class="sxs-lookup"><span data-stu-id="a0362-2988">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="a0362-2989">Cuando `Write` se usa para escribir datos en un archivo, solo numérico, `Boolean`, fecha, null, y `Error` se admiten los formatos de datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2989">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="a0362-2990">Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretan correctamente mediante `Input`, independientemente de la configuración regional:</span><span class="sxs-lookup"><span data-stu-id="a0362-2990">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="a0362-2991">Datos numéricos siempre se escriben con el punto como separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2991">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="a0362-2992">Para `Boolean` datos, ya sea `#TRUE#` o `#FALSE#` se imprime.</span><span class="sxs-lookup"><span data-stu-id="a0362-2992">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="a0362-2993">El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2993">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="a0362-2994">Datos de fecha se escriben en el archivo con el formato de fecha universal.</span><span class="sxs-lookup"><span data-stu-id="a0362-2994">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="a0362-2995">Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-2995">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="a0362-2996">Si se escribirá nada en el archivo `Output` datos están vacíos.</span><span class="sxs-lookup"><span data-stu-id="a0362-2996">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a0362-2997">Sin embargo, para datos nulos, `#NULL#` se escribe.</span><span class="sxs-lookup"><span data-stu-id="a0362-2997">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="a0362-2998">Para `Error` la salida de datos, aparece como `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="a0362-2998">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="a0362-2999">El `Error` palabra clave no se traduce, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-2999">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="a0362-3000">`WriteLine` Inserta un carácter de nueva línea (es decir, un retorno de carro/línea de fuente, o `Chr(13) + Chr(10)`), una vez que se ha escrito el último carácter `Output` al archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3000">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="a0362-3001">Puede insertar comillas en una cadena mediante el uso de comillas dobles, o "".</span><span class="sxs-lookup"><span data-stu-id="a0362-3001">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="a0362-3002">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="a0362-3002">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="a0362-3003">Devuelve una cadena con el valor de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="a0362-3003">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="a0362-3004">Escribir en un archivo mediante el uso de la `Write` o `WriteLine` functions requiere `Append` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-3004">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-3005">Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-3005">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-3006">Este ejemplo se usa el `Write` función para escribir datos sin procesar en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-3006">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="a0362-3007">El modo de archivo no es válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-3007">File mode is invalid.</span></span></exception>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-3008">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-3008">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-3009">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-3009">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-3010">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-3010">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="WriteLine">
      <MemberSignature Language="C#" Value="public static void WriteLine (int FileNumber, params object[] Output);" />
      <MemberSignature Language="ILAsm" Value=".method public static void WriteLine(int32 FileNumber, object[] Output) cil managed" />
      <MemberSignature Language="DocId" Value="M:Microsoft.VisualBasic.FileSystem.WriteLine(System.Int32,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteLine (FileNumber As Integer, ParamArray Output As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WriteLine(int FileNumber, ... cli::array &lt;System::Object ^&gt; ^ Output);" />
      <MemberSignature Language="F#" Value="static member WriteLine : int * obj[] -&gt; unit" Usage="Microsoft.VisualBasic.FileSystem.WriteLine (FileNumber, Output)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>Microsoft.VisualBasic</AssemblyName>
        <AssemblyVersion>7.0.5000.0</AssemblyVersion>
        <AssemblyVersion>8.0.0.0</AssemblyVersion>
        <AssemblyVersion>10.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="FileNumber" Type="System.Int32" />
        <Parameter Name="Output" Type="System.Object[]">
          <Attributes>
            <Attribute FrameworkAlternate="netframework-1.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="FileNumber"><span data-ttu-id="a0362-3011">Obligatorio.</span><span class="sxs-lookup"><span data-stu-id="a0362-3011">Required.</span></span> <span data-ttu-id="a0362-3012">Expresión <see langword="Integer" /> que contiene cualquier número de archivo válido.</span><span class="sxs-lookup"><span data-stu-id="a0362-3012">An <see langword="Integer" /> expression that contains any valid file number.</span></span></param>
        <param name="Output"><span data-ttu-id="a0362-3013">Opcional.</span><span class="sxs-lookup"><span data-stu-id="a0362-3013">Optional.</span></span> <span data-ttu-id="a0362-3014">Una o más expresiones delimitadas por comas para escribir en un archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3014">One or more comma-delimited expressions to write to a file.</span></span></param>
        <summary><span data-ttu-id="a0362-3015">Escribe datos en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-3015">Writes data to a sequential file.</span></span> <span data-ttu-id="a0362-3016">Los datos escritos con <see langword="Write" /> normalmente se leen desde un archivo mediante <see langword="Input" />.</span><span class="sxs-lookup"><span data-stu-id="a0362-3016">Data written with <see langword="Write" /> is usually read from a file by using <see langword="Input" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="a0362-3017">El `Write` y `WriteLine` funciones se proporcionan por compatibilidad con versiones anteriores y puede afectar al rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-3017">The `Write` and `WriteLine` functions are provided for backward compatibility and may affect performance.</span></span> <span data-ttu-id="a0362-3018">Para las aplicaciones que no es heredado, el `My.Computer.FileSystem` objeto proporciona un mejor rendimiento.</span><span class="sxs-lookup"><span data-stu-id="a0362-3018">For non-legacy applications, the `My.Computer.FileSystem` object provides better performance.</span></span> <span data-ttu-id="a0362-3019">Para obtener más información, consulte [acceso a archivos con Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span><span class="sxs-lookup"><span data-stu-id="a0362-3019">For more information, see [File Access with Visual Basic](~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md).</span></span>  
  
 <span data-ttu-id="a0362-3020">Si se omite `Output`, se imprime una línea en blanco en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3020">If you omit `Output`, a blank line is printed to the file.</span></span> <span data-ttu-id="a0362-3021">Varias expresiones se pueden separar con comas.</span><span class="sxs-lookup"><span data-stu-id="a0362-3021">Multiple expressions can be separated with a comma.</span></span>  
  
 <span data-ttu-id="a0362-3022">A diferencia de la `Print` función, el `Write` función inserta comas entre los elementos y las cadenas entre comillas, tal como se escriben en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3022">Unlike the `Print` function, the `Write` function inserts commas between items and quotation marks around strings as they are written to the file.</span></span> <span data-ttu-id="a0362-3023">No es necesario colocar delimitadores explícitos en la lista.</span><span class="sxs-lookup"><span data-stu-id="a0362-3023">You do not have to put explicit delimiters in the list.</span></span> <span data-ttu-id="a0362-3024">Cuando `Write` se usa para escribir datos en un archivo, solo numérico, `Boolean`, fecha, null, y `Error` se admiten los formatos de datos.</span><span class="sxs-lookup"><span data-stu-id="a0362-3024">When `Write` is used to write data to a file, only numeric, `Boolean`, date, null, and `Error` data formats are supported.</span></span> <span data-ttu-id="a0362-3025">Se siguen los siguientes supuestos universales para los datos siempre puedan leer e interpretan correctamente mediante `Input`, independientemente de la configuración regional:</span><span class="sxs-lookup"><span data-stu-id="a0362-3025">The following universal assumptions are followed so the data can always be read and correctly interpreted using `Input`, regardless of locale:</span></span>  
  
-   <span data-ttu-id="a0362-3026">Datos numéricos siempre se escriben con el punto como separador decimal.</span><span class="sxs-lookup"><span data-stu-id="a0362-3026">Numeric data is always written using the period as the decimal separator.</span></span>  
  
-   <span data-ttu-id="a0362-3027">Para `Boolean` datos, ya sea `#TRUE#` o `#FALSE#` se imprime.</span><span class="sxs-lookup"><span data-stu-id="a0362-3027">For `Boolean` data, either `#TRUE#` or `#FALSE#` is printed.</span></span> <span data-ttu-id="a0362-3028">El `True` y `False` palabras clave no se traducen, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-3028">The `True` and `False` keywords are not translated, regardless of locale.</span></span>  
  
-   <span data-ttu-id="a0362-3029">Datos de fecha se escriben en el archivo con el formato de fecha universal.</span><span class="sxs-lookup"><span data-stu-id="a0362-3029">Date data is written to the file using the universal date format.</span></span> <span data-ttu-id="a0362-3030">Cuando la fecha o el componente de hora falta o es cero, solo la parte proporcionada se escribe en el archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3030">When either the date or the time component is missing or zero, only the part provided is written to the file.</span></span>  
  
-   <span data-ttu-id="a0362-3031">Si se escribirá nada en el archivo `Output` datos están vacíos.</span><span class="sxs-lookup"><span data-stu-id="a0362-3031">Nothing is written to the file if `Output` data is empty.</span></span> <span data-ttu-id="a0362-3032">Sin embargo, para datos nulos, `#NULL#` se escribe.</span><span class="sxs-lookup"><span data-stu-id="a0362-3032">However, for null data, `#NULL#` is written.</span></span>  
  
-   <span data-ttu-id="a0362-3033">Para `Error` la salida de datos, aparece como `#ERROR errorcode#`.</span><span class="sxs-lookup"><span data-stu-id="a0362-3033">For `Error` data, the output appears as `#ERROR errorcode#`.</span></span> <span data-ttu-id="a0362-3034">El `Error` palabra clave no se traduce, independientemente de la configuración regional.</span><span class="sxs-lookup"><span data-stu-id="a0362-3034">The `Error` keyword is not translated, regardless of locale.</span></span>  
  
 <span data-ttu-id="a0362-3035">`WriteLine` Inserta un carácter de nueva línea (es decir, un retorno de carro/línea de fuente, o `Chr(13) + Chr(10)`), una vez que se ha escrito el último carácter `Output` al archivo.</span><span class="sxs-lookup"><span data-stu-id="a0362-3035">`WriteLine` inserts a newline character (that is, a carriage return/line feed, or `Chr(13) + Chr(10)`), after it has written the final character in `Output` to the file.</span></span>  
  
 <span data-ttu-id="a0362-3036">Puede insertar comillas en una cadena mediante el uso de comillas dobles, o "".</span><span class="sxs-lookup"><span data-stu-id="a0362-3036">You can embed quotation marks in a string by using double quotation marks, or "".</span></span> <span data-ttu-id="a0362-3037">Por ejemplo,</span><span class="sxs-lookup"><span data-stu-id="a0362-3037">For example,</span></span>  
  
 [!code-vb[VbVbalrCatRef#63](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#63)]  
  
 <span data-ttu-id="a0362-3038">Devuelve una cadena con el valor de `Double quotation marks aren't "difficult" to handle`.</span><span class="sxs-lookup"><span data-stu-id="a0362-3038">returns a string with the value of `Double quotation marks aren't "difficult" to handle`.</span></span>  
  
 <span data-ttu-id="a0362-3039">Escribir en un archivo mediante el uso de la `Write` o `WriteLine` functions requiere `Append` acceso desde el `FileIOPermissionAccess` enumeración.</span><span class="sxs-lookup"><span data-stu-id="a0362-3039">Writing to a file by using the `Write` or `WriteLine` functions requires `Append` access from the `FileIOPermissionAccess` enumeration.</span></span> <span data-ttu-id="a0362-3040">Para obtener más información, consulta <xref:System.Security.Permissions.FileIOPermissionAccess>.</span><span class="sxs-lookup"><span data-stu-id="a0362-3040">For more information, see <xref:System.Security.Permissions.FileIOPermissionAccess> .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="a0362-3041">Este ejemplo se usa el `Write` función para escribir datos sin procesar en un archivo secuencial.</span><span class="sxs-lookup"><span data-stu-id="a0362-3041">This example uses the `Write` function to write raw data to a sequential file.</span></span>  
  
 [!code-vb[VbVbalrCatRef#64](~/samples/snippets/visualbasic/VS_Snippets_VBCSharp/VbVbalrCatRef/VB/Class1.vb#64)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Write(System.Int32,System.Object[])" />
        <altmember cref="Overload:Microsoft.VisualBasic.FileSystem.Input" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.FileOpen(System.Int32,System.String,Microsoft.VisualBasic.OpenMode,Microsoft.VisualBasic.OpenAccess,Microsoft.VisualBasic.OpenShare,System.Int32)" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.Print(System.Int32,System.Object[])" />
        <altmember cref="M:Microsoft.VisualBasic.FileSystem.PrintLine(System.Int32,System.Object[])" />
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/file-access.md"><span data-ttu-id="a0362-3042">Acceso a archivos con Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-3042">File Access with Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files.md"><span data-ttu-id="a0362-3043">Cómo: Escribir texto en archivos en Visual Basic</span><span class="sxs-lookup"><span data-stu-id="a0362-3043">How to: Write Text to Files in Visual Basic</span></span></related>
        <related type="Article" href="~/docs/visual-basic/developing-apps/programming/drives-directories-files/how-to-write-text-to-files-with-a-streamwriter.md"><span data-ttu-id="a0362-3044">Filtrar Escribir texto en un archivo con StreamReader (Visual Basic)</span><span class="sxs-lookup"><span data-stu-id="a0362-3044">How to: Write Text to a File with a Streamwriter (Visual Basic)</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>