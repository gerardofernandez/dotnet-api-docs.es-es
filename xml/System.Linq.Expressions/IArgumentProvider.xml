<Type Name="IArgumentProvider" FullName="System.Linq.Expressions.IArgumentProvider">
  <TypeSignature Language="C#" Value="public interface IArgumentProvider" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IArgumentProvider" />
  <TypeSignature Language="DocId" Value="T:System.Linq.Expressions.IArgumentProvider" />
  <TypeSignature Language="VB.NET" Value="Public Interface IArgumentProvider" />
  <TypeSignature Language="C++ CLI" Value="public interface class IArgumentProvider" />
  <AssemblyInfo>
    <AssemblyName>System.Linq.Expressions</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="3d043-101">Proporciona una interfaz interna para acceder a los argumentos de varios nodos de árbol (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression e InexExpression).</span><span class="sxs-lookup"><span data-stu-id="3d043-101">Provides an internal interface for accessing the arguments of multiple tree nodes (DynamicExpression, ElementInit, MethodCallExpression, InvocationExpression, NewExpression, and InexExpression).</span></span>  <span data-ttu-id="3d043-102">No se debe usar esta API.</span><span class="sxs-lookup"><span data-stu-id="3d043-102">You should not use this API.</span></span>  <span data-ttu-id="3d043-103">Solo es pública debido a la refactorización de la DLL y existe únicamente para optimizaciones de rendimiento interno.</span><span class="sxs-lookup"><span data-stu-id="3d043-103">It is only public due to DLL refactoring and exists only for internal performance optimizations.</span></span>  
  
 <span data-ttu-id="3d043-104">Esto permite dos optimizaciones que reducen el tamaño de los árboles de expresiones.</span><span class="sxs-lookup"><span data-stu-id="3d043-104">This enables two optimizations which reduce the size of expression trees.</span></span>  <span data-ttu-id="3d043-105">La primera permite a los nodos de árbol utilizar una interfaz IList&lt;T&gt; en lugar de ReadOnlyCollection.</span><span class="sxs-lookup"><span data-stu-id="3d043-105">The first enables the tree nodes to hold onto an IList&lt;T&gt; instead of a ReadOnlyCollection.</span></span>  <span data-ttu-id="3d043-106">IList&lt;T&gt; ahorra el costo de asignar ReadOnlyCollection a cada nodo.</span><span class="sxs-lookup"><span data-stu-id="3d043-106">IList&lt;T&gt; saves the cost of allocating the ReadOnlyCollection for each node.</span></span>  <span data-ttu-id="3d043-107">La segunda permite crear subclases especializadas que utilizan un número específico de argumentos (por ejemplo, Block2, Block3, Block4).</span><span class="sxs-lookup"><span data-stu-id="3d043-107">The second enables creating specialized subclasses that hold onto a specific number of arguments (for example, Block2, Block3, Block4).</span></span>  <span data-ttu-id="3d043-108">Por lo tanto, estos nodos evitan asignar ReadOnlyCollection y una matriz para almacenar sus elementos, lo que permite ahorrar 32 bytes por nodo.</span><span class="sxs-lookup"><span data-stu-id="3d043-108">Therefore, these nodes avoid allocating both a ReadOnlyCollection and an array for storing their elements, saving 32 bytes per node.</span></span>  
  
 <span data-ttu-id="3d043-109">Los nodos de los árbol de expresiones siguen exponiendo las propiedades LINQ originales de ReadOnlyCollections.</span><span class="sxs-lookup"><span data-stu-id="3d043-109">The expression tree nodes continue to expose the original LINQ properties of ReadOnlyCollections.</span></span>  <span data-ttu-id="3d043-110">Para ello, los nodos vuelven a usar un campo para almacenar la matriz o un elemento que normalmente se almacenaría en la matriz.</span><span class="sxs-lookup"><span data-stu-id="3d043-110">The nodes do this by re-using a field for storing both the array or an element that would normally be stored in the array.</span></span>  
  
 <span data-ttu-id="3d043-111">En el caso de la matriz, se asigna a la colección el tipo IList&lt;T&gt; en lugar de ReadOnlyCollection&lt;T&gt;.</span><span class="sxs-lookup"><span data-stu-id="3d043-111">For the array case, the collection is typed to IList&lt;T&gt; instead of ReadOnlyCollection&lt;T&gt;.</span></span>  <span data-ttu-id="3d043-112">Cuando el nodo se construye inicialmente es una matriz.</span><span class="sxs-lookup"><span data-stu-id="3d043-112">When the node is initially constructed it is an array.</span></span>  <span data-ttu-id="3d043-113">Cuando el compilador accede a los miembros usa esta interfaz.</span><span class="sxs-lookup"><span data-stu-id="3d043-113">When the compiler accesses the members it uses this interface.</span></span>  <span data-ttu-id="3d043-114">Cuando se accede a los elementos de la matriz, la matriz se promueve a ReadOnlyCollection.</span><span class="sxs-lookup"><span data-stu-id="3d043-114">Accessing array elements promotes the array to a ReadOnlyCollection.</span></span>  
  
 <span data-ttu-id="3d043-115">En el caso del objeto, el primer argumento se almacena en un campo con tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="3d043-115">For the object case we store the first argument in a field typed to object.</span></span>  <span data-ttu-id="3d043-116">Cuando el nodo se construye inicialmente, el campo contiene la expresión.</span><span class="sxs-lookup"><span data-stu-id="3d043-116">When the node is initially constructed, the field holds the Expression.</span></span>  <span data-ttu-id="3d043-117">El compilador accede a los argumentos a través de esta interfaz, y el descriptor de acceso del primer argumento usa Expression.ReturnObject para devolver el objeto que controla el caso de la expresión o ReadOnlyCollection.</span><span class="sxs-lookup"><span data-stu-id="3d043-117">The compiler accesses arguments through this interface, and the accessor for the first argument uses Expression.ReturnObject to return the object that handles the Expression or ReadOnlyCollection case.</span></span>  <span data-ttu-id="3d043-118">Cuando el usuario accede a ReadOnlyCollection, se actualiza el campo de objeto para que utilice directamente ReadOnlyCollection.</span><span class="sxs-lookup"><span data-stu-id="3d043-118">When the user accesses the ReadOnlyCollection, then the object field is updated to hold directly onto the ReadOnlyCollection.</span></span>  
  
 <span data-ttu-id="3d043-119">Es importante que las expresiones devuelvan constantemente la misma ReadOnlyCollection.</span><span class="sxs-lookup"><span data-stu-id="3d043-119">It is important that the Expressions consistently return the same ReadOnlyCollection.</span></span>  <span data-ttu-id="3d043-120">En caso contrario, se interrumpirá el rastreador del árbol del sistema de reescritura.</span><span class="sxs-lookup"><span data-stu-id="3d043-120">Otherwise, the re-writer tree walker will break.</span></span>  <span data-ttu-id="3d043-121">Es un cambio importante con respecto a LINQ v1 devolver diferentes ReadOnlyCollections a partir del mismo nodo de expresión.</span><span class="sxs-lookup"><span data-stu-id="3d043-121">It is a breaking change from LINQ v1 to return different ReadOnlyCollections form the same Expression node.</span></span>  <span data-ttu-id="3d043-122">Actualmente los usuarios pueden confiar en la identidad del objeto para saber si el nodo cambió.</span><span class="sxs-lookup"><span data-stu-id="3d043-122">Currently users can rely on object identity to tell if the node has changed.</span></span>  <span data-ttu-id="3d043-123">Si se almacena ReadOnlyCollection en un campo sobrecargado, se reduce el uso de memoria y se mantiene la compatibilidad con la API pública.</span><span class="sxs-lookup"><span data-stu-id="3d043-123">Storing the ReadOnlyCollection in an overloaded field both reduces memory usage and maintains compatibility for the public API.</span></span></summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName="ArgumentCount">
      <MemberSignature Language="C#" Value="public int ArgumentCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ArgumentCount" />
      <MemberSignature Language="DocId" Value="P:System.Linq.Expressions.IArgumentProvider.ArgumentCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ArgumentCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ArgumentCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3d043-124">Devuelve el número de argumentos al nodo de árbol de expresión.</span><span class="sxs-lookup"><span data-stu-id="3d043-124">Returns the number of arguments to the expression tree node.</span></span>  <span data-ttu-id="3d043-125">No se debe usar este tipo.</span><span class="sxs-lookup"><span data-stu-id="3d043-125">You should not use this type.</span></span>  <span data-ttu-id="3d043-126">Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="3d043-126">It is only public due to assembly refactoring, and it is used internally for performance optimizations.</span></span></summary>
        <value><span data-ttu-id="3d043-127">Número de argumentos al nodo de árbol de expresión como <see cref="T:System.Int32" />.</span><span class="sxs-lookup"><span data-stu-id="3d043-127">The number of arguments to the expression tree node as <see cref="T:System.Int32" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArgument">
      <MemberSignature Language="C#" Value="public System.Linq.Expressions.Expression GetArgument (int index);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Linq.Expressions.Expression GetArgument(int32 index) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Linq.Expressions.IArgumentProvider.GetArgument(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetArgument (index As Integer) As Expression" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Linq::Expressions::Expression ^ GetArgument(int index);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Linq.Expressions</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Linq.Expressions.Expression</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="3d043-128">Índice del argumento.</span><span class="sxs-lookup"><span data-stu-id="3d043-128">The index of the argument.</span></span></param>
        <summary><span data-ttu-id="3d043-129">Devuelve el argumento en el índice, indicando si el índice está fuera de los límites.</span><span class="sxs-lookup"><span data-stu-id="3d043-129">Returns the argument at index, throwing if index is out of bounds.</span></span>  <span data-ttu-id="3d043-130">No se debe usar este tipo.</span><span class="sxs-lookup"><span data-stu-id="3d043-130">You should not use this type.</span></span>  <span data-ttu-id="3d043-131">Solo es público debido a la refactorización del ensamblado y se usa internamente para optimizaciones de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="3d043-131">It is only public due to assembly refactoring, and it is used internally for performance optimizations.</span></span></summary>
        <returns><span data-ttu-id="3d043-132">Argumento en el índice, indicando si el índice está fuera de los límites, como <see cref="T:System.Linq.Expressions.Expression" />.</span><span class="sxs-lookup"><span data-stu-id="3d043-132">The argument at index, throwing if index is out of bounds as <see cref="T:System.Linq.Expressions.Expression" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>