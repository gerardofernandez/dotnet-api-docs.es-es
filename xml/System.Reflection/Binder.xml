<Type Name="Binder" FullName="System.Reflection.Binder">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="42b4c18690d586a6a4c119f72306253c8b6ec5bd" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39975625" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Binder" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Binder extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Binder" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Binder" />
  <TypeSignature Language="C++ CLI" Value="public ref class Binder abstract" />
  <TypeSignature Language="F#" Value="type Binder = class" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.AutoDual)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="60b19-101">Selecciona un miembro de una lista de candidatos y realiza una conversión de tipo desde el tipo de argumento real al tipo de argumento formal.</span>
      <span class="sxs-lookup">
        <span data-stu-id="60b19-101">Selects a member from a list of candidates, and performs type conversion from actual argument type to formal argument type.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-102">Las implementaciones de la <xref:System.Reflection.Binder> la clase se utilizan los métodos como <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, que selecciona desde un conjunto de miembros posibles para ejecutar, basándose en un conjunto de tipos de parámetros y valores de argumento; <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, que selecciona un método basado en tipos de parámetro y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60b19-102">Implementations of the <xref:System.Reflection.Binder> class are used by methods such as <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>, which selects from a set of possible members to execute, based on a set of parameter types and argument values; <xref:System.Type.GetMethod%2A?displayProperty=nameWithType>, which selects a method based on parameter types; and so on.</span></span>  
  
 <span data-ttu-id="60b19-103">Una implementación predeterminada de la <xref:System.Reflection.Binder> clase la proporcionan los <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60b19-103">A default implementation of the <xref:System.Reflection.Binder> class is provided by the <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60b19-104">El ejemplo siguiente se implementa y se muestran todos los miembros de la `Binder` clase.</span><span class="sxs-lookup"><span data-stu-id="60b19-104">The following example implements and demonstrates all members of the `Binder` class.</span></span> <span data-ttu-id="60b19-105">El método privado `CanConvertFrom` busca tipos compatibles con un tipo determinado.</span><span class="sxs-lookup"><span data-stu-id="60b19-105">The private method `CanConvertFrom` finds compatible types for a given type.</span></span>  
  
 [!code-cpp[Binder_1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Binder_1/CPP/binder.cpp#1)]
 [!code-csharp[Binder_1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Binder_1/CS/binder.cs#1)]
 [!code-vb[Binder_1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Binder_1/VB/binder.vb#1)]  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="60b19-106">
        <para>Al heredar de <see cref="T:System.Reflection.Binder" />, debe reemplazar los miembros siguientes: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, y <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="60b19-106">
          <para>When you inherit from <see cref="T:System.Reflection.Binder" />, you must override the following members: <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, <see cref="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />, <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />, <see cref="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />, <see cref="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />, and <see cref="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />.</para>
        </span>
      </span>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Binder ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Binder();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="60b19-107">Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Binder" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-107">Initializes a new instance of the <see cref="T:System.Reflection.Binder" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-108">Este constructor llama a los constructores de clases derivadas para inicializar el estado de este tipo.</span><span class="sxs-lookup"><span data-stu-id="60b19-108">This constructor is called by the constructors of derived classes, to initialize state in this type.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BindToField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo BindToField (System.Reflection.BindingFlags bindingAttr, System.Reflection.FieldInfo[] match, object value, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo BindToField(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.FieldInfo[] match, object value, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToField(System.Reflection.BindingFlags,System.Reflection.FieldInfo[],System.Object,System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToField (bindingAttr As BindingFlags, match As FieldInfo(), value As Object, culture As CultureInfo) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ BindToField(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ match, System::Object ^ value, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member BindToField : System.Reflection.BindingFlags * System.Reflection.FieldInfo[] * obj * System.Globalization.CultureInfo -&gt; System.Reflection.FieldInfo" Usage="binder.BindToField (bindingAttr, match, value, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.FieldInfo[]" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="60b19-109">Combinación bit a bit de los valores de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-109">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</span>
          </span>
        </param>
        <param name="match">
          <span data-ttu-id="60b19-110">El conjunto de campos que podrían coincidir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-110">The set of fields that are candidates for matching.</span>
          </span>
          <span data-ttu-id="60b19-111">Por ejemplo, cuando un método <see cref="T:System.Reflection.Binder" /> utiliza un objeto <see cref="Overload:System.Type.InvokeMember" />, este parámetro especifica el conjunto de campos que la reflexión ha determinado como posibles coincidencias, normalmente porque tienen el nombre de miembro correcto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-111">For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of fields that reflection has determined to be possible matches, typically because they have the correct member name.</span>
          </span>
          <span data-ttu-id="60b19-112">La implementación predeterminada proporcionada por <see cref="P:System.Type.DefaultBinder" /> cambia el orden de esta matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-112">The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</span>
          </span>
        </param>
        <param name="value">
          <span data-ttu-id="60b19-113">Valor del campo utilizado para localizar un campo coincidente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-113">The field value used to locate a matching field.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="60b19-114">Instancia de <see cref="T:System.Globalization.CultureInfo" /> que se utiliza para controlar la conversión de tipos de datos en implementaciones de enlazadores en las que se convierten tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-114">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types, in binder implementations that coerce types.</span>
          </span>
          <span data-ttu-id="60b19-115">Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-115">If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="60b19-116">Nota   Por ejemplo, si una implementación del enlazador permite la conversión de valores de cadena en tipos numéricos, este parámetro es necesario para convertir un elemento <see langword="String" /> que representa 1000 en un valor <see langword="Double" />, puesto que 1000 no se representa del mismo modo en las distintas referencias culturales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-116">Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures.</span>
          </span>
          <span data-ttu-id="60b19-117">El enlazador predeterminado no realiza estas conversiones de cadenas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-117">The default binder does not do such string coercions.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-118">Selecciona un campo a partir de un conjunto de campos dado, según los criterios especificados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-118">Selects a field from the given set of fields, based on the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60b19-119">El campo correspondiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-119">The matching field.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-120">Si `bindingAttr` no incluye <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, la implementación de enlazador predeterminada proporcionada por <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> simplemente devuelve el primer elemento de `match`.</span><span class="sxs-lookup"><span data-stu-id="60b19-120">If `bindingAttr` does not include <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>, the default binder implementation provided by <xref:System.Type.DefaultBinder%2A?displayProperty=nameWithType> simply returns the first element of `match`.</span></span> <span data-ttu-id="60b19-121">No se realiza ninguna selección.</span><span class="sxs-lookup"><span data-stu-id="60b19-121">No selection is done.</span></span>  
  
 <span data-ttu-id="60b19-122">Este método controla el enlace proporcionado por <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60b19-122">This method controls the binding provided by <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="60b19-123">En el enlazador predeterminado, <paramref name="bindingAttr" /> incluye <see cref="F:System.Reflection.BindingFlags.SetField" /> y <paramref name="match" /> contiene varios campos que constituyen coincidencias igualmente buenas para <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-123">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> contains multiple fields that are equally good matches for <paramref name="value" />.</span>
          </span>
          <span data-ttu-id="60b19-124">Por ejemplo, <paramref name="value" /> contiene un objeto <c>MyClass</c> que implementa la interfaz <c>IMyClass</c> y <paramref name="match" /> contiene un campo de tipo <c>MyClass</c> y un campo de tipo <c>IMyClass</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-124">For example, <paramref name="value" /> contains a <c>MyClass</c> object that implements the <c>IMyClass</c> interface, and <paramref name="match" /> contains a field of type <c>MyClass</c> and a field of type <c>IMyClass</c>.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingFieldException">
          <span data-ttu-id="60b19-125">En el enlazador predeterminado, <paramref name="bindingAttr" /> incluye <see cref="F:System.Reflection.BindingFlags.SetField" /> y <paramref name="match" /> no contiene ningún campo que pueda aceptar <paramref name="value" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-125">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> contains no fields that can accept <paramref name="value" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="60b19-126">En el enlazador predeterminado, <paramref name="bindingAttr" /> incluye <see cref="F:System.Reflection.BindingFlags.SetField" /> y <paramref name="match" /> es <see langword="null" /> o una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-126">For the default binder, <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="match" /> is <see langword="null" /> or an empty array.</span>
          </span>
          <span data-ttu-id="60b19-127">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-127">-or-</span>
          </span>
          <span data-ttu-id="60b19-128">
            <paramref name="bindingAttr" /> incluye <see cref="F:System.Reflection.BindingFlags.SetField" /> y <paramref name="value" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-128">
              <paramref name="bindingAttr" /> includes <see cref="F:System.Reflection.BindingFlags.SetField" />, and <paramref name="value" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
      </Docs>
    </Member>
    <Member MemberName="BindToMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase BindToMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, ref object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] names, out object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase BindToMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, object[]&amp; args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] names, [out] object&amp; state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function BindToMethod (bindingAttr As BindingFlags, match As MethodBase(), ByRef args As Object(), modifiers As ParameterModifier(), culture As CultureInfo, names As String(), ByRef state As Object) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ BindToMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;System::Object ^&gt; ^ % args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ names, [Runtime::InteropServices::Out] System::Object ^ % state);" />
      <MemberSignature Language="F#" Value="abstract member BindToMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] *  * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] *  -&gt; System.Reflection.MethodBase" Usage="binder.BindToMethod (bindingAttr, match, args, modifiers, culture, names, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="names" Type="System.String[]" />
        <Parameter Name="state" Type="System.Object" RefType="out" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="60b19-129">Combinación bit a bit de los valores de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-129">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</span>
          </span>
        </param>
        <param name="match">
          <span data-ttu-id="60b19-130">El conjunto de métodos que podrían coincidir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-130">The set of methods that are candidates for matching.</span>
          </span>
          <span data-ttu-id="60b19-131">Por ejemplo, cuando un método <see cref="T:System.Reflection.Binder" /> utiliza un objeto <see cref="Overload:System.Type.InvokeMember" />, este parámetro especifica el conjunto de métodos que la reflexión ha determinado como posibles coincidencias, normalmente porque tienen el nombre de miembro correcto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-131">For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name.</span>
          </span>
          <span data-ttu-id="60b19-132">La implementación predeterminada proporcionada por <see cref="P:System.Type.DefaultBinder" /> cambia el orden de esta matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-132">The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</span>
          </span>
        </param>
        <param name="args">
          <span data-ttu-id="60b19-133">Argumentos que se han pasado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-133">The arguments that are passed in.</span>
          </span>
          <span data-ttu-id="60b19-134">El enlazador puede cambiar el orden de los argumentos de esta matriz; por ejemplo, el enlazador predeterminado cambia el orden de los argumentos si el parámetro <c>names</c> se usa para especificar un orden que no sea posicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-134">The binder can change the order of the arguments in this array; for example, the default binder changes the order of arguments if the <c>names</c> parameter is used to specify an order other than positional order.</span>
          </span>
          <span data-ttu-id="60b19-135">Si una implementación del enlazador convierte tipos de argumentos, los tipos y valores de los argumentos también se pueden cambiar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-135">If a binder implementation coerces argument types, the types and values of the arguments can be changed as well.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="60b19-136">Matriz de modificadores de parámetro que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-136">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</span>
          </span>
          <span data-ttu-id="60b19-137">La implementación de enlazador predeterminada no utiliza este parámetro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-137">The default binder implementation does not use this parameter.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="60b19-138">Instancia de <see cref="T:System.Globalization.CultureInfo" /> que se utiliza para controlar la conversión de tipos de datos en implementaciones de enlazadores en las que se convierten tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-138">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types, in binder implementations that coerce types.</span>
          </span>
          <span data-ttu-id="60b19-139">Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-139">If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="60b19-140">Nota   Por ejemplo, si una implementación del enlazador permite la conversión de valores de cadena en tipos numéricos, este parámetro es necesario para convertir un elemento <see langword="String" /> que representa 1000 en un valor <see langword="Double" />, puesto que 1000 no se representa del mismo modo en las distintas referencias culturales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-140">Note   For example, if a binder implementation allows coercion of string values to numeric types, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures.</span>
          </span>
          <span data-ttu-id="60b19-141">El enlazador predeterminado no realiza estas conversiones de cadenas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-141">The default binder does not do such string coercions.</span>
          </span>
        </param>
        <param name="names">
          <span data-ttu-id="60b19-142">Los nombres de los parámetros, si estos nombres se van a tener en cuenta cuando se produzca una coincidencia, al coincidir o <see langword="null" /> si los argumentos se van a tratar en un orden meramente posicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-142">The parameter names, if parameter names are to be considered when matching, or <see langword="null" /> if arguments are to be treated as purely positional.</span>
          </span>
          <span data-ttu-id="60b19-143">Por ejemplo, hay que utilizar los nombres de parámetros si los argumentos no se proporcionan en un orden posicional.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-143">For example, parameter names must be used if arguments are not supplied in positional order.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60b19-144">Cuando el método finaliza, <c>state</c> contiene un objeto proporcionado por el enlazador que hace un seguimiento de la reordenación de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-144">After the method returns, <c>state</c> contains a binder-provided object that keeps track of argument reordering.</span>
          </span>
          <span data-ttu-id="60b19-145">El enlazador crea este objeto y es su único consumidor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-145">The binder creates this object, and the binder is the sole consumer of this object.</span>
          </span>
          <span data-ttu-id="60b19-146">Si <c>state</c> no es <see langword="null" /> cuando <see langword="BindToMethod" /> finaliza, se debe pasar <c>state</c> al método <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> si se quiere restablecer <c>args</c> a su orden original, por ejemplo, para que se puedan recuperar los valores de los parámetros <see langword="ref" /> (parámetros <see langword="ByRef" /> en Visual Basic).</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-146">If <c>state</c> is not <see langword="null" /> when <see langword="BindToMethod" /> returns, you must pass <c>state</c> to the <see cref="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" /> method if you want to restore <c>args</c> to its original order, for example, so that you can retrieve the values of <see langword="ref" /> parameters (<see langword="ByRef" /> parameters in Visual Basic).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-147">Selecciona un método que se puede invocar desde el conjunto de métodos especificado en función de los argumentos suministrados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-147">Selects a method to invoke from the given set of methods, based on the supplied arguments.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60b19-148">El método correspondiente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-148">The matching method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-149">El enlazador predeterminado tiene en cuenta ambos parámetros que tienen valores y `params` matrices (`ParamArray` matrices en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60b19-149">The default binder takes into account both parameters that have values and `params` arrays (`ParamArray` arrays in Visual Basic).</span></span> <span data-ttu-id="60b19-150">Por lo tanto, es posible encontrar una coincidencia en los casos donde `args` y `match` no contienen el mismo número de elementos.</span><span class="sxs-lookup"><span data-stu-id="60b19-150">Thus, it is possible to find a match in cases where `args` and `match` do not contain the same number of elements.</span></span>  
  
 <span data-ttu-id="60b19-151">El enlazador permite que un cliente asignar la matriz de argumentos a su forma original si se ha manipulado la matriz de argumentos por <xref:System.Reflection.Binder.BindToMethod%2A>.</span><span class="sxs-lookup"><span data-stu-id="60b19-151">The binder enables a client to map the array of arguments back to its original form if the argument array has been manipulated by <xref:System.Reflection.Binder.BindToMethod%2A>.</span></span> <span data-ttu-id="60b19-152">Utilice esta función de reasignación obtener argumentos por referencia cuando tales argumentos están presentes.</span><span class="sxs-lookup"><span data-stu-id="60b19-152">Use this remap capability to get back by-reference arguments when such arguments are present.</span></span> <span data-ttu-id="60b19-153">Al pasar argumentos por nombre, el enlazador reordena la matriz de argumentos.</span><span class="sxs-lookup"><span data-stu-id="60b19-153">When you pass arguments by name, the binder reorders the argument array.</span></span> <span data-ttu-id="60b19-154">El `state` parámetro realiza un seguimiento de argumento reordenación, lo que permite el enlazador <xref:System.Reflection.Binder.ReorderArgumentArray%2A> método para volver a ordenar la matriz de argumentos a su forma original.</span><span class="sxs-lookup"><span data-stu-id="60b19-154">The `state` parameter keeps track of argument reordering, thus enabling the binder's <xref:System.Reflection.Binder.ReorderArgumentArray%2A> method to reorder the argument array to its original form.</span></span>  
  
 <span data-ttu-id="60b19-155">El <xref:System.Reflection.Binder.BindToMethod%2A> método lo usa el <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="60b19-155">The <xref:System.Reflection.Binder.BindToMethod%2A> method is used by the <xref:System.Type.InvokeMember%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="60b19-156">En el enlazador predeterminado, <paramref name="match" /> contiene varios métodos que constituyen coincidencias igualmente buenas para <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-156">For the default binder, <paramref name="match" /> contains multiple methods that are equally good matches for <paramref name="args" />.</span>
          </span>
          <span data-ttu-id="60b19-157">Por ejemplo, <paramref name="args" /> contiene un objeto <c>MyClass</c> que implementa la interfaz <c>IMyClass</c> y <paramref name="match" /> contiene un método que toma <c>MyClass</c> y un método que toma <c>IMyClass</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-157">For example, <paramref name="args" /> contains a <c>MyClass</c> object that implements the <c>IMyClass</c> interface, and <paramref name="match" /> contains a method that takes <c>MyClass</c> and a method that takes <c>IMyClass</c>.</span>
          </span>
        </exception>
        <exception cref="T:System.MissingMethodException">
          <span data-ttu-id="60b19-158">En el enlazador predeterminado, <paramref name="match" /> no contiene ningún método que pueda aceptar los argumentos proporcionados en <paramref name="args" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-158">For the default binder, <paramref name="match" /> contains no methods that can accept the arguments supplied in <paramref name="args" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60b19-159">En el enlazador predeterminado, <paramref name="match" /> es <see langword="null" /> o una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-159">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.MethodBase" />
      </Docs>
    </Member>
    <Member MemberName="CanChangeType">
      <MemberSignature Language="C#" Value="public virtual bool CanChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool CanChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.CanChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool CanChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool&#xA;override this.CanChangeType : obj * Type * System.Globalization.CultureInfo -&gt; bool" Usage="binder.CanChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="type">To be added.</param>
        <param name="culture">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ChangeType">
      <MemberSignature Language="C#" Value="public abstract object ChangeType (object value, Type type, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object ChangeType(object value, class System.Type type, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ChangeType(System.Object,System.Type,System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ ChangeType(System::Object ^ value, Type ^ type, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member ChangeType : obj * Type * System.Globalization.CultureInfo -&gt; obj" Usage="binder.ChangeType (value, type, culture)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="60b19-160">Objeto que debe cambiarse a un nuevo <see langword="Type" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-160">The object to change into a new <see langword="Type" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="60b19-161">Nuevo elemento <see langword="Type" /> en el que se convierte <c>value</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-161">The new <see langword="Type" /> that <c>value</c> will become.</span>
          </span>
        </param>
        <param name="culture">
          <span data-ttu-id="60b19-162">Instancia de <see cref="T:System.Globalization.CultureInfo" /> utilizada para controlar la conversión de tipos de datos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-162">An instance of <see cref="T:System.Globalization.CultureInfo" /> that is used to control the coercion of data types.</span>
          </span>
          <span data-ttu-id="60b19-163">Si <c>culture</c> es <see langword="null" />, se usa el elemento <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-163">If <c>culture</c> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span>
          </span>
          <span data-ttu-id="60b19-164">Nota   Por ejemplo, este parámetro es necesario para convertir un elemento <see langword="String" /> que representa 1000 en un valor <see langword="Double" />, ya que 1000 se representa de manera diferente según las distintas referencias culturales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-164">Note   For example, this parameter is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, because 1000 is represented differently by different cultures.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-165">Cambia el tipo del valor <see langword="Object" /> especificado por el tipo <see langword="Type" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-165">Changes the type of the given <see langword="Object" /> to the given <see langword="Type" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60b19-166">Objeto que contiene el valor dado como el nuevo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-166">An object that contains the given value as the new type.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-167">Las reglas de accesibilidad de common type system de los modelos de reflexión.</span><span class="sxs-lookup"><span data-stu-id="60b19-167">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="60b19-168">Por ejemplo, si el llamador está en el mismo ensamblado, el llamador no necesita permisos especiales para los miembros internos.</span><span class="sxs-lookup"><span data-stu-id="60b19-168">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="60b19-169">En caso contrario, el llamador necesita <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="60b19-169">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="60b19-170">Esto es coherente con la búsqueda de miembros que están protegidas, privadas y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60b19-170">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="60b19-171">El principio general es que `ChangeType` debe realizar sólo conversiones de ampliación, que nunca se pierden datos.</span><span class="sxs-lookup"><span data-stu-id="60b19-171">The general principle is that `ChangeType` should perform only widening coercions, which never lose data.</span></span> <span data-ttu-id="60b19-172">Un ejemplo de una conversión de ampliación es la conversión de un valor que es un entero de 32 bits con signo en un valor que es un entero con signo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="60b19-172">An example of a widening coercion is coercing a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="60b19-173">Esto se diferencia de una conversión de restricción, que podrían perder datos.</span><span class="sxs-lookup"><span data-stu-id="60b19-173">This is distinguished from a narrowing coercion, which may lose data.</span></span> <span data-ttu-id="60b19-174">Un ejemplo de una conversión de restricción es la conversión de un entero con signo de 64 bits en un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="60b19-174">An example of a narrowing coercion is coercing a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="60b19-175">La tabla siguiente enumeran las conversiones realizadas por el valor predeterminado `ChangeType`.</span><span class="sxs-lookup"><span data-stu-id="60b19-175">The following table lists the coercions performed by the default `ChangeType`.</span></span>  
  
|<span data-ttu-id="60b19-176">Tipo de origen</span><span class="sxs-lookup"><span data-stu-id="60b19-176">Source type</span></span>|<span data-ttu-id="60b19-177">Tipo de destino</span><span class="sxs-lookup"><span data-stu-id="60b19-177">Target type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="60b19-178">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="60b19-178">Any type</span></span>|<span data-ttu-id="60b19-179">Su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60b19-179">Its base type.</span></span>|  
|<span data-ttu-id="60b19-180">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="60b19-180">Any type</span></span>|<span data-ttu-id="60b19-181">La interfaz que implementa.</span><span class="sxs-lookup"><span data-stu-id="60b19-181">The interface it implements.</span></span>|  
|<span data-ttu-id="60b19-182">Char</span><span class="sxs-lookup"><span data-stu-id="60b19-182">Char</span></span>|<span data-ttu-id="60b19-183">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-183">UInt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-184">Byte</span><span class="sxs-lookup"><span data-stu-id="60b19-184">Byte</span></span>|<span data-ttu-id="60b19-185">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-185">Char, UInt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-186">SByte</span><span class="sxs-lookup"><span data-stu-id="60b19-186">SByte</span></span>|<span data-ttu-id="60b19-187">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-187">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-188">UInt16</span><span class="sxs-lookup"><span data-stu-id="60b19-188">UInt16</span></span>|<span data-ttu-id="60b19-189">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-189">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-190">Int16</span><span class="sxs-lookup"><span data-stu-id="60b19-190">Int16</span></span>|<span data-ttu-id="60b19-191">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-191">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-192">UInt32</span><span class="sxs-lookup"><span data-stu-id="60b19-192">UInt32</span></span>|<span data-ttu-id="60b19-193">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-193">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-194">Int32</span><span class="sxs-lookup"><span data-stu-id="60b19-194">Int32</span></span>|<span data-ttu-id="60b19-195">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-195">Int64, Single, Double</span></span>|  
|<span data-ttu-id="60b19-196">UInt64</span><span class="sxs-lookup"><span data-stu-id="60b19-196">UInt64</span></span>|<span data-ttu-id="60b19-197">Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-197">Single, Double</span></span>|  
|<span data-ttu-id="60b19-198">Int64</span><span class="sxs-lookup"><span data-stu-id="60b19-198">Int64</span></span>|<span data-ttu-id="60b19-199">Single, Double</span><span class="sxs-lookup"><span data-stu-id="60b19-199">Single, Double</span></span>|  
|<span data-ttu-id="60b19-200">Single</span><span class="sxs-lookup"><span data-stu-id="60b19-200">Single</span></span>|<span data-ttu-id="60b19-201">Doble</span><span class="sxs-lookup"><span data-stu-id="60b19-201">Double</span></span>|  
|<span data-ttu-id="60b19-202">Sin referencia</span><span class="sxs-lookup"><span data-stu-id="60b19-202">Non-reference</span></span>|<span data-ttu-id="60b19-203">Por referencia.</span><span class="sxs-lookup"><span data-stu-id="60b19-203">By-reference.</span></span>|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReorderArgumentArray">
      <MemberSignature Language="C#" Value="public abstract void ReorderArgumentArray (ref object[] args, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ReorderArgumentArray(object[]&amp; args, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.ReorderArgumentArray(System.Object[]@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub ReorderArgumentArray (ByRef args As Object(), state As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void ReorderArgumentArray(cli::array &lt;System::Object ^&gt; ^ % args, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="abstract member ReorderArgumentArray :  * obj -&gt; unit" Usage="binder.ReorderArgumentArray (args, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" RefType="ref" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="args">
          <span data-ttu-id="60b19-204">Argumentos reales pasados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-204">The actual arguments that are passed in.</span>
          </span>
          <span data-ttu-id="60b19-205">Tanto los tipos como los valores de los argumentos pueden modificarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-205">Both the types and values of the arguments can be changed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="60b19-206">Objeto proporcionado por el enlazador que realiza un seguimiento de la reordenación de argumentos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-206">A binder-provided object that keeps track of argument reordering.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-207">Después de devolver un valor de <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, restaura el argumento de <paramref name="args" />, reemplazándolo por lo que era cuando procedía de <see langword="BindToMethod" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-207">Upon returning from <see cref="M:System.Reflection.Binder.BindToMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Object[]@,System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[],System.Object@)" />, restores the <paramref name="args" /> argument to what it was when it came from <see langword="BindToMethod" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-208">Common language runtime llama a este método si `state` no `null` después de una devolución de `BindToMethod`.</span><span class="sxs-lookup"><span data-stu-id="60b19-208">The common language runtime calls this method if `state` is not `null` after a return from `BindToMethod`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SelectMethod">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodBase SelectMethod (System.Reflection.BindingFlags bindingAttr, System.Reflection.MethodBase[] match, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodBase SelectMethod(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MethodBase[] match, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectMethod(System.Reflection.BindingFlags,System.Reflection.MethodBase[],System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectMethod (bindingAttr As BindingFlags, match As MethodBase(), types As Type(), modifiers As ParameterModifier()) As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodBase ^ SelectMethod(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::MethodBase ^&gt; ^ match, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectMethod : System.Reflection.BindingFlags * System.Reflection.MethodBase[] * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodBase" Usage="binder.SelectMethod (bindingAttr, match, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.MethodBase[]" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="60b19-209">Combinación bit a bit de los valores de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-209">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</span>
          </span>
        </param>
        <param name="match">
          <span data-ttu-id="60b19-210">El conjunto de métodos que podrían coincidir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-210">The set of methods that are candidates for matching.</span>
          </span>
          <span data-ttu-id="60b19-211">Por ejemplo, cuando un método <see cref="T:System.Reflection.Binder" /> utiliza un objeto <see cref="Overload:System.Type.InvokeMember" />, este parámetro especifica el conjunto de métodos que la reflexión ha determinado como posibles coincidencias, normalmente porque tienen el nombre de miembro correcto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-211">For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of methods that reflection has determined to be possible matches, typically because they have the correct member name.</span>
          </span>
          <span data-ttu-id="60b19-212">La implementación predeterminada proporcionada por <see cref="P:System.Type.DefaultBinder" /> cambia el orden de esta matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-212">The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</span>
          </span>
        </param>
        <param name="types">
          <span data-ttu-id="60b19-213">Tipos de parámetros utilizados para localizar un método coincidente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-213">The parameter types used to locate a matching method.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="60b19-214">Matriz de modificadores de parámetro que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-214">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-215">Selecciona un método a partir de un conjunto de métodos, atendiendo al tipo de argumento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-215">Selects a method from the given set of methods, based on the argument type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60b19-216">El método coincidente, si se encuentra; de lo contrario, <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-216">The matching method, if found; otherwise, <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-217">Este método debe devolver `null` si no hay ningún método coincide con los criterios.</span><span class="sxs-lookup"><span data-stu-id="60b19-217">This method should return `null` if no method matches the criteria.</span></span> <span data-ttu-id="60b19-218">Este método controla la selección proporcionada por el `GetConstructor` y `GetMethod` métodos en `Type`.</span><span class="sxs-lookup"><span data-stu-id="60b19-218">This method controls the selection provided by the `GetConstructor` and `GetMethod` methods on `Type`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="60b19-219">En el enlazador predeterminado, <paramref name="match" /> contiene varios métodos que constituyen coincidencias igualmente buenas para los tipos de parámetro descritos por <paramref name="types" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-219">For the default binder, <paramref name="match" /> contains multiple methods that are equally good matches for the parameter types described by <paramref name="types" />.</span>
          </span>
          <span data-ttu-id="60b19-220">Por ejemplo, la matriz de <paramref name="types" /> contiene un objeto <see cref="T:System.Type" /> para <c>MyClass</c> y la matriz de <paramref name="match" /> contiene un método que toma una clase base de <c>MyClass</c> y un método que toma una interfaz que <c>MyClass</c> implementa.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-220">For example, the array in <paramref name="types" /> contains a <see cref="T:System.Type" /> object for <c>MyClass</c> and the array in <paramref name="match" /> contains a method that takes a base class of <c>MyClass</c> and a method that takes an interface that <c>MyClass</c> implements.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60b19-221">En el enlazador predeterminado, <paramref name="match" /> es <see langword="null" /> o una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-221">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.</span>
          </span>
          <span data-ttu-id="60b19-222">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-222">-or-</span>
          </span>
          <span data-ttu-id="60b19-223">Un elemento de <paramref name="types" /> se deriva de <see cref="T:System.Type" />, pero no es de tipo <see langword="RuntimeType" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-223">An element of <paramref name="types" /> derives from <see cref="T:System.Type" />, but is not of type <see langword="RuntimeType" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SelectProperty">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo SelectProperty (System.Reflection.BindingFlags bindingAttr, System.Reflection.PropertyInfo[] match, Type returnType, Type[] indexes, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo SelectProperty(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.PropertyInfo[] match, class System.Type returnType, class System.Type[] indexes, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Binder.SelectProperty(System.Reflection.BindingFlags,System.Reflection.PropertyInfo[],System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function SelectProperty (bindingAttr As BindingFlags, match As PropertyInfo(), returnType As Type, indexes As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::PropertyInfo ^ SelectProperty(System::Reflection::BindingFlags bindingAttr, cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ match, Type ^ returnType, cli::array &lt;Type ^&gt; ^ indexes, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member SelectProperty : System.Reflection.BindingFlags * System.Reflection.PropertyInfo[] * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="binder.SelectProperty (bindingAttr, match, returnType, indexes, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="match" Type="System.Reflection.PropertyInfo[]" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="indexes" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr">
          <span data-ttu-id="60b19-224">Combinación bit a bit de los valores de <see cref="T:System.Reflection.BindingFlags" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-224">A bitwise combination of <see cref="T:System.Reflection.BindingFlags" /> values.</span>
          </span>
        </param>
        <param name="match">
          <span data-ttu-id="60b19-225">El conjunto de propiedades que podrían coincidir.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-225">The set of properties that are candidates for matching.</span>
          </span>
          <span data-ttu-id="60b19-226">Por ejemplo, cuando un método <see cref="T:System.Reflection.Binder" /> utiliza un objeto <see cref="Overload:System.Type.InvokeMember" />, este parámetro especifica el conjunto de propiedades que la reflexión ha determinado como posibles coincidencias, normalmente porque tienen el nombre de miembro correcto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-226">For example, when a <see cref="T:System.Reflection.Binder" /> object is used by <see cref="Overload:System.Type.InvokeMember" />, this parameter specifies the set of properties that reflection has determined to be possible matches, typically because they have the correct member name.</span>
          </span>
          <span data-ttu-id="60b19-227">La implementación predeterminada proporcionada por <see cref="P:System.Type.DefaultBinder" /> cambia el orden de esta matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-227">The default implementation provided by <see cref="P:System.Type.DefaultBinder" /> changes the order of this array.</span>
          </span>
        </param>
        <param name="returnType">
          <span data-ttu-id="60b19-228">Valor devuelto que debe tener la propiedad coincidente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-228">The return value the matching property must have.</span>
          </span>
        </param>
        <param name="indexes">
          <span data-ttu-id="60b19-229">Tipos de índice de la propiedad que se está buscando.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-229">The index types of the property being searched for.</span>
          </span>
          <span data-ttu-id="60b19-230">Utilizado para las propiedades de índice como el indizador de una clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-230">Used for index properties such as the indexer for a class.</span>
          </span>
        </param>
        <param name="modifiers">
          <span data-ttu-id="60b19-231">Matriz de modificadores de parámetro que permite que el enlace funcione con firmas de parámetros en las que se han modificado los tipos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-231">An array of parameter modifiers that enable binding to work with parameter signatures in which the types have been modified.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="60b19-232">Selecciona, a partir de criterios especificados, una propiedad de un conjunto de criterios determinado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-232">Selects a property from the given set of properties, based on the specified criteria.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="60b19-233">La propiedad coincidente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-233">The matching property.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60b19-234">Este método controla la selección proporcionada por el `GetProperty` método `Type`.</span><span class="sxs-lookup"><span data-stu-id="60b19-234">This method controls the selection provided by the `GetProperty` method on `Type`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException">
          <span data-ttu-id="60b19-235">En el enlazador predeterminado, <paramref name="match" /> contiene varias propiedades que constituyen coincidencias igualmente buenas para <paramref name="returnType" /> e <paramref name="indexes" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-235">For the default binder, <paramref name="match" /> contains multiple properties that are equally good matches for <paramref name="returnType" /> and <paramref name="indexes" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="60b19-236">En el enlazador predeterminado, <paramref name="match" /> es <see langword="null" /> o una matriz vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="60b19-236">For the default binder, <paramref name="match" /> is <see langword="null" /> or an empty array.</span>
          </span>
        </exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
      </Docs>
    </Member>
  </Members>
</Type>