<Type Name="Assembly" FullName="System.Reflection.Assembly">
  <Metadata><Meta Name="ms.openlocfilehash" Value="05adb251a801722ef316092a68b4bda8ac4f1500" /><Meta Name="ms.sourcegitcommit" Value="67e8bb367eab32b26025454e7769040cfb1d71c4" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/09/2019" /><Meta Name="ms.locfileid" Value="57701389" /></Metadata><TypeSignature Language="C#" Value="public abstract class Assembly : System.Reflection.ICustomAttributeProvider, System.Runtime.InteropServices._Assembly, System.Runtime.Serialization.ISerializable, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract serializable beforefieldinit Assembly extends System.Object implements class System.Reflection.ICustomAttributeProvider, class System.Runtime.InteropServices._Assembly, class System.Runtime.Serialization.ISerializable, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.Assembly" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Assembly&#xA;Implements _Assembly, ICustomAttributeProvider, IEvidenceFactory, ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Assembly abstract : System::Reflection::ICustomAttributeProvider, System::Runtime::InteropServices::_Assembly, System::Runtime::Serialization::ISerializable, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type Assembly = class&#xA;    interface ICustomAttributeProvider&#xA;    interface _Assembly&#xA;    interface IEvidenceFactory&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.ICustomAttributeProvider</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Assembly</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Assembly))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="ba04a-101">Representa un ensamblado, que es un bloque de compilación reutilizable, versionable y autodescriptivo de una aplicación de Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="ba04a-101">Represents an assembly, which is a reusable, versionable, and self-describing building block of a common language runtime application.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-102">Use la <xref:System.Reflection.Assembly> clase para cargar ensamblados, para explorar las partes constituyentes y metadatos de los ensamblados, para detectar los tipos contenidos en ensamblados y crear instancias de esos tipos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-102">Use the <xref:System.Reflection.Assembly> class to load assemblies, to explore the metadata and constituent parts of assemblies, to discover the types contained in assemblies, and to create instances of those types.</span></span>  
  
 <span data-ttu-id="ba04a-103">Para obtener una matriz de <xref:System.Reflection.Assembly> objetos que representan los ensamblados actualmente cargados en un dominio de aplicación (por ejemplo, el dominio de aplicación predeterminado de un proyecto simple), use el <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-103">To get an array of <xref:System.Reflection.Assembly> objects representing the assemblies currently loaded into an application domain (for example, the default application domain of a simple project), use the <xref:System.AppDomain.GetAssemblies%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="ba04a-104">Para cargar ensamblados dinámicamente, el <xref:System.Reflection.Assembly> clase proporciona los siguientes métodos estáticos (`Shared` métodos en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ba04a-104">To load assemblies dynamically, the <xref:System.Reflection.Assembly> class provides the following static methods (`Shared` methods in Visual Basic).</span></span> <span data-ttu-id="ba04a-105">Los ensamblados se cargan en el dominio de aplicación donde se produce la operación de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-105">Assemblies are loaded into the application domain where the load operation occurs.</span></span>  
  
-   <span data-ttu-id="ba04a-106">La manera recomendada para cargar ensamblados es usar el <xref:System.AppDomain.Load%2A> método, que identifica el ensamblado que va a cargar su nombre para mostrar (por ejemplo, "System.Windows.Forms, Version = 2.0.0.0, referencia cultural = neutral, PublicKeyToken = b77a5c561934e089").</span><span class="sxs-lookup"><span data-stu-id="ba04a-106">The recommended way to load assemblies is to use the <xref:System.AppDomain.Load%2A> method, which identifies the assembly to be loaded by its display name (for example, "System.Windows.Forms, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089").</span></span> <span data-ttu-id="ba04a-107">La búsqueda del ensamblado sigue las reglas descritas en [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-107">The search for the assembly follows the rules described in [How the Runtime Locates Assemblies](~/docs/framework/deployment/how-the-runtime-locates-assemblies.md).</span></span>  
  
-   <span data-ttu-id="ba04a-108">El <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos permiten cargar un ensamblado para la reflexión, pero no para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-108">The <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods enable you to load an assembly for reflection, but not for execution.</span></span> <span data-ttu-id="ba04a-109">Por ejemplo, un ensamblado que tenga como destino una plataforma de 64 bits puede ser examinado por código que se ejecuta en una plataforma de 32 bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-109">For example, an assembly that targets a 64-bit platform can be examined by code that is running on a 32-bit platform.</span></span>  
  
-   <span data-ttu-id="ba04a-110">El <xref:System.Reflection.Assembly.LoadFile%2A> y <xref:System.Reflection.Assembly.LoadFrom%2A> se proporcionan métodos para los escasos escenarios en los que un ensamblado debe ser identificado por la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-110">The <xref:System.Reflection.Assembly.LoadFile%2A> and <xref:System.Reflection.Assembly.LoadFrom%2A> methods are provided for rare scenarios in which an assembly must be identified by path.</span></span>  
  
 <span data-ttu-id="ba04a-111">Para obtener un <xref:System.Reflection.Assembly> objeto para el ensamblado actualmente en ejecución, use el <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-111">To get an <xref:System.Reflection.Assembly> object for the currently executing assembly, use the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method.</span></span>  
  
 <span data-ttu-id="ba04a-112">Muchos de los miembros de la <xref:System.Reflection.Assembly> clase proporcionan información sobre un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-112">Many members of the <xref:System.Reflection.Assembly> class provide information about an assembly.</span></span> <span data-ttu-id="ba04a-113">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="ba04a-113">For example:</span></span>  
  
-   <span data-ttu-id="ba04a-114">El <xref:System.Reflection.Assembly.GetName%2A> método devuelve un <xref:System.Reflection.AssemblyName> objeto que proporciona acceso a las partes del nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-114">The <xref:System.Reflection.Assembly.GetName%2A> method returns an <xref:System.Reflection.AssemblyName> object that provides access to the parts of the assembly display name.</span></span>  
  
-   <span data-ttu-id="ba04a-115">El <xref:System.Reflection.Assembly.GetCustomAttributes%2A> método enumera los atributos aplicados al ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-115">The <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method lists the attributes applied to the assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-116">El <xref:System.Reflection.Assembly.GetFiles%2A> método proporciona acceso a los archivos en el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-116">The <xref:System.Reflection.Assembly.GetFiles%2A> method provides access to the files in the assembly manifest.</span></span>  
  
-   <span data-ttu-id="ba04a-117">El <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> método proporciona los nombres de los recursos en el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-117">The <xref:System.Reflection.Assembly.GetManifestResourceNames%2A> method provides the names of the resources in the assembly manifest.</span></span>  
  
 <span data-ttu-id="ba04a-118">El <xref:System.Reflection.Assembly.GetTypes%2A> método enumera todos los tipos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-118">The <xref:System.Reflection.Assembly.GetTypes%2A> method lists all the types in the assembly.</span></span> <span data-ttu-id="ba04a-119">El <xref:System.Reflection.Assembly.GetExportedTypes%2A> método enumera los tipos que son visibles para los llamadores fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-119">The <xref:System.Reflection.Assembly.GetExportedTypes%2A> method lists the types that are visible to callers outside the assembly.</span></span> <span data-ttu-id="ba04a-120">El <xref:System.Reflection.Assembly.GetType%2A> método puede utilizarse para buscar un tipo determinado en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-120">The <xref:System.Reflection.Assembly.GetType%2A> method can be used to search for a particular type in the assembly.</span></span> <span data-ttu-id="ba04a-121">El <xref:System.Reflection.Assembly.CreateInstance%2A> método puede utilizarse para buscar y crear instancias de tipos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-121">The <xref:System.Reflection.Assembly.CreateInstance%2A> method can be used to search for and create instances of types in the assembly.</span></span>  
  
 <span data-ttu-id="ba04a-122">Para obtener más información sobre los ensamblados, vea la sección "Dominios de aplicación y ensamblados" en el [dominios de aplicación](~/docs/framework/app-domains/application-domains.md) tema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-122">For more information on assemblies, see the "Application Domains and Assemblies" section in the [Application Domains](~/docs/framework/app-domains/application-domains.md) topic.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-123">El ejemplo de código siguiente muestra cómo obtener el ensamblado actualmente en ejecución, cree una instancia de un tipo de contenido en ese ensamblado e invocar uno de los métodos del tipo con el enlace en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-123">The following code example shows how to obtain the currently executing assembly, create an instance of a type contained in that assembly, and invoke one of the type's methods with late binding.</span></span> <span data-ttu-id="ba04a-124">Para este propósito, el ejemplo de código define una clase denominada `Example`, con un método denominado `SampleMethod`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-124">For this purpose, the code example defines a class named `Example`, with a method named `SampleMethod`.</span></span> <span data-ttu-id="ba04a-125">El constructor de la clase acepta un entero, que se usa para calcular el valor devuelto del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-125">The constructor of the class accepts an integer, which is used to compute the return value of the method.</span></span>  
  
 <span data-ttu-id="ba04a-126">El ejemplo de código también muestra el uso de la <xref:System.Reflection.Assembly.GetName%2A> método para obtener un <xref:System.Reflection.AssemblyName> objeto que se puede usar para analizar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-126">The code example also demonstrates the use of the <xref:System.Reflection.Assembly.GetName%2A> method to obtain an <xref:System.Reflection.AssemblyName> object that can be used to parse the full name of the assembly.</span></span> <span data-ttu-id="ba04a-127">En el ejemplo se muestra el número de versión del ensamblado, el <xref:System.Reflection.Assembly.CodeBase%2A> propiedad y el <xref:System.Reflection.Assembly.EntryPoint%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-127">The example displays the version number of the assembly, the <xref:System.Reflection.Assembly.CodeBase%2A> property, and the <xref:System.Reflection.Assembly.EntryPoint%2A> property.</span></span>  
  
 [!code-cpp[AssemblyClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyClass/cpp/source.cpp#1)]
 [!code-csharp[AssemblyClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyClass/cs/source.cs#1)]
 [!code-vb[AssemblyClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyClass/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="ba04a-128">para plena confianza para los herederos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-128">for full trust for inheritors.</span></span> <span data-ttu-id="ba04a-129">No se puede heredar esta clase por código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="ba04a-129">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="ba04a-130">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-130">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.AppDomain" />
    <altmember cref="T:System.Reflection.AssemblyName" />
    <related type="Article" href="~/docs/framework/app-domains/application-domains.md"><span data-ttu-id="ba04a-131">Dominios de aplicación</span><span class="sxs-lookup"><span data-stu-id="ba04a-131">Application Domains</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Assembly ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Assembly();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-132">Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-132">Initializes a new instance of the <see cref="T:System.Reflection.Assembly" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-133">Este constructor se invoca por clases derivadas durante la construcción de <xref:System.Reflection.Assembly> objetos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-133">This constructor is invoked by derived classes during the construction of <xref:System.Reflection.Assembly> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeBase">
      <MemberSignature Language="C#" Value="public virtual string CodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string CodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ CodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeBase : string" Usage="System.Reflection.Assembly.CodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.CodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-134">Obtiene la ubicación del ensamblado tal como se especificó originalmente, por ejemplo, en un objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-134">Gets the location of the assembly as specified originally, for example, in an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span></summary>
        <value><span data-ttu-id="ba04a-135">Ubicación del ensamblado tal y como se especificó originalmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-135">The location of the assembly as specified originally.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-136">Para obtener la ruta de acceso absoluta del archivo cargado que contiene el manifiesto, use el <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> propiedad en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-136">To get the absolute path to the loaded manifest-containing file, use the <xref:System.Reflection.Assembly.Location%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="ba04a-137">Si el ensamblado se cargó como una matriz de bytes, se usa una sobrecarga de la <xref:System.Reflection.Assembly.Load%2A> método que toma una matriz de bytes, esta propiedad devuelve la ubicación del llamador del método, no la ubicación del ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-137">If the assembly was loaded as a byte array, using an overload of the <xref:System.Reflection.Assembly.Load%2A> method that takes an array of bytes, this property returns the location of the caller of the method, not the location of the loaded assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-138">En el ejemplo siguiente se usa el <xref:System.Reflection.Assembly.CodeBase%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-138">The following example uses the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/codebase1.cpp#1)]
 [!code-csharp[System.Reflection.Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/codebase1.cs#1)]
 [!code-vb[System.Reflection.Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/codebase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-139">Para obtener acceso a la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-139">for access to the path.</span></span> <span data-ttu-id="ba04a-140">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-140">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-141">Localiza un tipo en este ensamblado y crea una instancia de dicho tipo mediante el activador del sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-141">Locates a type from this assembly and creates an instance of it using the system activator.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string -&gt; obj&#xA;override this.CreateInstance : string -&gt; obj" Usage="assembly.CreateInstance typeName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="ba04a-142"><see cref="P:System.Type.FullName" /> del tipo que se va a localizar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-142">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <summary><span data-ttu-id="ba04a-143">Localiza el tipo especificado en este ensamblado y crea una instancia del tipo mediante el activador del sistema, realizando una búsqueda en la que se distingue entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-143">Locates the specified type from this assembly and creates an instance of it using the system activator, using case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="ba04a-144">Instancia del tipo especificado creada con el constructor predeterminado, o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-144">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="ba04a-145">El tipo se resuelve usando el enlazador predeterminado, sin especificar atributos de activación o referencia cultural, y con el objeto <see cref="T:System.Reflection.BindingFlags" /> establecido en <see langword="Public" /> o <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-145">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-146">Si no puede encontrar el tiempo de ejecución `typeName` en el <xref:System.Reflection.Assembly> de instancia, devuelve `null` en lugar de producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-146">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="ba04a-147">Esto podría deberse a que:</span><span class="sxs-lookup"><span data-stu-id="ba04a-147">This might happen because:</span></span>  
  
-   <span data-ttu-id="ba04a-148">No ha especificado el nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-148">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="ba04a-149">Ha especificado el nombre de tipo completo, pero su caso no coincide con el caso de que el tipo <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-149">You've specified the fully qualified type name, but its case doesn't match the case of the type's <xref:System.Type.FullName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ba04a-150">Para obtener una comparación entre mayúsculas y minúsculas de `typeName` con el nombre del tipo completo, llame a la <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> sobrecarga y especifique `true` para el `ignoreCase` argumento.</span><span class="sxs-lookup"><span data-stu-id="ba04a-150">For a case-insensitive comparison of `typeName` with the type's full name, call the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specify `true` for the `ignoreCase` argument.</span></span>  
  
-   <span data-ttu-id="ba04a-151">El tipo no existe en la clase <xref:System.Reflection.Assembly> instancia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-151">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-152">En el ejemplo siguiente se define un `Person` clase y llama a la <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método para crear instancias de ella.</span><span class="sxs-lookup"><span data-stu-id="ba04a-152">The following example defines a `Person` class and calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance1.cs#1)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-153"><paramref name="typeName" /> es una cadena vacía ("") o una cadena que comienza con un carácter nulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-153"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="ba04a-154">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-154">-or-</span></span> 
<span data-ttu-id="ba04a-155">El ensamblado actual se ha cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-155">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-156"><paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-156"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="ba04a-157">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-157">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-158"><paramref name="typeName" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-158"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-159"><paramref name="typeName" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-159"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-160">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-160">-or-</span></span> 
<span data-ttu-id="ba04a-161">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="typeName" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-161">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-162"><paramref name="typeName" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-162"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-163">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-163">-or-</span></span> 
 <span data-ttu-id="ba04a-164"><paramref name="typeName" /> requiere un ensamblado dependiente que se compiló para una versión del tiempo de ejecución que es posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-164"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-165">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-165">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-166">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-166">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public object CreateInstance (string typeName, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (typeName As String, ignoreCase As Boolean) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool -&gt; obj&#xA;override this.CreateInstance : string * bool -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="ba04a-167"><see cref="P:System.Type.FullName" /> del tipo que se va a localizar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-167">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba04a-168">Es <see langword="true" /> para no hacer distinción entre mayúsculas y minúsculas en el nombre del tipo; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-168"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-169">Ubica el tipo especificado de este ensamblado y crea una instancia de dicho tipo mediante el activador del sistema, con búsqueda de mayúsculas y minúsculas opcional.</span><span class="sxs-lookup"><span data-stu-id="ba04a-169">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="ba04a-170">Instancia del tipo especificado creada con el constructor predeterminado, o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-170">An instance of the specified type created with the default constructor; or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="ba04a-171">El tipo se resuelve usando el enlazador predeterminado, sin especificar atributos de activación o referencia cultural, y con el objeto <see cref="T:System.Reflection.BindingFlags" /> establecido en <see langword="Public" /> o <see langword="Instance" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-171">The type is resolved using the default binder, without specifying culture or activation attributes, and with <see cref="T:System.Reflection.BindingFlags" /> set to <see langword="Public" /> or <see langword="Instance" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-172">Si no puede encontrar el tiempo de ejecución `typeName` en el <xref:System.Reflection.Assembly> de instancia, devuelve `null` en lugar de producir una excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-172">If the runtime is unable to find `typeName` in the <xref:System.Reflection.Assembly> instance, it returns `null` instead of throwing an exception.</span></span> <span data-ttu-id="ba04a-173">Esto podría deberse a que:</span><span class="sxs-lookup"><span data-stu-id="ba04a-173">This might happen because:</span></span>  
  
-   <span data-ttu-id="ba04a-174">No ha especificado el nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-174">You haven't specified the fully qualified name of the type.</span></span>  
  
-   <span data-ttu-id="ba04a-175">El tipo no existe en la clase <xref:System.Reflection.Assembly> instancia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-175">The type doesn't exist in the current <xref:System.Reflection.Assembly> instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-176">En el ejemplo siguiente se define un `Person` clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-176">The following example defines a `Person` class.</span></span> <span data-ttu-id="ba04a-177">A continuación, llama el <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> método para crear instancias de él, pero dado que las mayúsculas y minúsculas de la `typeName` argumento no coincide con el tipo de <xref:System.Type.FullName%2A> propiedad, el método devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-177">It then calls the <xref:System.Reflection.Assembly.CreateInstance%28System.String%29> method to instantiate it, but because the casing of the `typeName` argument doesn't match that of the type's <xref:System.Type.FullName%2A> property, the method returns `null`.</span></span> <span data-ttu-id="ba04a-178">Cuando el ejemplo pasa la misma cadena a la <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> sobrecarga y especifica que la comparación debe ser entre mayúsculas y minúsculas, el `Person` se encuentra la clase y un `Person` correctamente se crea una instancia del objeto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-178">When the example passes the same string to the <xref:System.Reflection.Assembly.CreateInstance%28System.String%2CSystem.Boolean%29> overload and specifies that the comparison should be case-insensitive, the `Person` class is found, and a `Person` object is successfully instantiated.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/cs/createinstance2.cs#2)]
 [!code-vb[System.Reflection.Assembly.CreateInstance#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.createinstance/vb/createinstance2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-179"><paramref name="typeName" /> es una cadena vacía ("") o una cadena que comienza con un carácter nulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-179"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="ba04a-180">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-180">-or-</span></span> 
<span data-ttu-id="ba04a-181">El ensamblado actual se ha cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-181">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="ba04a-182">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-182">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-183"><paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-183"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-184"><paramref name="typeName" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-184"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-185"><paramref name="typeName" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-185"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-186">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-186">-or-</span></span> 
<span data-ttu-id="ba04a-187">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="typeName" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-187">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-188"><paramref name="typeName" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-188"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-189">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-189">-or-</span></span> 
 <span data-ttu-id="ba04a-190"><paramref name="typeName" /> requiere un ensamblado dependiente que se compiló para una versión del tiempo de ejecución que es posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-190"><paramref name="typeName" /> requires a dependent assembly that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-191">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-191">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-192">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-192">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public virtual object CreateInstance (string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object CreateInstance(string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ CreateInstance(System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj&#xA;override this.CreateInstance : string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="assembly.CreateInstance (typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.CreateInstance(System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="ba04a-193"><see cref="P:System.Type.FullName" /> del tipo que se va a localizar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-193">The <see cref="P:System.Type.FullName" /> of the type to locate.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba04a-194">Es <see langword="true" /> para no hacer distinción entre mayúsculas y minúsculas en el nombre del tipo; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-194"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="ba04a-195">Máscara de bits que afecta al modo de realizar la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="ba04a-195">A bitmask that affects the way in which the search is conducted.</span></span> <span data-ttu-id="ba04a-196">El valor es una combinación de marcadores de bits de <see cref="T:System.Reflection.BindingFlags" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-196">The value is a combination of bit flags from <see cref="T:System.Reflection.BindingFlags" />.</span></span></param>
        <param name="binder"><span data-ttu-id="ba04a-197">Objeto que habilita el enlace, la conversión de tipos de argumentos, las llamadas a miembros y la recuperación de objetos <see langword="MemberInfo" /> mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-197">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see langword="MemberInfo" /> objects via reflection.</span></span> <span data-ttu-id="ba04a-198">Si <paramref name="binder" /> es <see langword="null" />, se usa el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-198">If <paramref name="binder" /> is <see langword="null" />, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="ba04a-199">Matriz que contiene los argumentos que se pasarán al constructor.</span><span class="sxs-lookup"><span data-stu-id="ba04a-199">An array that contains the arguments to be passed to the constructor.</span></span> <span data-ttu-id="ba04a-200">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor al que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-200">This array of arguments must match in number, order, and type the parameters of the constructor to be invoked.</span></span> <span data-ttu-id="ba04a-201">Si se desea el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-201">If the default constructor is desired, <paramref name="args" /> must be an empty array or <see langword="null" />.</span></span></param>
        <param name="culture"><span data-ttu-id="ba04a-202">Instancia de <see langword="CultureInfo" /> usada para regir la conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-202">An instance of <see langword="CultureInfo" /> used to govern the coercion of types.</span></span> <span data-ttu-id="ba04a-203">Si es <see langword="null" />, se utiliza <see langword="CultureInfo" /> para el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-203">If this is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span> <span data-ttu-id="ba04a-204">(Esto es necesario para convertir un objeto <see langword="String" /> que representa 1000 en un valor <see langword="Double" />, por ejemplo, dado que 1000 se representa de maneras diferentes según la referencia cultural).</span><span class="sxs-lookup"><span data-stu-id="ba04a-204">(This is necessary to convert a <see langword="String" /> that represents 1000 to a <see langword="Double" /> value, for example, since 1000 is represented differently by different cultures.)</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="ba04a-205">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-205">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="ba04a-206">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-206">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  <span data-ttu-id="ba04a-207">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-207">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="ba04a-208">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-208">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="ba04a-209">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="ba04a-209">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="ba04a-210">Ubica el tipo especificado en este ensamblado y crea una instancia de dicho tipo mediante el activador del sistema, con búsqueda de mayúsculas y minúsculas opcional y con los atributos de referencia cultural, argumentos, enlace y activación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-210">Locates the specified type from this assembly and creates an instance of it using the system activator, with optional case-sensitive search and having the specified culture, arguments, and binding and activation attributes.</span></span></summary>
        <returns><span data-ttu-id="ba04a-211">Instancia del tipo especificado, o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-211">An instance of the specified type, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="ba04a-212">Los argumentos proporcionados se utilizan para resolver el tipo y para enlazar el constructor que se utiliza para crear la instancia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-212">The supplied arguments are used to resolve the type, and to bind the constructor that is used to create the instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-213"><paramref name="typeName" /> es una cadena vacía ("") o una cadena que comienza con un carácter nulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-213"><paramref name="typeName" /> is an empty string ("") or a string beginning with a null character.</span></span>  
  
<span data-ttu-id="ba04a-214">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-214">-or-</span></span> 
<span data-ttu-id="ba04a-215">El ensamblado actual se ha cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-215">The current assembly was loaded into the reflection-only context.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-216"><paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-216"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="ba04a-217">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-217">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba04a-218">Una matriz de atributos de activación no vacía se pasa a un tipo que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-218">A non-empty activation attributes array is passed to a type that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-219"><paramref name="typeName" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-219"><paramref name="typeName" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-220"><paramref name="typeName" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-220"><paramref name="typeName" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-221">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-221">-or-</span></span> 
<span data-ttu-id="ba04a-222">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="typeName" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-222">The current assembly was loaded into the reflection-only context, and <paramref name="typeName" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-223"><paramref name="typeName" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-223"><paramref name="typeName" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-224">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-224">-or-</span></span> 
 <span data-ttu-id="ba04a-225"><paramref name="typeName" /> requiere un ensamblado dependiente compilado para una versión del sistema en tiempo de ejecución posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-225"><paramref name="typeName" /> requires a dependent assembly which that was compiled for a version of the runtime that is later than the currently loaded version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-226">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-226">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-227">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-227">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-228">Para crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-228">to create an instance of a delegate.</span></span> <span data-ttu-id="ba04a-229">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-229">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateQualifiedName">
      <MemberSignature Language="C#" Value="public static string CreateQualifiedName (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string CreateQualifiedName(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.CreateQualifiedName(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateQualifiedName (assemblyName As String, typeName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ CreateQualifiedName(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member CreateQualifiedName : string * string -&gt; string" Usage="System.Reflection.Assembly.CreateQualifiedName (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="ba04a-230">Nombre para mostrar de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-230">The display name of an assembly.</span></span></param>
        <param name="typeName"><span data-ttu-id="ba04a-231">Nombre completo de un tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-231">The full name of a type.</span></span></param>
        <summary><span data-ttu-id="ba04a-232">Crea el nombre de un tipo calificado con el nombre de presentación de su ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-232">Creates the name of a type qualified by the display name of its assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-233">Nombre completo del tipo calificado por el nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-233">The full name of the type qualified by the display name of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-234">El formato de la cadena devuelta es:</span><span class="sxs-lookup"><span data-stu-id="ba04a-234">The format of the returned string is:</span></span>  
  
 <span data-ttu-id="ba04a-235">\<FullTypeName>, \<AssemblyDisplayName></span><span class="sxs-lookup"><span data-stu-id="ba04a-235">\<FullTypeName>, \<AssemblyDisplayName></span></span>  
  
 <span data-ttu-id="ba04a-236">Consulte <xref:System.Reflection.AssemblyName> para obtener una descripción del formato del nombre para mostrar de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-236">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
 <span data-ttu-id="ba04a-237">Para dar cabida a cambios en versiones de common language runtime, utilice este método en lugar de construir el nombre calificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-237">To accommodate changes in versions of the common language runtime, use this method rather than constructing the qualified name yourself.</span></span>  <span data-ttu-id="ba04a-238">Para obtener información acerca de los nombres de ensamblado completo, vea <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-238">For information about qualified assembly names, see <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CustomAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt; CustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.CustomAttributeData&gt; CustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.CustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property CustomAttributes As IEnumerable(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ CustomAttributes { System::Collections::Generic::IEnumerable&lt;System::Reflection::CustomAttributeData ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CustomAttributes : seq&lt;System.Reflection.CustomAttributeData&gt;" Usage="System.Reflection.Assembly.CustomAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-239">Obtiene una colección que contiene los atributos personalizados de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-239">Gets a collection that contains this assembly's custom attributes.</span></span></summary>
        <value><span data-ttu-id="ba04a-240">Colección que contiene los atributos personalizados de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-240">A collection that contains this assembly's custom attributes.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DefinedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt; DefinedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.TypeInfo&gt; DefinedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.DefinedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DefinedTypes As IEnumerable(Of TypeInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ DefinedTypes { System::Collections::Generic::IEnumerable&lt;System::Reflection::TypeInfo ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefinedTypes : seq&lt;System.Reflection.TypeInfo&gt;" Usage="System.Reflection.Assembly.DefinedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.TypeInfo&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-241">Obtiene una colección de los tipos definidos en este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-241">Gets a collection of the types defined in this assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-242">Colección de los tipos definidos en este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-242">A collection of the types defined in this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-243">El <xref:System.Reflection.Assembly.DefinedTypes%2A> es comparable a la propiedad el <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método, salvo que el <xref:System.Reflection.Assembly.DefinedTypes%2A> propiedad devuelve una colección de <xref:System.Reflection.TypeInfo> objetos y el <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> método devuelve una matriz de <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-243">The <xref:System.Reflection.Assembly.DefinedTypes%2A> property is comparable to the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method, except that the <xref:System.Reflection.Assembly.DefinedTypes%2A> property returns a collection of <xref:System.Reflection.TypeInfo> objects, and the <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType> method returns an array of <xref:System.Type> objects.</span></span>  
  
 <span data-ttu-id="ba04a-244">La matriz devuelta incluye tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-244">The returned array includes nested types.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.Assembly.GetTypes" />
      </Docs>
    </Member>
    <Member MemberName="EntryPoint">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo EntryPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodInfo EntryPoint" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EntryPoint" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EntryPoint As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodInfo ^ EntryPoint { System::Reflection::MethodInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EntryPoint : System.Reflection.MethodInfo" Usage="System.Reflection.Assembly.EntryPoint" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EntryPoint</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-245">Obtiene el punto de entrada de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-245">Gets the entry point of this assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-246">Objeto que representa el punto de entrada de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-246">An object that represents the entry point of this assembly.</span></span> <span data-ttu-id="ba04a-247">Si no se encuentra ningún punto de entrada (por ejemplo, el ensamblado es una DLL), se devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-247">If no entry point is found (for example, the assembly is a DLL), <see langword="null" /> is returned.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="assembly.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="ba04a-248">Objeto que se va a comparar con esta instancia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-248">The object to compare with this instance.</span></span></param>
        <summary><span data-ttu-id="ba04a-249">Determina si este ensamblado y el objeto especificado son iguales.</span><span class="sxs-lookup"><span data-stu-id="ba04a-249">Determines whether this assembly and the specified object are equal.</span></span></summary>
        <returns><span data-ttu-id="ba04a-250"><see langword="true" /> si <paramref name="o" /> es igual a esta instancia; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-250"><see langword="true" /> if <paramref name="o" /> is equal to this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-251">El <xref:System.Reflection.Assembly.Equals%2A> método realiza una prueba de igualdad de referencia determinar si la instancia actual y `o` son iguales.</span><span class="sxs-lookup"><span data-stu-id="ba04a-251">The <xref:System.Reflection.Assembly.Equals%2A> method performs a test for reference equality to determine whether the current instance and `o` are equal.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EscapedCodeBase">
      <MemberSignature Language="C#" Value="public virtual string EscapedCodeBase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string EscapedCodeBase" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.EscapedCodeBase" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property EscapedCodeBase As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ EscapedCodeBase { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.EscapedCodeBase : string" Usage="System.Reflection.Assembly.EscapedCodeBase" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.EscapedCodeBase</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-252">Obtiene el identificador URI, incluidos los caracteres de escape, que representa el código base.</span><span class="sxs-lookup"><span data-stu-id="ba04a-252">Gets the URI, including escape characters, that represents the codebase.</span></span></summary>
        <value><span data-ttu-id="ba04a-253">URI con caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-253">A URI with escape characters.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-254">Para obtener acceso a la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-254">for access to the path.</span></span> <span data-ttu-id="ba04a-255">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-255">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public virtual System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.Reflection.Assembly.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Evidence</InterfaceMember>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-256">Obtiene la evidencia para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-256">Gets the evidence for this assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-257">Evidencia de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-257">The evidence for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-258">La evidencia es el conjunto de información que se utiliza para tomar decisiones de la directiva de seguridad, por ejemplo, qué permisos se conceden al código.</span><span class="sxs-lookup"><span data-stu-id="ba04a-258">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-259">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-259">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-260">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-260">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExportedTypes">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;Type&gt; ExportedTypes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Type&gt; ExportedTypes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ExportedTypes As IEnumerable(Of Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ ExportedTypes { System::Collections::Generic::IEnumerable&lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExportedTypes : seq&lt;Type&gt;" Usage="System.Reflection.Assembly.ExportedTypes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Type&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-261">Obtiene una colección de los tipos públicos definidos en este ensamblado que se pueden ver desde fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-261">Gets a collection of the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-262">Colección de los tipos públicos definidos en este ensamblado que se pueden ver desde fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-262">A collection of the public types defined in this assembly that are visible outside the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public virtual string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.FullName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Reflection.Assembly.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-263">Obtiene el nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-263">Gets the display name of the assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-264">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-264">The display name of the assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-265">Consulte <xref:System.Reflection.AssemblyName> para obtener una descripción del formato del nombre para mostrar de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-265">See <xref:System.Reflection.AssemblyName> for a description of the format of the display name of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-266">No se recomienda escribir su propio código para analizar los nombres para mostrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-266">Writing your own code to parse display names is not recommended.</span></span> <span data-ttu-id="ba04a-267">En su lugar, pase el nombre para mostrar el <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, que lo analiza y rellena los campos adecuados del nuevo <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-267">Instead, pass the display name to the <xref:System.Reflection.AssemblyName.%23ctor%2A> constructor, which parses it and populates the appropriate fields of the new <xref:System.Reflection.AssemblyName>.</span></span>  
  
 <span data-ttu-id="ba04a-268">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-268">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="ba04a-269">Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Reflection.Assembly.FullName%2A> propiedad, por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-269">However, it is not included in the string returned by the <xref:System.Reflection.Assembly.FullName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="ba04a-270">Vea <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-270">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-271">El ejemplo siguiente recupera el nombre para mostrar del ensamblado actualmente en ejecución y el nombre para mostrar del ensamblado que contiene el <xref:System.Int32> tipo (`int` en C#, `Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ba04a-271">The following example retrieves the display name of the currently executing assembly, and the display name of the assembly that contains the <xref:System.Int32> type (`int` in C#, `Integer` in Visual Basic).</span></span>  
  
 [!code-cpp[Assembly.FullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.FullName/CPP/Example.cpp#1)]
 [!code-csharp[Assembly.FullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.FullName/CS/Example.cs#1)]
 [!code-vb[Assembly.FullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.FullName/VB/Example.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="ba04a-272">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="ba04a-272">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetAssembly (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetAssembly(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetAssembly(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetAssembly : Type -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetAssembly type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="ba04a-273">Objeto que representa un tipo del ensamblado que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="ba04a-273">An object representing a type in the assembly that will be returned.</span></span></param>
        <summary><span data-ttu-id="ba04a-274">Obtiene el ensamblado cargado actualmente en el que se define el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-274">Gets the currently loaded assembly in which the specified type is defined.</span></span></summary>
        <returns><span data-ttu-id="ba04a-275">Ensamblado en el que se define el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-275">The assembly in which the specified type is defined.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-276">Llamar a este método es equivalente a recuperar el valor de la <xref:System.Type.Assembly?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-276">Calling this method is equivalent to retrieving the value of the  <xref:System.Type.Assembly?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ba04a-277">Sin embargo, el <xref:System.Type.Assembly?displayProperty=nameWithType> propiedad normalmente ofrece un rendimiento superior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-277">However, the <xref:System.Type.Assembly?displayProperty=nameWithType> property typically offers superior performance.</span></span>  
  
 <span data-ttu-id="ba04a-278">Para poder llamar a este método, debe tener un <xref:System.Type> objeto, lo que significa que el ensamblado en el que se define la clase ya debe estar cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-278">In order to call this method, you must have a <xref:System.Type> object, which means that the assembly in which the class is defined must already be loaded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-279">En el ejemplo siguiente se recupera el ensamblado que contiene el <xref:System.Int32> escriba y muestra su nombre y ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-279">The following example retrieves the assembly that contains the <xref:System.Int32> type and displays its name and file location.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/GetAssembly1.cpp#12)]
 [!code-csharp[System.Reflection.Assembly#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/GetAssembly1.cs#12)]
 [!code-vb[System.Reflection.Assembly#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/GetAssembly1.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-280"><paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-280"><paramref name="type" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-281">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-281">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-282">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-282">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCallingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetCallingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetCallingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCallingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCallingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetCallingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetCallingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetCallingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-283">Devuelve el <see cref="T:System.Reflection.Assembly" /> del método al que llamó el método actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-283">Returns the <see cref="T:System.Reflection.Assembly" /> of the method that invoked the currently executing method.</span></span></summary>
        <returns><span data-ttu-id="ba04a-284">Objeto <see langword="Assembly" /> del método al que llamó el método actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-284">The <see langword="Assembly" /> object of the method that invoked the currently executing method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-285">Si el método que llama el <xref:System.Reflection.Assembly.GetCallingAssembly%2A> método está expandido en línea por el compilador just-in-time (JIT), o si su llamador se expanden en línea, el ensamblado que es devuelto por <xref:System.Reflection.Assembly.GetCallingAssembly%2A> pueden diferir de forma inesperada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-285">If the method that calls the <xref:System.Reflection.Assembly.GetCallingAssembly%2A> method is expanded inline by the just-in-time (JIT) compiler, or if its caller is expanded inline, the assembly that is returned by <xref:System.Reflection.Assembly.GetCallingAssembly%2A> may differ unexpectedly.</span></span> <span data-ttu-id="ba04a-286">Por ejemplo, considere los siguientes métodos y ensamblados:</span><span class="sxs-lookup"><span data-stu-id="ba04a-286">For example, consider the following methods and assemblies:</span></span>  
  
-   <span data-ttu-id="ba04a-287">Método `M1` en ensamblado `A1` llamadas <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-287">Method `M1` in assembly `A1` calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
-   <span data-ttu-id="ba04a-288">Método `M2` en ensamblado `A2` llamadas `M1`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-288">Method `M2` in assembly `A2` calls `M1`.</span></span>  
  
-   <span data-ttu-id="ba04a-289">Método `M3` en ensamblado `A3` llamadas `M2`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-289">Method `M3` in assembly `A3` calls `M2`.</span></span>  
  
 <span data-ttu-id="ba04a-290">Cuando `M1` no está alineada, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> devuelve `A2`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-290">When `M1` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="ba04a-291">Cuando `M1` está insertada, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> devuelve `A3`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-291">When `M1` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span> <span data-ttu-id="ba04a-292">De forma similar, cuando `M2` no está alineada, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> devuelve `A2`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-292">Similarly, when `M2` is not inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A2`.</span></span> <span data-ttu-id="ba04a-293">Cuando `M2` está insertada, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> devuelve `A3`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-293">When `M2` is inlined, <xref:System.Reflection.Assembly.GetCallingAssembly%2A> returns `A3`.</span></span>  
  
 <span data-ttu-id="ba04a-294">Este efecto también se produce cuando `M1` se ejecuta como una llamada de cola de `M2`, o cuando `M2` se ejecuta como una llamada de cola desde `M3`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-294">This effect also occurs when `M1` executes as a tail call from `M2`, or when `M2` executes as a tail call from `M3`.</span></span> <span data-ttu-id="ba04a-295">Puede evitar que el compilador JIT de inclusión entre líneas al método que llama a <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, aplicando la <xref:System.Runtime.CompilerServices.MethodImplAttribute> atributo con el <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> marca, pero no hay ningún mecanismo similar para evitar las llamadas de cola.</span><span class="sxs-lookup"><span data-stu-id="ba04a-295">You can prevent the JIT compiler from inlining the method that calls <xref:System.Reflection.Assembly.GetCallingAssembly%2A>, by applying the <xref:System.Runtime.CompilerServices.MethodImplAttribute> attribute with the <xref:System.Runtime.CompilerServices.MethodImplOptions.NoInlining?displayProperty=nameWithType> flag, but there is no similar mechanism for preventing tail calls.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-296">En el ejemplo siguiente se obtiene el ensamblado que realiza la llamada del método actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-296">The following example gets the calling assembly of the current method.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/getcallingassembly1.cpp#4)]
 [!code-csharp[System.Reflection.Assembly#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/getcallingassembly1.cs#4)]
 [!code-vb[System.Reflection.Assembly#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/getcallingassembly1.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCustomAttributes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-297">Obtiene los atributos personalizados para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-297">Gets the custom attributes for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : bool -&gt; obj[]&#xA;override this.GetCustomAttributes : bool -&gt; obj[]" Usage="assembly.GetCustomAttributes inherit" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit"><span data-ttu-id="ba04a-298">Este argumento se omite para objetos de tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-298">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-299">Obtiene todos los atributos personalizados para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-299">Gets all the custom attributes for this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-300">Matriz que contiene los atributos personalizados de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-300">An array that contains the custom attributes for this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-301">Este método implementa el correspondiente <xref:System.Reflection.ICustomAttributeProvider> método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="ba04a-301">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="ba04a-302">Por lo tanto, el `inherit` debe especificarse el parámetro incluso si se omite.</span><span class="sxs-lookup"><span data-stu-id="ba04a-302">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-303">Un atributo pseudo indica los bits de los metadatos básicos que debe establecerse cuando el atributo está presente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-303">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="ba04a-304">A diferencia de un atributo personalizado que extiende los metadatos para un tipo y se guarda junto con el tipo, un atributo pseudo modifica los metadatos para el tipo y, a continuación, se descarta.</span><span class="sxs-lookup"><span data-stu-id="ba04a-304">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="ba04a-305">Algunos de los bits resultantes no son accesibles mediante la API de reflexión existentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-305">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="ba04a-306">En la tabla siguiente se resume los diferentes atributos pseudo y los descriptores de acceso para los bits que están disponibles en la reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-306">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="ba04a-307">Atributo pseudo</span><span class="sxs-lookup"><span data-stu-id="ba04a-307">Pseudo-Attribute</span></span>|<span data-ttu-id="ba04a-308">Bits de metadatos</span><span class="sxs-lookup"><span data-stu-id="ba04a-308">Metadata Bits</span></span>|<span data-ttu-id="ba04a-309">Descriptor de acceso de reflexión</span><span class="sxs-lookup"><span data-stu-id="ba04a-309">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="ba04a-310">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-310">DllImportAttribute</span></span>|<span data-ttu-id="ba04a-311">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="ba04a-311">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="ba04a-312">Nombre del archivo DLL</span><span class="sxs-lookup"><span data-stu-id="ba04a-312">DLL name</span></span>|<span data-ttu-id="ba04a-313">Ningún descriptor de acceso para PInvokeMap para los atributos de método método normal o global.</span><span class="sxs-lookup"><span data-stu-id="ba04a-313">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="ba04a-314">Ningún descriptor de acceso para el nombre del archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="ba04a-314">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="ba04a-315">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-315">GuidAttribute</span></span>|<span data-ttu-id="ba04a-316">Se almacena como un atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="ba04a-316">Stored as a real custom attribute.</span></span>|<span data-ttu-id="ba04a-317">Puede obtener acceso como un atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="ba04a-317">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="ba04a-318">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-318">ComImportAttribute</span></span>|<span data-ttu-id="ba04a-319">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="ba04a-319">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="ba04a-320">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="ba04a-320">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="ba04a-321">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-321">SerializableAttribute</span></span>|<span data-ttu-id="ba04a-322">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="ba04a-322">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="ba04a-323">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="ba04a-323">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="ba04a-324">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-324">NonSerializedAttribute</span></span>|<span data-ttu-id="ba04a-325">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="ba04a-325">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="ba04a-326">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="ba04a-326">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="ba04a-327">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-327">MethodImplAttribute</span></span>|<span data-ttu-id="ba04a-328">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="ba04a-328">CorMethodImpl</span></span>|<span data-ttu-id="ba04a-329">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="ba04a-329">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="ba04a-330">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="ba04a-330">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="ba04a-331">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-331">MarshalAsAttribute</span></span>|<span data-ttu-id="ba04a-332">Varios bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-332">Various bits.</span></span>|<span data-ttu-id="ba04a-333">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-333">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-334">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-334">PreserveSigAttribute</span></span>|<span data-ttu-id="ba04a-335">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-335">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="ba04a-336">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-336">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="ba04a-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-337">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="ba04a-338">InAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-338">InAttribute</span></span>|<span data-ttu-id="ba04a-339">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="ba04a-339">CorParamAttr.pdIn</span></span>|<span data-ttu-id="ba04a-340">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="ba04a-340">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="ba04a-341">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-341">OutAttribute</span></span>|<span data-ttu-id="ba04a-342">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="ba04a-342">CorParamAttr.pdOut</span></span>|<span data-ttu-id="ba04a-343">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="ba04a-343">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="ba04a-344">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-344">StructLayoutAttribute</span></span>|<span data-ttu-id="ba04a-345">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="ba04a-345">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="ba04a-346">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="ba04a-346">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="ba04a-347">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-347">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="ba04a-348">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-348">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="ba04a-349">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-349">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="ba04a-350">Empaquetado de clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-350">Class packing.</span></span>|<span data-ttu-id="ba04a-351">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="ba04a-351">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="ba04a-352">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="ba04a-352">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="ba04a-353">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-353">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="ba04a-354">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-354">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="ba04a-355">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-355">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="ba04a-356">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-356">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-357">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-357">FieldOffsetAttribute</span></span>|<span data-ttu-id="ba04a-358">Desplazamiento de campo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-358">Field offset.</span></span>|<span data-ttu-id="ba04a-359">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-359">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-360">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-360">AssemblyLoadAttribute</span></span>|<span data-ttu-id="ba04a-361">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="ba04a-361">CorAssemblyFlags</span></span>|<span data-ttu-id="ba04a-362">Ningún descriptor de acceso o enumerador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-362">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-363">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-363">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-364">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-364">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributes">
      <MemberSignature Language="C#" Value="public virtual object[] GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object[] GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Object ^&gt; ^ GetCustomAttributes(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributes : Type * bool -&gt; obj[]&#xA;override this.GetCustomAttributes : Type * bool -&gt; obj[]" Usage="assembly.GetCustomAttributes (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="ba04a-365">Tipo cuyos atributos personalizados se van a devolver.</span><span class="sxs-lookup"><span data-stu-id="ba04a-365">The type for which the custom attributes are to be returned.</span></span></param>
        <param name="inherit"><span data-ttu-id="ba04a-366">Este argumento se omite para objetos de tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-366">This argument is ignored for objects of type <see cref="T:System.Reflection.Assembly" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-367">Obtiene los atributos personalizados para este ensamblado tal y como lo especifica el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-367">Gets the custom attributes for this assembly as specified by type.</span></span></summary>
        <returns><span data-ttu-id="ba04a-368">Matriz que contiene los atributos personalizados de este ensamblado tal y como lo especifica <paramref name="attributeType" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-368">An array that contains the custom attributes for this assembly as specified by <paramref name="attributeType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-369">Este método implementa el correspondiente <xref:System.Reflection.ICustomAttributeProvider> método de interfaz.</span><span class="sxs-lookup"><span data-stu-id="ba04a-369">This method implements the corresponding <xref:System.Reflection.ICustomAttributeProvider> interface method.</span></span> <span data-ttu-id="ba04a-370">Por lo tanto, el `inherit` debe especificarse el parámetro incluso si se omite.</span><span class="sxs-lookup"><span data-stu-id="ba04a-370">Therefore, the `inherit` parameter must be specified even though it is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-371">Un atributo pseudo indica los bits de los metadatos básicos que debe establecerse cuando el atributo está presente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-371">A pseudo-attribute indicates bits of the core metadata that must be set when the attribute is present.</span></span> <span data-ttu-id="ba04a-372">A diferencia de un atributo personalizado que extiende los metadatos para un tipo y se guarda junto con el tipo, un atributo pseudo modifica los metadatos para el tipo y, a continuación, se descarta.</span><span class="sxs-lookup"><span data-stu-id="ba04a-372">Unlike a custom attribute that extends the metadata for a type and is saved along with the type, a pseudo-attribute modifies the metadata for the type and then is discarded.</span></span> <span data-ttu-id="ba04a-373">Algunos de los bits resultantes no son accesibles mediante la API de reflexión existentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-373">Some of the resulting bits cannot be accessed using existing reflection APIs.</span></span>  
  
 <span data-ttu-id="ba04a-374">En la tabla siguiente se resume los diferentes atributos pseudo y los descriptores de acceso para los bits que están disponibles en la reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-374">The following table summarizes the different pseudo-attributes and the accessors for the bits that are available in reflection.</span></span>  
  
|<span data-ttu-id="ba04a-375">Atributo pseudo</span><span class="sxs-lookup"><span data-stu-id="ba04a-375">Pseudo-Attribute</span></span>|<span data-ttu-id="ba04a-376">Bits de metadatos</span><span class="sxs-lookup"><span data-stu-id="ba04a-376">Metadata Bits</span></span>|<span data-ttu-id="ba04a-377">Descriptor de acceso de reflexión</span><span class="sxs-lookup"><span data-stu-id="ba04a-377">Reflection Accessor</span></span>|  
|-----------------------|-------------------|-------------------------|  
|<span data-ttu-id="ba04a-378">DllImportAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-378">DllImportAttribute</span></span>|<span data-ttu-id="ba04a-379">CorPInvokeMap</span><span class="sxs-lookup"><span data-stu-id="ba04a-379">CorPInvokeMap</span></span><br /><br /> <span data-ttu-id="ba04a-380">Nombre del archivo DLL</span><span class="sxs-lookup"><span data-stu-id="ba04a-380">DLL name</span></span>|<span data-ttu-id="ba04a-381">Ningún descriptor de acceso para PInvokeMap para los atributos de método método normal o global.</span><span class="sxs-lookup"><span data-stu-id="ba04a-381">No accessor for PInvokeMap for ordinary method/global method attributes.</span></span><br /><br /> <span data-ttu-id="ba04a-382">Ningún descriptor de acceso para el nombre del archivo DLL.</span><span class="sxs-lookup"><span data-stu-id="ba04a-382">No accessor for DLL name.</span></span>|  
|<span data-ttu-id="ba04a-383">GuidAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-383">GuidAttribute</span></span>|<span data-ttu-id="ba04a-384">Se almacena como un atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="ba04a-384">Stored as a real custom attribute.</span></span>|<span data-ttu-id="ba04a-385">Puede obtener acceso como un atributo personalizado real.</span><span class="sxs-lookup"><span data-stu-id="ba04a-385">Accessed as a real custom attribute.</span></span>|  
|<span data-ttu-id="ba04a-386">ComImportAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-386">ComImportAttribute</span></span>|<span data-ttu-id="ba04a-387">CorTypeAttr.tdImport</span><span class="sxs-lookup"><span data-stu-id="ba04a-387">CorTypeAttr.tdImport</span></span>|<span data-ttu-id="ba04a-388">Type.Attributes.Import</span><span class="sxs-lookup"><span data-stu-id="ba04a-388">Type.Attributes.Import</span></span>|  
|<span data-ttu-id="ba04a-389">SerializableAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-389">SerializableAttribute</span></span>|<span data-ttu-id="ba04a-390">CorTypeAttr.tdSerializable</span><span class="sxs-lookup"><span data-stu-id="ba04a-390">CorTypeAttr.tdSerializable</span></span>|<span data-ttu-id="ba04a-391">Type.Attributes.Serializable</span><span class="sxs-lookup"><span data-stu-id="ba04a-391">Type.Attributes.Serializable</span></span>|  
|<span data-ttu-id="ba04a-392">NonSerializedAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-392">NonSerializedAttribute</span></span>|<span data-ttu-id="ba04a-393">CorFieldAttr.fdNotSerialized</span><span class="sxs-lookup"><span data-stu-id="ba04a-393">CorFieldAttr.fdNotSerialized</span></span>|<span data-ttu-id="ba04a-394">FieldInfo.Attributes.NotSerialized</span><span class="sxs-lookup"><span data-stu-id="ba04a-394">FieldInfo.Attributes.NotSerialized</span></span>|  
|<span data-ttu-id="ba04a-395">MethodImplAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-395">MethodImplAttribute</span></span>|<span data-ttu-id="ba04a-396">CorMethodImpl</span><span class="sxs-lookup"><span data-stu-id="ba04a-396">CorMethodImpl</span></span>|<span data-ttu-id="ba04a-397">MethodInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="ba04a-397">MethodInfo.GetMethodImplementationFlags()</span></span><br /><br /> <span data-ttu-id="ba04a-398">ConstructorInfo.GetMethodImplementationFlags()</span><span class="sxs-lookup"><span data-stu-id="ba04a-398">ConstructorInfo.GetMethodImplementationFlags()</span></span>|  
|<span data-ttu-id="ba04a-399">MarshalAsAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-399">MarshalAsAttribute</span></span>|<span data-ttu-id="ba04a-400">Varios bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-400">Various bits.</span></span>|<span data-ttu-id="ba04a-401">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-401">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-402">PreserveSigAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-402">PreserveSigAttribute</span></span>|<span data-ttu-id="ba04a-403">CorMethodImpl.miOLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-403">CorMethodImpl.miOLE</span></span>|<span data-ttu-id="ba04a-404">MethodInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-404">MethodInfo.GetMethodImplementationFlags().OLE</span></span><br /><br /> <span data-ttu-id="ba04a-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span><span class="sxs-lookup"><span data-stu-id="ba04a-405">ConstructorInfo.GetMethodImplementationFlags().OLE</span></span>|  
|<span data-ttu-id="ba04a-406">InAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-406">InAttribute</span></span>|<span data-ttu-id="ba04a-407">CorParamAttr.pdIn</span><span class="sxs-lookup"><span data-stu-id="ba04a-407">CorParamAttr.pdIn</span></span>|<span data-ttu-id="ba04a-408">ParameterInfo.Attributes.In</span><span class="sxs-lookup"><span data-stu-id="ba04a-408">ParameterInfo.Attributes.In</span></span>|  
|<span data-ttu-id="ba04a-409">OutAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-409">OutAttribute</span></span>|<span data-ttu-id="ba04a-410">CorParamAttr.pdOut</span><span class="sxs-lookup"><span data-stu-id="ba04a-410">CorParamAttr.pdOut</span></span>|<span data-ttu-id="ba04a-411">ParameterInfo.Attributes.Out</span><span class="sxs-lookup"><span data-stu-id="ba04a-411">ParameterInfo.Attributes.Out</span></span>|  
|<span data-ttu-id="ba04a-412">StructLayoutAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-412">StructLayoutAttribute</span></span>|<span data-ttu-id="ba04a-413">CorTypeAttr.tdLayoutSequential</span><span class="sxs-lookup"><span data-stu-id="ba04a-413">CorTypeAttr.tdLayoutSequential</span></span><br /><br /> <span data-ttu-id="ba04a-414">CorTypeAttr.tdExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="ba04a-414">CorTypeAttr.tdExplicitLayout</span></span><br /><br /> <span data-ttu-id="ba04a-415">CorTypeAttr.tdAnsiClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-415">CorTypeAttr.tdAnsiClass</span></span><br /><br /> <span data-ttu-id="ba04a-416">CorTypeAttr.tdUnicodeClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-416">CorTypeAttr.tdUnicodeClass</span></span><br /><br /> <span data-ttu-id="ba04a-417">CorTypeAttr.tdAutoClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-417">CorTypeAttr.tdAutoClass</span></span><br /><br /> <span data-ttu-id="ba04a-418">Empaquetado de clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-418">Class packing.</span></span>|<span data-ttu-id="ba04a-419">Type.Attributes.LayoutSequential</span><span class="sxs-lookup"><span data-stu-id="ba04a-419">Type.Attributes.LayoutSequential</span></span><br /><br /> <span data-ttu-id="ba04a-420">Type.Attributes.ExplicitLayout</span><span class="sxs-lookup"><span data-stu-id="ba04a-420">Type.Attributes.ExplicitLayout</span></span><br /><br /> <span data-ttu-id="ba04a-421">Type.Attributes.AnsiClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-421">Type.Attributes.AnsiClass</span></span><br /><br /> <span data-ttu-id="ba04a-422">Type.Attributes.UnicodeClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-422">Type.Attributes.UnicodeClass</span></span><br /><br /> <span data-ttu-id="ba04a-423">Type.Attributes.AutoClass</span><span class="sxs-lookup"><span data-stu-id="ba04a-423">Type.Attributes.AutoClass</span></span><br /><br /> <span data-ttu-id="ba04a-424">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-424">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-425">FieldOffsetAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-425">FieldOffsetAttribute</span></span>|<span data-ttu-id="ba04a-426">Desplazamiento de campo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-426">Field offset.</span></span>|<span data-ttu-id="ba04a-427">Ningún descriptor de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-427">No accessor.</span></span>|  
|<span data-ttu-id="ba04a-428">AssemblyLoadAttribute</span><span class="sxs-lookup"><span data-stu-id="ba04a-428">AssemblyLoadAttribute</span></span>|<span data-ttu-id="ba04a-429">CorAssemblyFlags</span><span class="sxs-lookup"><span data-stu-id="ba04a-429">CorAssemblyFlags</span></span>|<span data-ttu-id="ba04a-430">Ningún descriptor de acceso o enumerador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-430">No accessor or enumerator.</span></span>|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-431"><paramref name="attributeType" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-431"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-432"><paramref name="attributeType" /> no es un tipo en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-432"><paramref name="attributeType" /> is not a runtime type.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-433">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-433">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-434">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-434">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCustomAttributesData">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt; GetCustomAttributesData ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IList`1&lt;class System.Reflection.CustomAttributeData&gt; GetCustomAttributesData() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetCustomAttributesData" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetCustomAttributesData () As IList(Of CustomAttributeData)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IList&lt;System::Reflection::CustomAttributeData ^&gt; ^ GetCustomAttributesData();" />
      <MemberSignature Language="F#" Value="abstract member GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;&#xA;override this.GetCustomAttributesData : unit -&gt; System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;" Usage="assembly.GetCustomAttributesData " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Reflection.CustomAttributeData&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-435">Devuelve información sobre los atributos que se han aplicado al <see cref="T:System.Reflection.Assembly" /> actual, expresado como objetos <see cref="T:System.Reflection.CustomAttributeData" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-435">Returns information about the attributes that have been applied to the current <see cref="T:System.Reflection.Assembly" />, expressed as <see cref="T:System.Reflection.CustomAttributeData" /> objects.</span></span></summary>
        <returns><span data-ttu-id="ba04a-436">Lista genérica de objetos <see cref="T:System.Reflection.CustomAttributeData" /> que representan datos acerca de los atributos que se han aplicado al ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-436">A generic list of <see cref="T:System.Reflection.CustomAttributeData" /> objects representing data about the attributes that have been applied to the current assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-437">Utilice este método para examinar los atributos personalizados del código en el contexto de solo reflexión, en casos donde se definen los atributos personalizados a sí mismos en el código que se carga en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-437">Use this method to examine the custom attributes of code in the reflection-only context, in cases where the custom attributes themselves are defined in code that is loaded into the reflection-only context.</span></span> <span data-ttu-id="ba04a-438">Métodos como <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> y <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> no se puede usar en casos como éste, porque crean instancias de los atributos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-438">Methods like <xref:System.Attribute.GetCustomAttributes%2A?displayProperty=nameWithType> and <xref:System.Reflection.Assembly.GetCustomAttributes%2A?displayProperty=nameWithType> cannot be used in such cases, because they create instances of the attributes.</span></span> <span data-ttu-id="ba04a-439">No se puede ejecutar código en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-439">Code in the reflection-only context cannot be executed.</span></span> <span data-ttu-id="ba04a-440">Para obtener más información y como código, vea el <xref:System.Reflection.CustomAttributeData> clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-440">For more information and for example code, see the <xref:System.Reflection.CustomAttributeData> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntryAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetEntryAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetEntryAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetEntryAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetEntryAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetEntryAssembly();" />
      <MemberSignature Language="F#" Value="static member GetEntryAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetEntryAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-441">Obtiene el ejecutable de procesos en el dominio de la aplicación predeterminada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-441">Gets the process executable in the default application domain.</span></span> <span data-ttu-id="ba04a-442">En otros dominios de la aplicación, este es el primer ejecutable que <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" /> ejecutó.</span><span class="sxs-lookup"><span data-stu-id="ba04a-442">In other application domains, this is the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span></summary>
        <returns><span data-ttu-id="ba04a-443">Ensamblado que es el ejecutable del proceso en el dominio de la aplicación predeterminada o el primer ejecutable que haya ejecutado <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-443">The assembly that is the process executable in the default application domain, or the first executable that was executed by <see cref="M:System.AppDomain.ExecuteAssembly(System.String)" />.</span></span> <span data-ttu-id="ba04a-444">Puede devolver <see langword="null" /> cuando se le llama desde código no administrado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-444">Can return <see langword="null" /> when called from unmanaged code.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-445">El <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método puede devolver `null` cuando se ha cargado desde una aplicación no administrada un ensamblado administrado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-445">The <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method can return `null` when a managed assembly has been loaded from an unmanaged application.</span></span> <span data-ttu-id="ba04a-446">Por ejemplo, si una aplicación no administrada crea una instancia de un componente COM escrito en C#, una llamada a la <xref:System.Reflection.Assembly.GetEntryAssembly%2A> método desde el componente de C# devuelve null, porque el punto de entrada para el proceso era código no administrado en lugar de un ensamblado administrado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-446">For example, if an unmanaged application creates an instance of a COM component written in C#, a call to the <xref:System.Reflection.Assembly.GetEntryAssembly%2A> method from the C# component returns null, because the entry point for the process was unmanaged code rather than a managed assembly.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExecutingAssembly">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly GetExecutingAssembly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly GetExecutingAssembly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExecutingAssembly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetExecutingAssembly () As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ GetExecutingAssembly();" />
      <MemberSignature Language="F#" Value="static member GetExecutingAssembly : unit -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.GetExecutingAssembly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-447">Obtiene el ensamblado que contiene el código que se está ejecutando actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-447">Gets the assembly that contains the code that is currently executing.</span></span></summary>
        <returns><span data-ttu-id="ba04a-448">Ensamblado que contiene el código que se está ejecutando actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-448">The assembly that contains the code that is currently executing.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-449">Por motivos de rendimiento, debe llamar a este método solo cuando se desconoce en tiempo de diseño qué ensamblado se está ejecutando actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-449">For performance reasons, you should call this method only when you do not know at design time what assembly is currently executing.</span></span> <span data-ttu-id="ba04a-450">La manera recomendada para recuperar un <xref:System.Reflection.Assembly> objeto que representa el ensamblado actual es usar el <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propiedad de un tipo se encuentra en el ensamblado, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-450">The recommended way to retrieve an <xref:System.Reflection.Assembly> object that represents the current assembly is to use the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property of a type found in the assembly, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/assembly1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/assembly1.vb#1)]  
  
 <span data-ttu-id="ba04a-451">Para obtener el ensamblado que contiene el método que llama el código actualmente en ejecución, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-451">To get the assembly that contains the method that called the currently executing code, use <xref:System.Reflection.Assembly.GetCallingAssembly%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-452">En el ejemplo siguiente se usa el <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propiedad va a obtener el ensamblado actualmente en ejecución en función de un tipo de contenido en ese ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-452">The following example uses the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property to get the currently executing assembly based on a type contained in that assembly.</span></span> <span data-ttu-id="ba04a-453">También llama a la <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> método para mostrar que devuelve un <xref:System.Reflection.Assembly> objeto que representa el mismo ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-453">It also calls the <xref:System.Reflection.Assembly.GetExecutingAssembly%2A> method to show that it returns an <xref:System.Reflection.Assembly> object that represents the same assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cpp/getexecutingassembly1.cpp#5)]
 [!code-csharp[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/cs/getexecutingassembly1.cs#5)]
 [!code-vb[System.Reflection.Assembly.GetExecutingAssembly#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.getexecutingassembly/vb/getexecutingassembly1.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetExportedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetExportedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetExportedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetExportedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetExportedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetExportedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetExportedTypes : unit -&gt; Type[]&#xA;override this.GetExportedTypes : unit -&gt; Type[]" Usage="assembly.GetExportedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetExportedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-454">Obtiene los tipos públicos definidos en este ensamblado que se pueden ver desde fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-454">Gets the public types defined in this assembly that are visible outside the assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-455">Matriz que representa los tipos definidos en este ensamblado y que se pueden ver desde fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-455">An array that represents the types defined in this assembly that are visible outside the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-456">Los únicos tipos que se pueden ver desde fuera de un ensamblado son tipos públicos y tipos públicos anidados en otros tipos públicos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-456">The only types visible outside an assembly are public types and public types nested within other public types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-457">Ejemplo de código siguiente define una serie de clases con varios niveles de acceso y las llamadas <xref:System.Reflection.Assembly.GetExportedTypes%2A> para mostrar las que son visibles desde fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-457">The following code sample defines a number of classes with various access levels, and calls <xref:System.Reflection.Assembly.GetExportedTypes%2A> to display the ones that are visible from outside the assembly.</span></span>  
  
 [!code-cpp[Assembly.GetExportedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.GetExportedTypes/CPP/source.cpp#1)]
 [!code-csharp[Assembly.GetExportedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.GetExportedTypes/CS/source.cs#1)]
 [!code-vb[Assembly.GetExportedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.GetExportedTypes/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba04a-458">El ensamblado es un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="ba04a-458">The assembly is a dynamic assembly.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-459">No se puede cargar un ensamblado dependiente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-459">Unable to load a dependent assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFile">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream GetFile (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream GetFile(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFile (name As String) As FileStream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::FileStream ^ GetFile(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetFile : string -&gt; System.IO.FileStream&#xA;override this.GetFile : string -&gt; System.IO.FileStream" Usage="assembly.GetFile name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFile(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-460">Nombre del archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-460">The name of the specified file.</span></span> <span data-ttu-id="ba04a-461">No incluya la ruta al archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-461">Do not include the path to the file.</span></span></param>
        <summary><span data-ttu-id="ba04a-462">Obtiene un objeto <see cref="T:System.IO.FileStream" /> para el archivo especificado en la tabla de archivos del manifiesto de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-462">Gets a <see cref="T:System.IO.FileStream" /> for the specified file in the file table of the manifest of this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-463">Flujo que contiene el archivo especificado, o <see langword="null" /> si no se encuentra el archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-463">A stream that contains the specified file, or <see langword="null" /> if the file is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-464">Este método funciona en ambos archivos de recursos públicos y privados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-464">This method works on both public and private resource files.</span></span>  
  
 <span data-ttu-id="ba04a-465">El `name` no debe incluir la ruta de acceso al archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-465">The `name` should not include the path to the file.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-466">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-466">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-467">El parámetro <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-467">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-468">El parámetro <paramref name="name" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-468">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-469">No se encontró <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-469"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-470"><paramref name="name" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-470"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-471">Para obtener acceso a la ruta de acceso y para leer el archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-471">for access to the path and for reading the specified file.</span></span> <span data-ttu-id="ba04a-472">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> y <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /> and <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFiles">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-473">Obtiene los archivos en la tabla de archivos del manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-473">Gets the files in the file table of an assembly manifest.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles () As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles();" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : unit -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : unit -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-474">Obtiene los archivos en la tabla de archivos del manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-474">Gets the files in the file table of an assembly manifest.</span></span></summary>
        <returns><span data-ttu-id="ba04a-475">Matriz de secuencias que contienen los archivos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-475">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-476">Este método funciona en archivos de recursos públicos y privados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-476">This method works on public and private resource files.</span></span>  
  
 <span data-ttu-id="ba04a-477">Esta sobrecarga es equivalente a llamar a la <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> sobrecarga y especificando `false`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-477">This overload is equivalent to calling the <xref:System.Reflection.Assembly.GetFiles%28System.Boolean%29> overload and specifying `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-478">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-478">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-479">No se encontró un archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-479">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-480">Un archivo no era un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-480">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetFiles">
      <MemberSignature Language="C#" Value="public virtual System.IO.FileStream[] GetFiles (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.FileStream[] GetFiles(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetFiles(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetFiles (getResourceModules As Boolean) As FileStream()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::IO::FileStream ^&gt; ^ GetFiles(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetFiles : bool -&gt; System.IO.FileStream[]&#xA;override this.GetFiles : bool -&gt; System.IO.FileStream[]" Usage="assembly.GetFiles getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetFiles(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.FileStream[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="ba04a-481"><see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-481"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-482">Obtiene los archivos en la tabla de archivos del manifiesto del ensamblado, especificando si deben incluirse módulos de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-482">Gets the files in the file table of an assembly manifest, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="ba04a-483">Matriz de secuencias que contienen los archivos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-483">An array of streams that contain the files.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-484">Este método funciona en archivos de recursos públicos y privados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-484">This method works on public and private resource files.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-485">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-485">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-486">No se encontró un archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-486">A file was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-487">Un archivo no era un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-487">A file was not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetForwardedTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetForwardedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetForwardedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetForwardedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetForwardedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetForwardedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetForwardedTypes : unit -&gt; Type[]&#xA;override this.GetForwardedTypes : unit -&gt; Type[]" Usage="assembly.GetForwardedTypes " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="assembly.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-488">Devuelve el código hash de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-488">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="ba04a-489">Código hash de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-489">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetLoadedModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-490">Obtiene todos los módulos cargados que forman parte de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-490">Gets all the loaded modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetLoadedModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLoadedModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules();" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-491">Obtiene todos los módulos cargados que forman parte de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-491">Gets all the loaded modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-492">Matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-492">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLoadedModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetLoadedModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetLoadedModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetLoadedModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetLoadedModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetLoadedModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetLoadedModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetLoadedModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetLoadedModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetLoadedModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="ba04a-493"><see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-493"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-494">Obtiene todos los módulos cargados que forman parte de este ensamblado, especificando si se deben incluir módulos de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-494">Gets all the loaded modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="ba04a-495">Matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-495">An array of modules.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceInfo">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ManifestResourceInfo GetManifestResourceInfo (string resourceName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ManifestResourceInfo GetManifestResourceInfo(string resourceName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceInfo(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceInfo (resourceName As String) As ManifestResourceInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ManifestResourceInfo ^ GetManifestResourceInfo(System::String ^ resourceName);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo&#xA;override this.GetManifestResourceInfo : string -&gt; System.Reflection.ManifestResourceInfo" Usage="assembly.GetManifestResourceInfo resourceName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceInfo(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ManifestResourceInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="resourceName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="resourceName"><span data-ttu-id="ba04a-496">Nombre, que distingue entre mayúsculas y minúsculas, del recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-496">The case-sensitive name of the resource.</span></span></param>
        <summary><span data-ttu-id="ba04a-497">Devuelve información sobre cómo el recurso dado ha persistido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-497">Returns information about how the given resource has been persisted.</span></span></summary>
        <returns><span data-ttu-id="ba04a-498">Objeto llenado con información sobre la topología del recurso o <see langword="null" /> si no se encuentra el recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-498">An object that is populated with information about the resource's topology, or <see langword="null" /> if the resource is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-499">Información de recursos solo se devuelve si el recurso está visible al autor de llamada o el llamador tiene <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-499">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-500"><paramref name="resourceName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-500"><paramref name="resourceName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-501">El parámetro <paramref name="resourceName" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-501">The <paramref name="resourceName" /> parameter is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-502">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-502">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-503">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-503">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetManifestResourceNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetManifestResourceNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetManifestResourceNames();" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceNames : unit -&gt; string[]&#xA;override this.GetManifestResourceNames : unit -&gt; string[]" Usage="assembly.GetManifestResourceNames " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceNames</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-504">Devuelve los nombres de todos los recursos de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-504">Returns the names of all the resources in this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-505">Matriz que contiene los nombres de todos los recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-505">An array that contains the names of all the resources.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-506">Puede usar el nombre de cada recurso en la matriz devuelta por este método como sigue:</span><span class="sxs-lookup"><span data-stu-id="ba04a-506">You can use each resource name in the array returned by this method as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-507">Puede pasar el nombre de recurso para el <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> método para obtener información adicional sobre el recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-507">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceInfo%2A> method to get additional information about the resource.</span></span>  
  
-   <span data-ttu-id="ba04a-508">Si el nombre identifica un archivo .resources binario, puede quitar la extensión del archivo .resources y pasarlo a la <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor para crear una instancia del Administrador de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-508">If the name identifies a binary .resources file, you can remove its .resources file extension and pass it to the <xref:System.Resources.ResourceManager.%23ctor%28System.String%2CSystem.Reflection.Assembly%29?displayProperty=nameWithType> constructor to instantiate the resource manager.</span></span>  
  
-   <span data-ttu-id="ba04a-509">Puede pasar el nombre de recurso para el <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar un <xref:System.IO.Stream> objeto que, a continuación, puede pasar a la <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span><span class="sxs-lookup"><span data-stu-id="ba04a-509">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceReader.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
-   <span data-ttu-id="ba04a-510">Puede pasar el nombre de recurso para el <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> método para recuperar un <xref:System.IO.Stream> objeto que, a continuación, puede pasar a la <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span><span class="sxs-lookup"><span data-stu-id="ba04a-510">You can pass the resource name to the <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> method to retrieve a <xref:System.IO.Stream> object that you can then pass to the <xref:System.Resources.ResourceSet.%23ctor%28System.IO.Stream%29?displayProperty=nameWithType> constructor.</span></span>  
  
 <span data-ttu-id="ba04a-511">Información de recursos solo se devuelve si el recurso está visible al autor de llamada o el llamador tiene <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-511">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-512">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-512">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-513">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-513">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetManifestResourceStream">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-514">Carga el recurso del manifiesto especificado a partir de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-514">Loads the specified manifest resource from this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetManifestResourceStream (name As String) As Stream" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-515">Nombre del recurso de manifiesto que se solicita, que distingue entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-515">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="ba04a-516">Carga el recurso del manifiesto especificado a partir de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-516">Loads the specified manifest resource from this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-517">Recurso de manifiesto, o <see langword="null" /> si no se especificaron recursos durante la compilación o si el recurso no está visible para el llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-517">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-518">Un recurso de manifiesto es un recurso (por ejemplo, un archivo de imagen) que se incrusta en el ensamblado en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-518">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="ba04a-519">Para obtener más información acerca de los recursos de manifiesto, vea [Fundamentos de recursos de Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ba04a-519">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="ba04a-520">Información de recursos solo se devuelve si el recurso está visible al autor de llamada o el llamador tiene <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-520">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-521">Este método devuelve `null` si se tiene acceso a un recurso en otro ensamblado privado y el llamador no tiene <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="ba04a-521">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="ba04a-522">Si el manifiesto del ensamblado muestra un archivo de recursos, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> devuelve un <xref:System.IO.Stream> objeto incluso si no se encuentra el archivo de recursos en el disco en el momento.</span><span class="sxs-lookup"><span data-stu-id="ba04a-522">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="ba04a-523">Si no se encuentra el archivo de recursos, se pasa el resultado <xref:System.IO.Stream> de objeto para el <xref:System.Resources.ResourceReader> causas constructor un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-523">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-524">El parámetro <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-524">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-525">El parámetro <paramref name="name" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-525">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ba04a-526">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-526">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ba04a-527">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-527">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-528">No se encontró <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-528"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-529"><paramref name="name" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-529"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ba04a-530">La longitud del recurso es mayor que <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-530">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-531">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-531">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-532">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-532">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="ba04a-533">Manifiesto del ensamblado</span><span class="sxs-lookup"><span data-stu-id="ba04a-533">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetManifestResourceStream">
      <MemberSignature Language="C#" Value="public virtual System.IO.Stream GetManifestResourceStream (Type type, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IO.Stream GetManifestResourceStream(class System.Type type, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetManifestResourceStream(System.Type,System.String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::IO::Stream ^ GetManifestResourceStream(Type ^ type, System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetManifestResourceStream : Type * string -&gt; System.IO.Stream&#xA;override this.GetManifestResourceStream : Type * string -&gt; System.IO.Stream" Usage="assembly.GetManifestResourceStream (type, name)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetManifestResourceStream(System.Type,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IO.Stream</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="ba04a-534">Tipo cuyo espacio de nombres se utiliza para establecer el nombre de recurso del manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-534">The type whose namespace is used to scope the manifest resource name.</span></span></param>
        <param name="name"><span data-ttu-id="ba04a-535">Nombre del recurso de manifiesto que se solicita, que distingue entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-535">The case-sensitive name of the manifest resource being requested.</span></span></param>
        <summary><span data-ttu-id="ba04a-536">Carga el recurso del manifiesto especificado según el espacio de nombres del tipo especificado a partir de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-536">Loads the specified manifest resource, scoped by the namespace of the specified type, from this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-537">Recurso de manifiesto, o <see langword="null" /> si no se especificaron recursos durante la compilación o si el recurso no está visible para el llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-537">The manifest resource; or <see langword="null" /> if no resources were specified during compilation or if the resource is not visible to the caller.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-538">Por ejemplo, si especifica el nombre completo de `type` es "MyNameSpace.MyClasses" y `name` es "Red", este método de sobrecarga busca un recurso denominado "MyNameSpace.Net".</span><span class="sxs-lookup"><span data-stu-id="ba04a-538">For example, if the full name specified for `type` is "MyNameSpace.MyClasses" and `name` is "Net", this method overload searches for a resource named "MyNameSpace.Net".</span></span>  
  
 <span data-ttu-id="ba04a-539">Un recurso de manifiesto es un recurso (por ejemplo, un archivo de imagen) que se incrusta en el ensamblado en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-539">A manifest resource is a resource (such as an image file) that is embedded in the assembly at compile time.</span></span> <span data-ttu-id="ba04a-540">Para obtener más información acerca de los recursos de manifiesto, vea [Fundamentos de recursos de Microsoft .NET Framework](https://go.microsoft.com/fwlink/?LinkId=204554) en MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="ba04a-540">For more information about manifest resources, see [Microsoft .NET Framework Resource Basics](https://go.microsoft.com/fwlink/?LinkId=204554) in the MSDN Library.</span></span>  
  
 <span data-ttu-id="ba04a-541">Información de recursos solo se devuelve si el recurso está visible al autor de llamada o el llamador tiene <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-541">Resource information is returned only if the resource is visible to the caller, or the caller has <xref:System.Security.Permissions.ReflectionPermission>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-542">Este método devuelve `null` si se tiene acceso a un recurso en otro ensamblado privado y el llamador no tiene <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> marca.</span><span class="sxs-lookup"><span data-stu-id="ba04a-542">This method returns `null` if a private resource in another assembly is accessed and the caller does not have <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess?displayProperty=nameWithType> flag.</span></span>  
  
 <span data-ttu-id="ba04a-543">Si el manifiesto del ensamblado muestra un archivo de recursos, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> devuelve un <xref:System.IO.Stream> objeto incluso si no se encuentra el archivo de recursos en el disco en el momento.</span><span class="sxs-lookup"><span data-stu-id="ba04a-543">If the assembly manifest lists a resource file, <xref:System.Reflection.Assembly.GetManifestResourceStream%2A> returns a <xref:System.IO.Stream> object even if the resource file cannot be found on disk at the time.</span></span> <span data-ttu-id="ba04a-544">Si no se encuentra el archivo de recursos, se pasa el resultado <xref:System.IO.Stream> de objeto para el <xref:System.Resources.ResourceReader> causas constructor un <xref:System.ArgumentException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-544">If the resource file is not found, passing the resulting <xref:System.IO.Stream> object to the <xref:System.Resources.ResourceReader> constructor causes an <xref:System.ArgumentException>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-545">El parámetro <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-545">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-546">El parámetro <paramref name="name" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-546">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-547">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-547">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-548">No se encontró <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-548"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-549"><paramref name="name" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-549"><paramref name="name" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="ba04a-550">La longitud del recurso es mayor que <see cref="F:System.Int64.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-550">Resource length is greater than <see cref="F:System.Int64.MaxValue" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="ba04a-551">Cuando se invoca en tiempo de ejecución a través de mecanismos como <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-551">when invoked late-bound through mechanisms such as <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span> <span data-ttu-id="ba04a-552">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-552">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.GetManifestResourceNames" />
        <related type="Article" href="~/docs/framework/app-domains/assembly-manifest.md"><span data-ttu-id="ba04a-553">Manifiesto del ensamblado</span><span class="sxs-lookup"><span data-stu-id="ba04a-553">Assembly Manifest</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module GetModule (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module GetModule(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModule(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModule (name As String) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ GetModule(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetModule : string -&gt; System.Reflection.Module&#xA;override this.GetModule : string -&gt; System.Reflection.Module" Usage="assembly.GetModule name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModule(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-554">Nombre del módulo que se está solicitando.</span><span class="sxs-lookup"><span data-stu-id="ba04a-554">The name of the module being requested.</span></span></param>
        <summary><span data-ttu-id="ba04a-555">Obtiene el módulo especificado en este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-555">Gets the specified module in this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-556">Módulo que se solicita o <see langword="null" /> si no se encuentra el módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-556">The module being requested, or <see langword="null" /> if the module is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-557">Este método funciona en los nombres de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-557">This method works on file names.</span></span>  
  
 <span data-ttu-id="ba04a-558">Las clases en el `Reflection.Emit` espacio de nombres emiten el nombre de ámbito para un módulo dinámico.</span><span class="sxs-lookup"><span data-stu-id="ba04a-558">Classes in the `Reflection.Emit` namespace emit the scope name for a dynamic module.</span></span> <span data-ttu-id="ba04a-559">El nombre de ámbito se puede determinar mediante el <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-559">The scope name can be determined by the <xref:System.Reflection.Module.ScopeName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="ba04a-560">Pasa el tipo de módulo que desea `Assembly.GetModule`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-560">Pass the kind of module you want to `Assembly.GetModule`.</span></span> <span data-ttu-id="ba04a-561">Por ejemplo, si desea que el módulo que contiene el manifiesto del ensamblado, pase el nombre de ámbito del módulo a `GetModule`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-561">For example, if you want the module that contains the assembly manifest, pass the scope name of the module to `GetModule`.</span></span> <span data-ttu-id="ba04a-562">En caso contrario, pase el nombre de archivo del módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-562">Otherwise, pass the file name of the module.</span></span> <span data-ttu-id="ba04a-563">Los ensamblados cargan por uno de los `Load` los métodos que tienen un parámetro de byte [] sólo tienen un módulo, y el módulo del manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-563">Assemblies loaded by one of the `Load` methods that have a byte[] parameter have only one module, and that is the manifest module.</span></span> <span data-ttu-id="ba04a-564">Busca siempre estos módulos mediante el nombre del ámbito.</span><span class="sxs-lookup"><span data-stu-id="ba04a-564">Always seek these modules using the scope name.</span></span>  
  
 <span data-ttu-id="ba04a-565">Un tipo se puede recuperar desde un módulo específico mediante <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-565">A type can be retrieved from a specific module using <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="ba04a-566">Una llamada a `Module.GetType` en el módulo que contiene el manifiesto no se iniciará una búsqueda de todo el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-566">Calling `Module.GetType` on the module containing the manifest will not initiate a search of the entire assembly.</span></span> <span data-ttu-id="ba04a-567">Para recuperar un tipo de un ensamblado, independientemente del módulo donde esté, se debe llamar a <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-567">To retrieve a type from an assembly, regardless of which module it is in, you must call <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-568">El parámetro <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-568">The <paramref name="name" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-569">El parámetro <paramref name="name" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-569">The <paramref name="name" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-570">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-570">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-571">No se encontró <paramref name="name" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-571"><paramref name="name" /> was not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-572"><paramref name="name" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-572"><paramref name="name" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetModules">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-573">Obtiene todos los módulos que forman parte de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-573">Gets all the modules that are part of this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public System.Reflection.Module[] GetModules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetModules () As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules();" />
      <MemberSignature Language="F#" Value="abstract member GetModules : unit -&gt; System.Reflection.Module[]&#xA;override this.GetModules : unit -&gt; System.Reflection.Module[]" Usage="assembly.GetModules " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-574">Obtiene todos los módulos que forman parte de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-574">Gets all the modules that are part of this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-575">Matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-575">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-576">Este método funciona en archivos de recursos públicos y privados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-576">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-577">Los módulos se deben emitir con extensiones de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-577">Modules must be emitted with file name extensions.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-578">El ejemplo siguiente muestra el nombre del módulo en la matriz devuelta que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-578">The following example displays the name of the module in the returned array that contains the assembly manifest.</span></span>  
  
 [!code-cpp[Classic Assembly.GetModules Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Assembly.GetModules Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/CS/source.cs#1)]
 [!code-vb[Classic Assembly.GetModules Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Assembly.GetModules Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-579">El módulo que se va a cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-579">The module to be loaded does not specify a file name extension.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetModules">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module[] GetModules (bool getResourceModules);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module[] GetModules(bool getResourceModules) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetModules(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetModules (getResourceModules As Boolean) As Module()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Module ^&gt; ^ GetModules(bool getResourceModules);" />
      <MemberSignature Language="F#" Value="abstract member GetModules : bool -&gt; System.Reflection.Module[]&#xA;override this.GetModules : bool -&gt; System.Reflection.Module[]" Usage="assembly.GetModules getResourceModules" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetModules(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="getResourceModules" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="getResourceModules"><span data-ttu-id="ba04a-580"><see langword="true" /> para incluir módulos de recursos; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-580"><see langword="true" /> to include resource modules; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-581">Obtiene todos los módulos que forman parte de este ensamblado e indica si se deben incluir módulos de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-581">Gets all the modules that are part of this assembly, specifying whether to include resource modules.</span></span></summary>
        <returns><span data-ttu-id="ba04a-582">Matriz de módulos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-582">An array of modules.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-583">Este método funciona en archivos de recursos públicos y privados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-583">This method works on public and private resource files.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-584">Los módulos se deben emitir con extensiones de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-584">Modules must be emitted with file name extensions.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetName">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-585">Obtiene un <see cref="T:System.Reflection.AssemblyName" /> para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-585">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName () As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName();" />
      <MemberSignature Language="F#" Value="abstract member GetName : unit -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : unit -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-586">Obtiene un <see cref="T:System.Reflection.AssemblyName" /> para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-586">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-587">Objeto que contiene el nombre para mostrar analizado totalmente para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-587">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-588">Para obtener acceso a la ruta de acceso del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-588">for access to the path of the assembly.</span></span> <span data-ttu-id="ba04a-589">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-589">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetName">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName GetName (bool copiedName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName GetName(bool copiedName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetName(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetName (copiedName As Boolean) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::AssemblyName ^ GetName(bool copiedName);" />
      <MemberSignature Language="F#" Value="abstract member GetName : bool -&gt; System.Reflection.AssemblyName&#xA;override this.GetName : bool -&gt; System.Reflection.AssemblyName" Usage="assembly.GetName copiedName" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetName(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="copiedName" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="copiedName"><span data-ttu-id="ba04a-590"><see langword="true" /> para establecer la propiedad <see cref="P:System.Reflection.Assembly.CodeBase" /> en la ubicación del ensamblado después de crear una instantánea; <see langword="false" /> para establecer la propiedad <see cref="P:System.Reflection.Assembly.CodeBase" /> en la ubicación original.</span><span class="sxs-lookup"><span data-stu-id="ba04a-590"><see langword="true" /> to set the <see cref="P:System.Reflection.Assembly.CodeBase" /> to the location of the assembly after it was shadow copied; <see langword="false" /> to set <see cref="P:System.Reflection.Assembly.CodeBase" /> to the original location.</span></span></param>
        <summary><span data-ttu-id="ba04a-591">Obtiene un objeto <see cref="T:System.Reflection.AssemblyName" /> para este ensamblado y establece el código base tal como especifica <paramref name="copiedName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-591">Gets an <see cref="T:System.Reflection.AssemblyName" /> for this assembly, setting the codebase as specified by <paramref name="copiedName" />.</span></span></summary>
        <returns><span data-ttu-id="ba04a-592">Objeto que contiene el nombre para mostrar analizado totalmente para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-592">An object that contains the fully parsed display name for this assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-593">Para obtener acceso a la ruta de acceso del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-593">for access to the path of the assembly.</span></span> <span data-ttu-id="ba04a-594">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="assembly.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="ba04a-595">Objeto que debe llenarse con información de serialización.</span><span class="sxs-lookup"><span data-stu-id="ba04a-595">The object to be populated with serialization information.</span></span></param>
        <param name="context"><span data-ttu-id="ba04a-596">Contexto de destino de la serialización.</span><span class="sxs-lookup"><span data-stu-id="ba04a-596">The destination context of the serialization.</span></span></param>
        <summary><span data-ttu-id="ba04a-597">Obtiene información de serialización con todos los datos necesarios para crear una nueva instancia de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-597">Gets serialization information with all of the data needed to reinstantiate this assembly.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-598"><paramref name="info" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-598"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba04a-599">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="ba04a-599">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba04a-600">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-600">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetReferencedAssemblies">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.AssemblyName[] GetReferencedAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.AssemblyName[] GetReferencedAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetReferencedAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetReferencedAssemblies () As AssemblyName()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::AssemblyName ^&gt; ^ GetReferencedAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]&#xA;override this.GetReferencedAssemblies : unit -&gt; System.Reflection.AssemblyName[]" Usage="assembly.GetReferencedAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetReferencedAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-601">Obtiene los objetos <see cref="T:System.Reflection.AssemblyName" /> de todos los ensamblados a los que hace referencia este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-601">Gets the <see cref="T:System.Reflection.AssemblyName" /> objects for all the assemblies referenced by this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-602">Matriz que contiene los nombres para mostrar analizados totalmente de todos los ensamblados a los que hace referencia este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-602">An array that contains the fully parsed display names of all the assemblies referenced by this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba04a-603">A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propiedad de un <xref:System.Reflection.AssemblyName> objeto devuelto por este método es <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> si no hay ningún algoritmo hash para el ensamblado que se hace referencia, o si el algoritmo hash del ensamblado que se hace referencia no es identificado por el <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-603">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property of an <xref:System.Reflection.AssemblyName> object that is returned by this method is <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.None?displayProperty=nameWithType> if there is no hash algorithm for the referenced assembly, or if the hash algorithm of the referenced assembly is not identified by the <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="ba04a-604">En versiones anteriores de .NET Framework, el <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> propiedad devuelta <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> en esta situación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-604">In previous versions of the .NET Framework, the <xref:System.Reflection.AssemblyName.HashAlgorithm%2A> property returned <xref:System.Configuration.Assemblies.AssemblyHashAlgorithm.SHA1?displayProperty=nameWithType> in this situation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-605">El ejemplo de código siguiente se muestra cómo llamar el <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-605">The following code example demonstrates calling the <xref:System.Reflection.Assembly.GetReferencedAssemblies%2A> method.</span></span> <span data-ttu-id="ba04a-606">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.Assembly> clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-606">This code example is part of a larger example provided for the <xref:System.Reflection.Assembly> class.</span></span>  
  
 [!code-cpp[Reflection#1](~/samples/snippets/cpp/VS_Snippets_CLR/Reflection/CPP/reflection.cpp#1)]
 [!code-csharp[Reflection#1](~/samples/snippets/csharp/VS_Snippets_CLR/Reflection/CS/Reflection.cs#1)]
 [!code-vb[Reflection#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Reflection/VB/Reflection.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSatelliteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-607">Obtiene el ensamblado satélite.</span><span class="sxs-lookup"><span data-stu-id="ba04a-607">Gets the satellite assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetSatelliteAssembly (culture As CultureInfo) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly culture" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ba04a-608">Referencia cultural especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-608">The specified culture.</span></span></param>
        <summary><span data-ttu-id="ba04a-609">Obtiene el ensamblado satélite para la referencia cultural especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-609">Gets the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba04a-610">Ensamblado satélite especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-610">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-611">Los ensamblados satélite contienen recursos localizados, a diferencia de los ensamblados de aplicación principal, que contienen código ejecutable no traducible y recursos para una única referencia cultural que sirven como referencia cultural neutra o predeterminada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-611">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="ba04a-612">Llame a este método para utilizar la versión de ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-612">Call this method to use your current assembly version.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-613"><paramref name="culture" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-613"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-614">No se encuentra el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-614">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-615">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> no coincidía con la especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-615">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> did not match the one specified.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-616">El ensamblado satélite no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-616">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetSatelliteAssembly">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Assembly GetSatelliteAssembly (System.Globalization.CultureInfo culture, Version version);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly GetSatelliteAssembly(class System.Globalization.CultureInfo culture, class System.Version version) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ GetSatelliteAssembly(System::Globalization::CultureInfo ^ culture, Version ^ version);" />
      <MemberSignature Language="F#" Value="abstract member GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly&#xA;override this.GetSatelliteAssembly : System.Globalization.CultureInfo * Version -&gt; System.Reflection.Assembly" Usage="assembly.GetSatelliteAssembly (culture, version)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetSatelliteAssembly(System.Globalization.CultureInfo,System.Version)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="version" Type="System.Version" />
      </Parameters>
      <Docs>
        <param name="culture"><span data-ttu-id="ba04a-617">Referencia cultural especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-617">The specified culture.</span></span></param>
        <param name="version"><span data-ttu-id="ba04a-618">Versión del ensamblado satélite.</span><span class="sxs-lookup"><span data-stu-id="ba04a-618">The version of the satellite assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-619">Obtiene la versión especificada del ensamblado satélite para la referencia cultural especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-619">Gets the specified version of the satellite assembly for the specified culture.</span></span></summary>
        <returns><span data-ttu-id="ba04a-620">Ensamblado satélite especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-620">The specified satellite assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-621">Los ensamblados satélite contienen recursos localizados, a diferencia de los ensamblados de aplicación principal, que contienen código ejecutable no traducible y recursos para una única referencia cultural que sirven como referencia cultural neutra o predeterminada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-621">Satellite assemblies contain localized resources, as distinct from main application assemblies, which contain non-localizable executable code and resources for a single culture that serve as the default or neutral culture.</span></span>  
  
 <span data-ttu-id="ba04a-622">Llame a la <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> sobrecarga al utilizar la versión de ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-622">Call the <xref:System.Reflection.Assembly.GetSatelliteAssembly%28System.Globalization.CultureInfo%29> overload to use your current assembly version.</span></span>  
  
 <span data-ttu-id="ba04a-623">Si `version` es `null`, la versión del ensamblado actual se usa si los ensamblados principales y los recursos están firmados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-623">If `version` is `null`, the current assembly version is used if both the resource and main assemblies are signed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-624"><paramref name="culture" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-624"><paramref name="culture" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-625">Se encontró un ensamblado satélite con un nombre de archivo coincidente, pero la <see langword="CultureInfo" /> o la versión no coincidía con la especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-625">The satellite assembly with a matching file name was found, but the <see langword="CultureInfo" /> or the version did not match the one specified.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-626">No se encuentra el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-626">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-627">El ensamblado satélite no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-627">The satellite assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-628">Obtiene el objeto <see cref="T:System.Type" /> que representa el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-628">Gets the <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="assembly.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="override this.GetType : string -&gt; Type" Usage="assembly.GetType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-629">Nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-629">The full name of the type.</span></span></param>
        <summary><span data-ttu-id="ba04a-630">Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado en la instancia de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-630">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance.</span></span></summary>
        <returns><span data-ttu-id="ba04a-631">Objeto que representa la clase especificada, o <see langword="null" /> si no se encuentra la clase.</span><span class="sxs-lookup"><span data-stu-id="ba04a-631">An object that represents the specified class, or <see langword="null" /> if the class is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-632">Este método solo busca la instancia actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-632">This method only searches the current assembly instance.</span></span> <span data-ttu-id="ba04a-633">El `name` parámetro incluye el espacio de nombres pero no el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-633">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="ba04a-634">Para buscar otros ensamblados para un tipo, use el <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga del método, que puede incluir opcionalmente un nombre para mostrar del ensamblado como parte del nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-634">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-635">Si el tipo se ha reenviado a otro ensamblado, todavía se devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-635">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="ba04a-636">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-636">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-637">En el ejemplo siguiente se define un abstracto `MeansOfTransportation` clase en el `Transportation` espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="ba04a-637">The following example defines an abstract `MeansOfTransportation` class in the `Transportation` namespace.</span></span> <span data-ttu-id="ba04a-638">Lo llama el <xref:System.Reflection.Assembly.GetType%28System.String%29> método para recuperar su <xref:System.Type> (objeto), las llamadas la <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> método para obtener una matriz de <xref:System.Reflection.PropertyInfo> objetos que representan las propiedades del tipo y, a continuación, muestra información sobre el tipo abstraer las propiedades.</span><span class="sxs-lookup"><span data-stu-id="ba04a-638">It calls the <xref:System.Reflection.Assembly.GetType%28System.String%29> method to retrieve its <xref:System.Type> object, calls the <xref:System.Type.GetProperties%2A?displayProperty=nameWithType> method to get an array of <xref:System.Reflection.PropertyInfo> objects that represent the type's properties, and then displays information on the type's abstract properties.</span></span> <span data-ttu-id="ba04a-639">Tenga en cuenta que la llamada a la <xref:System.Reflection.Assembly.GetType%28System.String%29> método usa el nombre del tipo completo (es decir, en su espacio de nombres junto con su nombre de tipo).</span><span class="sxs-lookup"><span data-stu-id="ba04a-639">Note that the call to the <xref:System.Reflection.Assembly.GetType%28System.String%29> method uses the type's fully qualified name (that is, its namespace along with its type name).</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.gettype/cs/gettype1.cs#1)]
 [!code-vb[System.Reflection.Assembly.GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.gettype/vb/gettype1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-640"><paramref name="name" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-640"><paramref name="name" /> is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-641"><paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-641"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-642"><paramref name="name" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-642"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ba04a-643">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-643">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block><span data-ttu-id="ba04a-644">
          <paramref name="name" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-644">
          <paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-645">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-645">-or-</span></span> 
<span data-ttu-id="ba04a-646">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="name" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-646">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-647"><paramref name="name" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-647"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-648">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-648">-or-</span></span> 
 <span data-ttu-id="ba04a-649"><paramref name="name" /> requiere un ensamblado dependiente compilado para una versión del tiempo de ejecución posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-649"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-650">Nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-650">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="ba04a-651"><see langword="true" /> para producir una excepción si no se encuentra el tipo; <see langword="false" /> para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-651"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-652">Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado en la instancia de ensamblado y, de manera opcional, produce una excepción si no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-652">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance and optionally throws an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="ba04a-653">Objeto que representa a la clase especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-653">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-654">Este método solo busca la instancia actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-654">This method only searches the current assembly instance.</span></span> <span data-ttu-id="ba04a-655">El `name` parámetro incluye el espacio de nombres pero no el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-655">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="ba04a-656">Para buscar otros ensamblados para un tipo, use el <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga del método, que puede incluir opcionalmente un nombre para mostrar del ensamblado como parte del nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-656">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-657">Si el tipo se ha reenviado a otro ensamblado, todavía se devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-657">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="ba04a-658">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-658">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="ba04a-659">El `throwOnError` parámetro sólo afecta a lo que sucede cuando no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-659">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="ba04a-660">No afecta a las otras excepciones que puedan producirse.</span><span class="sxs-lookup"><span data-stu-id="ba04a-660">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="ba04a-661">En concreto, si se encuentra el tipo, pero no se puede cargar, <xref:System.TypeLoadException> se pueden producir incluso si `throwOnError` es `false`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-661">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-662"><paramref name="name" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-662"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="ba04a-663">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-663">-or-</span></span> 
<span data-ttu-id="ba04a-664">La longitud de <paramref name="name" /> supera los 1024 caracteres.</span><span class="sxs-lookup"><span data-stu-id="ba04a-664">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-665"><paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-665"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="ba04a-666"><paramref name="throwOnError" /> es <see langword="true" /> y no se puede encontrar el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-666"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-667"><paramref name="name" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-667"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-668"><paramref name="name" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-668"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-669">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-669">-or-</span></span> 
<span data-ttu-id="ba04a-670">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="name" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-670">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-671"><paramref name="name" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-671"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-672">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-672">-or-</span></span> 
 <span data-ttu-id="ba04a-673"><paramref name="name" /> requiere un ensamblado dependiente compilado para una versión del tiempo de ejecución posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-673"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public virtual Type GetType (string name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType(string name, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetType (name As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType(System::String ^ name, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="override this.GetType : string * bool * bool -&gt; Type" Usage="assembly.GetType (name, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType(System.String,System.Boolean,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="ba04a-674">Nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-674">The full name of the type.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="ba04a-675"><see langword="true" /> para producir una excepción si no se encuentra el tipo; <see langword="false" /> para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-675"><see langword="true" /> to throw an exception if the type is not found; <see langword="false" /> to return <see langword="null" />.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="ba04a-676">Es <see langword="true" /> para no hacer distinción entre mayúsculas y minúsculas en el nombre del tipo; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-676"><see langword="true" /> to ignore the case of the type name; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-677">Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado en la instancia de ensamblado, con la opción de omitir el caso y de producir una excepción si no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-677">Gets the <see cref="T:System.Type" /> object with the specified name in the assembly instance, with the options of ignoring the case, and of throwing an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="ba04a-678">Objeto que representa a la clase especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-678">An object that represents the specified class.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-679">Este método solo busca la instancia actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-679">This method only searches the current assembly instance.</span></span> <span data-ttu-id="ba04a-680">El `name` parámetro incluye el espacio de nombres pero no el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-680">The `name` parameter includes the namespace but not the assembly.</span></span> <span data-ttu-id="ba04a-681">Para buscar otros ensamblados para un tipo, use el <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> sobrecarga del método, que puede incluir opcionalmente un nombre para mostrar del ensamblado como parte del nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-681">To search other assemblies for a type, use the <xref:System.Type.GetType%28System.String%29?displayProperty=nameWithType> method overload, which can optionally include an assembly display name as part of the type name.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-682">Si el tipo se ha reenviado a otro ensamblado, todavía se devuelve este método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-682">If the type has been forwarded to another assembly, it is still returned by this method.</span></span> <span data-ttu-id="ba04a-683">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-683">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="ba04a-684">El `throwOnError` parámetro sólo afecta a lo que sucede cuando no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-684">The `throwOnError` parameter only affects what happens when the type is not found.</span></span> <span data-ttu-id="ba04a-685">No afecta a las otras excepciones que puedan producirse.</span><span class="sxs-lookup"><span data-stu-id="ba04a-685">It does not affect any other exceptions that might be thrown.</span></span> <span data-ttu-id="ba04a-686">En concreto, si se encuentra el tipo, pero no se puede cargar, <xref:System.TypeLoadException> se pueden producir incluso si `throwOnError` es `false`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-686">In particular, if the type is found but cannot be loaded, <xref:System.TypeLoadException> can be thrown even if `throwOnError` is `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-687"><paramref name="name" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-687"><paramref name="name" /> is invalid.</span></span>  
  
<span data-ttu-id="ba04a-688">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-688">-or-</span></span> 
<span data-ttu-id="ba04a-689">La longitud de <paramref name="name" /> supera los 1024 caracteres.</span><span class="sxs-lookup"><span data-stu-id="ba04a-689">The length of <paramref name="name" /> exceeds 1024 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-690"><paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-690"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="ba04a-691"><paramref name="throwOnError" /> es <see langword="true" /> y no se puede encontrar el tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-691"><paramref name="throwOnError" /> is <see langword="true" />, and the type cannot be found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-692"><paramref name="name" /> requiere un ensamblado dependiente que no se pudo encontrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-692"><paramref name="name" /> requires a dependent assembly that could not be found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-693"><paramref name="name" /> requiere un ensamblado dependiente que se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-693"><paramref name="name" /> requires a dependent assembly that was found but could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-694">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-694">-or-</span></span> 
<span data-ttu-id="ba04a-695">El ensamblado actual se cargó en el contexto de solo reflexión y <paramref name="name" /> requiere un ensamblado dependiente que no se haya cargado previamente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-695">The current assembly was loaded into the reflection-only context, and <paramref name="name" /> requires a dependent assembly that was not preloaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-696"><paramref name="name" /> requiere un ensamblado dependiente, pero el archivo no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-696"><paramref name="name" /> requires a dependent assembly, but the file is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-697">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-697">-or-</span></span> 
 <span data-ttu-id="ba04a-698"><paramref name="name" /> requiere un ensamblado dependiente compilado para una versión del tiempo de ejecución posterior a la versión cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-698"><paramref name="name" /> requires a dependent assembly which was compiled for a version of the runtime later than the currently loaded version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypes">
      <MemberSignature Language="C#" Value="public virtual Type[] GetTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.GetTypes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetTypes : unit -&gt; Type[]&#xA;override this.GetTypes : unit -&gt; Type[]" Usage="assembly.GetTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-699">Obtiene los tipos definidos en este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-699">Gets the types defined in this assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-700">Matriz que contiene todos los tipos que están definidos en este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-700">An array that contains all the types that are defined in this assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-701">La matriz devuelta incluye tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-701">The returned array includes nested types.</span></span>  
  
 <span data-ttu-id="ba04a-702">Si el <xref:System.Reflection.Assembly.GetTypes%2A> método se llama en un ensamblado y un tipo en que el ensamblado depende de un tipo en un ensamblado que no se ha cargado (por ejemplo, si se deriva de un tipo del segundo ensamblado), un <xref:System.Reflection.ReflectionTypeLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="ba04a-702">If the <xref:System.Reflection.Assembly.GetTypes%2A> method is called on an assembly and a type in that assembly is dependent on a type in an assembly that has not been loaded (for example, if it derives from a type in the second assembly), a <xref:System.Reflection.ReflectionTypeLoadException> is thrown.</span></span> <span data-ttu-id="ba04a-703">Por ejemplo, esto puede ocurrir si el primer ensamblado se cargó con la <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> o <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos y el segundo ensamblado no se ha cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-703">For example, this can happen if the first assembly was loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> or <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods, and the second assembly was not loaded.</span></span> <span data-ttu-id="ba04a-704">También puede ocurrir con los ensamblados cargados mediante el <xref:System.Reflection.Assembly.Load%2A> y <xref:System.Reflection.Assembly.LoadFile%2A> métodos si el segundo ensamblado no puede encontrar cuando el <xref:System.Reflection.Assembly.GetTypes%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-704">It can also happen with assemblies loaded using the <xref:System.Reflection.Assembly.Load%2A> and <xref:System.Reflection.Assembly.LoadFile%2A> methods if the second assembly cannot be located when the <xref:System.Reflection.Assembly.GetTypes%2A> method is called.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-705">Si un tipo se ha reenviado a otro ensamblado, no se incluye en la matriz devuelta.</span><span class="sxs-lookup"><span data-stu-id="ba04a-705">If a type has been forwarded to another assembly, it is not included in the returned array.</span></span> <span data-ttu-id="ba04a-706">Para obtener información sobre el reenvío de tipos, vea [reenvío de tipos en Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-706">For information on type forwarding, see [Type Forwarding in the Common Language Runtime](~/docs/framework/app-domains/type-forwarding-in-the-common-language-runtime.md).</span></span>  
  
 <span data-ttu-id="ba04a-707">Para recuperar una colección de <xref:System.Reflection.TypeInfo> objetos en lugar de una matriz de <xref:System.Type> objetos, utilice el <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-707">To retrieve a collection of <xref:System.Reflection.TypeInfo> objects instead of an array of <xref:System.Type> objects, use the <xref:System.Reflection.Assembly.DefinedTypes%2A?displayProperty=nameWithType> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-708">El ejemplo siguiente muestra los parámetros de un método en un tipo en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-708">The following example displays parameters of one method on a type in the specified assembly.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.ReflectionTypeLoadException"><span data-ttu-id="ba04a-709">El ensamblado contiene uno o más tipos que no se pueden cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-709">The assembly contains one or more types that cannot be loaded.</span></span> <span data-ttu-id="ba04a-710">La matriz devuelta por la propiedad <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> de esta excepción contiene un objeto <see cref="T:System.Type" /> para cada tipo que se cargó y <see langword="null" /> para cada tipo que no se pudo cargar, mientras que la propiedad <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> contiene una excepción para cada tipo que no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-710">The array returned by the <see cref="P:System.Reflection.ReflectionTypeLoadException.Types" /> property of this exception contains a <see cref="T:System.Type" /> object for each type that was loaded and <see langword="null" /> for each type that could not be loaded, while the <see cref="P:System.Reflection.ReflectionTypeLoadException.LoaderExceptions" /> property contains an exception for each type that could not be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GlobalAssemblyCache">
      <MemberSignature Language="C#" Value="public virtual bool GlobalAssemblyCache { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool GlobalAssemblyCache" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GlobalAssemblyCache As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool GlobalAssemblyCache { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.GlobalAssemblyCache : bool" Usage="System.Reflection.Assembly.GlobalAssemblyCache" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.GlobalAssemblyCache</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-711">Obtiene un valor que indica si el ensamblado se ha cargado desde la caché global de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-711">Gets a value indicating whether the assembly was loaded from the global assembly cache.</span></span></summary>
        <value><span data-ttu-id="ba04a-712">Es <see langword="true" /> si el ensamblado se ha cargado desde la caché global de ensamblados; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-712"><see langword="true" /> if the assembly was loaded from the global assembly cache; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="HostContext">
      <MemberSignature Language="C#" Value="public virtual long HostContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 HostContext" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.HostContext" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property HostContext As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property long HostContext { long get(); };" />
      <MemberSignature Language="F#" Value="member this.HostContext : int64" Usage="System.Reflection.Assembly.HostContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-713">Obtiene el contexto del host con el que se cargó el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-713">Gets the host context with which the assembly was loaded.</span></span></summary>
        <value><span data-ttu-id="ba04a-714">Valor <see cref="T:System.Int64" /> que indica el contexto del host con el que se cargó el ensamblado, si existe.</span><span class="sxs-lookup"><span data-stu-id="ba04a-714">An <see cref="T:System.Int64" /> value that indicates the host context with which the assembly was loaded, if any.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ImageRuntimeVersion">
      <MemberSignature Language="C#" Value="public virtual string ImageRuntimeVersion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string ImageRuntimeVersion" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ImageRuntimeVersion As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ ImageRuntimeVersion { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ImageRuntimeVersion : string" Usage="System.Reflection.Assembly.ImageRuntimeVersion" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-715">Obtiene una cadena que representa la versión de Common Language Runtime (CLR) guardada en el archivo que contiene el manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-715">Gets a string representing the version of the common language runtime (CLR) saved in the file containing the manifest.</span></span></summary>
        <value><span data-ttu-id="ba04a-716">El nombre de la carpeta de versión de CLR.</span><span class="sxs-lookup"><span data-stu-id="ba04a-716">The CLR version folder name.</span></span> <span data-ttu-id="ba04a-717">Esta no es una ruta de acceso completa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-717">This is not a full path.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-718">Por ejemplo, el valor de la versión 1.1 de .NET Framework sería v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="ba04a-718">For example, the value for the .NET Framework version 1.1 would be v1.1.4322.</span></span> <span data-ttu-id="ba04a-719">Los archivos binarios de esa versión se encontrarían en la ruta de acceso % windir%\Microsoft.NET\Framework\v1.1.4322.</span><span class="sxs-lookup"><span data-stu-id="ba04a-719">The binary files for that version would be located in the path %windir%\Microsoft.NET\Framework\v1.1.4322.</span></span>  
  
 <span data-ttu-id="ba04a-720">De forma predeterminada, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> se establece en la versión de CLR que utiliza para compilar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-720">By default, <xref:System.Reflection.Assembly.ImageRuntimeVersion%2A> is set to the version of the CLR used to build the assembly.</span></span> <span data-ttu-id="ba04a-721">Sin embargo, se debería haberse establecido en otro valor en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-721">However, it might have been set to another value at compile time.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public virtual bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Reflection.Assembly.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-722">Obtiene un valor que indica si este ensamblado está contenido en un <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> recopilable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-722">Gets a value that indicates whether this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <value><span data-ttu-id="ba04a-723"><see langword="true" /> Si este ensamblado se mantiene en un recopilables <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-723"><see langword="true" /> if this assembly is held in a collectible <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="ba04a-724">Para obtener más información, consulte <see href="/en-us/dotnet/standard/assembly/unloadability-howto">cómo usar y depurar unloadability de ensamblado de .NET Core</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-724">For more information see <see href="/en-us/dotnet/standard/assembly/unloadability-howto">How to use and debug assembly unloadability in .NET Core</see>.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsDefined(Type ^ attributeType, bool inherit);" />
      <MemberSignature Language="F#" Value="abstract member IsDefined : Type * bool -&gt; bool&#xA;override this.IsDefined : Type * bool -&gt; bool" Usage="assembly.IsDefined (attributeType, inherit)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType"><span data-ttu-id="ba04a-725">Tipo del atributo personalizado que se va a comprobar para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-725">The type of the attribute to be checked for this assembly.</span></span></param>
        <param name="inherit"><span data-ttu-id="ba04a-726">Se omite este argumento para los objetos de este tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-726">This argument is ignored for objects of this type.</span></span></param>
        <summary><span data-ttu-id="ba04a-727">Indica si se ha aplicado un atributo especificado al ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-727">Indicates whether or not a specified attribute has been applied to the assembly.</span></span></summary>
        <returns><span data-ttu-id="ba04a-728">Es <see langword="true" /> si el atributo se ha aplicado al ensamblado; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-728"><see langword="true" /> if the attribute has been applied to the assembly; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="ba04a-729">El siguiente ejemplo de código se aplica el <xref:System.Reflection.AssemblyTitleAttribute> atributo a un ensamblado y, a continuación, usa <xref:System.Reflection.Assembly.IsDefined%2A> para indicar si se aplicó.</span><span class="sxs-lookup"><span data-stu-id="ba04a-729">The following code example applies the <xref:System.Reflection.AssemblyTitleAttribute> attribute to an assembly and then uses <xref:System.Reflection.Assembly.IsDefined%2A> to indicate whether it was applied.</span></span> <span data-ttu-id="ba04a-730">También comprueba un atributo que no se ha aplicado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-730">It also tests an attribute that was not applied.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/CS/isdefined.cs#1)]
 [!code-vb[System.Reflection.Assembly.IsDefined#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.isdefined/VB/isdefined.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-731"><paramref name="attributeType" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-731"><paramref name="attributeType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-732"><paramref name="attributeType" /> usa un tipo no válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-732"><paramref name="attributeType" /> uses an invalid type.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsDynamic">
      <MemberSignature Language="C#" Value="public virtual bool IsDynamic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDynamic" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsDynamic" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsDynamic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsDynamic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDynamic : bool" Usage="System.Reflection.Assembly.IsDynamic" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-733">Obtiene un valor que indica si el ensamblado actual se generó dinámicamente en el proceso actual utilizando emisión de la reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-733">Gets a value that indicates whether the current assembly was generated dynamically in the current process by using reflection emit.</span></span></summary>
        <value><span data-ttu-id="ba04a-734">Es <see langword="true" /> si el ensamblado actual se generó dinámicamente en el proceso actual; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-734"><see langword="true" /> if the current assembly was generated dynamically in the current process; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-735">Ensamblados dinámicos se representan mediante la clase derivada <xref:System.Reflection.Emit.AssemblyBuilder>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-735">Dynamic assemblies are represented by the derived class <xref:System.Reflection.Emit.AssemblyBuilder>.</span></span>  
  
 <span data-ttu-id="ba04a-736">Cuando un ensamblado dinámico se guarda en disco, el ensamblado guardado no es dinámica.</span><span class="sxs-lookup"><span data-stu-id="ba04a-736">When a dynamic assembly is saved to disk, the saved assembly is not dynamic.</span></span> <span data-ttu-id="ba04a-737">Si el ensamblado guardado se carga en otro dominio de aplicación o proceso, el <xref:System.Reflection.Assembly.IsDynamic%2A> propiedad devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-737">If the saved assembly is loaded into another application domain or process, the <xref:System.Reflection.Assembly.IsDynamic%2A> property returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.Reflection.Assembly.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-738">Obtiene un valor que indica si el ensamblado actual se carga con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-738">Gets a value that indicates whether the current assembly is loaded with full trust.</span></span></summary>
        <value><span data-ttu-id="ba04a-739">Es <see langword="true" /> si el ensamblado actual se carga con plena confianza; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-739"><see langword="true" /> if the current assembly is loaded with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-740">Carga un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-740">Loads an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="ba04a-741">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-741">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-742">Carga el ensamblado con una imagen que toma como base el formato Common Object File Format (COFF) y que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-742">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="ba04a-743">El ensamblado se carga en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-743">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="ba04a-744">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-744">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-745">El nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-745">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="ba04a-746">Para cargar un ensamblado desde una matriz de bytes con el nivel de confianza del dominio de aplicación, use el <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-746">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="ba04a-747">Para obtener más información sobre el uso de las pruebas con las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que toma las matrices de bytes, vea el <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-747">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="ba04a-748">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-748">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-749">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-749">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-750">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-750">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-751">Tenga en cuenta que esta sobrecarga del método siempre crea un nuevo <xref:System.Reflection.Assembly> objeto con su propia asignación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-751">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-752"><paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-752"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-753"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-753"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-754">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-754">-or-</span></span> 
<span data-ttu-id="ba04a-755">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-755">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="ba04a-756">Objeto que describe el ensamblado que va a cargarse.</span><span class="sxs-lookup"><span data-stu-id="ba04a-756">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="ba04a-757">Carga un ensamblado dado su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-757">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="ba04a-758">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-758">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-759"><xref:System.IO.FileLoadException> se produce si `assemblyRef` especifica el nombre completo del ensamblado y el primer ensamblado que coincida con el nombre sencillo tiene una versión diferente, la referencia cultural o el token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="ba04a-759"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="ba04a-760">El cargador no continuará la búsqueda de otros ensamblados que coinciden con el nombre simple.</span><span class="sxs-lookup"><span data-stu-id="ba04a-760">The loader does not continue probing for other assemblies that match the simple name.</span></span> <span data-ttu-id="ba04a-761">Empezando con .NET Framework 4, porque la ejecución de código en ensamblados remotos está deshabilitada de forma predeterminada, un <xref:System.IO.FileLoadException> también se produce si `assemblyRef` especifica un ensamblado remoto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-761">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="ba04a-762">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-762">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>     
  
> [!NOTE]
>  <span data-ttu-id="ba04a-763">No use un <xref:System.Reflection.AssemblyName> solamente con el <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propiedades.</span><span class="sxs-lookup"><span data-stu-id="ba04a-763">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="ba04a-764">El <xref:System.Reflection.AssemblyName.CodeBase%2A> propiedad no proporciona todos los elementos de la identidad del ensamblado (por ejemplo, nombre o versión), por lo que la carga no se produce según las reglas de carga por identidad, como podría esperar de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-764">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="ba04a-765">En su lugar, el ensamblado se carga con reglas de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-765">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="ba04a-766">Para obtener información acerca de las desventajas de utilizar el contexto de carga, consulte el <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga del método o [procedimientos recomendados para cargar ensamblados](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-766">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="ba04a-767">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-767">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-768">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-768">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-769">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-769">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-770">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-770">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-771">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.Load%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-771">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-772">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` parámetro para cargar una común imagen object file format (COFF), evidencia se hereda del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-772">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="ba04a-773">Esto se aplica a la versión 1.1 de .NET Framework Service Pack 1 (SP1) y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ba04a-773">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ba04a-774">En la versión 1.0 de .NET Framework y en la versión 1.1 sin SP1, cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` se combina el parámetro para cargar una imagen en formato COFF, evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-774">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="ba04a-775">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-775">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-776">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-776">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-777">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-777">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-778">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-778">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-779">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-779">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-780">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-780">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-781">Si tanto el <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propiedad y el <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propiedad se establece, el primer intento de cargar el ensamblado utiliza el nombre para mostrar (incluida la versión, referencia cultural y así sucesivamente, tal como lo devuelve el <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad).</span><span class="sxs-lookup"><span data-stu-id="ba04a-781">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="ba04a-782">Si no se encuentra el archivo, <xref:System.Reflection.AssemblyName.CodeBase%2A> se usa para buscar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-782">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="ba04a-783">Si se encuentra el ensamblado mediante <xref:System.Reflection.AssemblyName.CodeBase%2A>, el nombre para mostrar se compara con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-783">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="ba04a-784">Si se produce un error en la coincidencia, un <xref:System.IO.FileLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="ba04a-784">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-785">El ejemplo siguiente crea un <xref:System.Reflection.AssemblyName> objeto y lo usa para cargar el `sysglobal.dll` ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-785">The following example instantiates an <xref:System.Reflection.AssemblyName> object and uses it to load the `sysglobal.dll` assembly.</span></span> <span data-ttu-id="ba04a-786">En el ejemplo se muestra a continuación, el nombre completo de tipos públicos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-786">The example then displays the full name of the assembly's public types.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/Load2.cs#2)]
 [!code-vb[System.Reflection.Assembly.Load#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/Load2.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-787"><paramref name="assemblyRef" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-787"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-788">No se ha encontrado <paramref name="assemblyRef" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-788"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="ba04a-789">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-789">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="ba04a-790">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-790">A file that was found could not be loaded.</span></span>

<span data-ttu-id="ba04a-791">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-791">-or-</span></span>

<span data-ttu-id="ba04a-792"><paramref name="assemblyRef" /> especifica un ensamblado remoto, pero la capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-792"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-793">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-793">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-794"><paramref name="assemblyRef" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-794"><paramref name="assemblyRef" /> is not a valid assembly.</span></span> <span data-ttu-id="ba04a-795">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-795">-or-</span></span> 
<span data-ttu-id="ba04a-796">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-796">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-797">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="ba04a-797">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="ba04a-798">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-798">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-799">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-799">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-800">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-800">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-801">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-801">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="ba04a-802">Cómo el motor en tiempo de ejecución ubica ensamblados</span><span class="sxs-lookup"><span data-stu-id="ba04a-802">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member Load : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="ba04a-803">Nombre largo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-803">The long form of the assembly name.</span></span></param>
        <summary><span data-ttu-id="ba04a-804">Carga un ensamblado a partir de su nombre largo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-804">Loads an assembly given the long form of its name.</span></span></summary>
        <returns><span data-ttu-id="ba04a-805">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-805">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-806">El formato largo de un nombre de ensamblado consta de su nombre simple (por ejemplo, "sistema" para el ensamblado System.dll) junto con su versión, referencia cultural, token de clave pública y, opcionalmente, su arquitectura de procesador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-806">The long form of an assembly name consists of its simple name (such as "System" for the System.dll assembly) along with its version, culture, public key token, and optionally its processor architecture.</span></span> <span data-ttu-id="ba04a-807">Se corresponde con el ensamblado <xref:System.Reflection.Assembly.FullName%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-807">It corresponds to the assembly's <xref:System.Reflection.Assembly.FullName%2A> property.</span></span> <span data-ttu-id="ba04a-808">El ejemplo siguiente muestra el uso de un nombre largo para cargar el ensamblado System.dll de .NET Framework 4.</span><span class="sxs-lookup"><span data-stu-id="ba04a-808">The following example illustrates the use of a long name to load the System.dll assembly for the .NET Framework 4.</span></span>  
  
 [!code-csharp[System.Reflection.Assembly.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.assembly.load/cs/load1.cs#1)]
 [!code-vb[System.Reflection.Assembly.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.assembly.load/vb/load1.vb#1)]  
  
 <span data-ttu-id="ba04a-809"><xref:System.IO.FileLoadException> se produce si `assemblyString` especifica el nombre completo del ensamblado y el primer ensamblado que coincida con el nombre sencillo tiene una versión diferente, la referencia cultural o el token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="ba04a-809"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="ba04a-810">El cargador no continuará la búsqueda de otros ensamblados que coinciden con el nombre simple.</span><span class="sxs-lookup"><span data-stu-id="ba04a-810">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="ba04a-811">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-811">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-812">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-812">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-813">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-813">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-814">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-814">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-815">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.Load%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-815">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-816">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` parámetro para cargar una común imagen object file format (COFF), evidencia se hereda del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-816">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="ba04a-817">Esto se aplica a la versión 1.1 de .NET Framework Service Pack 1 (SP1) y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ba04a-817">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ba04a-818">En la versión 1.0 de .NET Framework y en la versión 1.1 sin SP1, cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` se combina el parámetro para cargar una imagen en formato COFF, evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-818">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="ba04a-819">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-819">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-820">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-820">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-821">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-821">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-822">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-822">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-823">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-823">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-824">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-824">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-825">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-825">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="ba04a-826">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="ba04a-826">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="ba04a-827">Sin embargo, es la manera recomendada para especificar un nombre de ensamblado crear un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-827">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="ba04a-828">Vea <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-828">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-829">El ejemplo siguiente carga un ensamblado dado su nombre completo y enumera todos los tipos contenidos en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-829">The following example loads an assembly given its fully qualified name, and lists all the types contained in the specified assembly.</span></span> <span data-ttu-id="ba04a-830">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-830">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="ba04a-831">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-831">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[assembly.load1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Assembly.Load1/CPP/load1.cpp#1)]
 [!code-csharp[assembly.load1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Assembly.Load1/CS/load1.cs#1)]
 [!code-vb[assembly.load1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Assembly.Load1/VB/load1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-832"><paramref name="assemblyString" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-832"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-833"><paramref name="assemblyString" /> es cadena de longitud cero.</span><span class="sxs-lookup"><span data-stu-id="ba04a-833"><paramref name="assemblyString" /> is a zero-length string.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-834">No se ha encontrado <paramref name="assemblyString" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-834"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-835">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-835">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-836"><paramref name="assemblyString" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-836"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-837">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-837">-or-</span></span> 
<span data-ttu-id="ba04a-838">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-838">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-839">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-839">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-840">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-840">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="ba04a-841">Cómo el motor en tiempo de ejecución ubica ensamblados</span><span class="sxs-lookup"><span data-stu-id="ba04a-841">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="ba04a-842">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-842">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="ba04a-843">Matriz de bytes que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-843">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-844">Carga el ensamblado con una imagen que toma como base el formato Common Object File Format (COFF) que contiene un ensamblado emitido, incluyendo opcionalmente los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-844">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols for the assembly.</span></span> <span data-ttu-id="ba04a-845">El ensamblado se carga en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-845">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="ba04a-846">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-846">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-847">El nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-847">The trust level of an assembly that is loaded by using this method is the same as the trust level of the calling assembly.</span></span> <span data-ttu-id="ba04a-848">Para cargar un ensamblado desde una matriz de bytes con el nivel de confianza del dominio de aplicación, use el <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-848">To load an assembly from a byte array with the trust level of the application domain, use the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.SecurityContextSource%29> method overload.</span></span> <span data-ttu-id="ba04a-849">Para obtener más información sobre el uso de las pruebas con las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que toma las matrices de bytes, vea el <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-849">For more information about the use of evidence with overloads of the <xref:System.Reflection.Assembly.Load%2A> method that take byte arrays, see the <xref:System.Reflection.Assembly.Load%28System.Byte%5B%5D%2CSystem.Byte%5B%5D%2CSystem.Security.Policy.Evidence%29> method overload.</span></span>  
  
 <span data-ttu-id="ba04a-850">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-850">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-851">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-851">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-852">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-852">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-853">Tenga en cuenta que esta sobrecarga del método siempre crea un nuevo <xref:System.Reflection.Assembly> objeto con su propia asignación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-853">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-854"><paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-854"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-855"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-855"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-856">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-856">-or-</span></span> 
<span data-ttu-id="ba04a-857">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-857">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="ba04a-858">Objeto que describe el ensamblado que va a cargarse.</span><span class="sxs-lookup"><span data-stu-id="ba04a-858">The object that describes the assembly to be loaded.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="ba04a-859">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-859">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-860">Carga un ensamblado dado su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-860">Loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span> <span data-ttu-id="ba04a-861">El ensamblado se carga en el dominio del llamador con la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-861">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="ba04a-862">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-862">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-863"><xref:System.IO.FileLoadException> se produce si `assemblyRef` especifica el nombre completo del ensamblado y el primer ensamblado que coincida con el nombre sencillo tiene una versión diferente, la referencia cultural o el token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="ba04a-863"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="ba04a-864">El cargador no continuará la búsqueda de otros ensamblados que coinciden con el nombre simple.</span><span class="sxs-lookup"><span data-stu-id="ba04a-864">The loader does not continue probing for other assemblies that match the simple name.</span></span>  <span data-ttu-id="ba04a-865">Empezando con .NET Framework 4, porque la ejecución de código en ensamblados remotos está deshabilitada de forma predeterminada, un <xref:System.IO.FileLoadException> también se produce si `assemblyRef` especifica un ensamblado remoto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-865">Starting with .NET Framework 4, because execution of code in remote assemblies is disabled by default, a <xref:System.IO.FileLoadException> is also thrown if `assemblyRef` specifies a remote assembly.</span></span> <span data-ttu-id="ba04a-866">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-866">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>   
  
> [!NOTE]
>  <span data-ttu-id="ba04a-867">No use un <xref:System.Reflection.AssemblyName> solamente con el <xref:System.Reflection.AssemblyName.CodeBase%2A> conjunto de propiedades.</span><span class="sxs-lookup"><span data-stu-id="ba04a-867">Do not use an <xref:System.Reflection.AssemblyName> with only the <xref:System.Reflection.AssemblyName.CodeBase%2A> property set.</span></span> <span data-ttu-id="ba04a-868">El <xref:System.Reflection.AssemblyName.CodeBase%2A> propiedad no proporciona todos los elementos de la identidad del ensamblado (por ejemplo, nombre o versión), por lo que la carga no se produce según las reglas de carga por identidad, como podría esperar de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-868">The <xref:System.Reflection.AssemblyName.CodeBase%2A> property does not supply any elements of the assembly identity (such as name or version), so loading does not occur according to load-by-identity rules, as you would expect from the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="ba04a-869">En su lugar, el ensamblado se carga con reglas de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-869">Instead, the assembly is loaded using load-from rules.</span></span> <span data-ttu-id="ba04a-870">Para obtener información acerca de las desventajas de utilizar el contexto de carga, consulte el <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> sobrecarga del método o [procedimientos recomendados para cargar ensamblados](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span><span class="sxs-lookup"><span data-stu-id="ba04a-870">For information about the disadvantages of using the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method overload or [Best Practices for Assembly Loading](~/docs/framework/deployment/best-practices-for-assembly-loading.md).</span></span>  
  
 <span data-ttu-id="ba04a-871">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-871">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-872">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-872">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-873">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-873">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-874">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-874">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-875">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.Load%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-875">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-876">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` parámetro para cargar una común imagen object file format (COFF), evidencia se hereda del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-876">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="ba04a-877">Esto se aplica a la versión 1.1 de .NET Framework Service Pack 1 (SP1) y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ba04a-877">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ba04a-878">En la versión 1.0 de .NET Framework y en la versión 1.1 sin SP1, cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` se combina el parámetro para cargar una imagen en formato COFF, evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-878">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="ba04a-879">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-879">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-880">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-880">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-881">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-881">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-882">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-882">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-883">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-883">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-884">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-884">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-885">Si tanto el <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propiedad y el <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propiedad se establece, el primer intento de cargar el ensamblado utiliza el nombre para mostrar (incluida la versión, referencia cultural y así sucesivamente, tal como lo devuelve el <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad).</span><span class="sxs-lookup"><span data-stu-id="ba04a-885">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="ba04a-886">Si no se encuentra el archivo, <xref:System.Reflection.AssemblyName.CodeBase%2A> se usa para buscar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-886">If the file is not found, <xref:System.Reflection.AssemblyName.CodeBase%2A> is used to search for the assembly.</span></span> <span data-ttu-id="ba04a-887">Si se encuentra el ensamblado mediante <xref:System.Reflection.AssemblyName.CodeBase%2A>, el nombre para mostrar se compara con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-887">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="ba04a-888">Si se produce un error en la coincidencia, un <xref:System.IO.FileLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="ba04a-888">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 <span data-ttu-id="ba04a-889">Si se llama a la <xref:System.Reflection.Assembly.Load%2A> método más de una vez en el mismo ensamblado, pero con una evidencia diferente, common language runtime no inicia una <xref:System.IO.FileLoadException> porque no pueden ser la igualdad y la integridad de las especificaciones de evidencias diferentes determinado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-889">If you call the <xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="ba04a-890">La evidencia que primero se realiza correctamente es la evidencia que se usa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-890">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-891"><paramref name="assemblyRef" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-891"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-892">No se ha encontrado <paramref name="assemblyRef" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-892"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-893"><paramref name="assemblyRef" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-893"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-894">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-894">-or-</span></span> 
<span data-ttu-id="ba04a-895">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-895">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-896">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-896">An assembly or module was loaded twice with two different evidences.</span></span>

<span data-ttu-id="ba04a-897">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-897">-or-</span></span>

<span data-ttu-id="ba04a-898"><paramref name="assemblyRef" /> especifica un ensamblado remoto, pero la capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-898"><paramref name="assemblyRef" /> specifies a remote assembly, but the ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-899">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-899">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-900">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="ba04a-900">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="ba04a-901">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-901">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-902">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-902">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-903">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-903">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-904">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-904">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="ba04a-905">Cómo el motor en tiempo de ejecución ubica ensamblados</span><span class="sxs-lookup"><span data-stu-id="ba04a-905">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="static member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="ba04a-906">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-906">The display name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="ba04a-907">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-907">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-908">Carga un ensamblado determinado a partir de su nombre de presentación, cargando el ensamblado en el dominio del llamador mediante la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-908">Loads an assembly given its display name, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="ba04a-909">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-909">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-910"><xref:System.IO.FileLoadException> se produce si `assemblyString` especifica el nombre completo del ensamblado y el primer ensamblado que coincida con el nombre sencillo tiene una versión diferente, la referencia cultural o el token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="ba04a-910"><xref:System.IO.FileLoadException> is thrown if `assemblyString` specifies the full assembly name, and the first assembly that matches the simple name has a different version, culture, or public key token.</span></span> <span data-ttu-id="ba04a-911">El cargador no continuará la búsqueda de otros ensamblados que coinciden con el nombre simple.</span><span class="sxs-lookup"><span data-stu-id="ba04a-911">The loader does not continue probing for other assemblies that match the simple name.</span></span>  
  
 <span data-ttu-id="ba04a-912">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-912">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-913">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-913">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-914">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-914">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-915">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-915">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-916">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.Load%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-916">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-917">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` parámetro para cargar una común imagen object file format (COFF), evidencia se hereda del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-917">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="ba04a-918">Esto se aplica a la versión 1.1 de .NET Framework Service Pack 1 (SP1) y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ba04a-918">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ba04a-919">En la versión 1.0 de .NET Framework y en la versión 1.1 sin SP1, cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` se combina el parámetro para cargar una imagen en formato COFF, evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-919">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="ba04a-920">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-920">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-921">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-921">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-922">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-922">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 <span data-ttu-id="ba04a-923">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-923">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-924">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-924">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-925">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-925">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-926">Si llama a este método varias veces en el mismo ensamblado, pero con una evidencia diferente, common language runtime no produce una <xref:System.IO.FileLoadException> porque no se puede determinar la igualdad y la integridad de las especificaciones de evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-926">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="ba04a-927">La evidencia que primero se realiza correctamente es la evidencia que se usa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-927">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="ba04a-928">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-928">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="ba04a-929">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="ba04a-929">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="ba04a-930">Sin embargo, es la manera recomendada para especificar un nombre de ensamblado crear un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-930">However, the recommended way to specify an assembly name is to create an <xref:System.Reflection.AssemblyName> object and pass it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="ba04a-931">Vea <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-931">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-932"><paramref name="assemblyString" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-932"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-933">No se ha encontrado <paramref name="assemblyString" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-933"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-934"><paramref name="assemblyString" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-934"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-935">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-935">-or-</span></span> 
<span data-ttu-id="ba04a-936">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-936">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-937">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-937">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-938">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-938">-or-</span></span> 
<span data-ttu-id="ba04a-939">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-939">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-940">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-940">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-941">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-941">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
        <related type="Article" href="~/docs/framework/deployment/how-the-runtime-locates-assemblies.md"><span data-ttu-id="ba04a-942">Cómo el motor en tiempo de ejecución ubica ensamblados</span><span class="sxs-lookup"><span data-stu-id="ba04a-942">How the Runtime Locates Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="ba04a-943">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-943">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="ba04a-944">Matriz de bytes que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-944">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="ba04a-945">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-945">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-946">Carga el ensamblado con una imagen que toma como base el formato Common Object File Format (COFF) que contiene un ensamblado emitido, incluyendo opcionalmente los símbolos y la evidencia del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-946">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and evidence for the assembly.</span></span> <span data-ttu-id="ba04a-947">El ensamblado se carga en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-947">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="ba04a-948">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-948">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-949">El ensamblado se carga en el dominio del llamador con la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-949">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span> <span data-ttu-id="ba04a-950">También se cargan los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-950">The raw bytes representing the symbols for the assembly are also loaded.</span></span>  
  
 <span data-ttu-id="ba04a-951">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-951">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-952">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-952">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-953">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-953">When you use a <xref:System.Reflection.Assembly.Load%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-954">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-954">When you use a <xref:System.Reflection.Assembly.Load%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-955">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.Load%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-955">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.Load%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-956">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` parámetro para cargar una imagen en formato COFF, evidencia se hereda del ensamblado que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-956">When you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is inherited from the calling assembly.</span></span> <span data-ttu-id="ba04a-957">Esto se aplica a la versión 1.1 de .NET Framework Service Pack 1 (SP1) y versiones posteriores.</span><span class="sxs-lookup"><span data-stu-id="ba04a-957">This applies to the .NET Framework version 1.1 Service Pack 1 (SP1) and subsequent releases.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="ba04a-958">En la versión 1.0 de .NET Framework y en la versión 1.1 sin SP1, cuando se usa un <xref:System.Reflection.Assembly.Load%2A> sobrecarga del método con un `Byte[]` se combina el parámetro para cargar una imagen en formato COFF, evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-958">In the .NET Framework version 1.0 and in version 1.1 without SP1, when you use a <xref:System.Reflection.Assembly.Load%2A> method overload with a `Byte[]` parameter to load a COFF image, evidence is combined.</span></span> <span data-ttu-id="ba04a-959">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-959">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-960">Cuando se usa un <xref:System.Reflection.Assembly.Load%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-960">When you use a <xref:System.Reflection.Assembly.Load%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-961">Evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF se omiten.</span><span class="sxs-lookup"><span data-stu-id="ba04a-961">Evidence of the calling assembly and evidence of the COFF image are ignored.</span></span>  
  
 <span data-ttu-id="ba04a-962">Reflejar en archivos ejecutables de C++ puede producir un <xref:System.BadImageFormatException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-962">Reflecting on C++ executable files might throw a <xref:System.BadImageFormatException>.</span></span> <span data-ttu-id="ba04a-963">Esto suele deberse a que el compilador de C++ las direcciones de reubicación o la `.reloc` sección desde el archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-963">This is most likely caused by the C++ compiler stripping the relocation addresses or the `.reloc` section from your executable file.</span></span> <span data-ttu-id="ba04a-964">Para conservar la `.reloc` de direcciones para el archivo ejecutable de C++, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-964">To preserve the `.reloc` address for your C++ executable file, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-965">Si se llama a las [\], bytes\<xref:System.Reflection.Assembly.Load%2A > método más de una vez en el mismo ensamblado, pero con una evidencia diferente, common language runtime no inicia una <xref:System.IO.FileLoadException> porque el no se puede determinar la igualdad y la integridad de las especificaciones de evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-965">If you call the [\], Byte\<xref:System.Reflection.Assembly.Load%2A> method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="ba04a-966">La evidencia que primero se realiza correctamente es la evidencia que se usa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-966">The evidence that first succeeds is the evidence that is used.</span></span>  
  
 <span data-ttu-id="ba04a-967">Tenga en cuenta que esta sobrecarga del método siempre crea un nuevo <xref:System.Reflection.Assembly> objeto con su propia asignación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-967">Note that this method overload always creates a new <xref:System.Reflection.Assembly> object with its own mapping.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-968"><paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-968"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-969"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-969"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-970">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-970">-or-</span></span> 
<span data-ttu-id="ba04a-971">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-971">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-972">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-972">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba04a-973"><paramref name="securityEvidence" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-973"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span>  <span data-ttu-id="ba04a-974">De forma predeterminada, la directiva CAS heredada no está habilitada en [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; cuando no está habilitada, <paramref name="securityEvidence" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-974">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-975">la capacidad suministrar la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-975">for the ability to supply evidence.</span></span> <span data-ttu-id="ba04a-976">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-976">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="ba04a-977">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-977">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.Load(System.Byte[],System.Byte[],System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="static member Load : byte[] * byte[] * System.Security.SecurityContextSource -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.Load (rawAssembly, rawSymbolStore, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="ba04a-978">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-978">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="ba04a-979">Matriz de bytes que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-979">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="ba04a-980">Origen del contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-980">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="ba04a-981">Carga el ensamblado con una imagen que toma como base el formato Common Object File Format (COFF) que contiene un ensamblado emitido, incluyendo opcionalmente los símbolos y especificando el origen del contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-981">Loads the assembly with a common object file format (COFF)-based image containing an emitted assembly, optionally including symbols and specifying the source for the security context.</span></span> <span data-ttu-id="ba04a-982">El ensamblado se carga en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-982">The assembly is loaded into the application domain of the caller.</span></span></summary>
        <returns><span data-ttu-id="ba04a-983">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-983">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-984">El ensamblado se carga en el dominio de aplicación del llamador con el origen especificado para el contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-984">The assembly is loaded into the application domain of the caller using the specified source for the security context.</span></span> <span data-ttu-id="ba04a-985">Si `rawSymbolStore` especifica, también se cargan los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-985">If `rawSymbolStore` was specified, the raw bytes that represent the symbols for the assembly are also loaded.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-986"><paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-986"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-987"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-987"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-988">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-988">-or-</span></span> 
 <span data-ttu-id="ba04a-989"><paramref name="rawAssembly" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-989"><paramref name="rawAssembly" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ba04a-990">El valor de <paramref name="securityContextSource" /> no es uno de los valores de enumeración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-990">The value of <paramref name="securityContextSource" /> is not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFile">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-991">Carga el contenido de un archivo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-991">Loads the contents of an assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="ba04a-992">Ruta de acceso completa al archivo que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-992">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="ba04a-993">Carga el contenido de un archivo de ensamblado en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-993">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="ba04a-994">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-994">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-995">Use el <xref:System.Reflection.Assembly.LoadFile%2A> método para cargar y examinar los ensamblados que tienen la misma identidad, pero se encuentran en diferentes rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-995">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="ba04a-996"><xref:System.Reflection.Assembly.LoadFile%2A> no carga archivos en el contexto de carga y no se resuelve las dependencias mediante la ruta de acceso de carga, como el <xref:System.Reflection.Assembly.LoadFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-996"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the load-from  context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="ba04a-997"><xref:System.Reflection.Assembly.LoadFile%2A> es útil en este escenario limitado porque <xref:System.Reflection.Assembly.LoadFrom%2A> no se puede usar para cargar ensamblados que tienen la misma identidad pero diferentes rutas de acceso; cargará solo el primer ensamblado de este tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-997"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="ba04a-998">A partir de .NET Framework 4, si `path` especifica un ensamblado en una ubicación remota, la carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFile` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-998">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-999">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-999">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
    
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1000">El argumento <paramref name="path" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1000">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1001">El parámetro <paramref name="path" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1001">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1002">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1002">A file that was found could not be loaded.</span></span>

<span data-ttu-id="ba04a-1003">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1003">-or-</span></span>

<span data-ttu-id="ba04a-1004">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1004">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1005">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1005">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1006">El parámetro <paramref name="path" /> es una cadena vacía ("") o no existe.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1006">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1007"><paramref name="path" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1007"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1008">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1008">-or-</span></span> 
<span data-ttu-id="ba04a-1009">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="path" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1009">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1010">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1010">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="ba04a-1011">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1011">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1012">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1012">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1013">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1013">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFile">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFile (string path, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFile(string path, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFile(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFile (path As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFile(System::String ^ path, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFile : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFile (path, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFile which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="ba04a-1014">Ruta de acceso completa al archivo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1014">The fully qualified path of the assembly file.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="ba04a-1015">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1015">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1016">Carga un ensamblado a partir de su ruta de acceso, cargando el ensamblado en el dominio del llamador mediante la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1016">Loads an assembly given its path, loading the assembly into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1017">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1017">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1018">Use el <xref:System.Reflection.Assembly.LoadFile%2A> método para cargar y examinar los ensamblados que tienen la misma identidad, pero se encuentran en diferentes rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1018">Use the <xref:System.Reflection.Assembly.LoadFile%2A> method to load and examine assemblies that have the same identity, but are located in different paths.</span></span> <span data-ttu-id="ba04a-1019"><xref:System.Reflection.Assembly.LoadFile%2A> no carga archivos en el <xref:System.Reflection.Assembly.LoadFrom%2A> contexto y no se resuelve las dependencias mediante la ruta de acceso de carga, como el <xref:System.Reflection.Assembly.LoadFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1019"><xref:System.Reflection.Assembly.LoadFile%2A> does not load files into the <xref:System.Reflection.Assembly.LoadFrom%2A> context, and does not resolve dependencies using the load path, as the <xref:System.Reflection.Assembly.LoadFrom%2A> method does.</span></span> <span data-ttu-id="ba04a-1020"><xref:System.Reflection.Assembly.LoadFile%2A> es útil en este escenario limitado porque <xref:System.Reflection.Assembly.LoadFrom%2A> no se puede usar para cargar ensamblados que tienen la misma identidad pero diferentes rutas de acceso; cargará solo el primer ensamblado de este tipo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1020"><xref:System.Reflection.Assembly.LoadFile%2A> is useful in this limited scenario because <xref:System.Reflection.Assembly.LoadFrom%2A> cannot be used to load assemblies that have the same identities but different paths; it will load only the first such assembly.</span></span>  

<span data-ttu-id="ba04a-1021">A partir de .NET Framework 4, si `path` especifica un ensamblado en una ubicación remota, la carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFile` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1021">Starting with .NET Framework 4, if `path` specifies an assembly in a remote location, assembly loading is disabled by default, and the `LoadFile` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1022">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1022">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1023">El argumento <paramref name="path" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1023">The <paramref name="path" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1024">El parámetro <paramref name="path" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1024">The <paramref name="path" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1025">El parámetro <paramref name="path" /> es una cadena vacía ("") o no existe.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1025">The <paramref name="path" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1026">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1026">A file that was found could not be loaded.</span></span>

<span data-ttu-id="ba04a-1027">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1027">-or-</span></span>

<span data-ttu-id="ba04a-1028">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1028">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1029">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1029">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1030"><paramref name="path" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1030"><paramref name="path" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1031">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1031">-or-</span></span> 
<span data-ttu-id="ba04a-1032">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="path" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1032">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="path" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba04a-1033"><paramref name="securityEvidence" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1033"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="ba04a-1034">De forma predeterminada, la directiva CAS heredada no está habilitada en [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; cuando no está habilitada, <paramref name="securityEvidence" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1034">By default, legacy CAS policy is not enabled in the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)]; when it is not enabled, <paramref name="securityEvidence" /> must be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1035">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1035">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="ba04a-1036">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1036">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1037">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1037">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1038">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1038">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-1039">Carga un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1039">Loads an assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
             
## Remarks

<span data-ttu-id="ba04a-1040">A partir de .NET Framework 4, la capacidad de ejecutar código en los ensamblados cargados desde ubicaciones remotas está deshabilitada de forma predeterminada y la llamada a la `LoadFrom` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1040">Starting with .NET Framework 4, the ability to execute code in assemblies loaded from remote locations is disabled by default, and the call to the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1041">Para cargar el ensamblado y ejecutar su código, debe:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1041">To load the assembly and execute its code, you must either:</span></span>

- <span data-ttu-id="ba04a-1042">Cree explícitamente un espacio aislado para el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1042">Explicitly create a sandbox for the assembly.</span></span> <span data-ttu-id="ba04a-1043">Vea [Cómo: Ejecutar código de confianza parcial en un recinto](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span><span class="sxs-lookup"><span data-stu-id="ba04a-1043">(See [How to: Run Partially Trusted Code in a Sandbox](~/docs/framework/misc/how-to-run-partially-trusted-code-in-a-sandbox.md).)</span></span>

- <span data-ttu-id="ba04a-1044">Ejecutar el código del ensamblado de plena confianza estableciendo el `enabled` atributo de la [ `<loadFromRemoteSources>` elemento de configuración](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) a `true`.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1044">Run the assembly's code in full trust by setting the `enabled` attribute of the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) to `true`.</span></span> <span data-ttu-id="ba04a-1045">Para obtener más información, consulte el [ `<loadFromRemoteSources>` elemento de configuración](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) artículo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1045">For more information, see the [`<loadFromRemoteSources>` configuration element](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) article.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1046">Nombre o ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1046">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1047">Carga un ensamblado a partir del nombre o ruta de acceso del archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1047">Loads an assembly given its file name or path.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1048">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1048">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1049">El `assemblyFile` parámetro debe hacer referencia a un identificador URI sin caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1049">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="ba04a-1050">Este método proporciona los caracteres de escape para todos los caracteres no válidos en el URI.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1050">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-1051">No se admite el protocolo de transferencia de archivos (FTP).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1051">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="ba04a-1052">Si el URI proporcionado para `assemblyFile` es una dirección FTP, no se carga el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1052">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="ba04a-1053">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1053">No exception is thrown.</span></span>  
  
 <span data-ttu-id="ba04a-1054">`assemblyFile` puede ser absoluta o relativa al directorio actual, y el ensamblado se carga en el dominio del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1054">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="ba04a-1055">Los ensamblados pueden cargarse en uno de estos tres contextos o pueden cargados sin contexto:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1055">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="ba04a-1056">El contexto de carga contiene ensamblados que se encuentran al sondear: en la GAC, en un ensamblado de almacén si se hospeda el tiempo de ejecución, o en el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1056">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="ba04a-1057">La mayoría de las sobrecargas del método <xref:System.Reflection.Assembly.Load%2A> carga ensamblados en este contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1057">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="ba04a-1058">El contexto de carga contiene ensamblados para los que el usuario proporcionó una ruta de acceso que no se incluye en los directorios para buscar mediante sondeo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1058">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="ba04a-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.AppDomain.ExecuteAssembly%2A> son ejemplos de métodos que cargan por ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1059"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span> 

    <span data-ttu-id="ba04a-1060">A partir de .NET Framework 4, si el identificador URI de `assemblyFile` especifica una ubicación remota, carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFrom` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1060">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1061">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1061">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="ba04a-1062">El contexto de solo reflexión contiene ensamblados cargados con los <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código de estos contextos no se puede ejecutar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1062">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="ba04a-1063">Si el usuario se genera o encuentra el ensamblado, no es en ningún contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1063">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="ba04a-1064">Esto se aplica a los ensamblados cargados mediante las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que especifique una matriz de bytes que contiene un ensamblado y a los ensamblados dinámicos transitorios creados con reflection emit y no se guardan en el disco.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1064">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="ba04a-1065">El contexto de carga permite que un ensamblado se cargue desde una ruta de acceso no está incluida en el sondeo y permite las dependencias de esa ruta de acceso que se busquen y se puede cargar porque el contexto mantiene la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1065">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="ba04a-1066">El <xref:System.Reflection.Assembly.LoadFrom%2A> método tiene las siguientes desventajas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1066">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="ba04a-1067">Considere usar <xref:System.Reflection.Assembly.Load%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1067">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="ba04a-1068">Si hay un ensamblado con la misma identidad ya cargado, <xref:System.Reflection.Assembly.LoadFrom%2A> devuelve el ensamblado cargado aunque se haya especificado otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1068">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="ba04a-1069">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>y más adelante un ensamblado en el contexto de carga intenta cargar el mismo ensamblado por nombre para mostrar, se produce un error en el intento de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1069">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="ba04a-1070">Esto puede ocurrir cuando se deserializa un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1070">This can occur when an assembly is de-serialized.</span></span>  
  
-   <span data-ttu-id="ba04a-1071">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>, y la ruta de acceso de sondeo incluye un ensamblado con la misma identidad pero en una ubicación diferente, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o puede producirse otro comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1071">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="ba04a-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, o <xref:System.Net.WebPermission>, en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1072"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="ba04a-1073">Si existe una imagen nativa para `assemblyFile`, no se utiliza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1073">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="ba04a-1074">El ensamblado no se puede cargar como dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1074">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="ba04a-1075">En la versión 1.0 y 1.1 de .NET Framework, no se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1075">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-1076">El ejemplo siguiente carga un ensamblado dado su nombre de archivo o ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1076">The following example loads an assembly given its file name or path.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#11)]
 [!code-csharp[System.Reflection.Assembly#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#11)]
 [!code-vb[System.Reflection.Assembly#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1077"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1077"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1078">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1078"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1079">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1079">A file that was found could not be loaded.</span></span>

<span data-ttu-id="ba04a-1080">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1080">-or-</span></span>

<span data-ttu-id="ba04a-1081">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1081">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1082">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1082">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1083"><paramref name="assemblyFile" /> no es un ensamblado válido; por ejemplo, un ensamblado de 32 bits en un proceso de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1083"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="ba04a-1084">Consulte el tema sobre excepciones para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1084">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="ba04a-1085">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1085">-or-</span></span> 
<span data-ttu-id="ba04a-1086">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1086">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1087">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1087">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1088">El parámetro <paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1088">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1089">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1089">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1090">para leer un URI que comienza con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1090">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="ba04a-1091">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1091">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-1092">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1092">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1093">Nombre o ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1093">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="ba04a-1094">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1094">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1095">Carga un ensamblado determinado a partir del nombre o ruta de acceso del archivo, a la vez que proporciona evidencia de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1095">Loads an assembly given its file name or path and supplying security evidence.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1096">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1096">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1097">El `assemblyFile` parámetro debe hacer referencia a un identificador URI sin caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1097">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="ba04a-1098">Este método proporciona los caracteres de escape para todos los caracteres no válidos en el URI.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1098">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-1099">No se admite el protocolo de transferencia de archivos (FTP).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1099">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="ba04a-1100">Si el URI proporcionado para `assemblyFile` es una dirección FTP, no se carga el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1100">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="ba04a-1101">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1101">No exception is thrown.</span></span>  
  
 <span data-ttu-id="ba04a-1102">`assemblyFile` puede ser absoluta o relativa al directorio actual, y el ensamblado se carga en el dominio del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1102">`assemblyFile` may be absolute or  relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="ba04a-1103">Los ensamblados pueden cargarse en uno de estos tres contextos o pueden cargados sin contexto:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1103">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="ba04a-1104">El contexto de carga contiene ensamblados que se encuentran al sondear: en la GAC, en un ensamblado de almacén si se hospeda el tiempo de ejecución, o en el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1104">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="ba04a-1105">La mayoría de las sobrecargas del método <xref:System.Reflection.Assembly.Load%2A> carga ensamblados en este contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1105">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="ba04a-1106">El contexto de carga contiene ensamblados para los que el usuario proporcionó una ruta de acceso que no se incluye en los directorios para buscar mediante sondeo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1106">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="ba04a-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.AppDomain.ExecuteAssembly%2A> son ejemplos de métodos que cargan por ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1107"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>

    <span data-ttu-id="ba04a-1108">A partir de .NET Framework 4, si el identificador URI de `assemblyFile` especifica una ubicación remota, carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFrom` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1108">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1109">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1109">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="ba04a-1110">El contexto de solo reflexión contiene ensamblados cargados con los <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código de estos contextos no se puede ejecutar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1110">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="ba04a-1111">Si el usuario se genera o encuentra el ensamblado, no es en ningún contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1111">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="ba04a-1112">Esto se aplica a los ensamblados cargados mediante las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que especifique una matriz de bytes que contiene un ensamblado y a los ensamblados dinámicos transitorios creados con reflection emit y no se guardan en el disco.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1112">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="ba04a-1113">El contexto de carga permite que un ensamblado se cargue desde una ruta de acceso no está incluida en el sondeo y permite las dependencias de esa ruta de acceso que se busquen y se puede cargar porque el contexto mantiene la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1113">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="ba04a-1114">El <xref:System.Reflection.Assembly.LoadFrom%2A> método tiene las siguientes desventajas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1114">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="ba04a-1115">Considere usar <xref:System.Reflection.Assembly.Load%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1115">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="ba04a-1116">Si hay un ensamblado con la misma identidad ya cargado, <xref:System.Reflection.Assembly.LoadFrom%2A> devuelve el ensamblado cargado aunque se haya especificado otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1116">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="ba04a-1117">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>y más adelante un ensamblado en el contexto de carga intenta cargar el mismo ensamblado por nombre para mostrar, se produce un error en el intento de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1117">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="ba04a-1118">Esto puede ocurrir cuando se deserializa un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1118">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="ba04a-1119">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>, y la ruta de acceso de sondeo incluye un ensamblado con la misma identidad pero en una ubicación diferente, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o puede producirse otro comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1119">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="ba04a-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, o <xref:System.Net.WebPermission>, en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1120"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="ba04a-1121">Si existe una imagen nativa para `assemblyFile`, no se utiliza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1121">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="ba04a-1122">El ensamblado no se puede cargar como dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1122">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="ba04a-1123">En la versión 1.0 y 1.1 de .NET Framework, no se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1123">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="ba04a-1124">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1124">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-1125">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1125">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-1126">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1126">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-1127">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1127">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-1128">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.LoadFrom%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1128">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-1129">Si llama a este método varias veces en el mismo ensamblado, pero con una evidencia diferente, common language runtime no produce una <xref:System.IO.FileLoadException> porque no se puede determinar la igualdad y la integridad de las especificaciones de evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1129">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="ba04a-1130">La evidencia que primero se realiza correctamente es la evidencia que se usa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1130">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="ba04a-1131">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un `Byte[]` se combina el parámetro a una común imagen object file format (COFF), pruebas de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1131">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="ba04a-1132">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1132">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-1133">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1133">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-1134">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1134">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1135"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1135"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1136">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1136"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1137">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1137">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-1138">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1138">-or-</span></span> 
<span data-ttu-id="ba04a-1139">El elemento <paramref name="securityEvidence" /> no es ambiguo y se determinó que no es válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1139">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="ba04a-1140">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1140">-or-</span></span>

<span data-ttu-id="ba04a-1141">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1141">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1142">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1142">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1143"><paramref name="assemblyFile" /> no es un ensamblado válido; por ejemplo, un ensamblado de 32 bits en un proceso de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1143"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="ba04a-1144">Consulte el tema sobre excepciones para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1144">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="ba04a-1145">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1145">-or-</span></span> 
<span data-ttu-id="ba04a-1146">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1146">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1147">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1147">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1148">El parámetro <paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1148">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1149">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1149">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1150">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1150">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1151">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1151">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1152">para leer un URI que comienza con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1152">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="ba04a-1153">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1153">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-1154">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1154">for reading a URI that does not begin with "file://".</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1155">Nombre o ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1155">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="ba04a-1156">Valor del código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1156">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="ba04a-1157">Algoritmo hash utilizado para los archivos hash y para generar el nombre seguro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1157">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="ba04a-1158">Carga un ensamblado a partir de su nombre o ruta de acceso de archivo, valor hash y algoritmo hash.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1158">Loads an assembly given its file name or path, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1159">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1159">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1160">El `assemblyFile` parámetro debe hacer referencia a un identificador URI sin caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1160">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="ba04a-1161">Este método proporciona los caracteres de escape para todos los caracteres no válidos en el URI.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1161">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-1162">No se admite el protocolo de transferencia de archivos (FTP).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1162">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="ba04a-1163">Si el URI proporcionado para `assemblyFile` es una dirección FTP, no se carga el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1163">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="ba04a-1164">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1164">No exception is thrown.</span></span>  
  
 <span data-ttu-id="ba04a-1165">`assemblyFile` puede ser absoluta o relativa al directorio actual, y el ensamblado se carga en el dominio del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1165">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="ba04a-1166">Los ensamblados pueden cargarse en uno de estos tres contextos o pueden cargados sin contexto:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1166">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="ba04a-1167">El contexto de carga contiene ensamblados que se encuentran al sondear: en la caché global de ensamblados, en un ensamblado de almacén si se hospeda el tiempo de ejecución, o en el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1167">The load context contains assemblies found by probing: in the global assembly cache, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="ba04a-1168">La mayoría de las sobrecargas del método <xref:System.Reflection.Assembly.Load%2A> carga ensamblados en este contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1168">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="ba04a-1169">El contexto de carga contiene ensamblados para los que el usuario proporcionó una ruta de acceso que no se incluye en el sondeo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1169">The load-from context contains assemblies for which the user provided a path that is not included in probing.</span></span> <span data-ttu-id="ba04a-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.AppDomain.ExecuteAssembly%2A> son ejemplos de métodos que cargan por ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1170"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="ba04a-1171">A partir de .NET Framework 4, si el identificador URI de `assemblyFile` especifica una ubicación remota, carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFrom` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1171">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1172">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1172">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="ba04a-1173">El contexto de solo reflexión contiene ensamblados cargados con los <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código de estos contextos no se puede ejecutar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1173">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="ba04a-1174">Si el usuario se genera o encuentra el ensamblado, no es en ningún contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1174">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="ba04a-1175">Esto se aplica a los ensamblados cargados mediante las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que especifique una matriz de bytes que contiene un ensamblado y a los ensamblados dinámicos transitorios creados con reflection emit y no se guardan en el disco.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1175">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="ba04a-1176">El contexto de carga permite que un ensamblado se cargue desde una ruta de acceso que no se incluye en el sondeo y permite las dependencias de esa ruta de acceso que se busquen y se puede cargar porque el contexto mantiene la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1176">The load-from context allows an assembly to be loaded from a path that is not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="ba04a-1177">El <xref:System.Reflection.Assembly.LoadFrom%2A> método tiene las siguientes desventajas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1177">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="ba04a-1178">Considere usar <xref:System.Reflection.Assembly.Load%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1178">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="ba04a-1179">Si hay un ensamblado con la misma identidad ya cargado, <xref:System.Reflection.Assembly.LoadFrom%2A> devuelve el ensamblado cargado aunque se haya especificado otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1179">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="ba04a-1180">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>y más adelante un ensamblado en el contexto de carga intenta cargar el mismo ensamblado por nombre para mostrar, se produce un error en el intento de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1180">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="ba04a-1181">Esto puede ocurrir cuando se deserializa un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1181">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="ba04a-1182">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>, y la ruta de acceso de sondeo incluye un ensamblado con la misma identidad pero en una ubicación diferente, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o puede producirse otro comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1182">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="ba04a-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, o <xref:System.Net.WebPermission>, en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1183"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="ba04a-1184">Si existe una imagen nativa para `assemblyFile`, no se utiliza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1184">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="ba04a-1185">No se puede cargar el ensamblado con dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1185">The assembly cannot be loaded as domain-neutral.</span></span>  
  
 <span data-ttu-id="ba04a-1186">El ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1186">The assembly is loaded with the evidence that the loader supplies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1187"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1187"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1188">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1188"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1189">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1189">A file that was found could not be loaded.</span></span>

<span data-ttu-id="ba04a-1190">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1190">-or-</span></span>

<span data-ttu-id="ba04a-1191">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1191">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1192">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1192">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1193"><paramref name="assemblyFile" /> no es un ensamblado válido; por ejemplo, un ensamblado de 32 bits en un proceso de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1193"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="ba04a-1194">Consulte el tema sobre excepciones para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1194">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="ba04a-1195">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1195">-or-</span></span> 
 <span data-ttu-id="ba04a-1196"><paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1196"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1197">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1197">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1198">El parámetro <paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1198">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1199">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1199">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1200">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1200">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1201">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1201">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1202">para leer un URI que comienza con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1202">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="ba04a-1203">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1203">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-1204">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1204">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadFrom (string assemblyFile, System.Security.Policy.Evidence securityEvidence, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadFrom(string assemblyFile, class System.Security.Policy.Evidence securityEvidence, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadFrom(System.String,System.Security.Policy.Evidence,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadFrom (assemblyFile As String, securityEvidence As Evidence, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadFrom(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ securityEvidence, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="static member LoadFrom : string * System.Security.Policy.Evidence * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadFrom (assemblyFile, securityEvidence, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method is obsolete and will be removed in a future release of the .NET Framework. Please use an overload of LoadFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1205">Nombre o ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1205">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="ba04a-1206">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1206">Evidence for loading the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="ba04a-1207">Valor del código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1207">The value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="ba04a-1208">Algoritmo hash utilizado para los archivos hash y para generar el nombre seguro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1208">The hash algorithm used for hashing files and for generating the strong name.</span></span></param>
        <summary><span data-ttu-id="ba04a-1209">Carga un ensamblado a partir de su nombre o ruta de acceso de archivo, evidencia de seguridad, valor hash y algoritmo hash.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1209">Loads an assembly given its file name or path, security evidence, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1210">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1210">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1211">El `assemblyFile` parámetro debe hacer referencia a un identificador URI sin caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1211">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="ba04a-1212">Este método proporciona los caracteres de escape para todos los caracteres no válidos en el URI.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1212">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-1213">No se admite el protocolo de transferencia de archivos (FTP).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1213">File transfer protocol (FTP) is not supported.</span></span> <span data-ttu-id="ba04a-1214">Si el URI proporcionado para `assemblyFile` es una dirección FTP, no se carga el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1214">If the URI supplied for `assemblyFile` is an FTP address, the assembly is not loaded.</span></span> <span data-ttu-id="ba04a-1215">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1215">No exception is thrown.</span></span>  
  
 <span data-ttu-id="ba04a-1216">`assemblyFile` puede ser absoluta o relativa al directorio actual, y el ensamblado se carga en el dominio del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1216">`assemblyFile` may be absolute or relative to the current directory, and the assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="ba04a-1217">Los ensamblados pueden cargarse en uno de estos tres contextos o pueden cargados sin contexto:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1217">Assemblies can be loaded into one of three contexts, or can be loaded without context:</span></span>  
  
-   <span data-ttu-id="ba04a-1218">El contexto de carga contiene ensamblados que se encuentran al sondear: en la GAC, en un ensamblado de almacén si se hospeda el tiempo de ejecución, o en el <xref:System.AppDomainSetup.ApplicationBase%2A> y <xref:System.AppDomainSetup.PrivateBinPath%2A> del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1218">The load context contains assemblies found by probing: in the GAC, in a host assembly store if the runtime is hosted, or in the <xref:System.AppDomainSetup.ApplicationBase%2A> and <xref:System.AppDomainSetup.PrivateBinPath%2A> of the application domain.</span></span> <span data-ttu-id="ba04a-1219">La mayoría de las sobrecargas del método <xref:System.Reflection.Assembly.Load%2A> carga ensamblados en este contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1219">Most overloads of the <xref:System.Reflection.Assembly.Load%2A> method load assemblies into this context.</span></span>  
  
-   <span data-ttu-id="ba04a-1220">El contexto de carga contiene ensamblados para los que el usuario proporcionó una ruta de acceso que no se incluye en los directorios para buscar mediante sondeo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1220">The load-from context contains assemblies for which the user provided a path not included in the directories searched by probing.</span></span> <span data-ttu-id="ba04a-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.AppDomain.ExecuteAssembly%2A> son ejemplos de métodos que cargan por ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1221"><xref:System.Reflection.Assembly.LoadFrom%2A>, <xref:System.AppDomain.CreateInstanceFrom%2A>, and <xref:System.AppDomain.ExecuteAssembly%2A> are examples of methods that load by path.</span></span>  

    <span data-ttu-id="ba04a-1222">A partir de .NET Framework 4, si el identificador URI de `assemblyFile` especifica una ubicación remota, carga de ensamblados está deshabilitada de forma predeterminada y el `LoadFrom` método produce una <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1222">Starting with .NET Framework 4, if the URI of `assemblyFile` specifies a remote location, assembly loading is disabled by default, and the `LoadFrom` method throws a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1223">Para habilitar la ejecución de código cargado desde ubicaciones remotas, puede usar el [ `<loadFromRemoteSources>` ](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) elemento de configuración.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1223">To enable execution of code loaded from remote locations, you can use the [`<loadFromRemoteSources>`](~/docs/framework/configure-apps/file-schema/runtime/loadfromremotesources-element.md) configuration element.</span></span>    
  
-   <span data-ttu-id="ba04a-1224">El contexto de solo reflexión contiene ensamblados cargados con los <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> y <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> métodos; código de estos contextos no se puede ejecutar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1224">The reflection-only context contains assemblies loaded with the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> and <xref:System.Reflection.Assembly.ReflectionOnlyLoadFrom%2A> methods; code in these contexts cannot be executed.</span></span>  
  
-   <span data-ttu-id="ba04a-1225">Si el usuario se genera o encuentra el ensamblado, no es en ningún contexto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1225">If the user generated or found the assembly, it is not in any context.</span></span> <span data-ttu-id="ba04a-1226">Esto se aplica a los ensamblados cargados mediante las sobrecargas de los <xref:System.Reflection.Assembly.Load%2A> método que especifique una matriz de bytes que contiene un ensamblado y a los ensamblados dinámicos transitorios creados con reflection emit y no se guardan en el disco.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1226">This applies to assemblies loaded using overloads of the <xref:System.Reflection.Assembly.Load%2A> method that specify a byte array containing an assembly, and to transient dynamic assemblies created with reflection emit and not saved to disk.</span></span>  
  
 <span data-ttu-id="ba04a-1227">El contexto de carga permite que un ensamblado se cargue desde una ruta de acceso no está incluida en el sondeo y permite las dependencias de esa ruta de acceso que se busquen y se puede cargar porque el contexto mantiene la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1227">The load-from context allows an assembly to be loaded from a path not included in probing, and yet allows dependencies on that path to be found and loaded because the path information is maintained by the context.</span></span>  
  
 <span data-ttu-id="ba04a-1228">El <xref:System.Reflection.Assembly.LoadFrom%2A> método tiene las siguientes desventajas.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1228">The <xref:System.Reflection.Assembly.LoadFrom%2A> method has the following disadvantages.</span></span> <span data-ttu-id="ba04a-1229">Considere usar <xref:System.Reflection.Assembly.Load%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1229">Consider using <xref:System.Reflection.Assembly.Load%2A> instead.</span></span>  
  
-   <span data-ttu-id="ba04a-1230">Si hay un ensamblado con la misma identidad ya cargado, <xref:System.Reflection.Assembly.LoadFrom%2A> devuelve el ensamblado cargado aunque se haya especificado otra ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1230">If an assembly with the same identity is already loaded, <xref:System.Reflection.Assembly.LoadFrom%2A> returns the loaded assembly even if a different path was specified.</span></span>  
  
-   <span data-ttu-id="ba04a-1231">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>y más adelante un ensamblado en el contexto de carga intenta cargar el mismo ensamblado por nombre para mostrar, se produce un error en el intento de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1231">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and later an assembly in the load context attempts to load the same assembly by display name, the load attempt fails.</span></span> <span data-ttu-id="ba04a-1232">Esto puede ocurrir cuando se deserializa un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1232">This can occur when an assembly is deserialized.</span></span>  
  
-   <span data-ttu-id="ba04a-1233">Si un ensamblado se carga con <xref:System.Reflection.Assembly.LoadFrom%2A>, y la ruta de acceso de sondeo incluye un ensamblado con la misma identidad pero en una ubicación diferente, un <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, o puede producirse otro comportamiento inesperado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1233">If an assembly is loaded with <xref:System.Reflection.Assembly.LoadFrom%2A>, and the probing path includes an assembly with the same identity but a different location, an <xref:System.InvalidCastException>, <xref:System.MissingMethodException>, or other unexpected behavior can occur.</span></span>  
  
-   <span data-ttu-id="ba04a-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> exige <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> y <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, o <xref:System.Net.WebPermission>, en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1234"><xref:System.Reflection.Assembly.LoadFrom%2A> demands <xref:System.Security.Permissions.FileIOPermissionAccess.Read?displayProperty=nameWithType> and <xref:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery?displayProperty=nameWithType>, or <xref:System.Net.WebPermission>, on the specified path.</span></span>  
  
-   <span data-ttu-id="ba04a-1235">Si existe una imagen nativa para `assemblyFile`, no se utiliza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1235">If a native image exists for `assemblyFile`, it is not used.</span></span> <span data-ttu-id="ba04a-1236">El ensamblado no se puede cargar como dominio neutro.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1236">The assembly cannot be loaded as domain neutral.</span></span>  
  
-   <span data-ttu-id="ba04a-1237">En la versión 1.0 y 1.1 de .NET Framework, no se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1237">In the .NET Framework version 1.0 and 1.1, policy is not applied.</span></span>  
  
 <span data-ttu-id="ba04a-1238">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1238">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-1239">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1239">The rules for assembly and security evidence merging are as follows:</span></span>  
  
-   <span data-ttu-id="ba04a-1240">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método sin ningún <xref:System.Security.Policy.Evidence> parámetro, el ensamblado se carga con la evidencia que proporciona el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1240">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with no <xref:System.Security.Policy.Evidence> parameter, the assembly is loaded with the evidence that the loader supplies.</span></span>  
  
-   <span data-ttu-id="ba04a-1241">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1241">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="ba04a-1242">Evidencias proporcionada como argumento a la <xref:System.Reflection.Assembly.LoadFrom%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1242">Pieces of evidence supplied as an argument to the <xref:System.Reflection.Assembly.LoadFrom%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
-   <span data-ttu-id="ba04a-1243">Si llama a este método varias veces en el mismo ensamblado, pero con una evidencia diferente, common language runtime no produce una <xref:System.IO.FileLoadException> porque no se puede determinar la igualdad y la integridad de las especificaciones de evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1243">If you call this method more than once on the same assembly but with a different evidence specified, the common language runtime does not throw a <xref:System.IO.FileLoadException> because the equality and integrity of the different evidence specifications cannot be determined.</span></span> <span data-ttu-id="ba04a-1244">La evidencia que primero se realiza correctamente es la evidencia que se usa.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1244">The evidence that first succeeds is the evidence that is used.</span></span>  
  
-   <span data-ttu-id="ba04a-1245">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un `Byte[]` se combina el parámetro a una común imagen object file format (COFF), pruebas de carga.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1245">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter to load a common object file format (COFF) image, evidence is combined.</span></span> <span data-ttu-id="ba04a-1246">`Zone`, `Url` y `Site` se heredan del ensamblado que realiza la llamada, y `Hash` y `StrongName` se toman del ensamblado COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1246">`Zone`, `Url` and `Site` are inherited from the calling assembly, and `Hash` and `StrongName` are taken from the COFF assembly.</span></span>  
  
-   <span data-ttu-id="ba04a-1247">Cuando se usa un <xref:System.Reflection.Assembly.LoadFrom%2A> método con un `Byte[]` parámetro y <xref:System.Security.Policy.Evidence> para cargar una imagen en formato COFF, se usa solo la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1247">When you use a <xref:System.Reflection.Assembly.LoadFrom%2A> method with a `Byte[]` parameter and <xref:System.Security.Policy.Evidence> to load a COFF image, only the supplied evidence is used.</span></span> <span data-ttu-id="ba04a-1248">Se omiten la evidencia del ensamblado que realiza la llamada y la evidencia de la imagen COFF.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1248">Evidence of the calling assembly and evidence of the COFF image is ignored.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1249"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1249"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1250">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1250"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1251">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1251">A file that was found could not be loaded.</span></span>  
  
<span data-ttu-id="ba04a-1252">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1252">-or-</span></span> 
<span data-ttu-id="ba04a-1253">El elemento <paramref name="securityEvidence" /> no es ambiguo y se determinó que no es válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1253">The <paramref name="securityEvidence" /> is not ambiguous and is determined to be invalid.</span></span>

<span data-ttu-id="ba04a-1254">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1254">-or-</span></span>

<span data-ttu-id="ba04a-1255">La capacidad de ejecutar código en los ensamblados remotos está deshabilitada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1255">The ability to execute code in remote assemblies is disabled.</span></span> <span data-ttu-id="ba04a-1256">Vea <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1256">See <see href="https://docs.microsoft.com/dotnet/framework/configure-apps/file-schema/runtime/loadfromremotesources-element">&lt;loadFromRemoteSources&gt;</see>.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1257"><paramref name="assemblyFile" /> no es un ensamblado válido; por ejemplo, un ensamblado de 32 bits en un proceso de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1257"><paramref name="assemblyFile" /> is not a valid assembly; for example, a 32-bit assembly in a 64-bit process.</span></span> <span data-ttu-id="ba04a-1258">Consulte el tema sobre excepciones para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1258">See the exception topic for more information.</span></span>  
  
<span data-ttu-id="ba04a-1259">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1259">-or-</span></span> 
<span data-ttu-id="ba04a-1260">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1260">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1261">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1261">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1262">El parámetro <paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1262">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1263">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1263">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1264">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1264">to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1265">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1265">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1266">para leer un URI que comienza con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1266">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="ba04a-1267">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1267">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-1268">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1268">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadModule">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-1269">Carga el módulo interno para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1269">Loads the module internal to this assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public System.Reflection.Module LoadModule (string moduleName, byte[] rawModule);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadModule (moduleName As String, rawModule As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="ba04a-1270">El nombre del módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1270">The name of the module.</span></span> <span data-ttu-id="ba04a-1271">Esta cadena debe corresponder a un nombre de archivo en el manifiesto de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1271">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="ba04a-1272">Matriz de bytes que es una imagen basada en COFF que contiene un módulo emitido o un recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1272">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <summary><span data-ttu-id="ba04a-1273">Carga el módulo, que es interno para este ensamblado, con una imagen que toma como base el formato Common Object File Format (COFF) y que contiene un módulo emitido o un archivo de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1273">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1274">Módulo cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1274">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1275"><paramref name="moduleName" /> o <paramref name="rawModule" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1275"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1276"><paramref name="moduleName" /> no coincide con una entrada de archivo en el manifiesto de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1276"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1277"><paramref name="rawModule" /> no es un módulo válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1277"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1278">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1278">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1279">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1279">to provide evidence.</span></span> <span data-ttu-id="ba04a-1280">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1280">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="LoadModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module LoadModule (string moduleName, byte[] rawModule, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Module LoadModule(string moduleName, unsigned int8[] rawModule, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadModule(System.String,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function LoadModule (moduleName As String, rawModule As Byte(), rawSymbolStore As Byte()) As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Module ^ LoadModule(System::String ^ moduleName, cli::array &lt;System::Byte&gt; ^ rawModule, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module&#xA;override this.LoadModule : string * byte[] * byte[] -&gt; System.Reflection.Module" Usage="assembly.LoadModule (moduleName, rawModule, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.LoadModule(System.String,System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="moduleName" Type="System.String" />
        <Parameter Name="rawModule" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="moduleName"><span data-ttu-id="ba04a-1281">El nombre del módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1281">The name of the module.</span></span> <span data-ttu-id="ba04a-1282">Esta cadena debe corresponder a un nombre de archivo en el manifiesto de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1282">This string must correspond to a file name in this assembly's manifest.</span></span></param>
        <param name="rawModule"><span data-ttu-id="ba04a-1283">Matriz de bytes que es una imagen basada en COFF que contiene un módulo emitido o un recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1283">A byte array that is a COFF-based image containing an emitted module, or a resource.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="ba04a-1284">Matriz de bytes que contiene los bytes sin formato que representan a los símbolos del módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1284">A byte array containing the raw bytes representing the symbols for the module.</span></span> <span data-ttu-id="ba04a-1285">Debe ser <see langword="null" /> si es un archivo de recurso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1285">Must be <see langword="null" /> if this is a resource file.</span></span></param>
        <summary><span data-ttu-id="ba04a-1286">Carga el módulo, que es interno para este ensamblado, con una imagen que toma como base el formato Common Object File Format (COFF) y que contiene un módulo emitido o un archivo de recursos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1286">Loads the module, internal to this assembly, with a common object file format (COFF)-based image containing an emitted module, or a resource file.</span></span> <span data-ttu-id="ba04a-1287">También se cargan los bytes sin formato que representan a los símbolos del módulo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1287">The raw bytes representing the symbols for the module are also loaded.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1288">Módulo cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1288">The loaded module.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1289"><paramref name="moduleName" /> o <paramref name="rawModule" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1289"><paramref name="moduleName" /> or <paramref name="rawModule" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1290"><paramref name="moduleName" /> no coincide con una entrada de archivo en el manifiesto de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1290"><paramref name="moduleName" /> does not match a file entry in this assembly's manifest.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1291"><paramref name="rawModule" /> no es un módulo válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1291"><paramref name="rawModule" /> is not a valid module.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1292">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1292">A file that was found could not be loaded.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1293">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1293">to provide evidence.</span></span> <span data-ttu-id="ba04a-1294">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1294">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="LoadWithPartialName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-1295">Carga un ensamblado desde el directorio de la aplicación o desde la caché global de ensamblados utilizando un nombre parcial.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1295">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba04a-1296">Las sobrecargas de los <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> método están obsoleto y se han conservado por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1296">The overloads of the <xref:System.Reflection.Assembly.LoadWithPartialName%2A?displayProperty=nameWithType> method are obsolete and have been retained for backward compatibility.</span></span> <span data-ttu-id="ba04a-1297">La alternativa no obsoleta es el método <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1297">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName partialName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="ba04a-1298">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1298">The display name of the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1299">Carga un ensamblado desde el directorio de la aplicación o desde la caché global de ensamblados utilizando un nombre parcial.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1299">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1300">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1300">The loaded assembly.</span></span> <span data-ttu-id="ba04a-1301">Si no se encuentra <paramref name="partialName" />, este método devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1301">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba04a-1302">El <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> método está obsoleto y se ha conservado por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1302">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="ba04a-1303">La alternativa no obsoleta es el método <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1303">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba04a-1304">Las aplicaciones que se cargan ensamblados con este método se verán afectadas por las actualizaciones de esos ensamblados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1304">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="ba04a-1305">Por lo tanto, no utilice este método; diseñar la aplicación para usar el <xref:System.Reflection.Assembly.Load%28System.String%29> sobrecarga del método o la <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1305">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%28System.String%29> method overload or the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 <span data-ttu-id="ba04a-1306">Este método llama primero al <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1306">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="ba04a-1307">Si no se encuentra el ensamblado, este método devuelve el ensamblado de la caché global de ensamblados que tiene el mismo nombre simple y el número de versión superior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1307">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1308">El parámetro <paramref name="partialName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1308">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1309"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1309"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1310">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1310">-or-</span></span> 
<span data-ttu-id="ba04a-1311">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="partialName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1311">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="LoadWithPartialName">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly LoadWithPartialName (string partialName, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly LoadWithPartialName(string partialName, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.LoadWithPartialName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function LoadWithPartialName (partialName As String, securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ LoadWithPartialName(System::String ^ partialName, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="static member LoadWithPartialName : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.LoadWithPartialName (partialName, securityEvidence)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use Assembly.Load() instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="partialName" Type="System.String" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="partialName"><span data-ttu-id="ba04a-1312">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1312">The display name of the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="ba04a-1313">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1313">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1314">Carga un ensamblado desde el directorio de la aplicación o desde la caché global de ensamblados utilizando un nombre parcial.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1314">Loads an assembly from the application directory or from the global assembly cache using a partial name.</span></span> <span data-ttu-id="ba04a-1315">El ensamblado se carga en el dominio del llamador con la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1315">The assembly is loaded into the domain of the caller using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1316">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1316">The loaded assembly.</span></span> <span data-ttu-id="ba04a-1317">Si no se encuentra <paramref name="partialName" />, este método devuelve <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1317">If <paramref name="partialName" /> is not found, this method returns <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="ba04a-1318">El <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> método está obsoleto y se ha conservado por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1318">The <xref:System.Reflection.Assembly.LoadWithPartialName%28System.String%2CSystem.Security.Policy.Evidence%29> method is obsolete and has been retained for backward compatibility.</span></span> <span data-ttu-id="ba04a-1319">La alternativa no obsoleta es el método <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1319">The non-obsolete alternative is <xref:System.Reflection.Assembly.Load%28System.String%29?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="ba04a-1320">La evidencia es el conjunto de información que se utiliza para tomar decisiones de la directiva de seguridad, por ejemplo, qué permisos se conceden al código.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1320">Evidence is the set of information that constitutes input to security policy decisions, such as what permissions can be granted to code.</span></span>  
  
 <span data-ttu-id="ba04a-1321">Las aplicaciones que se cargan ensamblados con este método se verán afectadas por las actualizaciones de esos ensamblados.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1321">Applications that load assemblies with this method will be affected by upgrades of those assemblies.</span></span> <span data-ttu-id="ba04a-1322">Por lo tanto, no utilice este método; diseñar la aplicación para usar el <xref:System.Reflection.Assembly.Load%2A> método o la <xref:System.Reflection.Assembly.LoadFrom%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1322">Therefore, do not use this method; redesign the application to use the <xref:System.Reflection.Assembly.Load%2A> method or the <xref:System.Reflection.Assembly.LoadFrom%2A> method.</span></span>  
  
 <span data-ttu-id="ba04a-1323">Este método llama primero al <xref:System.Reflection.Assembly.Load%2A>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1323">This method first calls <xref:System.Reflection.Assembly.Load%2A>.</span></span> <span data-ttu-id="ba04a-1324">Si no se encuentra el ensamblado, este método devuelve el ensamblado de la caché global de ensamblados que tiene el mismo nombre simple y el número de versión superior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1324">If the assembly is not found, this method returns the assembly from the global assembly cache that has the same simple name, and the highest version number.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1325">Se cargó un ensamblado o módulo dos veces con dos conjuntos de evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1325">An assembly or module was loaded twice with two different sets of evidence.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1326">El parámetro <paramref name="partialName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1326">The <paramref name="partialName" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1327"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1327"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1328">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1328">-or-</span></span> 
<span data-ttu-id="ba04a-1329">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="partialName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1329">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="partialName" /> was compiled with a later version.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="ba04a-1330">para llamar a código no administrado y cargar un ensamblado con evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1330">for calling unmanaged code and to load an assembly with evidence.</span></span> <span data-ttu-id="ba04a-1331">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1331">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" /></span></span></permission>
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
        <altmember cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="Location">
      <MemberSignature Language="C#" Value="public virtual string Location { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Location" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Location" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Location As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Location { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Location : string" Usage="System.Reflection.Assembly.Location" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Assembly.Location</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1332">Obtiene la ruta de acceso completa o la ubicación UNC del archivo cargado que contiene el manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1332">Gets the full path or UNC location of the loaded file that contains the manifest.</span></span></summary>
        <value><span data-ttu-id="ba04a-1333">Ubicación del archivo cargado que contiene el manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1333">The location of the loaded file that contains the manifest.</span></span> <span data-ttu-id="ba04a-1334">Si se creó una instantánea del archivo cargado, la ubicación se corresponde con la del archivo después de que se hiciera la instantánea.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1334">If the loaded file was shadow-copied, the location is that of the file after being shadow-copied.</span></span> <span data-ttu-id="ba04a-1335">Si el ensamblado se carga desde una matriz de bytes, como cuando se usa la sobrecarga del método <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" />, el valor devuelto es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1335">If the assembly is loaded from a byte array, such as when using the <see cref="M:System.Reflection.Assembly.Load(System.Byte[])" /> method overload, the value returned is an empty string ("").</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1336">Para obtener la ubicación antes de que el archivo se copia sombra, use el <xref:System.Reflection.Assembly.CodeBase%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1336">To get the location before the file has been shadow-copied, use the <xref:System.Reflection.Assembly.CodeBase%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="ba04a-1337">El ejemplo siguiente muestra la ubicación del archivo cargado que contiene el manifiesto.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1337">The following example displays the location of the loaded file that contains the manifest.</span></span>  
  
 [!code-cpp[System.Reflection.Assembly#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Reflection.Assembly/CPP/assembly.cpp#3)]
 [!code-csharp[System.Reflection.Assembly#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Reflection.Assembly/CS/assembly.cs#3)]
 [!code-vb[System.Reflection.Assembly#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Reflection.Assembly/VB/assembly.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="ba04a-1338">El ensamblado actual es un ensamblado dinámico, representado por un objeto <see cref="T:System.Reflection.Emit.AssemblyBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1338">The current assembly is a dynamic assembly, represented by an <see cref="T:System.Reflection.Emit.AssemblyBuilder" /> object.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1339">Para obtener acceso a la ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1339">for access to the path.</span></span> <span data-ttu-id="ba04a-1340">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1340">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="ba04a-1341">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="ba04a-1341">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManifestModule">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.Module ManifestModule { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module ManifestModule" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ManifestModule" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ManifestModule As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::Module ^ ManifestModule { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ManifestModule : System.Reflection.Module" Usage="System.Reflection.Assembly.ManifestModule" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1342">Obtiene el módulo que contiene el manifiesto del ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1342">Gets the module that contains the manifest for the current assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-1343">Módulo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1343">The module that contains the manifest for the assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ModuleResolve">
      <MemberSignature Language="C#" Value="public virtual event System.Reflection.ModuleResolveEventHandler ModuleResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Reflection.ModuleResolveEventHandler ModuleResolve" />
      <MemberSignature Language="DocId" Value="E:System.Reflection.Assembly.ModuleResolve" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Custom Event ModuleResolve As ModuleResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event System::Reflection::ModuleResolveEventHandler ^ ModuleResolve;" />
      <MemberSignature Language="F#" Value="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " Usage="member this.ModuleResolve : System.Reflection.ModuleResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System.Runtime.InteropServices._Assembly.ModuleResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ModuleResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1344">Se produce cuando el cargador de clases Common Language Runtime no puede resolver una referencia a un módulo interno de un ensamblado por medios normales.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1344">Occurs when the common language runtime class loader cannot resolve a reference to an internal module of an assembly through normal means.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1345">Este evento proporciona la devolución de llamada una oportunidad para buscar y cargar el módulo y devolverlo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1345">This event gives the callback a chance to find and load the module itself and return it.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba04a-1346">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1346">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba04a-1347">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1347">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Modules">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt; Modules { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Module&gt; Modules" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.Modules" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property Modules As IEnumerable(Of Module)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ Modules { System::Collections::Generic::IEnumerable&lt;System::Reflection::Module ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Modules : seq&lt;System.Reflection.Module&gt;" Usage="System.Reflection.Assembly.Modules" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Module&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1348">Obtiene una colección que contiene los módulos de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1348">Gets a collection that contains the modules in this assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-1349">Colección que contiene los módulos de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1349">A collection that contains the modules in this assembly.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Equality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ba04a-1350">Ensamblado que se va a comparar con <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1350">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="ba04a-1351">Ensamblado que se va a comparar con <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1351">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-1352">Indica si dos objetos <see cref="T:System.Reflection.Assembly" /> son iguales.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1352">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1353"><see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1353"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.Assembly left, System.Reflection.Assembly right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.Assembly left, class System.Reflection.Assembly right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.op_Inequality(System.Reflection.Assembly,System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Assembly, right As Assembly) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::Assembly ^ left, System::Reflection::Assembly ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.Assembly * System.Reflection.Assembly -&gt; bool" Usage="System.Reflection.Assembly.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.Assembly" />
        <Parameter Name="right" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="ba04a-1354">Ensamblado que se va a comparar con <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1354">The assembly to compare to <paramref name="right" />.</span></span></param>
        <param name="right"><span data-ttu-id="ba04a-1355">Ensamblado que se va a comparar con <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1355">The assembly to compare to <paramref name="left" />.</span></span></param>
        <summary><span data-ttu-id="ba04a-1356">Indica si dos objetos <see cref="T:System.Reflection.Assembly" /> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1356">Indicates whether two <see cref="T:System.Reflection.Assembly" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1357">Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1357"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.Reflection.Assembly.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1358">Obtiene el conjunto de permisos del ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1358">Gets the grant set of the current assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-1359">Conjunto de permisos del ensamblado actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1359">The grant set of the current assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1360"><xref:System.Security.PermissionSet> los objetos pueden contener información confidencial como las rutas de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1360"><xref:System.Security.PermissionSet> objects can contain sensitive information such as paths.</span></span> <span data-ttu-id="ba04a-1361">Por lo tanto, se requiere plena confianza para tener acceso a estos objetos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1361">Therefore, full trust is required to access these objects.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba04a-1362">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1362">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba04a-1363">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1363">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnly">
      <MemberSignature Language="C#" Value="public virtual bool ReflectionOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ReflectionOnly" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.ReflectionOnly" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReflectionOnly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ReflectionOnly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnly : bool" Usage="System.Reflection.Assembly.ReflectionOnly" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1364">Obtiene un valor <see cref="T:System.Boolean" /> que indica si este ensamblado se cargó en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1364">Gets a <see cref="T:System.Boolean" /> value indicating whether this assembly was loaded into the reflection-only context.</span></span></summary>
        <value><span data-ttu-id="ba04a-1365"><see langword="true" /> si el ensamblado se cargó en el contexto de sólo reflexión y no en el contexto de ejecución; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1365"><see langword="true" /> if the assembly was loaded into the reflection-only context, rather than the execution context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1366">Si un ensamblado se ha cargado en el contexto de solo reflexión, usando la <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método, no se puede ejecutar código en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1366">If an assembly has been loaded into the reflection-only context, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, you cannot execute code in the assembly.</span></span> <span data-ttu-id="ba04a-1367">Para ejecutar código, el ensamblado deben cargarse en el contexto de ejecución.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1367">To execute code, the assembly must be loaded into the execution context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReflectionOnlyLoad">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="ba04a-1368">Carga un ensamblado en un contexto de solo reflexión, donde se puede examinar pero no ejecutar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1368">Loads an assembly into the reflection-only context, where it can be examined but not executed.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : byte[] -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad rawAssembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="ba04a-1369">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1369">A byte array that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1370">Carga el ensamblado desde una imagen que toma como base el formato Common Object File Format (COFF) y que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1370">Loads the assembly from a common object file format (COFF)-based image containing an emitted assembly.</span></span> <span data-ttu-id="ba04a-1371">El ensamblado se carga en el contexto de solo reflexión del dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1371">The assembly is loaded into the reflection-only context of the caller's application domain.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1372">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1372">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1373">No se puede ejecutar código desde un ensamblado cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1373">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="ba04a-1374">Para ejecutar código, el ensamblado debe cargarse en el contexto de ejecución, mediante el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1374">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="ba04a-1375">El contexto de solo reflexión es no difiere de otros contextos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1375">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="ba04a-1376">Pueden descargar los ensamblados que se cargan en el contexto de solo si se descarga el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1376">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1377"><paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1377"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1378"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1378"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1379">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1379">-or-</span></span> 
<span data-ttu-id="ba04a-1380">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1380">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1381">No se puede cargar <paramref name="rawAssembly" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1381"><paramref name="rawAssembly" /> cannot be loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoad">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoad (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoad(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoad(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoad (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoad(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoad : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoad assemblyString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="ba04a-1382">Nombre para mostrar del ensamblado, tal como lo devuelve la propiedad <see cref="P:System.Reflection.AssemblyName.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1382">The display name of the assembly, as returned by the <see cref="P:System.Reflection.AssemblyName.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="ba04a-1383">Carga un ensamblado en el contexto de solo reflexión, de acuerdo con su nombre de presentación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1383">Loads an assembly into the reflection-only context, given its display name.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1384">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1384">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1385">Las dependencias no se cargan automáticamente en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1385">Dependencies are not automatically loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="ba04a-1386">No se puede ejecutar código desde un ensamblado cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1386">You cannot execute code from an assembly loaded into the reflection-only context.</span></span> <span data-ttu-id="ba04a-1387">Para ejecutar código, el ensamblado debe cargarse en el contexto de ejecución, mediante el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1387">To execute code, the assembly must be loaded into the execution context as well, using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="ba04a-1388">La concesión de permisos específicos para un ensamblado se basa en la evidencia.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1388">Whether certain permissions are granted or not granted to an assembly is based on evidence.</span></span> <span data-ttu-id="ba04a-1389">Las reglas de ensamblado y la combinación de evidencia de seguridad son los siguientes:</span><span class="sxs-lookup"><span data-stu-id="ba04a-1389">The rules for assembly and security evidence merging are as follows:</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="ba04a-1390">Reflejar en archivos ejecutables compilados en C++ podría producir un <xref:System.IO.FileLoadException>.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1390">Reflecting on executable files compiled in C++ might throw a <xref:System.IO.FileLoadException>.</span></span> <span data-ttu-id="ba04a-1391">Esto probablemente está causado por el compilador de C++ las direcciones de reubicación o la sección .reloc del archivo ejecutable.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1391">This is most likely caused by the C++ compiler stripping the relocation addresses or the .reloc section from your executable file.</span></span> <span data-ttu-id="ba04a-1392">Para conservar la dirección .reloc, especifique `/fixed:no` cuando realice la vinculación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1392">To preserve the .reloc address, specify `/fixed:no` when you are linking.</span></span>  
  
 <span data-ttu-id="ba04a-1393">El contexto de solo reflexión es no difiere de otros contextos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1393">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="ba04a-1394">Pueden descargar los ensamblados que se cargan en el contexto de solo si se descarga el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1394">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1395"><paramref name="assemblyString" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1395"><paramref name="assemblyString" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1396"><paramref name="assemblyString" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1396"><paramref name="assemblyString" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1397">No se ha encontrado <paramref name="assemblyString" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1397"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1398">Se ha encontrado <paramref name="assemblyString" />, pero no se puede cargar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1398"><paramref name="assemblyString" /> is found, but cannot be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1399"><paramref name="assemblyString" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1399"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1400">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1400">-or-</span></span> 
<span data-ttu-id="ba04a-1401">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1401">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly ReflectionOnlyLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly ReflectionOnlyLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ReflectionOnlyLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ ReflectionOnlyLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.ReflectionOnlyLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1402">Ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1402">The path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1403">Carga un ensamblado en el contexto de solo reflexión, de acuerdo con su ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1403">Loads an assembly into the reflection-only context, given its path.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1404">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1404">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1405">Las dependencias no se cargan automáticamente en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1405">Dependencies are not automatically loaded into the reflection-only context.</span></span> <span data-ttu-id="ba04a-1406">Para cargar automáticamente las dependencias, controlar el <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> carga la dependencia en el controlador de eventos y eventos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1406">To automatically load dependencies, handle the <xref:System.AppDomain.ReflectionOnlyAssemblyResolve> event and load the dependency in the event handler.</span></span>  
  
 <span data-ttu-id="ba04a-1407">No se puede ejecutar código desde un ensamblado que se han cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1407">You cannot execute code from an assembly that has been loaded into the reflection-only context.</span></span> <span data-ttu-id="ba04a-1408">Para ejecutar el código, cargue el ensamblado con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1408">To execute the code, load the assembly with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="ba04a-1409">El `assemblyFile` parámetro debe hacer referencia a un identificador URI sin caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1409">The `assemblyFile` parameter must refer to a URI without escape characters.</span></span> <span data-ttu-id="ba04a-1410">Este método proporciona los caracteres de escape para todos los caracteres no válidos en el URI.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1410">This method supplies escape characters for all invalid characters in the URI.</span></span>  
  
 <span data-ttu-id="ba04a-1411">La ruta especificada para `assemblyFile` es relativa al directorio actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1411">The path specified for `assemblyFile` is relative to the current directory.</span></span> <span data-ttu-id="ba04a-1412">El ensamblado se carga en el dominio del llamador.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1412">The assembly is loaded into the domain of the caller.</span></span>  
  
 <span data-ttu-id="ba04a-1413">El contexto de solo reflexión es no difiere de otros contextos.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1413">The reflection-only context is no different from other contexts.</span></span> <span data-ttu-id="ba04a-1414">Pueden descargar los ensamblados que se cargan en el contexto de solo si se descarga el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1414">Assemblies that are loaded into the context can be unloaded only by unloading the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1415"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1415"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1416">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1416"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a file name extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1417">Se encuentra <paramref name="assemblyFile" /> pero no pudo cargarse.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1417"><paramref name="assemblyFile" /> is found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1418"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1418"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1419">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1419">-or-</span></span> 
<span data-ttu-id="ba04a-1420">La versión 2.0 u otra posterior del Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1420">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1421">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1421">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1422">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1422">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1423"><paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1423"><paramref name="assemblyFile" /> is an empty string ("").</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="ba04a-1424">para leer un URI que comienza con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1424">for reading a URI that begins with "file://".</span></span> <span data-ttu-id="ba04a-1425">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span><span class="sxs-lookup"><span data-stu-id="ba04a-1425">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="ba04a-1426">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="ba04a-1426">for reading a URI that does not begin with "file://".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SecurityRuleSet">
      <MemberSignature Language="C#" Value="public virtual System.Security.SecurityRuleSet SecurityRuleSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Security.SecurityRuleSet SecurityRuleSet" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.Assembly.SecurityRuleSet" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property SecurityRuleSet As SecurityRuleSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Security::SecurityRuleSet SecurityRuleSet { System::Security::SecurityRuleSet get(); };" />
      <MemberSignature Language="F#" Value="member this.SecurityRuleSet : System.Security.SecurityRuleSet" Usage="System.Reflection.Assembly.SecurityRuleSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityRuleSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ba04a-1427">Obtiene un valor que indica el conjunto de reglas de seguridad que Common Language Runtime (CLR) aplica para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1427">Gets a value that indicates which set of security rules the common language runtime (CLR) enforces for this assembly.</span></span></summary>
        <value><span data-ttu-id="ba04a-1428">Conjunto de reglas de seguridad que CLR aplica para este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1428">The security rule set that the CLR enforces for this assembly.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1429">De forma predeterminada, los ensamblados que se compilación con la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] tienen transparencia, aunque puede convertirlas explícitamente en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1429">By default, assemblies that you compile with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)] have  transparency, although you can explicitly make them  instead.</span></span> <span data-ttu-id="ba04a-1430">Los ensamblados que se compilaron con versiones anteriores de .NET Framework tienen transparencia de nivel 1.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1430">Assemblies that were compiled with earlier versions of the .NET Framework have level 1 transparency.</span></span>  
  
 <span data-ttu-id="ba04a-1431">Vea [Security Changes](~/docs/framework/security/security-changes.md) (Cambios de seguridad).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1431">See [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/framework/misc/security-transparent-code.md"><span data-ttu-id="ba04a-1432">Código transparente en seguridad</span><span class="sxs-lookup"><span data-stu-id="ba04a-1432">Security-Transparent Code</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="ba04a-1433">Cambios de seguridad en .NET Framework 4</span><span class="sxs-lookup"><span data-stu-id="ba04a-1433">Security Changes in the .NET Framework 4</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.GetCustomAttributes">
      <MemberSignature Language="C#" Value="object[] ICustomAttributeProvider.GetCustomAttributes (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object[] System.Reflection.ICustomAttributeProvider.GetCustomAttributes(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#GetCustomAttributes(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function GetCustomAttributes (attributeType As Type, inherit As Boolean) As Object() Implements ICustomAttributeProvider.GetCustomAttributes" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;System::Object ^&gt; ^ System.Reflection.ICustomAttributeProvider.GetCustomAttributes(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::GetCustomAttributes;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.GetCustomAttributes(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Reflection.ICustomAttributeProvider.IsDefined">
      <MemberSignature Language="C#" Value="bool ICustomAttributeProvider.IsDefined (Type attributeType, bool inherit);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Reflection.ICustomAttributeProvider.IsDefined(class System.Type attributeType, bool inherit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Reflection#ICustomAttributeProvider#IsDefined(System.Type,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function IsDefined (attributeType As Type, inherit As Boolean) As Boolean Implements ICustomAttributeProvider.IsDefined" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Reflection.ICustomAttributeProvider.IsDefined(Type ^ attributeType, bool inherit) = System::Reflection::ICustomAttributeProvider::IsDefined;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Reflection.ICustomAttributeProvider.IsDefined(System.Type,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="attributeType" Type="System.Type" />
        <Parameter Name="inherit" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="attributeType">To be added.</param>
        <param name="inherit">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Assembly.GetType">
      <MemberSignature Language="C#" Value="Type _Assembly.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._Assembly.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.System#Runtime#InteropServices#_Assembly#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _Assembly.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._Assembly.GetType() = System::Runtime::InteropServices::_Assembly::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-1434">Devuelve el tipo de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1434">Returns the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1435">Objeto que representa el tipo <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1435">An object that represents the <see cref="T:System.Reflection.Assembly" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="assembly.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Assembly.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ba04a-1436">Devuelve el nombre completo del ensamblado, también conocido como nombre para mostrar.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1436">Returns the full name of the assembly, also known as the display name.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1437">Nombre completo del ensamblado o nombre de la clase si no es posible determinar su nombre completo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1437">The full name of the assembly, or the class name if the full name of the assembly cannot be determined.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeLoadFrom">
      <MemberSignature Language="C#" Value="public static System.Reflection.Assembly UnsafeLoadFrom (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.Assembly UnsafeLoadFrom(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.Assembly.UnsafeLoadFrom(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeLoadFrom (assemblyFile As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::Assembly ^ UnsafeLoadFrom(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="static member UnsafeLoadFrom : string -&gt; System.Reflection.Assembly" Usage="System.Reflection.Assembly.UnsafeLoadFrom assemblyFile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="ba04a-1438">Nombre o ruta de acceso del archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1438">The name or path of the file that contains the manifest of the assembly.</span></span></param>
        <summary><span data-ttu-id="ba04a-1439">Carga un ensamblado en el contexto de origen de carga, omitiendo algunas comprobaciones de seguridad.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1439">Loads an assembly into the load-from context, bypassing some security checks.</span></span></summary>
        <returns><span data-ttu-id="ba04a-1440">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1440">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ba04a-1441">Utilice este método para cargar un ensamblado local que el sistema operativo ha marcado como cargado desde la Web (por ejemplo, un archivo temporal que ha descargado de Internet o intranet).</span><span class="sxs-lookup"><span data-stu-id="ba04a-1441">Use this method to load a local assembly that the operating system has flagged as having been loaded from the Web (for example, a temporary file that was downloaded from the Internet or intranet).</span></span> <span data-ttu-id="ba04a-1442">Antes de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], dichos ensamblados se cargan automáticamente en un dominio de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1442">Before the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], such assemblies were automatically loaded into a sandboxed application domain.</span></span> <span data-ttu-id="ba04a-1443">A partir de la [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], se cargan con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1443">Starting with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], they are loaded with full trust.</span></span>  
  
 <span data-ttu-id="ba04a-1444">Como alternativa al uso de este método, puede aplicar el [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) en el archivo de configuración de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1444">As an alternative to using this method, you can apply the [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md) in your application configuration file.</span></span> <span data-ttu-id="ba04a-1445">Esto hace que common language runtime revertir a la directiva de seguridad de la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="ba04a-1445">This causes the common language runtime to revert to the security policy of the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="ba04a-1446">Si usa cualquiera de estas soluciones, debe asegurarse de que es seguro para cargar `assemblyFile` con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1446">If you use either of these solutions, you must be certain that it is safe to load `assemblyFile` with full trust.</span></span>  
  
 <span data-ttu-id="ba04a-1447">Para obtener una explicación de los contextos de carga, incluido el contexto de carga, consulte el <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1447">For a discussion of load contexts, including the load-from context, see the <xref:System.Reflection.Assembly.LoadFrom%28System.String%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ba04a-1448"><paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1448"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="ba04a-1449">No se encuentra <paramref name="assemblyFile" /> o el módulo que está intentando cargar no especifica una extensión de nombre de archivo.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1449"><paramref name="assemblyFile" /> is not found, or the module you are trying to load does not specify a filename extension.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="ba04a-1450">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1450">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="ba04a-1451"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1451"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="ba04a-1452">O bien</span><span class="sxs-lookup"><span data-stu-id="ba04a-1452">-or-</span></span> 
 <span data-ttu-id="ba04a-1453"><paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1453"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="ba04a-1454">Se especificó un código base que no comienza con "file://" sin el <see cref="T:System.Net.WebPermission" /> necesario.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1454">A codebase that does not start with "file://" was specified without the required <see cref="T:System.Net.WebPermission" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ba04a-1455">El parámetro <paramref name="assemblyFile" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="ba04a-1455">The <paramref name="assemblyFile" /> parameter is an empty string ("").</span></span></exception>
        <exception cref="T:System.IO.PathTooLongException"><span data-ttu-id="ba04a-1456">El nombre del ensamblado supera la longitud máxima definida por el sistema.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1456">The assembly name exceeds the system-defined maximum length.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="ba04a-1457">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1457">requires full trust for the immediate caller.</span></span> <span data-ttu-id="ba04a-1458">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="ba04a-1458">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>
