<Type Name="MethodInfo" FullName="System.Reflection.MethodInfo">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7e2a4af924b8881619adeb17a41c712fdb395e48" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233190" /></Metadata><TypeSignature Language="C#" Value="public abstract class MethodInfo : System.Reflection.MethodBase, System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit MethodInfo extends System.Reflection.MethodBase implements class System.Runtime.InteropServices._MethodInfo" />
  <TypeSignature Language="DocId" Value="T:System.Reflection.MethodInfo" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class MethodInfo&#xA;Inherits MethodBase&#xA;Implements _MethodInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class MethodInfo abstract : System::Reflection::MethodBase, System::Runtime::InteropServices::_MethodInfo" />
  <TypeSignature Language="F#" Value="type MethodInfo = class&#xA;    inherit MethodBase&#xA;    interface _MethodInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Reflection</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Reflection.MethodBase</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._MethodInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._MethodInfo))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e9650-101">Detecta los atributos de un método y proporciona acceso a sus metadatos.</span><span class="sxs-lookup"><span data-stu-id="e9650-101">Discovers the attributes of a method and provides access to method metadata.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-102">La <xref:System.Reflection.MethodInfo> clase representa un método de un tipo.</span><span class="sxs-lookup"><span data-stu-id="e9650-102">The <xref:System.Reflection.MethodInfo> class represents a method of a type.</span></span> <span data-ttu-id="e9650-103">Puede usar un <xref:System.Reflection.MethodInfo> para obtener información sobre el método que representa el objeto e invocar el método de objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-103">You can use a <xref:System.Reflection.MethodInfo> object to obtain information about the method that the object represents and to invoke the method.</span></span> <span data-ttu-id="e9650-104">Por ejemplo:</span><span class="sxs-lookup"><span data-stu-id="e9650-104">For example:</span></span>  
  
-   <span data-ttu-id="e9650-105">Puede determinar la visibilidad del método al recuperar los valores de la <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, y <xref:System.Reflection.MethodBase.IsPublic%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="e9650-105">You can determine the method's visibility by retrieving the values of the <xref:System.Reflection.MethodBase.IsFamilyAndAssembly%2A>, <xref:System.Reflection.MethodBase.IsFamilyOrAssembly%2A>, <xref:System.Reflection.MethodBase.IsPrivate%2A>, and <xref:System.Reflection.MethodBase.IsPublic%2A> properties.</span></span>  
  
-   <span data-ttu-id="e9650-106">Puede detectar los atributos que se aplican al método, recupere el valor de la <xref:System.Reflection.MethodBase.Attributes%2A> propiedad o llamar a la <xref:System.Reflection.Assembly.GetCustomAttributes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-106">You can discover what attributes are applied to the method by retrieving the value of the <xref:System.Reflection.MethodBase.Attributes%2A> property or calling the <xref:System.Reflection.Assembly.GetCustomAttributes%2A> method.</span></span>  
  
-   <span data-ttu-id="e9650-107">Puede determinar si el método es un método genérico, abierto de método genérico construido o construye una cerrado un método genérico, al recuperar los valores de la <xref:System.Reflection.MethodBase.IsGenericMethod%2A> y <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="e9650-107">You can determine whether the method is a generic method, an open constructed generic method, or a closed constructed generic method, by retrieving the values of the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> and <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> properties.</span></span>  
  
-   <span data-ttu-id="e9650-108">Puede obtener información acerca de los parámetros del método y devolver el tipo de la <xref:System.Reflection.MethodBase.GetParameters%2A> método y el <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, y <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="e9650-108">You can get information about the method's parameters and return type from the <xref:System.Reflection.MethodBase.GetParameters%2A> method and the <xref:System.Reflection.MethodInfo.ReturnParameter%2A>, <xref:System.Reflection.MethodInfo.ReturnType%2A>, and <xref:System.Reflection.MethodInfo.ReturnTypeCustomAttributes%2A> properties.</span></span>  
  
-   <span data-ttu-id="e9650-109">Puede ejecutar un método en una instancia de la clase mediante una llamada a la <xref:System.Reflection.MethodBase.Invoke%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-109">You can execute a method on a class instance by calling the <xref:System.Reflection.MethodBase.Invoke%2A> method.</span></span>  
  
-   <span data-ttu-id="e9650-110">Puede crear instancias de un <xref:System.Reflection.MethodInfo> objeto que representa un método genérico construido de uno que representa una definición de método genérico mediante una llamada a la <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-110">You can instantiate a <xref:System.Reflection.MethodInfo> object that represents a constructed generic method from one that represents a generic method definition by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 <span data-ttu-id="e9650-111">Puede crear instancias de un <xref:System.Reflection.MethodInfo> instancias mediante una llamada a la <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> o <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> método, o mediante una llamada a la <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> método de un <xref:System.Reflection.MethodInfo> objeto que representa una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-111">You can instantiate a <xref:System.Reflection.MethodInfo> instances by calling the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> or <xref:System.Type.GetMethod%2A?displayProperty=nameWithType> method, or by calling the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A?displayProperty=nameWithType> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
 <span data-ttu-id="e9650-112">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-112">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="e9650-113">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-113">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="e9650-114">para plena confianza para los herederos.</span><span class="sxs-lookup"><span data-stu-id="e9650-114">for full trust for inheritors.</span></span> <span data-ttu-id="e9650-115">No se puede heredar esta clase por código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="e9650-115">This class cannot be inherited by partially trusted code.</span></span></permission>
    <threadsafe><span data-ttu-id="e9650-116">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="e9650-116">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="e9650-117">Al heredar de <see cref="T:System.Reflection.MethodInfo" />, debe invalidar <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, y <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-117">When you inherit from <see cref="T:System.Reflection.MethodInfo" />, you must override <see cref="M:System.Reflection.MethodInfo.GetBaseDefinition" />, <see cref="P:System.Reflection.MethodInfo.ReturnType" />, <see cref="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />, <see cref="M:System.Reflection.MethodBase.GetParameters" />, <see cref="M:System.Reflection.MethodBase.GetMethodImplementationFlags" />, <see cref="P:System.Reflection.MethodBase.MethodHandle" />, <see cref="P:System.Reflection.MethodBase.Attributes" />, <see cref="M:System.Reflection.MethodBase.Invoke(System.Object,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />, <see cref="P:System.Reflection.MemberInfo.Name" />, <see cref="P:System.Reflection.MemberInfo.MemberType" />, <see cref="P:System.Reflection.MemberInfo.DeclaringType" />, <see cref="P:System.Reflection.MemberInfo.ReflectedType" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />, <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />, and <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />.</span></span></para></block>
    <altmember cref="Overload:System.Type.GetMethods" />
    <altmember cref="Overload:System.Type.GetMethod" />
    <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected MethodInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; MethodInfo();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-118">Inicializa una nueva instancia de la clase <see cref="T:System.Reflection.MethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-118">Initializes a new instance of the <see cref="T:System.Reflection.MethodInfo" /> class.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public override bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Reflection.MethodInfo.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-119">Obtiene un valor que indica si un método genérico contiene parámetros de tipo genérico sin asignar.</span><span class="sxs-lookup"><span data-stu-id="e9650-119">Gets a value indicating whether a generic method contains unassigned generic type parameters.</span></span></summary>
        <value><span data-ttu-id="e9650-120"><see langword="true" /> si el <see cref="T:System.Reflection.MethodInfo" /> actual contiene parámetros de tipo genérico sin asignar; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-120"><see langword="true" /> if the current <see cref="T:System.Reflection.MethodInfo" /> contains unassigned generic type parameters; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="e9650-121">Para invocar un método genérico, no debe haber ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del método propio, o en los tipos envolventes.</span><span class="sxs-lookup"><span data-stu-id="e9650-121">To invoke a generic method, there must be no generic type definitions or open constructed types in the type arguments of the method itself, or in any enclosing types.</span></span> <span data-ttu-id="e9650-122">Hacer esta determinación recursiva puede ser difícil.</span><span class="sxs-lookup"><span data-stu-id="e9650-122">Making this recursive determination can be difficult.</span></span> <span data-ttu-id="e9650-123">Para mayor comodidad y para reducir la posibilidad de error, el `ContainsGenericParameters` propiedad proporciona una manera estándar para distinguir entre los métodos construidos cerrados, que se pueden invocar, y construido abierto métodos, que no se pueden.</span><span class="sxs-lookup"><span data-stu-id="e9650-123">For convenience, and to reduce the chance of error, the `ContainsGenericParameters` property provides a standard way to distinguish between closed constructed methods, which can be invoked, and open constructed methods, which cannot.</span></span> <span data-ttu-id="e9650-124">Si el `ContainsGenericParameters` propiedad devuelve true, no se puede invocar el método.</span><span class="sxs-lookup"><span data-stu-id="e9650-124">If the `ContainsGenericParameters` property returns true, the method cannot be invoked.</span></span>

<span data-ttu-id="e9650-125">El `ContainsGenericParameters` propiedad busca los parámetros de tipo de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="e9650-125">The `ContainsGenericParameters` property searches recursively for type parameters.</span></span> <span data-ttu-id="e9650-126">Por ejemplo, devuelve `true` para cualquier método en un tipo abierto `A<T>` (`A(Of T)` en Visual Basic), aunque el propio método no es genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-126">For example, it returns `true` for any method in an open type `A<T>` (`A(Of T)` in Visual Basic), even though the method itself is not generic.</span></span> <span data-ttu-id="e9650-127">Compare esto con el comportamiento de la <xref:System.Reflection.MethodInfo.IsGenericMethod> propiedad, que devuelve `false` para dicho método.</span><span class="sxs-lookup"><span data-stu-id="e9650-127">Contrast this with the behavior of the <xref:System.Reflection.MethodInfo.IsGenericMethod> property, which returns `false` for such a method.</span></span>

<span data-ttu-id="e9650-128">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodInfo.IsGenericMethod> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-128">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="e9650-129">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-129">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="e9650-130">El siguiente ejemplo de código utiliza el `ContainsGenericParameters` propiedad para mostrar un mensaje que indica si un <xref:System.Reflection.MethodInfo> es un método genérico abierto (es decir, si lo ha sin enlazar parámetros de tipo).</span><span class="sxs-lookup"><span data-stu-id="e9650-130">The following code example uses the `ContainsGenericParameters` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> is an open generic method (that is, whether it has unbound type parameters).</span></span>

<span data-ttu-id="e9650-131">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-131">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Does it have unassigned generic parameters? {0}", _
    mi.ContainsGenericParameters)
```

```csharp
Console.WriteLine("\tDoes it have unassigned generic parameters? {0}", 
    mi.ContainsGenericParameters);
```

```cpp
Console::WriteLine("\tDoes it have unassigned generic parameters? {0}", 
    mi->ContainsGenericParameters);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="e9650-132">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="e9650-132">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="e9650-133">Introducción a los genéricos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="e9650-133">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDelegate">
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e9650-134">Crea un delegado a partir de este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-134">Creates a delegate from this method.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type -&gt; Delegate&#xA;override this.CreateDelegate : Type -&gt; Delegate" Usage="methodInfo.CreateDelegate delegateType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e9650-135">Tipo del delegado que se va a crear.</span><span class="sxs-lookup"><span data-stu-id="e9650-135">The type of the delegate to create.</span></span></param>
        <summary><span data-ttu-id="e9650-136">Crea un delegado del tipo especificado a partir de este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-136">Creates a delegate of the specified type from this method.</span></span></summary>
        <returns><span data-ttu-id="e9650-137">Delegado para este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-137">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDelegate">
      <MemberSignature Language="C#" Value="public virtual Delegate CreateDelegate (Type delegateType, object target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Delegate CreateDelegate(class System.Type delegateType, object target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.CreateDelegate(System.Type,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function CreateDelegate (delegateType As Type, target As Object) As Delegate" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Delegate ^ CreateDelegate(Type ^ delegateType, System::Object ^ target);" />
      <MemberSignature Language="F#" Value="abstract member CreateDelegate : Type * obj -&gt; Delegate&#xA;override this.CreateDelegate : Type * obj -&gt; Delegate" Usage="methodInfo.CreateDelegate (delegateType, target)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Delegate</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="delegateType" Type="System.Type" />
        <Parameter Name="target" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="delegateType"><span data-ttu-id="e9650-138">Tipo del delegado que se va a crear.</span><span class="sxs-lookup"><span data-stu-id="e9650-138">The type of the delegate to create.</span></span></param>
        <param name="target"><span data-ttu-id="e9650-139">El objeto de destino por parte del delegado.</span><span class="sxs-lookup"><span data-stu-id="e9650-139">The object targeted by the delegate.</span></span></param>
        <summary><span data-ttu-id="e9650-140">Crea un delegado del tipo especificado con el destino especificado a partir de este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-140">Creates a delegate of the specified type with the specified target from this method.</span></span></summary>
        <returns><span data-ttu-id="e9650-141">Delegado para este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-141">The delegate for this method.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="methodInfo.Equals obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e9650-142">Objeto que se va a comparar con esta instancia o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-142">An object to compare with this instance, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="e9650-143">Devuelve un valor que indica si esta instancia es igual que un objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="e9650-143">Returns a value that indicates whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="e9650-144">Es <see langword="true" /> si <paramref name="obj" /> es igual al tipo y valor de esta instancia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-144"><see langword="true" /> if <paramref name="obj" /> equals the type and value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetBaseDefinition">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo GetBaseDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetBaseDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetBaseDefinition" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetBaseDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::MethodInfo ^ GetBaseDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetBaseDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetBaseDefinition " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetBaseDefinition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-145">Cuando se reemplaza en una clase derivada, se devuelve el objeto <see cref="T:System.Reflection.MethodInfo" /> del método en la clase base directa o indirecta en la que se declaró por primera vez el método representado mediante esta instancia.</span><span class="sxs-lookup"><span data-stu-id="e9650-145">When overridden in a derived class, returns the <see cref="T:System.Reflection.MethodInfo" /> object for the method on the direct or indirect base class in which the method represented by this instance was first declared.</span></span></summary>
        <returns><span data-ttu-id="e9650-146">Objeto <see cref="T:System.Reflection.MethodInfo" /> para la primera implementación de este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-146">A <see cref="T:System.Reflection.MethodInfo" /> object for the first implementation of this method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-147">El <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve la primera definición del método especificado en la jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="e9650-147">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the first definition of the specified method in the class hierarchy.</span></span> <span data-ttu-id="e9650-148">Se puede determinar el tipo en el que se encuentra la primera definición del método al recuperar el valor de la <xref:System.Reflection.MemberInfo.DeclaringType%2A> propiedad en el valor devuelto <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-148">You can determine the type on which the first definition of the method is found by retrieving the value of the <xref:System.Reflection.MemberInfo.DeclaringType%2A> property on the returned <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="e9650-149">El <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método se comporta como sigue:</span><span class="sxs-lookup"><span data-stu-id="e9650-149">The <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method behaves as follows:</span></span>  
  
-   <span data-ttu-id="e9650-150">Si el actual <xref:System.Reflection.MethodInfo> objeto representa una implementación de interfaz, el <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve el valor actual <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-150">If the current <xref:System.Reflection.MethodInfo> object represents an interface implementation, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="e9650-151">Si el actual <xref:System.Reflection.MethodInfo> objeto representa un método que reemplaza una definición virtual en una clase base, el <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve un <xref:System.Reflection.MethodInfo> objeto que representa la definición de virtual.</span><span class="sxs-lookup"><span data-stu-id="e9650-151">If the current <xref:System.Reflection.MethodInfo> object represents a method that overrides a virtual definition in a base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the virtual definition.</span></span>  
  
-   <span data-ttu-id="e9650-152">Si actual <xref:System.Reflection.MethodInfo> objeto representa un método que se especifica con el `new` palabra clave en C# o la `Shadows` palabra clave en Visual Basic (como en `newslot`, tal y como se describe en [Common Type System](~/docs/standard/base-types/common-type-system.md)), el <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve el valor actual <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-152">If the current <xref:System.Reflection.MethodInfo> object represents a method that is specified with the `new` keyword in C# or the `Shadows` keyword in Visual Basic (as in `newslot`, as described in [Common Type System](~/docs/standard/base-types/common-type-system.md)), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
-   <span data-ttu-id="e9650-153">Si el actual <xref:System.Reflection.MethodInfo> objeto representa un método heredado (es decir, el método actual no proporciona su propia implementación), el <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve un <xref:System.Reflection.MethodInfo> objeto que representa el método más bajo en la jerarquía de clases.</span><span class="sxs-lookup"><span data-stu-id="e9650-153">If the current <xref:System.Reflection.MethodInfo> object represents an inherited method (that is, the current method does not provide its own implementation), the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns a <xref:System.Reflection.MethodInfo> object that represents the lowest method in the class hierarchy.</span></span> <span data-ttu-id="e9650-154">Por ejemplo, si `Base.ToString` invalida `Object.ToString`, y `Derived.ToString` invalida `Base.ToString`, al llamar a la <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método en un <xref:System.Reflection.MethodInfo> objeto que representa `Derived.ToString` devuelve un <xref:System.Reflection.MethodInfo> objeto que representa `Object.ToString`.</span><span class="sxs-lookup"><span data-stu-id="e9650-154">For example, if `Base.ToString` overrides `Object.ToString`, and `Derived.ToString` overrides `Base.ToString`, calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method on a <xref:System.Reflection.MethodInfo> object that represents `Derived.ToString` returns a <xref:System.Reflection.MethodInfo> object that represents `Object.ToString`.</span></span>  
  
-   <span data-ttu-id="e9650-155">Si el actual <xref:System.Reflection.MethodInfo> objeto representa un método que no está presente en cualquier clase base, el <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método devuelve el valor actual <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-155">If the current <xref:System.Reflection.MethodInfo> object represents a method that is not present in any base class, the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method returns the current <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 <span data-ttu-id="e9650-156">Puede determinar si el método actual invalida un método en una clase base mediante una llamada a la <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-156">You can determine whether the current method overrides a method in a base class by calling the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span> <span data-ttu-id="e9650-157">El ejemplo siguiente implementa un `IsOverride` método que lo haga.</span><span class="sxs-lookup"><span data-stu-id="e9650-157">The following example implements an `IsOverride` method that does this.</span></span>  
  
 [!code-csharp[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/IsOverride1.cs#2)]
 [!code-vb[system.reflection.methodinfo.getbasedefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/IsOverride1.vb#2)]  
  
 <span data-ttu-id="e9650-158">Para llamar a la `GetBaseDefinition` método:</span><span class="sxs-lookup"><span data-stu-id="e9650-158">To call the `GetBaseDefinition` method:</span></span>  
  
1.  <span data-ttu-id="e9650-159">Obtener un <xref:System.Type> objeto que representa el tipo (la clase o estructura) que contiene la propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-159">Get a <xref:System.Type> object that represents the type (the class or structure) that contains the property.</span></span> <span data-ttu-id="e9650-160">Si está trabajando con un objeto (una instancia de un tipo), puede llamar a su <xref:System.Object.GetType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-160">If you are working with an object (an instance of a type), you can call its <xref:System.Object.GetType%2A> method.</span></span> <span data-ttu-id="e9650-161">En caso contrario, se puede utilizar el operador de C# o el operador de Visual Basic, como en el ejemplo se muestra.</span><span class="sxs-lookup"><span data-stu-id="e9650-161">Otherwise, you can use the C#  operator or the Visual Basic  operator, as the example illustrates.</span></span>  
  
2.  <span data-ttu-id="e9650-162">Obtener un <xref:System.Reflection.MethodInfo> objeto que representa el método que interesa.</span><span class="sxs-lookup"><span data-stu-id="e9650-162">Get a <xref:System.Reflection.MethodInfo> object that represents the method in which you're interested.</span></span> <span data-ttu-id="e9650-163">Puede hacerlo mediante la obtención de una matriz de todos los métodos de la <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> método y, a continuación, recorrer en iteración los elementos de la matriz, o se pueden recuperar el <xref:System.Reflection.MethodInfo> objeto que representa el método directamente mediante una llamada a la <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> método y especificar el nombre del método.</span><span class="sxs-lookup"><span data-stu-id="e9650-163">You can do this by getting an array of all methods from the <xref:System.Type.GetMethods%2A?displayProperty=nameWithType> method and then iterating the elements in the array, or you can retrieve the <xref:System.Reflection.MethodInfo> object that represents the method directly by calling the <xref:System.Type.GetMethod%28System.String%29?displayProperty=nameWithType> method and specifying the method name.</span></span>  
  
3.  <span data-ttu-id="e9650-164">Llame a la <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método para obtener el valor de la <xref:System.Reflection.MethodInfo> objeto que representa la definición del método base.</span><span class="sxs-lookup"><span data-stu-id="e9650-164">Call the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method to get the value of the <xref:System.Reflection.MethodInfo> object that represents the base method definition.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9650-165">En el ejemplo siguiente se muestra el comportamiento de la <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-165">The following example demonstrates the behavior of the <xref:System.Reflection.MethodInfo.GetBaseDefinition%2A> method.</span></span>  
  
 [!code-csharp[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/cs/getbasedefinition1.cs#1)]
 [!code-vb[System.Reflection.MethodInfo.GetBaseDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.reflection.methodinfo.getbasedefinition/vb/getbasedefinition1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/53c57c96-83e1-4ee3-9543-9ac832671a89"><span data-ttu-id="e9650-166">Sistema de tipos comunes</span><span class="sxs-lookup"><span data-stu-id="e9650-166">Common Type System</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public override Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="override this.GetGenericArguments : unit -&gt; Type[]" Usage="methodInfo.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-167">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-167">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span></summary>
        <returns><span data-ttu-id="e9650-168">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un método genérico o los parámetros de tipo de una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-168">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic method or the type parameters of a generic method definition.</span></span> <span data-ttu-id="e9650-169">Devuelve una matriz vacía si el método actual no es un método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-169">Returns an empty array if the current method is not a generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-170">Los elementos de la matriz devuelta están en el orden en que aparecen en la lista de parámetros de tipo para el método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-170">The elements of the returned array are in the order in which they appear in the list of type parameters for the generic method.</span></span>  
  
-   <span data-ttu-id="e9650-171">Si el método actual es un tipo construido cerrado (es decir, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `false`), la matriz devuelta por la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método contiene los tipos que se han asignado a los parámetros de tipo genérico del método genérico definición.</span><span class="sxs-lookup"><span data-stu-id="e9650-171">If the current method is a closed constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic method definition.</span></span>  
  
-   <span data-ttu-id="e9650-172">Si el método actual es una definición de método genérico, la matriz contiene los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="e9650-172">If the current method is a generic method definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="e9650-173">Si el método actual es un tipo construido abierto (es decir, el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `true`) en los tipos específicos se han asignado a algunos parámetros de tipo y el tipo se han asignado a otro tipo de parámetros de tipos genéricos envolventes los parámetros, la matriz contiene los tipos y tipo de parámetros.</span><span class="sxs-lookup"><span data-stu-id="e9650-173">If the current method is an open constructed method (that is, the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`) in which specific types have been assigned to some type parameters and type parameters of enclosing generic types have been assigned to other type parameters, the array contains both types and type parameters.</span></span> <span data-ttu-id="e9650-174">Use el <xref:System.Type.IsGenericParameter%2A> propiedad para distinguirlos.</span><span class="sxs-lookup"><span data-stu-id="e9650-174">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="e9650-175">Para ver una demostración de este escenario, vea el ejemplo de código para el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-175">For a demonstration of this scenario, see the code example for the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="e9650-176">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-176">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="e9650-177">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-177">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A?displayProperty=nameWithType> property.</span></span>  
  
## Examples  
 <span data-ttu-id="e9650-178">El ejemplo de código siguiente muestra cómo obtener los argumentos de tipo de un método genérico y mostrarlos.</span><span class="sxs-lookup"><span data-stu-id="e9650-178">The following code example shows how to get the type arguments of a generic method and display them.</span></span>  
  
 <span data-ttu-id="e9650-179">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-179">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#8](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#8)]
 [!code-csharp[MethodInfo.Generics#8](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#8)]
 [!code-vb[MethodInfo.Generics#8](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="e9650-180">No se admite este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-180">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <altmember cref="P:System.Type.IsGenericType" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="e9650-181">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="e9650-181">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="e9650-182">Introducción a los genéricos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="e9650-182">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo GetGenericMethodDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetGenericMethodDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericMethodDefinition () As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetGenericMethodDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo&#xA;override this.GetGenericMethodDefinition : unit -&gt; System.Reflection.MethodInfo" Usage="methodInfo.GetGenericMethodDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-183">Devuelve un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa una definición de método genérico a partir de la cual se puede construir el método actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-183">Returns a <see cref="T:System.Reflection.MethodInfo" /> object that represents a generic method definition from which the current method can be constructed.</span></span></summary>
        <returns><span data-ttu-id="e9650-184">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa una definición de método genérico a partir de la cual se puede construir el método actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-184">A <see cref="T:System.Reflection.MethodInfo" /> object representing a generic method definition from which the current method can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-185">Una definición de método genérico es una plantilla desde el que se pueden construir métodos.</span><span class="sxs-lookup"><span data-stu-id="e9650-185">A generic method definition is a template from which methods can be constructed.</span></span> <span data-ttu-id="e9650-186">Por ejemplo, desde la definición de método genérico `T M<T>(T t)` (expresada en sintaxis de C#; `Function M(Of T)(ByVal tVal As T) As T` en Visual Basic) puede construir e invocar el método `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="e9650-186">For example, from the generic method definition `T M<T>(T t)` (expressed in C# syntax; `Function M(Of T)(ByVal tVal As T) As T` in Visual Basic) you can construct and invoke the method `int M<int>(int t)` (`Function M(Of Integer)(ByVal tVal As Integer) As Integer` in Visual Basic).</span></span> <span data-ttu-id="e9650-187">Dado un <xref:System.Reflection.MethodInfo> construido de objeto que representa este método, el <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> método devuelve la definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-187">Given a <xref:System.Reflection.MethodInfo> object representing this constructed method, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the generic method definition.</span></span>  
  
 <span data-ttu-id="e9650-188">Si se crean dos métodos construidos desde la misma definición de método genérico, la <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> que devuelve el mismo método <xref:System.Reflection.MethodInfo> objeto para ambos métodos.</span><span class="sxs-lookup"><span data-stu-id="e9650-188">If two constructed methods are created from the same generic method definition, the <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> method returns the same <xref:System.Reflection.MethodInfo> object for both methods.</span></span>  
  
 <span data-ttu-id="e9650-189">Si se llama a <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> en un <xref:System.Reflection.MethodInfo> ya que representa una definición de método genérico, devuelve el valor actual <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="e9650-189">If you call <xref:System.Reflection.MethodInfo.GetGenericMethodDefinition%2A> on a <xref:System.Reflection.MethodInfo> that already represents a generic method definition, it returns the current <xref:System.Reflection.MethodInfo>.</span></span>  
  
 <span data-ttu-id="e9650-190">Si una definición de método genérico incluye parámetros genéricos del tipo declarativo, habrá una definición de método genérico específicas de cada tipo construido.</span><span class="sxs-lookup"><span data-stu-id="e9650-190">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="e9650-191">Por ejemplo, considere el siguiente código de C#, Visual Basic y C++:</span><span class="sxs-lookup"><span data-stu-id="e9650-191">For example, consider the following C#, Visual Basic, and C++ code:</span></span>  
  
```  
class B<U,V> {}  
class C<T> { public B<T,S> M<S>() {...}}  
  
Class B(Of U, V)  
End Class  
Class C(Of T)  
    Public Function M(Of S)() As B(Of T, S)  
        ...  
    End Function  
End Class   
  
generic <typename U, typename V> ref class B {};  
generic <typename T> ref class C  
{  
public:  
    generic <typename S> B<T,S>^ M() {...};  
};  
```  
  
 <span data-ttu-id="e9650-192">En el tipo construido `C<int>` (`C(Of Integer)` en Visual Basic), el método genérico `M` devuelve `B<int, S>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-192">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method `M` returns `B<int, S>`.</span></span> <span data-ttu-id="e9650-193">En el tipo abierto `C<T>`, `M` devuelve `B<T, S>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-193">In the open type `C<T>`, `M` returns `B<T, S>`.</span></span> <span data-ttu-id="e9650-194">En ambos casos, el <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> propiedad devuelve `true` para el <xref:System.Reflection.MethodInfo> que representa `M`, por lo que <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> puede llamarse en ambos <xref:System.Reflection.MethodInfo> objetos.</span><span class="sxs-lookup"><span data-stu-id="e9650-194">In both cases, the <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `true` for the <xref:System.Reflection.MethodInfo> that represents `M`, so <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> can be called on both <xref:System.Reflection.MethodInfo> objects.</span></span> <span data-ttu-id="e9650-195">En el caso del tipo construido, el resultado de llamar a <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> es un <xref:System.Reflection.MethodInfo> que puede invocarse.</span><span class="sxs-lookup"><span data-stu-id="e9650-195">In the case of the constructed type, the result of calling <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> is a <xref:System.Reflection.MethodInfo> that can be invoked.</span></span> <span data-ttu-id="e9650-196">En el caso del tipo abierto, el <xref:System.Reflection.MethodInfo> devuelto por <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> no se puede invocar.</span><span class="sxs-lookup"><span data-stu-id="e9650-196">In the case of the open type, the <xref:System.Reflection.MethodInfo> returned by <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> cannot be invoked.</span></span>  
  
 <span data-ttu-id="e9650-197">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-197">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="e9650-198">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-198">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9650-199">En el ejemplo de código siguiente se muestra una clase con un método genérico y el código necesario para obtener un <xref:System.Reflection.MethodInfo> para el método, enlace el método a argumentos de tipo y obtener la definición de tipo genérico original del método enlazado.</span><span class="sxs-lookup"><span data-stu-id="e9650-199">The following code example shows a class with a generic method and the code required to obtain a <xref:System.Reflection.MethodInfo> for the method, bind the method to type arguments, and get the original generic type definition back from the bound method.</span></span>  
  
 <span data-ttu-id="e9650-200">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-200">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#2](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#2)]
 [!code-csharp[MethodInfo.Generics#2](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#2)]
 [!code-vb[MethodInfo.Generics#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#2)]  
[!code-cpp[MethodInfo.Generics#3](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#3)]
[!code-csharp[MethodInfo.Generics#3](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#3)]
[!code-vb[MethodInfo.Generics#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#3)]  
[!code-cpp[MethodInfo.Generics#4](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#4)]
[!code-csharp[MethodInfo.Generics#4](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#4)]
[!code-vb[MethodInfo.Generics#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9650-201">El método actual no es genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-201">The current method is not a generic method.</span></span> <span data-ttu-id="e9650-202">Es decir, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-202">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethod" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="e9650-203">No se admite este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-203">This method is not supported.</span></span></exception>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethod" />
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="e9650-204">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="e9650-204">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="e9650-205">Introducción a los genéricos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="e9650-205">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="methodInfo.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-206">Devuelve el código hash de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="e9650-206">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="e9650-207">Código hash de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="e9650-207">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="methodInfo.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Invoke">
      <MemberSignature Language="C#" Value="public object Invoke (object obj, object[] parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Invoke(object obj, object[] parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.Invoke(System.Object,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Invoke (obj As Object, parameters As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ Invoke(System::Object ^ obj, cli::array &lt;System::Object ^&gt; ^ parameters);" />
      <MemberSignature Language="F#" Value="override this.Invoke : obj * obj[] -&gt; obj" Usage="methodInfo.Invoke (obj, parameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="parameters" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="parameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethod">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethod" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethod As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethod { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethod : bool" Usage="System.Reflection.MethodInfo.IsGenericMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodDefinition">
      <MemberSignature Language="C#" Value="public override bool IsGenericMethodDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property IsGenericMethodDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodDefinition : bool" Usage="System.Reflection.MethodInfo.IsGenericMethodDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-208">Obtiene un valor que indica si el <see cref="T:System.Reflection.MethodInfo" /> actual representa la definición de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-208">Gets a value indicating whether the current <see cref="T:System.Reflection.MethodInfo" /> represents the definition of a generic method.</span></span></summary>
        <value><span data-ttu-id="e9650-209"><see langword="true" /> si el objeto <see cref="T:System.Reflection.MethodInfo" /> representa la definición de un método genérico; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-209"><see langword="true" /> if the <see cref="T:System.Reflection.MethodInfo" /> object represents the definition of a generic method; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="e9650-210">Si el actual <xref:System.Reflection.MethodInfo> representa una definición de método genérico, a continuación:</span><span class="sxs-lookup"><span data-stu-id="e9650-210">If the current <xref:System.Reflection.MethodInfo> represents a generic method definition, then:</span></span>

  - <span data-ttu-id="e9650-211">`IsGenericMethodDefinition` devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="e9650-211">`IsGenericMethodDefinition` returns `true`.</span></span>

  - <span data-ttu-id="e9650-212">Para cada <xref:System.Type> objeto en la matriz devuelta por la <xref:System.Reflection.MethodInfo.GetGenericArguments> método:</span><span class="sxs-lookup"><span data-stu-id="e9650-212">For each <xref:System.Type> object in the array returned by the <xref:System.Reflection.MethodInfo.GetGenericArguments> method:</span></span>

      - <span data-ttu-id="e9650-213">La propiedad <xref:System.Type.IsGenericParameter?displayProperty=nameWithType> devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="e9650-213">The <xref:System.Type.IsGenericParameter?displayProperty=nameWithType> property returns `true`.</span></span>

      - <span data-ttu-id="e9650-214">El <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> devuelve el valor actual <xref:System.Reflection.MethodInfo>.</span><span class="sxs-lookup"><span data-stu-id="e9650-214">The <xref:System.Type.DeclaringMethod?displayProperty=nameWithType> returns the current <xref:System.Reflection.MethodInfo>.</span></span>

      - <span data-ttu-id="e9650-215">El <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> propiedad es igual a la posición de la <xref:System.Type> los objetos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="e9650-215">The <xref:System.Type.GenericParameterPosition?displayProperty=nameWithType> property is the same as the position of the <xref:System.Type> object in the array.</span></span>

<span data-ttu-id="e9650-216">Use el `IsGenericMethodDefinition` propiedad para determinar si los argumentos de tipo se han asignado a los parámetros de tipo de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-216">Use the `IsGenericMethodDefinition` property to determine whether type arguments have been assigned to the type parameters of a generic method.</span></span> <span data-ttu-id="e9650-217">Si se han asignado los argumentos de tipo, el `IsGenericMethodDefinition` propiedad devuelve false, incluso si algunos de los argumentos de tipo son <xref:System.Type> objetos que representan los parámetros de tipo de tipos envolventes.</span><span class="sxs-lookup"><span data-stu-id="e9650-217">If type arguments have been assigned, the `IsGenericMethodDefinition` property returns false even if some of the type arguments are <xref:System.Type> objects that represent type parameters of enclosing types.</span></span> <span data-ttu-id="e9650-218">Por ejemplo, considere el siguiente C\#, Visual Basic y el código de C++:</span><span class="sxs-lookup"><span data-stu-id="e9650-218">For example, consider the following C\#, Visual Basic, and C++ code:</span></span>

    ```cs
    class C
    {
        T N<T,U>(T t, U u) {...}
        public V M<V>(V v)
        {
            return N<V,int>(v, 42);
        }
    }
    ```

    ```vb
    Class C
        Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T
            ...
        End Function
        Public Function M(Of V)(ByVal va As V ) As V
            Return N(Of V, Integer)(va, 42)
        End Function
    End Class
    ```

    ```cpp
    ref class C
    {
    private:
        generic <typename T, typename U> T N(T t, U u) {...}
    public:
        generic <typename V> V M(V v)
        {
            return N<V, int>(v, 42);
        }
    };
    ```

<span data-ttu-id="e9650-219">El cuerpo del método de M contiene una llamada al método N, especificando el parámetro de tipo de M y el tipo <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e9650-219">The method body of M contains a call to method N, specifying the type parameter of M and the type <xref:System.Int32>.</span></span> <span data-ttu-id="e9650-220">El `IsGenericMethodDefinition` propiedad devuelve false para el método `N<V,int>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-220">The `IsGenericMethodDefinition` property returns false for method `N<V,int>`.</span></span>

> [!NOTE]
> <span data-ttu-id="e9650-221">Aunque el método construido abierto `N<V,int>` no es encontrado al reflejar en la clase C, debe generarse con <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> con el fin de emitir C como una clase dinámica.</span><span class="sxs-lookup"><span data-stu-id="e9650-221">Although the open constructed method `N<V,int>` is not encountered when reflecting over class C, it must be generated using <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> in order to emit C as a dynamic class.</span></span>


<span data-ttu-id="e9650-222">Si una definición de método genérico incluye parámetros genéricos del tipo declarativo, habrá una definición de método genérico específicas de cada tipo construido.</span><span class="sxs-lookup"><span data-stu-id="e9650-222">If a generic method definition includes generic parameters of the declaring type, there will be a generic method definition specific to each constructed type.</span></span> <span data-ttu-id="e9650-223">Por ejemplo, considere el siguiente C\# y código de Visual Basic:</span><span class="sxs-lookup"><span data-stu-id="e9650-223">For example, consider the following C\# and Visual Basic code:</span></span>

    ```csharp
    class B<U,V> {}
    class C<T> { public B<T,S> M<S>() {...}}
    ```

    ```vb
    Class B(Of U, V)
    End Class
    Class C(Of T)
        Public Function M(Of S)() As B(Of T, S)
            ...
        End Function
    End Class
    ```

    ```cpp
    generic <typename U, typename V> ref class B {};
    generic <typename T> ref class C
    {
    public:
        generic <typename S> B<T,S>^ M() {...};
    };
    ```

<span data-ttu-id="e9650-224">En el tipo construido `C<int>` (`C(Of Integer)` en Visual Basic), devuelve el método genérico M `B<int, S>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-224">In the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the generic method M returns `B<int, S>`.</span></span> <span data-ttu-id="e9650-225">En el tipo abierto `C<T>`, M devuelve `B<T, S>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-225">In the open type `C<T>`, M returns `B<T, S>`.</span></span> <span data-ttu-id="e9650-226">En ambos casos, el `IsGenericMethodDefinition` propiedad devuelve `true` para el <xref:System.Reflection.MethodInfo> que representa M.</span><span class="sxs-lookup"><span data-stu-id="e9650-226">In both cases, the `IsGenericMethodDefinition` property returns `true` for the <xref:System.Reflection.MethodInfo> that represents M.</span></span>

<span data-ttu-id="e9650-227">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodInfo.IsGenericMethod> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-227">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodInfo.IsGenericMethod> property.</span></span> <span data-ttu-id="e9650-228">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-228">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType> property.</span></span>

## Examples  
<span data-ttu-id="e9650-229">El siguiente ejemplo de código utiliza el `IsGenericMethodDefinition` propiedad para mostrar un mensaje que indica si un <xref:System.Reflection.MethodInfo> representa una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-229">The following code example uses the `IsGenericMethodDefinition` property to display a message indicating whether a <xref:System.Reflection.MethodInfo> represents a generic method definition.</span></span>

<span data-ttu-id="e9650-230">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método.</span><span class="sxs-lookup"><span data-stu-id="e9650-230">This example is part of a larger example provided for the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method.</span></span>

```vb
Console.WriteLine(vbTab _
    & "Is this a generic method definition? {0}", _
    mi.IsGenericMethodDefinition)
```

```csharp
Console.WriteLine("\tIs this a generic method definition? {0}", 
    mi.IsGenericMethodDefinition);
```

```cpp
Console::WriteLine("\tIs this a generic method definition? {0}", 
    mi->IsGenericMethodDefinition);
```

]]></format>
        </remarks>
        <altmember cref="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="e9650-231">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="e9650-231">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="e9650-232">Introducción a los genéricos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="e9650-232">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodInfo MakeGenericMethod (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo MakeGenericMethod(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.MakeGenericMethod(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericMethod (ParamArray typeArguments As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ MakeGenericMethod(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.MakeGenericMethod : Type[] -&gt; System.Reflection.MethodInfo" Usage="methodInfo.MakeGenericMethod typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="e9650-233">Matriz de tipos que se van a sustituir por los parámetros de tipo de la definición de método genérico actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-233">An array of types to be substituted for the type parameters of the current generic method definition.</span></span></param>
        <summary><span data-ttu-id="e9650-234">Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de método genérico actual y devuelve un objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método construido resultante.</span><span class="sxs-lookup"><span data-stu-id="e9650-234">Substitutes the elements of an array of types for the type parameters of the current generic method definition, and returns a <see cref="T:System.Reflection.MethodInfo" /> object representing the resulting constructed method.</span></span></summary>
        <returns><span data-ttu-id="e9650-235">Objeto <see cref="T:System.Reflection.MethodInfo" /> que representa el método construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros de tipo de la definición de método genérico actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-235">A <see cref="T:System.Reflection.MethodInfo" /> object that represents the constructed method formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic method definition.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-236">El <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método le permite escribir código que asigna tipos específicos a los parámetros de tipo de una definición de método genérico, creando así un <xref:System.Reflection.MethodInfo> objeto que representa un método construido determinado.</span><span class="sxs-lookup"><span data-stu-id="e9650-236">The <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method allows you to write code that assigns specific types to the type parameters of a generic method definition, thus creating a <xref:System.Reflection.MethodInfo> object that represents a particular constructed method.</span></span> <span data-ttu-id="e9650-237">Si el <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad de este <xref:System.Reflection.MethodInfo> objeto devuelve `true`, puede usar para invocar el método o para crear un delegado para invocar el método.</span><span class="sxs-lookup"><span data-stu-id="e9650-237">If the <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property of this <xref:System.Reflection.MethodInfo> object returns `true`, you can use it to invoke the method or to create a delegate to invoke the method.</span></span>  
  
 <span data-ttu-id="e9650-238">Los métodos que se construyen con la <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> método puede estar abierto, es decir, algunos de sus argumentos de tipo pueden ser parámetros de tipo de tipos genéricos envolventes.</span><span class="sxs-lookup"><span data-stu-id="e9650-238">Methods constructed with the <xref:System.Reflection.MethodInfo.MakeGenericMethod%2A> method can be open, that is, some of their type arguments can be type parameters of enclosing generic types.</span></span> <span data-ttu-id="e9650-239">Puede usar dichos métodos construidos abiertos al generar ensamblados dinámicos.</span><span class="sxs-lookup"><span data-stu-id="e9650-239">You might use such open constructed methods when you generate dynamic assemblies.</span></span> <span data-ttu-id="e9650-240">Por ejemplo, considere el siguiente código de C#, Visual Basic y C++.</span><span class="sxs-lookup"><span data-stu-id="e9650-240">For example, consider the following C#, Visual Basic, and C++ code.</span></span>  
  
```  
class C  
{  
    T N<T,U>(T t, U u) {...}  
    public V M<V>(V v)  
    {  
        return N<V,int>(v, 42);  
    }  
}  
  
Class C  
    Public Function N(Of T,U)(ByVal ta As T, ByVal ua As U) As T  
        ...  
    End Function  
    Public Function M(Of V)(ByVal va As V ) As V  
        Return N(Of V, Integer)(va, 42)  
    End Function  
End Class  
  
ref class C  
{  
private:  
    generic <typename T, typename U> T N(T t, U u) {...}  
public:  
    generic <typename V> V M(V v)  
    {  
        return N<V, int>(v, 42);  
    }  
};  
```  
  
 <span data-ttu-id="e9650-241">El cuerpo del método de `M` contiene una llamada al método `N`, especificando el parámetro de tipo de `M` y el tipo <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="e9650-241">The method body of `M` contains a call to method `N`, specifying the type parameter of `M` and the type <xref:System.Int32>.</span></span> <span data-ttu-id="e9650-242">El <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> propiedad devuelve `false` método `N<V,int>`.</span><span class="sxs-lookup"><span data-stu-id="e9650-242">The <xref:System.Reflection.MethodBase.IsGenericMethodDefinition%2A> property returns `false` for method `N<V,int>`.</span></span> <span data-ttu-id="e9650-243">El <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> propiedad devuelve `true`, ese método `N<V,int>` no se puede invocar.</span><span class="sxs-lookup"><span data-stu-id="e9650-243">The <xref:System.Reflection.MethodBase.ContainsGenericParameters%2A> property returns `true`, so method `N<V,int>` cannot be invoked.</span></span>  
  
 <span data-ttu-id="e9650-244">Para obtener una lista de las condiciones invariables para los términos específicos de los métodos genéricos, vea el <xref:System.Reflection.MethodBase.IsGenericMethod%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-244">For a list of the invariant conditions for terms specific to generic methods, see the <xref:System.Reflection.MethodBase.IsGenericMethod%2A> property.</span></span> <span data-ttu-id="e9650-245">Para obtener una lista de las condiciones invariables en otros términos utilizados en la reflexión genérica, vea el <xref:System.Type.IsGenericType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="e9650-245">For a list of the invariant conditions for other terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9650-246">El ejemplo de código siguiente muestra las propiedades y métodos de <xref:System.Reflection.MethodInfo> que admiten el examen de los métodos genéricos.</span><span class="sxs-lookup"><span data-stu-id="e9650-246">The following code example demonstrates the properties and methods of <xref:System.Reflection.MethodInfo> that support the examination of generic methods.</span></span> <span data-ttu-id="e9650-247">El ejemplo hace lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="e9650-247">The example does the following:</span></span>  
  
-   <span data-ttu-id="e9650-248">Define una clase que tiene un método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-248">Defines a class that has a generic method.</span></span>  
  
-   <span data-ttu-id="e9650-249">Crea un <xref:System.Reflection.MethodInfo> que representa el método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-249">Creates a <xref:System.Reflection.MethodInfo> that represents the generic method.</span></span>  
  
-   <span data-ttu-id="e9650-250">Muestra las propiedades de la definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-250">Displays properties of the generic method definition.</span></span>  
  
-   <span data-ttu-id="e9650-251">Asigna argumentos de tipo a los parámetros de tipo de la <xref:System.Reflection.MethodInfo>e invoca el método genérico construido resultante.</span><span class="sxs-lookup"><span data-stu-id="e9650-251">Assigns type arguments to the type parameters of the <xref:System.Reflection.MethodInfo>, and invokes the resulting constructed generic method.</span></span>  
  
-   <span data-ttu-id="e9650-252">Muestra las propiedades del método genérico construido.</span><span class="sxs-lookup"><span data-stu-id="e9650-252">Displays properties of the constructed generic method.</span></span>  
  
-   <span data-ttu-id="e9650-253">Recupera la definición de método genérico del método construido y lo compara con la definición original.</span><span class="sxs-lookup"><span data-stu-id="e9650-253">Retrieves the generic method definition from the constructed method and compares it to the original definition.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="e9650-254">El <see cref="T:System.Reflection.MethodInfo" /> actual no representa una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="e9650-254">The current <see cref="T:System.Reflection.MethodInfo" /> does not represent a generic method definition.</span></span> <span data-ttu-id="e9650-255">Es decir, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-255">That is, <see cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="e9650-256">El valor de <paramref name="typeArguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-256"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="e9650-257">O bien</span><span class="sxs-lookup"><span data-stu-id="e9650-257">-or-</span></span> 
<span data-ttu-id="e9650-258">Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-258">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="e9650-259">El número de elementos de <paramref name="typeArguments" /> no es el mismo que el número de parámetros de tipo de la definición de método genérico actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-259">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters of the current generic method definition.</span></span>  
  
<span data-ttu-id="e9650-260">O bien</span><span class="sxs-lookup"><span data-stu-id="e9650-260">-or-</span></span> 
<span data-ttu-id="e9650-261">Un elemento de <paramref name="typeArguments" /> no satisface las restricciones especificadas para el parámetro de tipo correspondiente de la definición de método genérico actual.</span><span class="sxs-lookup"><span data-stu-id="e9650-261">An element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic method definition.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="e9650-262">No se admite este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-262">This method is not supported.</span></span></exception>
        <altmember cref="P:System.Reflection.MethodBase.IsGenericMethodDefinition" />
        <altmember cref="M:System.Reflection.MethodInfo.GetGenericMethodDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="e9650-263">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="e9650-263">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/csharp/programming-guide/generics/introduction-to-generics.md"><span data-ttu-id="e9650-264">Introducción a los genéricos (Guía de programación de C#)</span><span class="sxs-lookup"><span data-stu-id="e9650-264">Introduction to Generics (C# Programming Guide)</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Reflection.MethodInfo.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-265">Obtiene un valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un método.</span><span class="sxs-lookup"><span data-stu-id="e9650-265">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></summary>
        <value><span data-ttu-id="e9650-266">Valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un método.</span><span class="sxs-lookup"><span data-stu-id="e9650-266">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-267">Esta propiedad invalida <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e9650-267">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e9650-268">Por lo tanto, cuando se examina un conjunto de <xref:System.Reflection.MemberInfo> objetos: por ejemplo, la matriz devuelta por <xref:System.Type.GetMembers%2A> : la <xref:System.Reflection.MemberInfo.MemberType%2A> propiedad devuelve <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> sólo cuando un miembro determinado es un método.</span><span class="sxs-lookup"><span data-stu-id="e9650-268">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.Method?displayProperty=nameWithType> only when a given member is a method.</span></span>  
  
 <span data-ttu-id="e9650-269">Para obtener el `MemberType` propiedad, obtenga primero la clase `Type`.</span><span class="sxs-lookup"><span data-stu-id="e9650-269">To get the `MemberType` property, first get the class `Type`.</span></span> <span data-ttu-id="e9650-270">Desde el `Type`, obtener el `MethodInfo`.</span><span class="sxs-lookup"><span data-stu-id="e9650-270">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="e9650-271">Desde el `MethodInfo`, obtener el `MemberType`.</span><span class="sxs-lookup"><span data-stu-id="e9650-271">From the `MethodInfo`, get the `MemberType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9650-272">El ejemplo siguiente muestra el tipo del miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="e9650-272">The following example displays the type of the specified member.</span></span>  
  
 [!code-cpp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Equality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e9650-273">Primer objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="e9650-273">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="e9650-274">Segundo objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="e9650-274">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="e9650-275">Indica si dos objetos <see cref="T:System.Reflection.MethodInfo" /> son iguales.</span><span class="sxs-lookup"><span data-stu-id="e9650-275">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="e9650-276"><see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-276"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Reflection.MethodInfo left, System.Reflection.MethodInfo right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Reflection.MethodInfo left, class System.Reflection.MethodInfo right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.op_Inequality(System.Reflection.MethodInfo,System.Reflection.MethodInfo)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As MethodInfo, right As MethodInfo) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Reflection::MethodInfo ^ left, System::Reflection::MethodInfo ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Reflection.MethodInfo * System.Reflection.MethodInfo -&gt; bool" Usage="System.Reflection.MethodInfo.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Reflection.MethodInfo" />
        <Parameter Name="right" Type="System.Reflection.MethodInfo" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e9650-277">Primer objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="e9650-277">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="e9650-278">Segundo objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="e9650-278">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="e9650-279">Indica si dos objetos <see cref="T:System.Reflection.MethodInfo" /> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="e9650-279">Indicates whether two <see cref="T:System.Reflection.MethodInfo" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="e9650-280">Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-280"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnParameter">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.ParameterInfo ReturnParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ParameterInfo ReturnParameter" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnParameter As ParameterInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::ParameterInfo ^ ReturnParameter { System::Reflection::ParameterInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnParameter : System.Reflection.ParameterInfo" Usage="System.Reflection.MethodInfo.ReturnParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ParameterInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-281">Obtiene un objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto del método como, por ejemplo, cuando el tipo de valor devuelto tiene modificadores personalizados.</span><span class="sxs-lookup"><span data-stu-id="e9650-281">Gets a <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type of the method, such as whether the return type has custom modifiers.</span></span></summary>
        <value><span data-ttu-id="e9650-282">Objeto <see cref="T:System.Reflection.ParameterInfo" /> que contiene información sobre el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="e9650-282">A <see cref="T:System.Reflection.ParameterInfo" /> object that contains information about the return type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-283">Pueden utilizar los diseñadores de compiladores el <xref:System.Reflection.ParameterInfo> objeto devuelto por esta propiedad para detectar si personalizado modificadores, como <xref:Microsoft.VisualC.IsConstModifier>, se han aplicado al tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="e9650-283">Compiler designers can use the <xref:System.Reflection.ParameterInfo> object returned by this property to discover whether custom modifiers, such as <xref:Microsoft.VisualC.IsConstModifier>, have been applied to the return type.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="e9650-284">Este método no se implementa.</span><span class="sxs-lookup"><span data-stu-id="e9650-284">This method is not implemented.</span></span></exception>
        <altmember cref="M:System.Reflection.ParameterInfo.GetOptionalCustomModifiers" />
        <altmember cref="M:System.Reflection.ParameterInfo.GetRequiredCustomModifiers" />
      </Docs>
    </Member>
    <Member MemberName="ReturnType">
      <MemberSignature Language="C#" Value="public virtual Type ReturnType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReturnType" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ReturnType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReturnType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnType : Type" Usage="System.Reflection.MethodInfo.ReturnType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-285">Obtiene el tipo de valor devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="e9650-285">Gets the return type of this method.</span></span></summary>
        <value><span data-ttu-id="e9650-286">Tipo de valor devuelto del método.</span><span class="sxs-lookup"><span data-stu-id="e9650-286">The return type of this method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-287">Para obtener la propiedad de tipo de valor devuelto, obtenga primero la clase `Type`.</span><span class="sxs-lookup"><span data-stu-id="e9650-287">To get the return type property, first get the class `Type`.</span></span> <span data-ttu-id="e9650-288">Desde el `Type`, obtener el `MethodInfo`.</span><span class="sxs-lookup"><span data-stu-id="e9650-288">From the `Type`, get the `MethodInfo`.</span></span> <span data-ttu-id="e9650-289">Desde el `MethodInfo`, obtener el `ReturnType`.</span><span class="sxs-lookup"><span data-stu-id="e9650-289">From the `MethodInfo`, get the `ReturnType`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e9650-290">El ejemplo siguiente muestra el tipo de valor devuelto del método especificado.</span><span class="sxs-lookup"><span data-stu-id="e9650-290">The following example displays the return type of the specified method.</span></span>  
  
 [!code-cpp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/CS/source.cs#1)]
 [!code-vb[Classic MethodInfo.ReturnType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodInfo.ReturnType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReturnTypeCustomAttributes">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ICustomAttributeProvider ReturnTypeCustomAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property ReturnTypeCustomAttributes As ICustomAttributeProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::ICustomAttributeProvider ^ ReturnTypeCustomAttributes { System::Reflection::ICustomAttributeProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReturnTypeCustomAttributes : System.Reflection.ICustomAttributeProvider" Usage="System.Reflection.MethodInfo.ReturnTypeCustomAttributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._MethodInfo.ReturnTypeCustomAttributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ICustomAttributeProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e9650-291">Obtiene los atributos personalizados del tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="e9650-291">Gets the custom attributes for the return type.</span></span></summary>
        <value><span data-ttu-id="e9650-292">Objeto <see langword="ICustomAttributeProvider" /> que representa los atributos personalizados para el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="e9650-292">An <see langword="ICustomAttributeProvider" /> object representing the custom attributes for the return type.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _MethodInfo.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_MethodInfo::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="e9650-293">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="e9650-293">Reserved for future use.</span></span> <span data-ttu-id="e9650-294">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="e9650-294">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="e9650-295">Matriz que se pasa con los nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="e9650-295">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="e9650-296">Número de nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="e9650-296">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="e9650-297">Contexto de configuración regional en el que se van a interpretar los nombres.</span><span class="sxs-lookup"><span data-stu-id="e9650-297">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="e9650-298">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span><span class="sxs-lookup"><span data-stu-id="e9650-298">Caller-allocated array that receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="e9650-299">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span><span class="sxs-lookup"><span data-stu-id="e9650-299">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-300">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="e9650-300">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="e9650-301">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="e9650-301">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="e9650-302">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="e9650-302">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetType">
      <MemberSignature Language="C#" Value="Type _MethodInfo.GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Type System.Runtime.InteropServices._MethodInfo.GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetType" />
      <MemberSignature Language="VB.NET" Value="Function GetType () As Type Implements _MethodInfo.GetType" />
      <MemberSignature Language="C++ CLI" Value=" virtual Type ^ System.Runtime.InteropServices._MethodInfo.GetType() = System::Runtime::InteropServices::_MethodInfo::GetType;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e9650-303">Proporciona acceso al método <see cref="M:System.Object.GetType" /> desde COM.</span><span class="sxs-lookup"><span data-stu-id="e9650-303">Provides access to the <see cref="M:System.Object.GetType" /> method from COM.</span></span></summary>
        <returns><span data-ttu-id="e9650-304">Objeto <see cref="T:System.Type" /> que representa el tipo <see cref="T:System.Reflection.MethodInfo" />.</span><span class="sxs-lookup"><span data-stu-id="e9650-304">A <see cref="T:System.Type" /> object representing the <see cref="T:System.Reflection.MethodInfo" /> type.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _MethodInfo.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="e9650-305">Información de tipos que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="e9650-305">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="e9650-306">Identificador de la configuración regional de la información de tipo.</span><span class="sxs-lookup"><span data-stu-id="e9650-306">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="e9650-307">Recibe un puntero al objeto de información de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="e9650-307">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="e9650-308">Obtiene la información de tipos de un objeto, que puede utilizarse para obtener la información de tipos de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="e9650-308">Retrieves the type information for an object, which can be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-309">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="e9650-309">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="e9650-310">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="e9650-310">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="e9650-311">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="e9650-311">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _MethodInfo.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _MethodInfo.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_MethodInfo::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="e9650-312">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-312">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="e9650-313">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span><span class="sxs-lookup"><span data-stu-id="e9650-313">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-314">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="e9650-314">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="e9650-315">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="e9650-315">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="e9650-316">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="e9650-316">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._MethodInfo.Invoke">
      <MemberSignature Language="C#" Value="void _MethodInfo.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._MethodInfo.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Reflection.MethodInfo.System#Runtime#InteropServices#_MethodInfo#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _MethodInfo.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._MethodInfo.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_MethodInfo::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._MethodInfo.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Reflection</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="e9650-317">Identifica el miembro.</span><span class="sxs-lookup"><span data-stu-id="e9650-317">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="e9650-318">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="e9650-318">Reserved for future use.</span></span> <span data-ttu-id="e9650-319">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="e9650-319">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="e9650-320">Contexto de la configuración regional en que se interpretan los argumentos.</span><span class="sxs-lookup"><span data-stu-id="e9650-320">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="e9650-321">Marcas que describen el contexto de la llamada.</span><span class="sxs-lookup"><span data-stu-id="e9650-321">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="e9650-322">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span><span class="sxs-lookup"><span data-stu-id="e9650-322">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="e9650-323">Puntero a la ubicación donde se va a almacenar el resultado.</span><span class="sxs-lookup"><span data-stu-id="e9650-323">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="e9650-324">Puntero a una estructura que contiene información de excepciones.</span><span class="sxs-lookup"><span data-stu-id="e9650-324">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="e9650-325">Índice del primer argumento que tiene un error.</span><span class="sxs-lookup"><span data-stu-id="e9650-325">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="e9650-326">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span><span class="sxs-lookup"><span data-stu-id="e9650-326">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e9650-327">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="e9650-327">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="e9650-328">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="e9650-328">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="e9650-329">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="e9650-329">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>