<Type Name="SecurityTokenResolver" FullName="System.IdentityModel.Selectors.SecurityTokenResolver">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7a9f1909ecc5cbcee826670141ca59c0644e0e92" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39746884" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class SecurityTokenResolver" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit SecurityTokenResolver extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.IdentityModel.Selectors.SecurityTokenResolver" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SecurityTokenResolver" />
  <TypeSignature Language="C++ CLI" Value="public ref class SecurityTokenResolver abstract" />
  <TypeSignature Language="F#" Value="type SecurityTokenResolver = class" />
  <AssemblyInfo>
    <AssemblyName>System.IdentityModel</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces></Interfaces>
  <Docs>
    <summary>Representa una clase de utilidad que puede recuperar tokens de seguridad o claves al tener un identificador clave o cláusula de identificador de clave.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Utilice la clase <xref:System.IdentityModel.Selectors.SecurityTokenResolver> para recuperar una clave o token de seguridad al tener un identificador clave o cláusula de identificador de clave. <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> recuperan un token proporcionado que es un identificador clave o cláusula de identificador de clave. <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A> y <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> recupera una clave proporcionada que es una cláusula de identificador clave. Los métodos con el prefijo `Try` devuelven `false` cuando la recuperación es incorrecta, mientras que los métodos sin un tipo de prefijo `Try` inician una excepción.  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SecurityTokenResolver ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SecurityTokenResolver();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateDefaultSecurityTokenResolver">
      <MemberSignature Language="C#" Value="public static System.IdentityModel.Selectors.SecurityTokenResolver CreateDefaultSecurityTokenResolver (System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Tokens.SecurityToken&gt; tokens, bool canMatchLocalId);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.IdentityModel.Selectors.SecurityTokenResolver CreateDefaultSecurityTokenResolver(class System.Collections.ObjectModel.ReadOnlyCollection`1&lt;class System.IdentityModel.Tokens.SecurityToken&gt; tokens, bool canMatchLocalId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.CreateDefaultSecurityTokenResolver(System.Collections.ObjectModel.ReadOnlyCollection{System.IdentityModel.Tokens.SecurityToken},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDefaultSecurityTokenResolver (tokens As ReadOnlyCollection(Of SecurityToken), canMatchLocalId As Boolean) As SecurityTokenResolver" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::IdentityModel::Selectors::SecurityTokenResolver ^ CreateDefaultSecurityTokenResolver(System::Collections::ObjectModel::ReadOnlyCollection&lt;System::IdentityModel::Tokens::SecurityToken ^&gt; ^ tokens, bool canMatchLocalId);" />
      <MemberSignature Language="F#" Value="static member CreateDefaultSecurityTokenResolver : System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Tokens.SecurityToken&gt; * bool -&gt; System.IdentityModel.Selectors.SecurityTokenResolver" Usage="System.IdentityModel.Selectors.SecurityTokenResolver.CreateDefaultSecurityTokenResolver (tokens, canMatchLocalId)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Selectors.SecurityTokenResolver</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="tokens" Type="System.Collections.ObjectModel.ReadOnlyCollection&lt;System.IdentityModel.Tokens.SecurityToken&gt;" />
        <Parameter Name="canMatchLocalId" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="tokens">
          <see cref="T:System.Collections.ObjectModel.ReadOnlyCollection`1" /> de tipo <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que contiene el conjunto de tokens de seguridad para los que esta resolución del token de seguridad puede resolver identificadores clave y cláusulas de identificador de clave.</param>
        <param name="canMatchLocalId">
          <see langword="true" /> para resolver las cláusulas de identificador clave <see langword="&lt;SecurityTokenReference&gt;" /> que hacen referencia a una clave de seguridad que se busca en alguna otra parte en el mensaje SOAP; de lo contrario, <see langword="false" />.</param>
        <summary>Crea una resolución del token de seguridad predeterminada para los tokens de seguridad especificados.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Selectors.SecurityTokenResolver" /> que resuelve los identificadores clave y cláusulas que coinciden con los tokens de seguridad especificados en el parámetro <paramref name="tokens" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 La resolución del token de seguridad que se devuelve de este método, utiliza <xref:System.IdentityModel.Tokens.SecurityToken.MatchesKeyIdentifierClause%2A> y los métodos <xref:System.IdentityModel.Tokens.SecurityToken.ResolveKeyIdentifierClause%2A> en los tokens de seguridad especificados para resolver identificadores clave y cláusulas de identificador de clave.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadCustomConfiguration">
      <MemberSignature Language="C#" Value="public virtual void LoadCustomConfiguration (System.Xml.XmlNodeList nodelist);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void LoadCustomConfiguration(class System.Xml.XmlNodeList nodelist) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.LoadCustomConfiguration(System.Xml.XmlNodeList)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub LoadCustomConfiguration (nodelist As XmlNodeList)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void LoadCustomConfiguration(System::Xml::XmlNodeList ^ nodelist);" />
      <MemberSignature Language="F#" Value="abstract member LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit&#xA;override this.LoadCustomConfiguration : System.Xml.XmlNodeList -&gt; unit" Usage="securityTokenResolver.LoadCustomConfiguration nodelist" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IdentityModel.Configuration.ICustomIdentityConfiguration.LoadCustomConfiguration(System.Xml.XmlNodeList)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nodelist" Type="System.Xml.XmlNodeList" />
      </Parameters>
      <Docs>
        <param name="nodelist">Elementos de configuración personalizados.</param>
        <summary>Cuando se reemplaza en una clase derivada, carga la configuración personalizada de XML.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 De forma predeterminada, se produce un <xref:System.NotImplementedException>. Puede invalidar este método para proporcionar funcionalidad en una clase derivada.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolveSecurityKey">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityKey ResolveSecurityKey (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SecurityKey ResolveSecurityKey(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveSecurityKey (keyIdentifierClause As SecurityKeyIdentifierClause) As SecurityKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SecurityKey ^ ResolveSecurityKey(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" />
      <MemberSignature Language="F#" Value="member this.ResolveSecurityKey : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; System.IdentityModel.Tokens.SecurityKey" Usage="securityTokenResolver.ResolveSecurityKey keyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityKey</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para el que se va a recuperar la clave.</param>
        <summary>Obtiene la clave a la que se hace referencia en la cláusula de identificador clave especificada.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> que es la clave a la que se hace referencia en la cláusula de identificador clave especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como una clave. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keyIdentifierClause" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Una clave no se pudo recuperar para la cláusula de identificador clave especificada en el parámetro <paramref name="keyIdentifierClause" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ResolveToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Recupera un token de seguridad que coincide con el identificador clave especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ResolveToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityToken ResolveToken (System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SecurityToken ResolveToken(class System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken(System.IdentityModel.Tokens.SecurityKeyIdentifier)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveToken (keyIdentifier As SecurityKeyIdentifier) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SecurityToken ^ ResolveToken(System::IdentityModel::Tokens::SecurityKeyIdentifier ^ keyIdentifier);" />
      <MemberSignature Language="F#" Value="member this.ResolveToken : System.IdentityModel.Tokens.SecurityKeyIdentifier -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenResolver.ResolveToken keyIdentifier" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
      </Parameters>
      <Docs>
        <param name="keyIdentifier">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" /> para la que crear un token de seguridad.</param>
        <summary>Recupera un token de seguridad que coincide con una de las cláusulas de identificador de la clave  que están incluidas dentro del identificador clave especificado.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa el identificador clave especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como un token de seguridad. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keyIdentifier" /> es <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Un token de seguridad no se puede crear para el identificador clave especificado.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveToken">
      <MemberSignature Language="C#" Value="public System.IdentityModel.Tokens.SecurityToken ResolveToken (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IdentityModel.Tokens.SecurityToken ResolveToken(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken(System.IdentityModel.Tokens.SecurityKeyIdentifierClause)" />
      <MemberSignature Language="VB.NET" Value="Public Function ResolveToken (keyIdentifierClause As SecurityKeyIdentifierClause) As SecurityToken" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::IdentityModel::Tokens::SecurityToken ^ ResolveToken(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause);" />
      <MemberSignature Language="F#" Value="member this.ResolveToken : System.IdentityModel.Tokens.SecurityKeyIdentifierClause -&gt; System.IdentityModel.Tokens.SecurityToken" Usage="securityTokenResolver.ResolveToken keyIdentifierClause" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IdentityModel.Tokens.SecurityToken</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para la que crear un token de seguridad.</param>
        <summary>Recupera el token de seguridad que coincide con la cláusula de identificador especificada.</summary>
        <returns>
          <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa la cláusula de identificador especificada.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como un token de seguridad. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryResolveSecurityKey">
      <MemberSignature Language="C#" Value="public bool TryResolveSecurityKey (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, out System.IdentityModel.Tokens.SecurityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryResolveSecurityKey(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, [out] class System.IdentityModel.Tokens.SecurityKey&amp; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey(System.IdentityModel.Tokens.SecurityKeyIdentifierClause,System.IdentityModel.Tokens.SecurityKey@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryResolveSecurityKey (keyIdentifierClause As SecurityKeyIdentifierClause, ByRef key As SecurityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryResolveSecurityKey(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityKey ^ % key);" />
      <MemberSignature Language="F#" Value="member this.TryResolveSecurityKey : System.IdentityModel.Tokens.SecurityKeyIdentifierClause *  -&gt; bool" Usage="securityTokenResolver.TryResolveSecurityKey (keyIdentifierClause, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
        <Parameter Name="key" Type="System.IdentityModel.Tokens.SecurityKey" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para el que se va a recuperar la clave.</param>
        <param name="key">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> que contiene la clave a la que se hace referencia en la cláusula de identificador clave especificada. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta recuperar la clave a la que se hace referencia en la cláusula de identificador clave especificada.</summary>
        <returns>
          <see langword="true" /> cuando una clave se puede recuperar para el identificador clave especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como una clave. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keyIdentifierClause" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryResolveSecurityKeyCore">
      <MemberSignature Language="C#" Value="protected abstract bool TryResolveSecurityKeyCore (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, out System.IdentityModel.Tokens.SecurityKey key);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryResolveSecurityKeyCore(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, [out] class System.IdentityModel.Tokens.SecurityKey&amp; key) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKeyCore(System.IdentityModel.Tokens.SecurityKeyIdentifierClause,System.IdentityModel.Tokens.SecurityKey@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryResolveSecurityKeyCore (keyIdentifierClause As SecurityKeyIdentifierClause, ByRef key As SecurityKey) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryResolveSecurityKeyCore(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityKey ^ % key);" />
      <MemberSignature Language="F#" Value="abstract member TryResolveSecurityKeyCore : System.IdentityModel.Tokens.SecurityKeyIdentifierClause *  -&gt; bool" Usage="securityTokenResolver.TryResolveSecurityKeyCore (keyIdentifierClause, key)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
        <Parameter Name="key" Type="System.IdentityModel.Tokens.SecurityKey" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">
          <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para el que se va a recuperar la clave.</param>
        <param name="key">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityKey" /> que contiene la clave a la que se hace referencia en la cláusula de identificador clave especificada. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta recuperar la clave a la que se hace referencia en la cláusula de identificador clave especificada.</summary>
        <returns>
          <see langword="true" /> cuando una clave se puede recuperar para el identificador clave especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKeyCore%2A> y <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveSecurityKey%2A> llaman automáticamente al método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveSecurityKey%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryResolveToken">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta recuperar el token de seguridad al que se hace referencia en el objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryResolveToken">
      <MemberSignature Language="C#" Value="public bool TryResolveToken (System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier, out System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryResolveToken(class System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier, [out] class System.IdentityModel.Tokens.SecurityToken&amp; token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken(System.IdentityModel.Tokens.SecurityKeyIdentifier,System.IdentityModel.Tokens.SecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryResolveToken (keyIdentifier As SecurityKeyIdentifier, ByRef token As SecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryResolveToken(System::IdentityModel::Tokens::SecurityKeyIdentifier ^ keyIdentifier, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityToken ^ % token);" />
      <MemberSignature Language="F#" Value="member this.TryResolveToken : System.IdentityModel.Tokens.SecurityKeyIdentifier *  -&gt; bool" Usage="securityTokenResolver.TryResolveToken (keyIdentifier, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifier">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" /> para la que crear un token de seguridad.</param>
        <param name="token">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa el identificador clave especificado. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta recuperar el token de seguridad que coincide con una de las cláusulas de identificador de la clave que están incluidas dentro del identificador clave especificado.</summary>
        <returns>
          <see langword="true" /> cuando un token de seguridad se puede recuperar para el identificador clave especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como un token de seguridad. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keyIdentifier" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="TryResolveToken">
      <MemberSignature Language="C#" Value="public bool TryResolveToken (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, out System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryResolveToken(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, [out] class System.IdentityModel.Tokens.SecurityToken&amp; token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken(System.IdentityModel.Tokens.SecurityKeyIdentifierClause,System.IdentityModel.Tokens.SecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryResolveToken (keyIdentifierClause As SecurityKeyIdentifierClause, ByRef token As SecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryResolveToken(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityToken ^ % token);" />
      <MemberSignature Language="F#" Value="member this.TryResolveToken : System.IdentityModel.Tokens.SecurityKeyIdentifierClause *  -&gt; bool" Usage="securityTokenResolver.TryResolveToken (keyIdentifierClause, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para la que crear un token de seguridad.</param>
        <param name="token">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa la cláusula identificador clave especificada. Este parámetro se pasa sin inicializar.</param>
        <summary>Intenta recuperar el token de seguridad que coincide con la cláusula de identificador clave especificada.</summary>
        <returns>
          <see langword="true" /> cuando un token de seguridad se puede recuperar para la cláusula identificador clave; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> y los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> difieren en lo que pasa cuando la cláusula de identificador clave no se puede resolver como un token de seguridad. El método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> devuelve `false`, mientras que el método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A> produce una excepción.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="keyIdentifierClause" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryResolveTokenCore">
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Intenta recuperar la clave a la que se hace referencia en el objeto especificado.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryResolveTokenCore">
      <MemberSignature Language="C#" Value="protected abstract bool TryResolveTokenCore (System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier, out System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryResolveTokenCore(class System.IdentityModel.Tokens.SecurityKeyIdentifier keyIdentifier, [out] class System.IdentityModel.Tokens.SecurityToken&amp; token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveTokenCore(System.IdentityModel.Tokens.SecurityKeyIdentifier,System.IdentityModel.Tokens.SecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryResolveTokenCore (keyIdentifier As SecurityKeyIdentifier, ByRef token As SecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryResolveTokenCore(System::IdentityModel::Tokens::SecurityKeyIdentifier ^ keyIdentifier, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityToken ^ % token);" />
      <MemberSignature Language="F#" Value="abstract member TryResolveTokenCore : System.IdentityModel.Tokens.SecurityKeyIdentifier *  -&gt; bool" Usage="securityTokenResolver.TryResolveTokenCore (keyIdentifier, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifier" Type="System.IdentityModel.Tokens.SecurityKeyIdentifier" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifier">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifier" /> para la que crear un token de seguridad.</param>
        <param name="token">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa el identificador clave especificado. Este parámetro se pasa sin inicializar.</param>
        <summary>Cuando se invalida en una clase derivada, intenta recuperar el token de seguridad que coincide por lo menos con una de las cláusulas de identificador clave contenido dentro del identificador clave especificado.</summary>
        <returns>
          <see langword="true" /> cuando un token de seguridad se puede recuperar para el identificador clave especificado; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveTokenCore%2A> y <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> llaman automáticamente al método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryResolveTokenCore">
      <MemberSignature Language="C#" Value="protected abstract bool TryResolveTokenCore (System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, out System.IdentityModel.Tokens.SecurityToken token);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool TryResolveTokenCore(class System.IdentityModel.Tokens.SecurityKeyIdentifierClause keyIdentifierClause, [out] class System.IdentityModel.Tokens.SecurityToken&amp; token) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveTokenCore(System.IdentityModel.Tokens.SecurityKeyIdentifierClause,System.IdentityModel.Tokens.SecurityToken@)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function TryResolveTokenCore (keyIdentifierClause As SecurityKeyIdentifierClause, ByRef token As SecurityToken) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool TryResolveTokenCore(System::IdentityModel::Tokens::SecurityKeyIdentifierClause ^ keyIdentifierClause, [Runtime::InteropServices::Out] System::IdentityModel::Tokens::SecurityToken ^ % token);" />
      <MemberSignature Language="F#" Value="abstract member TryResolveTokenCore : System.IdentityModel.Tokens.SecurityKeyIdentifierClause *  -&gt; bool" Usage="securityTokenResolver.TryResolveTokenCore (keyIdentifierClause, token)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.IdentityModel</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keyIdentifierClause" Type="System.IdentityModel.Tokens.SecurityKeyIdentifierClause" />
        <Parameter Name="token" Type="System.IdentityModel.Tokens.SecurityToken" RefType="out" />
      </Parameters>
      <Docs>
        <param name="keyIdentifierClause">Clase <see cref="T:System.IdentityModel.Tokens.SecurityKeyIdentifierClause" /> para la que crear un token de seguridad.</param>
        <param name="token">Cuando este método finaliza, contiene <see cref="T:System.IdentityModel.Tokens.SecurityToken" /> que representa la cláusula identificador clave especificada. Este parámetro se pasa sin inicializar.</param>
        <summary>Cuando se invalida en una clase derivada, intenta resolver el token de seguridad que coincide con la cláusula de identificador clave especificada.</summary>
        <returns>
          <see langword="true" /> cuando un token de seguridad se puede recuperar para la cláusula identificador clave; de lo contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los métodos <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveTokenCore%2A> y <xref:System.IdentityModel.Selectors.SecurityTokenResolver.TryResolveToken%2A> llaman automáticamente al método <xref:System.IdentityModel.Selectors.SecurityTokenResolver.ResolveToken%2A>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>