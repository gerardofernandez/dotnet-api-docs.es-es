<Type Name="CipherMode" FullName="System.Security.Cryptography.CipherMode">
  <Metadata><Meta Name="ms.openlocfilehash" Value="6ddf3bf6d0eb6756fcc7288c5f2986a788353bac" /><Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/27/2018" /><Meta Name="ms.locfileid" Value="52341459" /></Metadata><TypeSignature Language="C#" Value="public enum CipherMode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed CipherMode extends System.Enum" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.CipherMode" />
  <TypeSignature Language="VB.NET" Value="Public Enum CipherMode" />
  <TypeSignature Language="C++ CLI" Value="public enum class CipherMode" />
  <TypeSignature Language="F#" Value="type CipherMode = " />
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Enum</BaseTypeName>
  </Base>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="faf43-101">Especifica el modo de cifrado de bloques que se utilizará para el cifrado.</span><span class="sxs-lookup"><span data-stu-id="faf43-101">Specifies the block cipher mode to use for encryption.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="faf43-102">Algoritmos de cifrado de bloque cifran datos en unidades de bloque, en lugar de un solo byte a la vez.</span><span class="sxs-lookup"><span data-stu-id="faf43-102">Block cipher algorithms encrypt data in block units, rather than a single byte at a time.</span></span> <span data-ttu-id="faf43-103">El tamaño de bloque más comunes es de 8 bytes.</span><span class="sxs-lookup"><span data-stu-id="faf43-103">The most common block size is 8 bytes.</span></span> <span data-ttu-id="faf43-104">Dado que cada bloque se procesa intensivamente, cifrados de bloques simétricos proporcionan un mayor nivel de seguridad que cifrados de flujos.</span><span class="sxs-lookup"><span data-stu-id="faf43-104">Because each block is heavily processed, block ciphers provide a higher level of security than stream ciphers.</span></span> <span data-ttu-id="faf43-105">Sin embargo, los algoritmos de cifrado de bloque tienden a ejecutar más lentamente que los cifrados de flujos.</span><span class="sxs-lookup"><span data-stu-id="faf43-105">However, block cipher algorithms tend to execute more slowly than stream ciphers.</span></span>  
  
 <span data-ttu-id="faf43-106">Los cifrados de bloques utilizan el mismo algoritmo de cifrado para cada bloque.</span><span class="sxs-lookup"><span data-stu-id="faf43-106">Block ciphers use the same encryption algorithm for each block.</span></span> <span data-ttu-id="faf43-107">Por este motivo, un bloque de texto sin formato siempre devolverá el mismo texto de cifrado al cifrado con la misma clave y algoritmo.</span><span class="sxs-lookup"><span data-stu-id="faf43-107">Because of this, a block of plain text will always return the same cipher text when encrypted with the same key and algorithm.</span></span> <span data-ttu-id="faf43-108">Dado que este comportamiento se puede usar para descifrar un cifrado, se presentan los modos de cifrado que modifican el proceso de cifrado según los comentarios anteriores por cifrados de bloques.</span><span class="sxs-lookup"><span data-stu-id="faf43-108">Because this behavior can be used to crack a cipher, cipher modes are introduced that modify the encryption process based on feedback from earlier block encryptions.</span></span> <span data-ttu-id="faf43-109">Cifrado resultante proporciona un mayor nivel de seguridad que un simple cifrado de bloques.</span><span class="sxs-lookup"><span data-stu-id="faf43-109">The resulting encryption provides a higher level of security than a simple block encryption.</span></span>  
  
 ]]></format>
    </remarks>
    <related type="Article" href="~/docs/standard/security/cryptographic-services.md"><span data-ttu-id="faf43-110">servicios criptográficos</span><span class="sxs-lookup"><span data-stu-id="faf43-110">Cryptographic Services</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="CBC">
      <MemberSignature Language="C#" Value="CBC" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CBC = int32(1)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CBC" />
      <MemberSignature Language="VB.NET" Value="CBC" />
      <MemberSignature Language="C++ CLI" Value="CBC" />
      <MemberSignature Language="F#" Value="CBC = 1" Usage="System.Security.Cryptography.CipherMode.CBC" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>1</MemberValue>
      <Docs>
        <summary><span data-ttu-id="faf43-111">El modo Cipher Block Chaining (<see langword="CBC" />) incluye información de cifrados anteriores.</span><span class="sxs-lookup"><span data-stu-id="faf43-111">The Cipher Block Chaining (<see langword="CBC" />) mode introduces feedback.</span></span> <span data-ttu-id="faf43-112">Antes de cifrarse cada bloque de texto sin formato, cada uno de ellos se combina con el texto de cifrado del bloque anterior mediante una operación OR exclusiva bit a bit.</span><span class="sxs-lookup"><span data-stu-id="faf43-112">Before each plain text block is encrypted, it is combined with the cipher text of the previous block by a bitwise exclusive OR operation.</span></span> <span data-ttu-id="faf43-113">Esto garantiza que, aunque el texto sin formato contenga muchos bloques idénticos, cada uno de ellos se cifrará en un bloque de texto de cifrado distinto.</span><span class="sxs-lookup"><span data-stu-id="faf43-113">This ensures that even if the plain text contains many identical blocks, they will each encrypt to a different cipher text block.</span></span> <span data-ttu-id="faf43-114">El vector de inicialización se combina con el primer bloque de texto sin formato mediante una operación OR exclusiva bit a bit antes de cifrar el bloque.</span><span class="sxs-lookup"><span data-stu-id="faf43-114">The initialization vector is combined with the first plain text block by a bitwise exclusive OR operation before the block is encrypted.</span></span> <span data-ttu-id="faf43-115">Si se trastoca un único bit del bloque de texto de cifrado, se trastoca también el bloque de texto sin formato correspondiente.</span><span class="sxs-lookup"><span data-stu-id="faf43-115">If a single bit of the cipher text block is mangled, the corresponding plain text block will also be mangled.</span></span> <span data-ttu-id="faf43-116">Asimismo, se trastocará el bit del bloque siguiente que se encuentra en la misma posición que el bit trastocado original.</span><span class="sxs-lookup"><span data-stu-id="faf43-116">In addition, a bit in the subsequent block, in the same position as the original mangled bit, will be mangled.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="CFB">
      <MemberSignature Language="C#" Value="CFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CFB = int32(4)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CFB" />
      <MemberSignature Language="VB.NET" Value="CFB" />
      <MemberSignature Language="C++ CLI" Value="CFB" />
      <MemberSignature Language="F#" Value="CFB = 4" Usage="System.Security.Cryptography.CipherMode.CFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>4</MemberValue>
      <Docs>
        <summary><span data-ttu-id="faf43-117">El modo Cipher Feedback (<see langword="CFB" />) procesa pequeños incrementos del texto sin formato como texto de cifrado, en lugar de procesar un bloque completo cada vez.</span><span class="sxs-lookup"><span data-stu-id="faf43-117">The Cipher Feedback (<see langword="CFB" />) mode processes small increments of plain text into cipher text, instead of processing an entire block at a time.</span></span> <span data-ttu-id="faf43-118">Este modo utiliza un registro de desplazamiento con una longitud de un bloque y dividido en secciones.</span><span class="sxs-lookup"><span data-stu-id="faf43-118">This mode uses a shift register that is one block in length and is divided into sections.</span></span> <span data-ttu-id="faf43-119">Por ejemplo, si el tamaño del bloque es de 8 bytes y se procesa un byte cada vez, el registro de desplazamiento se divide en ocho secciones.</span><span class="sxs-lookup"><span data-stu-id="faf43-119">For example, if the block size is 8 bytes, with one byte processed at a time, the shift register is divided into eight sections.</span></span> <span data-ttu-id="faf43-120">Si se trastoca un bit del texto de cifrado, se trastoca un bit del texto sin formato y el registro de desplazamiento queda dañado.</span><span class="sxs-lookup"><span data-stu-id="faf43-120">If a bit in the cipher text is mangled, one plain text bit is mangled and the shift register is corrupted.</span></span> <span data-ttu-id="faf43-121">Esto da lugar a que los siguientes incrementos del texto sin formato se trastoquen hasta que el bit erróneo se elimine del registro de desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="faf43-121">This results in the next several plain text increments being mangled until the bad bit is shifted out of the shift register.</span></span> <span data-ttu-id="faf43-122">El tamaño del comentario predeterminado puede variar en función del algoritmo, pero suele ser de 8 bits o el número de bits del tamaño de bloque.</span><span class="sxs-lookup"><span data-stu-id="faf43-122">The default feedback size can vary by algorithm, but is typically either 8 bits or the number of bits of the block size.</span></span> <span data-ttu-id="faf43-123">Puede modificar el número de bits del comentario mediante la propiedad <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" />.</span><span class="sxs-lookup"><span data-stu-id="faf43-123">You can alter the number of feedback bits by using the <see cref="P:System.Security.Cryptography.SymmetricAlgorithm.FeedbackSize" /> property.</span></span> <span data-ttu-id="faf43-124">Los algoritmos que admiten CFB usan esta propiedad para establecer los comentarios.</span><span class="sxs-lookup"><span data-stu-id="faf43-124">Algorithms that support CFB use this property to set the feedback.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="CTS">
      <MemberSignature Language="C#" Value="CTS" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode CTS = int32(5)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.CTS" />
      <MemberSignature Language="VB.NET" Value="CTS" />
      <MemberSignature Language="C++ CLI" Value="CTS" />
      <MemberSignature Language="F#" Value="CTS = 5" Usage="System.Security.Cryptography.CipherMode.CTS" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>5</MemberValue>
      <Docs>
        <summary><span data-ttu-id="faf43-125">El modo Cipher Text Stealing (<see langword="CTS" />) controla el texto sin formato de cualquier tamaño y produce texto de cifrado cuya longitud coincide con la del texto sin formato.</span><span class="sxs-lookup"><span data-stu-id="faf43-125">The Cipher Text Stealing (<see langword="CTS" />) mode handles any length of plain text and produces cipher text whose length matches the plain text length.</span></span> <span data-ttu-id="faf43-126">Este modo se comporta igual que el modo <see langword="CBC" /> para todos los bloques excepto para los dos últimos del texto sin formato.</span><span class="sxs-lookup"><span data-stu-id="faf43-126">This mode behaves like the <see langword="CBC" /> mode for all but the last two blocks of the plain text.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="ECB">
      <MemberSignature Language="C#" Value="ECB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode ECB = int32(2)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.ECB" />
      <MemberSignature Language="VB.NET" Value="ECB" />
      <MemberSignature Language="C++ CLI" Value="ECB" />
      <MemberSignature Language="F#" Value="ECB = 2" Usage="System.Security.Cryptography.CipherMode.ECB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>2</MemberValue>
      <Docs>
        <summary><span data-ttu-id="faf43-127">El modo Electronic Codebook (<see langword="ECB" />) cifra cada bloque por separado.</span><span class="sxs-lookup"><span data-stu-id="faf43-127">The Electronic Codebook (<see langword="ECB" />) mode encrypts each block individually.</span></span> <span data-ttu-id="faf43-128">Los bloques de texto sin formato que sean idénticos y estén en el mismo mensaje, o en uno diferente cifrado con la misma clave, se convertirán en bloques de texto de cifrado idénticos.</span><span class="sxs-lookup"><span data-stu-id="faf43-128">Any blocks of plain text that are identical and in the same message, or that are in a different message encrypted with the same key, will be transformed into identical cipher text blocks.</span></span> <span data-ttu-id="faf43-129">**Importante**: No se recomienda este modo porque representa un riesgo para la seguridad.</span><span class="sxs-lookup"><span data-stu-id="faf43-129">**Important**:  This mode is not recommended because it opens the door for multiple security exploits.</span></span> <span data-ttu-id="faf43-130">Si el texto sin formato que se va a cifrar contiene muchas repeticiones, es posible que el texto de cifrado se divida en un bloque cada vez.</span><span class="sxs-lookup"><span data-stu-id="faf43-130">If the plain text to be encrypted contains substantial repetition, it is feasible for the cipher text to be broken one block at a time.</span></span> <span data-ttu-id="faf43-131">También es posible usar el análisis de bloques para determinar la clave de cifrado.</span><span class="sxs-lookup"><span data-stu-id="faf43-131">It is also possible to use block analysis to determine the encryption key.</span></span> <span data-ttu-id="faf43-132">Un adversario activo también puede sustituir e intercambiar bloques individuales sin ser detectado, lo que permite guardar los bloques e insertarlos en la secuencia en otros puntos sin que se advierta.</span><span class="sxs-lookup"><span data-stu-id="faf43-132">Also, an active adversary can substitute and exchange individual blocks without detection, which allows blocks to be saved and inserted into the stream at other points without detection.</span></span></summary>
      </Docs>
    </Member>
    <Member MemberName="OFB">
      <MemberSignature Language="C#" Value="OFB" />
      <MemberSignature Language="ILAsm" Value=".field public static literal valuetype System.Security.Cryptography.CipherMode OFB = int32(3)" />
      <MemberSignature Language="DocId" Value="F:System.Security.Cryptography.CipherMode.OFB" />
      <MemberSignature Language="VB.NET" Value="OFB" />
      <MemberSignature Language="C++ CLI" Value="OFB" />
      <MemberSignature Language="F#" Value="OFB = 3" Usage="System.Security.Cryptography.CipherMode.OFB" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Primitives</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.CipherMode</ReturnType>
      </ReturnValue>
      <MemberValue>3</MemberValue>
      <Docs>
        <summary><span data-ttu-id="faf43-133">El modo Output Feedback (<see langword="OFB" />) procesa pequeños incrementos del texto sin formato como texto de cifrado, en lugar de procesar un bloque completo cada vez.</span><span class="sxs-lookup"><span data-stu-id="faf43-133">The Output Feedback (<see langword="OFB" />) mode processes small increments of plain text into cipher text instead of processing an entire block at a time.</span></span> <span data-ttu-id="faf43-134">Este modo es similar a <see langword="CFB" />; la única diferencia entre los dos modos es la forma en que se rellena el registro de desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="faf43-134">This mode is similar to <see langword="CFB" />; the only difference between the two modes is the way that the shift register is filled.</span></span> <span data-ttu-id="faf43-135">Si se trastoca un bit del texto de cifrado, se trastoca también el bit del texto sin formato correspondiente.</span><span class="sxs-lookup"><span data-stu-id="faf43-135">If a bit in the cipher text is mangled, the corresponding bit of plain text will be mangled.</span></span> <span data-ttu-id="faf43-136">Sin embargo, si hay bits adicionales o falta alguno en el texto de cifrado, el texto sin formato sólo se trastoca a partir de ese punto.</span><span class="sxs-lookup"><span data-stu-id="faf43-136">However, if there are extra or missing bits from the cipher text, the plain text will be mangled from that point on.</span></span></summary>
      </Docs>
    </Member>
  </Members>
</Type>