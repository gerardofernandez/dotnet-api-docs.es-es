<Type Name="ECDiffieHellman" FullName="System.Security.Cryptography.ECDiffieHellman">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="1983db03975384ac2bf4358eb5bc70a9cf1b248a" />
    <Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/29/2018" />
    <Meta Name="ms.locfileid" Value="52597126" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ECDiffieHellman : System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ECDiffieHellman extends System.Security.Cryptography.AsymmetricAlgorithm" />
  <TypeSignature Language="DocId" Value="T:System.Security.Cryptography.ECDiffieHellman" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ECDiffieHellman&#xA;Inherits AsymmetricAlgorithm" />
  <TypeSignature Language="C++ CLI" Value="public ref class ECDiffieHellman abstract : System::Security::Cryptography::AsymmetricAlgorithm" />
  <TypeSignature Language="F#" Value="type ECDiffieHellman = class&#xA;    inherit AsymmetricAlgorithm" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
    <AssemblyVersion>4.3.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Cryptography.AsymmetricAlgorithm</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="61b8e-101">Proporciona una clase base abstracta de la que pueden derivar las implementaciones de algoritmos Diffie-Hellman de curva elíptica (ECDH).</span>
      <span class="sxs-lookup">
        <span data-stu-id="61b8e-101">Provides an abstract base class that Elliptic Curve Diffie-Hellman (ECDH) algorithm implementations can derive from.</span>
      </span>
      <span data-ttu-id="61b8e-102">Esta clase proporciona el conjunto básico de operaciones que todas las implementaciones ECDH deben admitir.</span>
      <span class="sxs-lookup">
        <span data-stu-id="61b8e-102">This class provides the basic set of operations that all ECDH implementations must support.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-103">Esta clase actúa como la clase base abstracta para las implementaciones ECDH.</span><span class="sxs-lookup"><span data-stu-id="61b8e-103">This class serves as the abstract base class for ECDH implementations.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ECDiffieHellman ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ECDiffieHellman();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-104">Inicializa una nueva instancia de la clase <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-104">Initializes a new instance of the <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-105">Este constructor se llama a las clases que derivan de la <xref:System.Security.Cryptography.ECDiffieHellman> clase.</span><span class="sxs-lookup"><span data-stu-id="61b8e-105">This constructor is called by classes that derive from the <xref:System.Security.Cryptography.ECDiffieHellman> class.</span></span> <span data-ttu-id="61b8e-106">El <xref:System.Security.Cryptography.ECDiffieHellmanCng> clase es la única implementación actualmente se incluye en el [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span><span class="sxs-lookup"><span data-stu-id="61b8e-106">The <xref:System.Security.Cryptography.ECDiffieHellmanCng> class is the only implementation that is currently included in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].</span></span> <span data-ttu-id="61b8e-107">Para obtener información sobre cómo crear una nueva implementación del algoritmo Diffie-Hellman de curva elíptica (ECDH), consulte el <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61b8e-107">For information about how to create a new implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm, see the <xref:System.Security.Cryptography.ECDiffieHellman.Create%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Create">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-108">Crea una nueva instancia de una implementación del algoritmo Diffie-Hellman de curva elíptica (ECDH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-108">Creates a new instance of an implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create () As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create();" />
      <MemberSignature Language="F#" Value="static member Create : unit -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-109">Crea una nueva instancia de la implementación predeterminada del algoritmo Diffie-Hellman de curva elíptica (ECDH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-109">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-110">Nueva instancia de la implementación predeterminada de esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-110">A new instance of the default implementation of this class.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (curve As ECCurve) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECCurve -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">
          <span data-ttu-id="61b8e-111">La curva que se usará para generar un nuevo par de claves pública-privada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-111">The curve to use to generate a new public/private key-pair.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-112">Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con un nuevo par de claves pública-privada que se genera sobre la curva especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-112">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with a new public/private key-pair generated over the specified curve.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-113">Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-113">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-114">debe validar la curva (es decir, debe devolver true cuando se pasan a la <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="61b8e-114">curve must validate (that is, it must return true when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="61b8e-115">Las curvas de característica 2 no se admiten en Windows.</span><span class="sxs-lookup"><span data-stu-id="61b8e-115">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="61b8e-116">
            <paramref name="curve" /> no se valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-116">
              <paramref name="curve" /> does not validate.</span>
          </span>
        </exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (parameters As ECParameters) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="static member Create : System.Security.Cryptography.ECParameters -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <span data-ttu-id="61b8e-117">Parámetros del algoritmo de criptografía de curva elíptica (ECC).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-117">The parameters  for the elliptic curve cryptography (ECC) algorithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-118">Crea una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH) con la clave que describe el objeto <see cref="T:System.Security.Cryptography.ECParameters" /> especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-118">Creates a new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm with the key described by the specified  <see cref="T:System.Security.Cryptography.ECParameters" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-119">Una nueva instancia de la implementación predeterminada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-119">A new instance of the default implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-120">`parameters` debe validar (es decir, debe devolver `true`) cuando se pasan a la <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="61b8e-120">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="61b8e-121">No se admiten parámetros de curva implícita.</span><span class="sxs-lookup"><span data-stu-id="61b8e-121">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="61b8e-122">Las curvas de característica 2 no se admiten en Windows.</span><span class="sxs-lookup"><span data-stu-id="61b8e-122">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="61b8e-123">
            <paramref name="parameters" /> no se valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-123">
              <paramref name="parameters" /> does not validate.</span>
          </span>
        </exception>
        <altmember cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Security.Cryptography.ECDiffieHellman Create (string algorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Security.Cryptography.ECDiffieHellman Create(string algorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.Create(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (algorithm As String) As ECDiffieHellman" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Security::Cryptography::ECDiffieHellman ^ Create(System::String ^ algorithm);" />
      <MemberSignature Language="F#" Value="static member Create : string -&gt; System.Security.Cryptography.ECDiffieHellman" Usage="System.Security.Cryptography.ECDiffieHellman.Create algorithm" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellman</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="algorithm" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="algorithm">
          <span data-ttu-id="61b8e-124">Nombre de una implementación del algoritmo ECDH.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-124">The name of an implementation of the ECDH algorithm.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-125">Crea una nueva instancia de la implementación especificada del algoritmo de Diffie-Hellman de curva elíptica (ECDH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-125">Creates a new instance of the specified implementation of the Elliptic Curve Diffie-Hellman (ECDH) algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-126">Nueva instancia de la implementación especificada de esta clase.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-126">A new instance of the specified implementation of this class.</span>
          </span>
          <span data-ttu-id="61b8e-127">Si el nombre del algoritmo especificado no se asigna a una implementación ECDH, este método devuelve <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-127">If the specified algorithm name does not map to an ECDH implementation, this method returns <see langword="null" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-128">Si desarrolla su propia implementación de un <xref:System.Security.Cryptography.ECDiffieHellman> objeto, puede usar el <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> sobrecarga del método para crear un personalizado `algorithm` cadena que especifica la implementación.</span><span class="sxs-lookup"><span data-stu-id="61b8e-128">If you develop your own implementation of an <xref:System.Security.Cryptography.ECDiffieHellman> object, you can use the <xref:System.Security.Cryptography.ECDiffieHellman.Create%28System.String%29> method overload to create a custom `algorithm` string that specifies your implementation.</span></span>  
  
 <span data-ttu-id="61b8e-129">El `algorithm` parámetro especifica el nombre de una implementación del algoritmo ECDH.</span><span class="sxs-lookup"><span data-stu-id="61b8e-129">The `algorithm` parameter specifies the name of an implementation of the ECDH algorithm.</span></span> <span data-ttu-id="61b8e-130">Las cadenas siguientes hacen todas referencia a la misma implementación, que es la única implementación actualmente admitida en [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span><span class="sxs-lookup"><span data-stu-id="61b8e-130">The following strings all refer to the same implementation, which is the only implementation currently supported in the [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]:</span></span>  
  
-   <span data-ttu-id="61b8e-131">"ECDH"</span><span class="sxs-lookup"><span data-stu-id="61b8e-131">"ECDH"</span></span>  
  
-   <span data-ttu-id="61b8e-132">"ECDiffieHellman"</span><span class="sxs-lookup"><span data-stu-id="61b8e-132">"ECDiffieHellman"</span></span>  
  
-   <span data-ttu-id="61b8e-133">"ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="61b8e-133">"ECDiffieHellmanCng"</span></span>  
  
-   <span data-ttu-id="61b8e-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span><span class="sxs-lookup"><span data-stu-id="61b8e-134">"System.Security.Cryptography.ECDiffieHellmanCng"</span></span>  
  
 <span data-ttu-id="61b8e-135">También puede proporcionar el nombre de una implementación ECDH personalizada para el `algorithm` parámetro.</span><span class="sxs-lookup"><span data-stu-id="61b8e-135">You can also provide the name of a custom ECDH implementation for the `algorithm` parameter.</span></span> <span data-ttu-id="61b8e-136">Si lo hace, el <xref:System.Security.Cryptography.CryptoConfig> objeto utiliza para determinar si se puede crear un objeto ECDH.</span><span class="sxs-lookup"><span data-stu-id="61b8e-136">If you do that, the <xref:System.Security.Cryptography.CryptoConfig> object will use it to determine whether an ECDH object can be created.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="61b8e-137">El parámetro <paramref name="algorithm" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-137">The <paramref name="algorithm" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHash">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-138">Deriva bytes que se pueden usar como una clave mediante una función hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-138">Derives bytes that can be used as a key using a hash function .</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName)" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-139">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-139">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="61b8e-140">Algoritmo hash que se va a usar para derivar el material de clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-140">The hash algorithm  to use to derive the key material.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-141">Deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte y el nombre del algoritmo hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-141">Derives bytes that can be used as a key using a hash function, given another party's public key and hash algorithm's name.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-142">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-142">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-143">Esta sobrecarga llama a la <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> método pasando `null` como el prepend y anexar valores.</span><span class="sxs-lookup"><span data-stu-id="61b8e-143">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHash">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHash (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHash(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHash(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHash (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHash(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHash : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHash (otherPartyPublicKey, hashAlgorithm, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-144">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-144">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="61b8e-145">Algoritmo hash que se va a usar para derivar el material de clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-145">The hash algorithm  to use to derive the key material.</span>
          </span>
        </param>
        <param name="secretPrepend">
          <span data-ttu-id="61b8e-146">Valor para anteponer al secreto derivado antes de la operación hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-146">A value to prepend to the derived secret before hashing.</span>
          </span>
        </param>
        <param name="secretAppend">
          <span data-ttu-id="61b8e-147">Valor para anexar al secreto derivado antes de la operación hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-147">A value to append to the derived secret before hashing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-148">Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante una función hash, dada la clave pública de otra parte, el nombre del algoritmo hash, un valor Prepend y un valor Append.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-148">When implemented in a derived class, derives bytes that can be used as a key using a hash function, given another party's public key, hash algorithm's name, a prepend value and an append value.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-149">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-149">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-150">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-150">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DeriveKeyFromHmac">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-151">Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-151">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey);" />
      <MemberSignature Language="F#" Value="member this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-152">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-152">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="61b8e-153">Algoritmo hash que se va a usar para derivar el material de clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-153">The hash algorithm to use to derive the key material.</span>
          </span>
        </param>
        <param name="hmacKey">
          <span data-ttu-id="61b8e-154">Clave para HMAC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-154">The key for the HMAC.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-155">Deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-155">Derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-156">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-156">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-157">Esta sobrecarga llama a la <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> método pasando `null` como el prepend y anexar valores.</span><span class="sxs-lookup"><span data-stu-id="61b8e-157">This overload calls the <xref:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac%2A> method passing `null` as the prepend and append values.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyFromHmac">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyFromHmac (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, System.Security.Cryptography.HashAlgorithmName hashAlgorithm, byte[] hmacKey, byte[] secretPrepend, byte[] secretAppend);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyFromHmac(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, valuetype System.Security.Cryptography.HashAlgorithmName hashAlgorithm, unsigned int8[] hmacKey, unsigned int8[] secretPrepend, unsigned int8[] secretAppend) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyFromHmac(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Security.Cryptography.HashAlgorithmName,System.Byte[],System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyFromHmac (otherPartyPublicKey As ECDiffieHellmanPublicKey, hashAlgorithm As HashAlgorithmName, hmacKey As Byte(), secretPrepend As Byte(), secretAppend As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyFromHmac(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, System::Security::Cryptography::HashAlgorithmName hashAlgorithm, cli::array &lt;System::Byte&gt; ^ hmacKey, cli::array &lt;System::Byte&gt; ^ secretPrepend, cli::array &lt;System::Byte&gt; ^ secretAppend);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyFromHmac : System.Security.Cryptography.ECDiffieHellmanPublicKey * System.Security.Cryptography.HashAlgorithmName * byte[] * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyFromHmac (otherPartyPublicKey, hashAlgorithm, hmacKey, secretPrepend, secretAppend)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="hashAlgorithm" Type="System.Security.Cryptography.HashAlgorithmName" />
        <Parameter Name="hmacKey" Type="System.Byte[]" />
        <Parameter Name="secretPrepend" Type="System.Byte[]" />
        <Parameter Name="secretAppend" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-158">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-158">The other party's public key.</span>
          </span>
        </param>
        <param name="hashAlgorithm">
          <span data-ttu-id="61b8e-159">Algoritmo hash que se va a usar para derivar el material de clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-159">The hash algorithm to use to derive the key material.</span>
          </span>
        </param>
        <param name="hmacKey">
          <span data-ttu-id="61b8e-160">Clave para HMAC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-160">The key for the HMAC.</span>
          </span>
        </param>
        <param name="secretPrepend">
          <span data-ttu-id="61b8e-161">Valor para anteponer al secreto derivado antes de la operación hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-161">A value to prepend to the derived secret before hashing.</span>
          </span>
        </param>
        <param name="secretAppend">
          <span data-ttu-id="61b8e-162">Valor para anexar al secreto derivado antes de la operación hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-162">A value to append to the derived secret before hashing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-163">Cuando se implementa en un clase derivada, deriva bytes que se pueden usar como una clave mediante un código de autenticación de mensajes basado en hash (HMAC).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-163">When implemented in a derived class, derives bytes that can be used as a key using a Hash-based Message Authentication Code (HMAC).</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-164">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-164">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-165">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-165">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyMaterial">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyMaterial (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyMaterial(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyMaterial(System.Security.Cryptography.ECDiffieHellmanPublicKey)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyMaterial (otherPartyPublicKey As ECDiffieHellmanPublicKey) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyMaterial(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]&#xA;override this.DeriveKeyMaterial : System.Security.Cryptography.ECDiffieHellmanPublicKey -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyMaterial otherPartyPublicKey" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-166">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-166">The other party's public key.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-167">Deriva bytes que se pueden utilizar como clave, si hay una clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-167">Derives bytes that can be used as a key, given another party's public key.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-168">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-168">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-169">Para obtener más información acerca de las claves públicas, consulte el <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> clase.</span><span class="sxs-lookup"><span data-stu-id="61b8e-169">For more information about public keys, see the <xref:System.Security.Cryptography.ECDiffieHellmanPublicKey> class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DeriveKeyTls">
      <MemberSignature Language="C#" Value="public virtual byte[] DeriveKeyTls (System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, byte[] prfLabel, byte[] prfSeed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance unsigned int8[] DeriveKeyTls(class System.Security.Cryptography.ECDiffieHellmanPublicKey otherPartyPublicKey, unsigned int8[] prfLabel, unsigned int8[] prfSeed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.DeriveKeyTls(System.Security.Cryptography.ECDiffieHellmanPublicKey,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function DeriveKeyTls (otherPartyPublicKey As ECDiffieHellmanPublicKey, prfLabel As Byte(), prfSeed As Byte()) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Byte&gt; ^ DeriveKeyTls(System::Security::Cryptography::ECDiffieHellmanPublicKey ^ otherPartyPublicKey, cli::array &lt;System::Byte&gt; ^ prfLabel, cli::array &lt;System::Byte&gt; ^ prfSeed);" />
      <MemberSignature Language="F#" Value="abstract member DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]&#xA;override this.DeriveKeyTls : System.Security.Cryptography.ECDiffieHellmanPublicKey * byte[] * byte[] -&gt; byte[]" Usage="eCDiffieHellman.DeriveKeyTls (otherPartyPublicKey, prfLabel, prfSeed)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="otherPartyPublicKey" Type="System.Security.Cryptography.ECDiffieHellmanPublicKey" />
        <Parameter Name="prfLabel" Type="System.Byte[]" />
        <Parameter Name="prfSeed" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="otherPartyPublicKey">
          <span data-ttu-id="61b8e-170">Clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-170">The other party's public key.</span>
          </span>
        </param>
        <param name="prfLabel">
          <span data-ttu-id="61b8e-171">Etiqueta PRF con codificación ASCII.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-171">The ASCII-encoded PRF label.</span>
          </span>
        </param>
        <param name="prfSeed">
          <span data-ttu-id="61b8e-172">Valor de inicialización de PRF de 64 bytes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-172">The 64-byte PRF seed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-173">Cuando se implementa en una clase derivada, deriva bytes que se pueden usar como una clave mediante un algoritmo de derivación de la función pesudoaleatoria (PRF) de seguridad de capa de transporte (TLS).</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-173">When implemented in a derived class, derives bytes that can be used as a key using a Transport Layer Security (TLS) Pseudo-Random Function (PRF) derivation algorithm.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-174">Material de clave del intercambio de claves con la clave pública de la otra parte.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-174">The key material from the key exchange with the other party's public key.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-175">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-175">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExportExplicitParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportExplicitParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportExplicitParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportExplicitParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportExplicitParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportExplicitParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportExplicitParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportExplicitParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <span data-ttu-id="61b8e-176">Es <see langword="true" /> si se van a incluir parámetros privados; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-176">
              <see langword="true" /> to include private parameters; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-177">Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada con el formulario de curva explícito desde una clave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabajo a una estructura <see cref="T:System.Security.Cryptography.ECParameters" /> de modo que pueda pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-177">When overridden in a derived class, exports either the public or the public and private key information using the explicit curve form from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-178">Un objeto que representa el punto de la curva para esta clave, con el formato de curva explícito.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-178">An object that represents the point on the curve for this key, using the explicit curve format.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-179">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-179">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ExportParameters">
      <MemberSignature Language="C#" Value="public virtual System.Security.Cryptography.ECParameters ExportParameters (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Security.Cryptography.ECParameters ExportParameters(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ExportParameters(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function ExportParameters (includePrivateParameters As Boolean) As ECParameters" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::Cryptography::ECParameters ExportParameters(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="abstract member ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters&#xA;override this.ExportParameters : bool -&gt; System.Security.Cryptography.ECParameters" Usage="eCDiffieHellman.ExportParameters includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECParameters</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">
          <span data-ttu-id="61b8e-180">
            <see langword="true" /> para incluir parámetros privados; en caso contrario, <see langword="false" /> para incluir solo parámetros públicos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-180">
              <see langword="true" /> to include private parameters; otherwise, <see langword="false" /> to include public parameters only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-181">Si se reemplaza en una clase derivada, exporta la información de clave pública o la información de clave pública y privada desde una clave <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> de trabajo a una estructura <see cref="T:System.Security.Cryptography.ECParameters" /> de modo que pueda pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-181">When overridden in a derived class, exports either the public or the public and private key information from a working <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> key to an <see cref="T:System.Security.Cryptography.ECParameters" /> structure so that it can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="61b8e-182">Un objeto que representa el punto de la curva para esta clave.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-182">An object that represents the point on the curve for this key.</span>
          </span>
          <span data-ttu-id="61b8e-183">Puede pasarse al método <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-183">It can be passed to the <see cref="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" /> method.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-184">Si la curva tiene un nombre, el <xref:System.Security.Cryptography.ECParameters.Curve> propiedad contiene los parámetros de curva con nombre; en caso contrario, contiene parámetros explícitos.</span><span class="sxs-lookup"><span data-stu-id="61b8e-184">If the curve has a name, the <xref:System.Security.Cryptography.ECParameters.Curve> property contains named curve parameters; otherwise, it will contain explicit parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-185">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-185">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="FromXmlString">
      <MemberSignature Language="C#" Value="public override void FromXmlString (string xmlString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void FromXmlString(string xmlString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.FromXmlString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub FromXmlString (xmlString As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void FromXmlString(System::String ^ xmlString);" />
      <MemberSignature Language="F#" Value="override this.FromXmlString : string -&gt; unit" Usage="eCDiffieHellman.FromXmlString xmlString" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="xmlString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="xmlString">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GenerateKey">
      <MemberSignature Language="C#" Value="public virtual void GenerateKey (System.Security.Cryptography.ECCurve curve);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GenerateKey(valuetype System.Security.Cryptography.ECCurve curve) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.GenerateKey(System.Security.Cryptography.ECCurve)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GenerateKey (curve As ECCurve)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GenerateKey(System::Security::Cryptography::ECCurve curve);" />
      <MemberSignature Language="F#" Value="abstract member GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit&#xA;override this.GenerateKey : System.Security.Cryptography.ECCurve -&gt; unit" Usage="eCDiffieHellman.GenerateKey curve" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="curve" Type="System.Security.Cryptography.ECCurve" />
      </Parameters>
      <Docs>
        <param name="curve">
          <span data-ttu-id="61b8e-186">La curva usada para generar un par de claves pública-privada efímeras.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-186">The curve used to generate an ephemeral public/private key pair.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-187">Si se reemplaza en una clase derivada, genera un nuevo par de claves pública-privada efímeras para la curva especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-187">When overridden in a derived class, generates a new ephemeral public/private key pair for the specified curve.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-188">`curve` debe validar (es decir, debe devolver `true`) cuando se pasan a la <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> método) y no debe ser implícita.</span><span class="sxs-lookup"><span data-stu-id="61b8e-188">`curve` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECCurve.Validate%2A?displayProperty=nameWithType> method) and must not be implicit.</span></span>  
  
 <span data-ttu-id="61b8e-189">Las curvas de característica 2 no se admiten en Windows.</span><span class="sxs-lookup"><span data-stu-id="61b8e-189">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="61b8e-190">
            <paramref name="curve" /> no se valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-190">
              <paramref name="curve" /> does not validate.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-191">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-191">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ImportParameters">
      <MemberSignature Language="C#" Value="public virtual void ImportParameters (System.Security.Cryptography.ECParameters parameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ImportParameters(valuetype System.Security.Cryptography.ECParameters parameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ImportParameters(System.Security.Cryptography.ECParameters)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub ImportParameters (parameters As ECParameters)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ImportParameters(System::Security::Cryptography::ECParameters parameters);" />
      <MemberSignature Language="F#" Value="abstract member ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit&#xA;override this.ImportParameters : System.Security.Cryptography.ECParameters -&gt; unit" Usage="eCDiffieHellman.ImportParameters parameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameters" Type="System.Security.Cryptography.ECParameters" />
      </Parameters>
      <Docs>
        <param name="parameters">
          <span data-ttu-id="61b8e-192">Los parámetros de la curva que se importarán.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-192">The curve's parameters to import.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="61b8e-193">Si se reemplaza en una clase derivada, importa los parámetros especificados para un objeto <see cref="T:System.Security.Cryptography.ECCurve" /> como clave efímera en el objeto <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-193">When overridden in a derived class, imports the specified parameters for an <see cref="T:System.Security.Cryptography.ECCurve" /> as an ephemeral key into the current <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-194">`parameters` debe validar (es decir, debe devolver `true`) cuando se pasan a la <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="61b8e-194">`parameters` must validate (that is, it must return `true`) when passed to the <xref:System.Security.Cryptography.ECParameters.Validate%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="61b8e-195">No se admiten parámetros de curva implícita.</span><span class="sxs-lookup"><span data-stu-id="61b8e-195">Parameters over implicit curves are not supported.</span></span>  
  
 <span data-ttu-id="61b8e-196">Las curvas de característica 2 no se admiten en Windows.</span><span class="sxs-lookup"><span data-stu-id="61b8e-196">Characteristic-2 curves are not supported on Windows.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.Cryptography.CryptographicException">
          <span data-ttu-id="61b8e-197">
            <paramref name="parameters" /> no se valida.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-197">
              <paramref name="parameters" /> does not validate.</span>
          </span>
        </exception>
        <exception cref="T:System.NotImplementedException">
          <span data-ttu-id="61b8e-198">Una clase derivada debe reemplazar este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-198">A derived class must override this method.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="KeyExchangeAlgorithm">
      <MemberSignature Language="C#" Value="public override string KeyExchangeAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string KeyExchangeAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property KeyExchangeAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ KeyExchangeAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.KeyExchangeAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.KeyExchangeAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-199">Obtiene el nombre del algoritmo de intercambio de claves.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-199">Gets the name of the key exchange algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="61b8e-200">Nombre del algoritmo de intercambio de claves.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-200">The name of the key exchange algorithm.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-201">La implementación de predeterminada (no reemplazar) de esta propiedad devuelve la cadena "ECDiffieHellman".</span><span class="sxs-lookup"><span data-stu-id="61b8e-201">The default (non-overridden) implementation of this property returns the string "ECDiffieHellman".</span></span>  
  
 <span data-ttu-id="61b8e-202">Esta propiedad se hereda de la <xref:System.Security.Cryptography.AsymmetricAlgorithm> clase base.</span><span class="sxs-lookup"><span data-stu-id="61b8e-202">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PublicKey">
      <MemberSignature Language="C#" Value="public abstract System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Cryptography.ECDiffieHellmanPublicKey PublicKey" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property PublicKey As ECDiffieHellmanPublicKey" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Security::Cryptography::ECDiffieHellmanPublicKey ^ PublicKey { System::Security::Cryptography::ECDiffieHellmanPublicKey ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PublicKey : System.Security.Cryptography.ECDiffieHellmanPublicKey" Usage="System.Security.Cryptography.ECDiffieHellman.PublicKey" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Cryptography.ECDiffieHellmanPublicKey</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-203">Obtiene la clave pública que utiliza la instancia Diffie-Hellman de curva elíptica (ECDH) actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-203">Gets the public key that is being used by the current Elliptic Curve Diffie-Hellman (ECDH) instance.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="61b8e-204">Parte pública del par de claves ECDH utilizada por esta instancia <see cref="T:System.Security.Cryptography.ECDiffieHellman" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-204">The public part of the ECDH key pair that is being used by this <see cref="T:System.Security.Cryptography.ECDiffieHellman" /> instance.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SignatureAlgorithm">
      <MemberSignature Language="C#" Value="public override string SignatureAlgorithm { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string SignatureAlgorithm" />
      <MemberSignature Language="DocId" Value="P:System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property SignatureAlgorithm As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ SignatureAlgorithm { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SignatureAlgorithm : string" Usage="System.Security.Cryptography.ECDiffieHellman.SignatureAlgorithm" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="61b8e-205">Obtiene el nombre del algoritmo de firma.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-205">Gets the name of the signature algorithm.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="61b8e-206">Siempre es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="61b8e-206">Always <see langword="null" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61b8e-207">Esta propiedad se hereda de la <xref:System.Security.Cryptography.AsymmetricAlgorithm> clase base.</span><span class="sxs-lookup"><span data-stu-id="61b8e-207">This property is inherited from the <xref:System.Security.Cryptography.AsymmetricAlgorithm> base class.</span></span>  
  
 <span data-ttu-id="61b8e-208">El algoritmo de Diffie-Hellman de curva elíptica (ECDH) se utiliza para la derivación de claves, la generación de firmas digitales no.</span><span class="sxs-lookup"><span data-stu-id="61b8e-208">The Elliptic Curve Diffie-Hellman (ECDH) algorithm is used for key derivation, not digital signature generation.</span></span> <span data-ttu-id="61b8e-209">Por lo tanto, esta propiedad devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="61b8e-209">Therefore, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXmlString">
      <MemberSignature Language="C#" Value="public override string ToXmlString (bool includePrivateParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToXmlString(bool includePrivateParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Cryptography.ECDiffieHellman.ToXmlString(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToXmlString (includePrivateParameters As Boolean) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToXmlString(bool includePrivateParameters);" />
      <MemberSignature Language="F#" Value="override this.ToXmlString : bool -&gt; string" Usage="eCDiffieHellman.ToXmlString includePrivateParameters" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Security.Cryptography.Algorithms</AssemblyName>
        <AssemblyVersion>4.3.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="includePrivateParameters" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="includePrivateParameters">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>