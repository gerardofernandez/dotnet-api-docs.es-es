<Type Name="EntityContainer" FullName="System.Data.Metadata.Edm.EntityContainer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="434418950ed0e73b3d9e7d8b52b5910b642100ae" /><Meta Name="ms.sourcegitcommit" Value="16d2d159872fd213cae4b8f371d7ae9c8b027c89" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/17/2018" /><Meta Name="ms.locfileid" Value="51887959" /></Metadata><TypeSignature Language="C#" Value="public sealed class EntityContainer : System.Data.Metadata.Edm.GlobalItem" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit EntityContainer extends System.Data.Metadata.Edm.GlobalItem" />
  <TypeSignature Language="DocId" Value="T:System.Data.Metadata.Edm.EntityContainer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class EntityContainer&#xA;Inherits GlobalItem" />
  <TypeSignature Language="C++ CLI" Value="public ref class EntityContainer sealed : System::Data::Metadata::Edm::GlobalItem" />
  <TypeSignature Language="F#" Value="type EntityContainer = class&#xA;    inherit GlobalItem" />
  <AssemblyInfo>
    <AssemblyName>System.Data.Entity</AssemblyName>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Data.Metadata.Edm.GlobalItem</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa un contenedor de entidades en un modelo conceptual. Un <see cref="T:System.Data.Metadata.Edm.EntityContainer" /> es una agrupación lógica de conjuntos de entidades y de conjuntos de asociaciones.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En el nivel conceptual, la clase <xref:System.Data.Metadata.Edm.EntityContainer> representa un contenedor que se asignará a un objeto de base de datos en el esquema de metadatos de almacenamiento. En el nivel de almacenamiento, la clase <xref:System.Data.Metadata.Edm.EntityContainer> representa una descripción de las relaciones de tabla y/o de clave que conservan los datos para las aplicaciones basadas en el modelo. Para obtener más información acerca de los contenedores de entidades en un modelo conceptual, vea [contenedores de entidades (EDM)](https://msdn.microsoft.com/library/9afa762f-59b8-4a70-b76d-89d90760144c).  
  
   
  
## Examples  
 En el ejemplo de código siguiente se muestra cómo obtener un área de trabajo de metadatos desde la conexión que y cómo se usa después dicha área de trabajo para recuperar información acerca de los contenedores de entidades en el modelo de datos especificado. Observe que el área de trabajo de metadatos es un componente del servicio en tiempo de ejecución que proporciona compatibilidad para recuperar los metadatos.  
  
 En el ejemplo de código se usa un <xref:System.Data.Metadata.Edm.DataSpace.CSpace> y un <xref:System.Data.Metadata.Edm.DataSpace.SSpace> para especificar el modelo. <xref:System.Data.Metadata.Edm.DataSpace.CSpace> representa el nombre predeterminado del modelo conceptual. <xref:System.Data.Metadata.Edm.DataSpace.SSpace> representa el nombre predeterminado del modelo de almacenamiento.  
  
 El `GetEntityContainers` método obtiene una colección de contenedores de entidades y, a continuación, recorre en iteración la colección para obtener cada conjunto de entidades y un conjunto de asociaciones en el contenedor especificado. El ejemplo de código usa el modelo de AdventureWorks que se proporciona en el [Adventure Works Model (EDM)](https://msdn.microsoft.com/library/da87d29e-8c89-4310-bbac-5cbd062930a7) tema. Para obtener un ejemplo del archivo de configuración de aplicación, consulte [modelo de objetos de Adventure Works en las aplicaciones (EDM)](https://msdn.microsoft.com/library/84c01270-90ba-467b-ad24-df10c1ca8f45).  
  
```csharp  
using System;  
using System.Data;  
using System.Data.EntityClient;  
using System.Data.Metadata.Edm;  
using System.Collections.ObjectModel;  
  
class GetEntityContainerExample  
{  
  static void Main()  
  {  
    try  
    {  
       // Establish a connection to the underlying data provider by   
       // using the connection string specified in the config file.  
       using (EntityConnection connection =  
          new EntityConnection("Name=AdventureWorksEntities"))  
       {  
         // Open the connection.  
         connection.Open();  
  
         // Access the metadata workspace.  
         MetadataWorkspace workspace =   
            connection.GetMetadataWorkspace();  
  
         // Get the entity containers in the conceptual model.  
         GetEntityContainers(workspace, DataSpace.CSpace);  
  
         // Get the entity containers in the storage model.  
             GetEntityContainers(workspace, DataSpace.SSpace);  
       }  
    }  
    catch (MetadataException exceptionMetadata)  
    {  
      Console.WriteLine("MetadataException: {0}",   
                       exceptionMetadata.Message);  
    }  
    catch (System.Data.MappingException exceptionMapping)  
    {  
      Console.WriteLine("MappingException: {0}",  
                       exceptionMapping.Message);  
    }  
  }  
  
  public static void GetEntityContainers(  
      MetadataWorkspace workspace, DataSpace model)  
  {  
    // Get a collection of the entity containers.  
    ReadOnlyCollection<EntityContainer> containers =   
         workspace.GetItems<EntityContainer>(model);  
  
    // Iterate through the collection to get each entity container.  
    foreach (EntityContainer container in containers)  
    {  
       Console.WriteLine("EntityContainer Name: {0} ",   
                        container.Name);  
  
       // EntitySetBase is a super type for   
       // EntitySets and RelationshipSets.   
       // Iterate through the collection to get each EntitySetBase.  
       foreach (EntitySetBase baseSet in container.BaseEntitySets)  
       {  
          // Check if this instance is an EntitySet.  
          if (baseSet is EntitySet)  
          {  
             Console.WriteLine(  
                "  EntitySet Name: {0} , EntityType Name: {1} ",  
                baseSet.Name, baseSet.ElementType.FullName);  
          }  
  
         // RelationshipSet is a super type for AssociationSet.  
         // Check if this instance is an AssociationSet.  
         if (baseSet is AssociationSet)  
         {  
            Console.WriteLine(  
               "  AssociationSet Name: {0} , " +  
               "AssociationType Name: {1} ",  
                baseSet.Name, baseSet.ElementType.FullName);  
  
            // Get the AssociationSet.  
            AssociationSet associationSet =   
                  baseSet as AssociationSet;  
  
            // Iterate through the collection to get   
            // each AssociatedSetEnd.  
            foreach (AssociationSetEnd end in   
               associationSet.AssociationSetEnds)  
            {  
               Console.WriteLine(  
                  "   EntitySet Name: {0} , Name: {1} ",  
                  end.EntitySet, end.Name);  
            }  
         }  
      }  
    }  
  }  
}  
```  
  
```vb  
Imports System  
Imports System.Collections.ObjectModel  
Imports System.Data  
Imports System.Data.EntityClient  
Imports System.Data.Metadata.Edm  
  
Class GetEntityContainerExample  
  Public Shared Sub Main()  
    Try  
      ' Establish a connection to the underlying data provider by   
      ' using the connection string specified in the config file.  
      Using connection As EntityConnection = _  
        New EntityConnection("Name=AdventureWorksEntities")  
  
        ' Open the conection.  
        connection.Open()  
  
        ' Access the metadata workspace.  
        Dim workspace As MetadataWorkspace = _  
           connection.GetMetadataWorkspace  
  
        ' Get the entity containers in the conceptual model.  
        GetEntityContainers(workspace, DataSpace.CSpace)  
  
        ' Get the entity containers in the storage model.  
        GetEntityContainers(workspace, DataSpace.SSpace)  
      End Using  
    Catch exceptionMetadata As MetadataException  
       Console.WriteLine("MetadataException: {0}", _  
          exceptionMetadata.Message)  
    Catch exceptionMapping As MappingException  
       Console.WriteLine("MappingException: {0}", _  
          exceptionMapping.Message)  
     End Try  
  End Sub  
  
  Public Shared Sub GetEntityContainers( _  
    ByVal workspace As MetadataWorkspace, ByVal model As DataSpace)  
  
    ' Get a collection of the entity containers.  
    Dim containers As ReadOnlyCollection(Of EntityContainer) = _  
       workspace.GetItems(Of EntityContainer)(model)  
  
    ' Iterate through the collection to get each entity container.  
    Dim container As EntityContainer  
    For Each container In containers  
      Console.WriteLine("EntityContainer Name: {0} ", container.Name)  
  
      ' EntitySetBase is a super type for   
      ' EntitySets and RelationshipSets.   
      ' Iterate through the collection to get each EntitySetBase.  
      Dim baseSet As EntitySetBase  
      For Each baseSet In container.BaseEntitySets  
         ' Check if this instance is an EntitySet.  
         If TypeOf baseSet Is EntitySet Then  
           Console.WriteLine( _  
              "  EntitySet Name: {0} , EntityType Name: {1} ", _  
              baseSet.Name, baseSet.ElementType.FullName)  
          End If  
  
          ' RelationshipSet is a super type for AssociationSet.  
          ' Check if this instance is an AssociationSet.  
          If TypeOf baseSet Is AssociationSet Then  
            Console.WriteLine( _  
              "  AssociationSet Name: {0} , " + _  
              "AssociationType Name: {1} ", _  
              baseSet.Name, baseSet.ElementType.FullName)  
  
            ' Get the AssociationSet.  
            Dim associationSet As AssociationSet = _  
               TryCast(baseSet, AssociationSet)  
  
            ' Iterate through the collection to get   
            '  each AssociatedSetEnd.  
            Dim endMember As AssociationSetEnd  
            For Each endMember In associationSet.AssociationSetEnds  
              Console.WriteLine( _  
                 "   EntitySet Name: {0} , Name: {1} ", _  
                 endMember.EntitySet, endMember.Name)  
            Next  
          End If  
      Next  
    Next  
  End Sub  
End Class  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="BaseEntitySets">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EntitySetBase&gt; BaseEntitySets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.ReadOnlyMetadataCollection`1&lt;class System.Data.Metadata.Edm.EntitySetBase&gt; BaseEntitySets" />
      <MemberSignature Language="DocId" Value="P:System.Data.Metadata.Edm.EntityContainer.BaseEntitySets" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseEntitySets As ReadOnlyMetadataCollection(Of EntitySetBase)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::ReadOnlyMetadataCollection&lt;System::Data::Metadata::Edm::EntitySetBase ^&gt; ^ BaseEntitySets { System::Data::Metadata::Edm::ReadOnlyMetadataCollection&lt;System::Data::Metadata::Edm::EntitySetBase ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseEntitySets : System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EntitySetBase&gt;" Usage="System.Data.Metadata.Edm.EntityContainer.BaseEntitySets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EntitySetBase&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene una lista de los conjuntos de entidades y los conjuntos de asociaciones que este <see cref="T:System.Data.Metadata.Edm.EntityContainer" /> incluye.</summary>
        <value>Un objeto <see cref="T:System.Data.Metadata.Edm.ReadOnlyMetadataCollection`1" /> que contiene una lista de los conjuntos de entidades y los conjuntos de asociaciones que este <see cref="T:System.Data.Metadata.Edm.EntityContainer" /> incluye.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="BuiltInTypeKind">
      <MemberSignature Language="C#" Value="public override System.Data.Metadata.Edm.BuiltInTypeKind BuiltInTypeKind { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Data.Metadata.Edm.BuiltInTypeKind BuiltInTypeKind" />
      <MemberSignature Language="DocId" Value="P:System.Data.Metadata.Edm.EntityContainer.BuiltInTypeKind" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property BuiltInTypeKind As BuiltInTypeKind" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Data::Metadata::Edm::BuiltInTypeKind BuiltInTypeKind { System::Data::Metadata::Edm::BuiltInTypeKind get(); };" />
      <MemberSignature Language="F#" Value="member this.BuiltInTypeKind : System.Data.Metadata.Edm.BuiltInTypeKind" Usage="System.Data.Metadata.Edm.EntityContainer.BuiltInTypeKind" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.BuiltInTypeKind</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la modalidad del tipo integrado para <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</summary>
        <value>Objeto <see cref="T:System.Data.Metadata.Edm.BuiltInTypeKind" /> que representa la modalidad del tipo integrado para <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="FunctionImports">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EdmFunction&gt; FunctionImports { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Data.Metadata.Edm.ReadOnlyMetadataCollection`1&lt;class System.Data.Metadata.Edm.EdmFunction&gt; FunctionImports" />
      <MemberSignature Language="DocId" Value="P:System.Data.Metadata.Edm.EntityContainer.FunctionImports" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FunctionImports As ReadOnlyMetadataCollection(Of EdmFunction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Data::Metadata::Edm::ReadOnlyMetadataCollection&lt;System::Data::Metadata::Edm::EdmFunction ^&gt; ^ FunctionImports { System::Data::Metadata::Edm::ReadOnlyMetadataCollection&lt;System::Data::Metadata::Edm::EdmFunction ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FunctionImports : System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EdmFunction&gt;" Usage="System.Data.Metadata.Edm.EntityContainer.FunctionImports" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.ReadOnlyMetadataCollection&lt;System.Data.Metadata.Edm.EdmFunction&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Especifica una colección de elementos de <see cref="T:System.Data.Metadata.Edm.EdmFunction" />. Cada función contiene los detalles de un procedimiento almacenado que existe en la base de datos o la propiedad <c>CommandText</c> equivalente asignada a una entidad y sus propiedades.</summary>
        <value>Un objeto <see cref="T:System.Data.Metadata.Edm.ReadOnlyMetadataCollection`1" /> que contiene elementos <see cref="T:System.Data.Metadata.Edm.EdmFunction" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEntitySetByName">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.EntitySet GetEntitySetByName (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.EntitySet GetEntitySetByName(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Metadata.Edm.EntityContainer.GetEntitySetByName(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEntitySetByName (name As String, ignoreCase As Boolean) As EntitySet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::EntitySet ^ GetEntitySetByName(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.GetEntitySetByName : string * bool -&gt; System.Data.Metadata.Edm.EntitySet" Usage="entityContainer.GetEntitySetByName (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.EntitySet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del conjunto de entidades que se busca.</param>
        <param name="ignoreCase">Es <see langword="true" /> para que la búsqueda se realice sin distinción entre mayúsculas y minúsculas; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> mediante el uso del nombre especificado para el conjunto de entidades.</summary>
        <returns>Un objeto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> que representa el conjunto de entidades que tiene el nombre especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRelationshipSetByName">
      <MemberSignature Language="C#" Value="public System.Data.Metadata.Edm.RelationshipSet GetRelationshipSetByName (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Data.Metadata.Edm.RelationshipSet GetRelationshipSetByName(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Metadata.Edm.EntityContainer.GetRelationshipSetByName(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRelationshipSetByName (name As String, ignoreCase As Boolean) As RelationshipSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Data::Metadata::Edm::RelationshipSet ^ GetRelationshipSetByName(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="member this.GetRelationshipSetByName : string * bool -&gt; System.Data.Metadata.Edm.RelationshipSet" Usage="entityContainer.GetRelationshipSetByName (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Data.Metadata.Edm.RelationshipSet</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del conjunto de relaciones que se busca.</param>
        <param name="ignoreCase">Es <see langword="true" /> para que la búsqueda se realice sin distinción entre mayúsculas y minúsculas; de lo contrario, es <see langword="false" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Data.Metadata.Edm.RelationshipSet" /> mediante el uso del nombre especificado para el conjunto de relaciones.</summary>
        <returns>Un objeto <see cref="T:System.Data.Metadata.Edm.RelationshipSet" /> que representa el conjunto de relaciones que tiene el nombre especificado.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Data.Metadata.Edm.EntityContainer.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Data.Metadata.Edm.EntityContainer.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el nombre de <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</summary>
        <value>Nombre de <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Metadata.Edm.EntityContainer.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="entityContainer.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve el nombre de este <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</summary>
        <returns>Nombre de <see cref="T:System.Data.Metadata.Edm.EntityContainer" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetEntitySetByName">
      <MemberSignature Language="C#" Value="public bool TryGetEntitySetByName (string name, bool ignoreCase, out System.Data.Metadata.Edm.EntitySet entitySet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetEntitySetByName(string name, bool ignoreCase, [out] class System.Data.Metadata.Edm.EntitySet&amp; entitySet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Metadata.Edm.EntityContainer.TryGetEntitySetByName(System.String,System.Boolean,System.Data.Metadata.Edm.EntitySet@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetEntitySetByName (name As String, ignoreCase As Boolean, ByRef entitySet As EntitySet) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetEntitySetByName(System::String ^ name, bool ignoreCase, [Runtime::InteropServices::Out] System::Data::Metadata::Edm::EntitySet ^ % entitySet);" />
      <MemberSignature Language="F#" Value="member this.TryGetEntitySetByName : string * bool *  -&gt; bool" Usage="entityContainer.TryGetEntitySetByName (name, ignoreCase, entitySet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="entitySet" Type="System.Data.Metadata.Edm.EntitySet" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del conjunto de entidades que se busca.</param>
        <param name="ignoreCase">Es <see langword="true" /> para que la búsqueda se realice sin distinción entre mayúsculas y minúsculas; de lo contrario, es <see langword="false" />.</param>
        <param name="entitySet">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Data.Metadata.Edm.EntitySet" />. Si no hay conjuntos de entidades, este parámetro de salida contiene null.</param>
        <summary>Devuelve un objeto <see cref="T:System.Data.Metadata.Edm.EntitySet" /> mediante el uso del nombre especificado para el conjunto de entidades.</summary>
        <returns>Es <see langword="true" /> si hay un conjunto de entidades que coincide con los criterios de búsqueda; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetRelationshipSetByName">
      <MemberSignature Language="C#" Value="public bool TryGetRelationshipSetByName (string name, bool ignoreCase, out System.Data.Metadata.Edm.RelationshipSet relationshipSet);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetRelationshipSetByName(string name, bool ignoreCase, [out] class System.Data.Metadata.Edm.RelationshipSet&amp; relationshipSet) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Data.Metadata.Edm.EntityContainer.TryGetRelationshipSetByName(System.String,System.Boolean,System.Data.Metadata.Edm.RelationshipSet@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetRelationshipSetByName (name As String, ignoreCase As Boolean, ByRef relationshipSet As RelationshipSet) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetRelationshipSetByName(System::String ^ name, bool ignoreCase, [Runtime::InteropServices::Out] System::Data::Metadata::Edm::RelationshipSet ^ % relationshipSet);" />
      <MemberSignature Language="F#" Value="member this.TryGetRelationshipSetByName : string * bool *  -&gt; bool" Usage="entityContainer.TryGetRelationshipSetByName (name, ignoreCase, relationshipSet)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Data.Entity</AssemblyName>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="relationshipSet" Type="System.Data.Metadata.Edm.RelationshipSet" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name">Nombre del conjunto de relaciones que se busca.</param>
        <param name="ignoreCase">Es <see langword="true" /> para que la búsqueda se realice sin distinción entre mayúsculas y minúsculas; de lo contrario, es <see langword="false" />.</param>
        <param name="relationshipSet">Cuando este método devuelve un resultado, contiene un objeto <see cref="T:System.Data.Metadata.Edm.RelationshipSet" />.</param>
        <summary>Devuelve un objeto <see cref="T:System.Data.Metadata.Edm.RelationshipSet" /> mediante el uso del nombre especificado para el conjunto de relaciones.</summary>
        <returns>Es <see langword="true" /> si hay un conjunto de relaciones que coincide con los criterios de búsqueda; de lo contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>