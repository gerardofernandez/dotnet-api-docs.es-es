<Type Name="Timer" FullName="System.Threading.Timer">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="67fe19429800288028bf5585c9bd4f03134790db" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30530819" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class Timer : MarshalByRefObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Timer extends System.MarshalByRefObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Timer" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Timer&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Timer sealed : MarshalByRefObject, IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Timer</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="31e3b-101">Proporciona un mecanismo para ejecutar un método en un subproceso del grupo de subprocesos en intervalos especificados.</span>
      <span class="sxs-lookup">
        <span data-stu-id="31e3b-101">Provides a mechanism for executing a method on a thread pool thread at specified intervals.</span>
      </span>
      <span data-ttu-id="31e3b-102">Esta clase no puede heredarse.</span>
      <span class="sxs-lookup">
        <span data-stu-id="31e3b-102">This class cannot be inherited.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-103">Use un <xref:System.Threading.TimerCallback> delegado para especificar el método que desee el <xref:System.Threading.Timer> para ejecutar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-103">Use a <xref:System.Threading.TimerCallback> delegate to specify the method you want the <xref:System.Threading.Timer> to execute.</span></span> <span data-ttu-id="31e3b-104">La firma de la <xref:System.Threading.TimerCallback> delegado es:</span><span class="sxs-lookup"><span data-stu-id="31e3b-104">The signature of the <xref:System.Threading.TimerCallback> delegate is:</span></span>  
  
```csharp  
void TimerCallback(Object state)  
```  
  
```cpp  
void TimerCallback(Object state)  
```  
  
```vb  
Sub TimerCallback(state As Object)  
```  
  
 <span data-ttu-id="31e3b-105">El delegado de temporizador se especifica cuando se construye el temporizador y no se puede cambiar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-105">The timer delegate is specified when the timer is constructed, and cannot be changed.</span></span> <span data-ttu-id="31e3b-106">El método no se ejecuta en el subproceso que creó el temporizador; en él se ejecuta en un <xref:System.Threading.ThreadPool> subproceso proporcionado por el sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-106">The method does not execute on the thread that created the timer; it executes on a <xref:System.Threading.ThreadPool> thread supplied by the system.</span></span>  
  
> [!TIP]
> <span data-ttu-id="31e3b-107">.NET incluye cuatro clases denominadas `Timer`, cada una de la que ofrece una funcionalidad diferente:</span><span class="sxs-lookup"><span data-stu-id="31e3b-107">.NET includes four classes named `Timer`, each of which offers different functionality:</span></span>  
>
> - <span data-ttu-id="31e3b-108"><xref:System.Timers.Timer?displayProperty=nameWithType>, que desencadena un evento y ejecuta el código en uno o más eventos receptores a intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="31e3b-108"><xref:System.Timers.Timer?displayProperty=nameWithType>, which fires an event and executes the code in one or more event sinks at regular intervals.</span></span> <span data-ttu-id="31e3b-109">La clase está diseñada para usarla como basada en un servidor o componente del servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="31e3b-109">The class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</span></span>
> - <span data-ttu-id="31e3b-110"><xref:System.Threading.Timer?displayProperty=nameWithType>, que ejecuta un método de devolución de llamada solo en un subproceso del grupo a intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="31e3b-110"><xref:System.Threading.Timer?displayProperty=nameWithType>, which executes a single callback method on a thread pool thread at regular intervals.</span></span> <span data-ttu-id="31e3b-111">Se define el método de devolución de llamada cuando el temporizador se crea una instancia y no se puede cambiar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-111">The callback method is defined when the timer is instantiated and cannot be changed.</span></span> <span data-ttu-id="31e3b-112">Al igual que el <xref:System.Timers.Timer?displayProperty=nameWithType> (clase), esta clase está pensada para su uso como un componente basado en servidor o el servicio en un entorno multiproceso; no tiene ninguna interfaz de usuario y no es visible en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="31e3b-112">Like the <xref:System.Timers.Timer?displayProperty=nameWithType> class, this class is intended for use as a server-based or service component in a multithreaded environment; it has no user interface and is not visible at runtime.</span></span>
> - <span data-ttu-id="31e3b-113"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (Solo en .NET framework,) un componente de Windows Forms que se desencadena un evento y se ejecuta el código en uno o varios receptores de eventos a intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="31e3b-113"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> (.NET Framework only), a Windows Forms component that fires an event and executes the code in one or more event sinks at regular intervals.</span></span> <span data-ttu-id="31e3b-114">El componente no tiene ninguna interfaz de usuario y está diseñado para su uso en un entorno de un único subproceso; ejecuta en el subproceso de interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="31e3b-114">The component has no user interface and is designed for use in a single-threaded environment; it executes on the UI thread.</span></span>
> - <span data-ttu-id="31e3b-115"><xref:System.Web.UI.Timer?displayProperty=nameWithType> (Solo en .NET framework,) un componente ASP.NET que realiza postback de página web asincrónicos o sincrónicos a intervalos regulares.</span><span class="sxs-lookup"><span data-stu-id="31e3b-115"><xref:System.Web.UI.Timer?displayProperty=nameWithType> (.NET Framework only), an ASP.NET component that performs asynchronous or synchronous web page postbacks at a regular interval.</span></span>
  
 <span data-ttu-id="31e3b-116">Cuando se crea un temporizador, puede especificar una cantidad de tiempo de espera antes de la primera ejecución del método (tiempo de expiración) y una cantidad de tiempo de espera entre las ejecuciones posteriores (período).</span><span class="sxs-lookup"><span data-stu-id="31e3b-116">When you create a timer, you can specify an amount of time to wait before the first execution of the method (due time), and an amount of time to wait between subsequent executions (period).</span></span> <span data-ttu-id="31e3b-117">La <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-117">The <xref:System.Threading.Timer> class has the same resolution as the system clock.</span></span> <span data-ttu-id="31e3b-118">Esto significa que si el período es menor que la resolución del reloj del sistema, la <xref:System.Threading.TimerCallback> delegado se ejecutará a intervalos definidos por la resolución del reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8.</span><span class="sxs-lookup"><span data-stu-id="31e3b-118">This means that if the period is less than the resolution of the system clock, the <xref:System.Threading.TimerCallback> delegate will execute at intervals defined by the resolution of the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems.</span></span> <span data-ttu-id="31e3b-119">Puede cambiar el vencimiento tiempo y un punto o deshabilitar el temporizador, utilizando el <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-119">You can change the due time and period, or disable the timer, by using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31e3b-120">Siempre y cuando usa un <xref:System.Threading.Timer>, debe mantener una referencia a él.</span><span class="sxs-lookup"><span data-stu-id="31e3b-120">As long as you are using a <xref:System.Threading.Timer>, you must keep a reference to it.</span></span> <span data-ttu-id="31e3b-121">Al igual que con cualquier objeto administrado, un <xref:System.Threading.Timer> está sujeta a la colección de elementos no utilizados cuando no hay ninguna referencia a ella.</span><span class="sxs-lookup"><span data-stu-id="31e3b-121">As with any managed object, a <xref:System.Threading.Timer> is subject to garbage collection when there are no references to it.</span></span> <span data-ttu-id="31e3b-122">El hecho de que un <xref:System.Threading.Timer> está todavía activo no impide se recopilan.</span><span class="sxs-lookup"><span data-stu-id="31e3b-122">The fact that a <xref:System.Threading.Timer> is still active does not prevent it from being collected.</span></span>  
  
 <span data-ttu-id="31e3b-123">Cuando ya no se necesita un temporizador, utilice el <xref:System.Threading.Timer.Dispose%2A> método para liberar los recursos mantenidos por el temporizador.</span><span class="sxs-lookup"><span data-stu-id="31e3b-123">When a timer is no longer needed, use the <xref:System.Threading.Timer.Dispose%2A> method to free the resources held by the timer.</span></span> <span data-ttu-id="31e3b-124">Tenga en cuenta que las devoluciones de llamada pueden producirse después de la <xref:System.Threading.Timer.Dispose> sobrecarga del método se ha llamado, porque el temporizador pone en cola las devoluciones de llamada para su ejecución por grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-124">Note that callbacks can occur after the <xref:System.Threading.Timer.Dispose> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</span></span> <span data-ttu-id="31e3b-125">Puede usar el <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.</span><span class="sxs-lookup"><span data-stu-id="31e3b-125">You can use the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload to wait until all callbacks have completed.</span></span>  
  
 <span data-ttu-id="31e3b-126">El método de devolución de llamada ejecutado por el temporizador debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-126">The callback method executed by the timer should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-127">La devolución de llamada se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar la devolución de llamada, o si todos los subprocesos del grupo de subprocesos están en uso y la devolución de llamada se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-127">The callback can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the callback, or if all thread pool threads are in use and the callback is queued multiple times.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31e3b-128"><xref:System.Threading.Timer?displayProperty=nameWithType> es un temporizador sencillo y ligero que utiliza métodos de devolución de llamada y se envía al grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-128"><xref:System.Threading.Timer?displayProperty=nameWithType> is a simple, lightweight timer that uses callback methods and is served by thread pool threads.</span></span> <span data-ttu-id="31e3b-129">No se recomienda para su uso con Windows Forms, porque las devoluciones de llamada no se producen en el subproceso de interfaz de usuario.</span><span class="sxs-lookup"><span data-stu-id="31e3b-129">It is not recommended for use with Windows Forms, because its callbacks do not occur on the user interface thread.</span></span> <span data-ttu-id="31e3b-130"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> es una opción mejor para su uso con Windows Forms.</span><span class="sxs-lookup"><span data-stu-id="31e3b-130"><xref:System.Windows.Forms.Timer?displayProperty=nameWithType> is a better choice for use with Windows Forms.</span></span> <span data-ttu-id="31e3b-131">Para obtener funcionalidades de temporizador basadas en servidor, puede ser interesante usar <xref:System.Timers.Timer?displayProperty=nameWithType>, que genera eventos y tiene características adicionales.</span><span class="sxs-lookup"><span data-stu-id="31e3b-131">For server-based timer functionality, you might consider using <xref:System.Timers.Timer?displayProperty=nameWithType>, which raises events and has additional features.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-132">En el ejemplo siguiente se define un `StatusChecker` clase que incluya un `CheckStatus` método cuya firma es el mismo como el <xref:System.Threading.TimerCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-132">The following example defines a `StatusChecker` class  that includes a `CheckStatus` method whose signature is the same as the <xref:System.Threading.TimerCallback> delegate.</span></span> <span data-ttu-id="31e3b-133">El `state` argumento de la `CheckStatus` método es un <xref:System.Threading.AutoResetEvent> objeto que se utiliza para sincronizar el subproceso de la aplicación y el subproceso del grupo que ejecuta el delegado de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="31e3b-133">The  `state` argument of the `CheckStatus` method is an <xref:System.Threading.AutoResetEvent> object that is used to synchronize the application thread and the thread pool thread that executes the callback delegate.</span></span> <span data-ttu-id="31e3b-134">La `StatusChecker` clase también incluye dos variables de estado:</span><span class="sxs-lookup"><span data-stu-id="31e3b-134">The `StatusChecker` class also includes two state variables:</span></span>  
  
 `invokeCount`  
 <span data-ttu-id="31e3b-135">Indica el número de veces que se ha invocado el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="31e3b-135">Indicates the number of times the callback method has been invoked.</span></span>  
  
 `maxCount`  
 <span data-ttu-id="31e3b-136">Determina el número máximo de veces que se debe invocar el método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="31e3b-136">Determines the maximum number of times the callback method should be invoked.</span></span>  
  
 <span data-ttu-id="31e3b-137">El subproceso de la aplicación crea el temporizador, que espera un segundo y, a continuación, ejecuta el `CheckStatus` método de devolución de llamada cada 250 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-137">The application thread creates the timer, which waits one second and then executes  the `CheckStatus` callback method every 250 milliseconds.</span></span> <span data-ttu-id="31e3b-138">El subproceso de la aplicación, a continuación, se bloquea hasta que el <xref:System.Threading.AutoResetEvent> se señaliza el objeto.</span><span class="sxs-lookup"><span data-stu-id="31e3b-138">The application thread then blocks until the <xref:System.Threading.AutoResetEvent> object is signaled.</span></span> <span data-ttu-id="31e3b-139">Cuando el `CheckStatus` el método de devolución de llamada se ejecuta `maxCount` veces, llama a la `AutoResetEvent.Set` método para establecer el estado de la <xref:System.Threading.AutoResetEvent> objeto que se va a señalar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-139">When the `CheckStatus` callback method executes `maxCount` times, it calls the `AutoResetEvent.Set` method to set the state of the <xref:System.Threading.AutoResetEvent> object to signaled.</span></span> <span data-ttu-id="31e3b-140">La primera vez que esto ocurre, el subproceso de la aplicación llama el <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> método para que el método de devolución de llamada ejecutará cada medio segundo.</span><span class="sxs-lookup"><span data-stu-id="31e3b-140">The first time this happens, the application thread calls the <xref:System.Threading.Timer.Change%28System.Int32%2CSystem.Int32%29> method so that the callback method now executes every half second.</span></span> <span data-ttu-id="31e3b-141">Una vez más se bloquea hasta que el <xref:System.Threading.AutoResetEvent> se señaliza el objeto.</span><span class="sxs-lookup"><span data-stu-id="31e3b-141">It once again blocks until the <xref:System.Threading.AutoResetEvent> object is signaled.</span></span> <span data-ttu-id="31e3b-142">Cuando esto sucede, se destruye el temporizador mediante una llamada a su <xref:System.Threading.Timer.Dispose%2A> método y la aplicación finaliza.</span><span class="sxs-lookup"><span data-stu-id="31e3b-142">When this happens, the timer is destroyed by calling its <xref:System.Threading.Timer.Dispose%2A> method, and the application terminates.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="31e3b-143">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="31e3b-143">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.TimerCallback" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31e3b-144">Inicializa una nueva instancia de la clase <see langword="Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-144">Initializes a new instance of the <see langword="Timer" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="31e3b-145">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-145">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-146">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Timer" /> con un período y un tiempo límite infinitos, utilizando el objeto <see cref="T:System.Threading.Timer" /> recién creado como objeto de estado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-146">Initializes a new instance of the <see cref="T:System.Threading.Timer" /> class with an infinite period and an infinite due time, using the newly created <see cref="T:System.Threading.Timer" /> object as the state object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-147">Llamar a este constructor cuando desee utilizar el <xref:System.Threading.Timer> propio objeto como el objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="31e3b-147">Call this constructor when you want to use the <xref:System.Threading.Timer> object itself as the state object.</span></span> <span data-ttu-id="31e3b-148">Después de crear el temporizador, utilice el <xref:System.Threading.Timer.Change%2A> método para establecer el intervalo y tiempo de expiración.</span><span class="sxs-lookup"><span data-stu-id="31e3b-148">After creating the timer, use the <xref:System.Threading.Timer.Change%2A> method to set the interval and due time.</span></span>  
  
 <span data-ttu-id="31e3b-149">Este constructor especifica un límite infinitos tiempo antes de la primera devolución de llamada y un intervalo infinito entre devoluciones de llamada, para evitar que la primera devolución de llamada que se producen antes de la <xref:System.Threading.Timer> objeto se asigna al objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="31e3b-149">This constructor specifies an infinite due time before the first callback and an infinite interval between callbacks, in order to prevent the first callback from occurring before the <xref:System.Threading.Timer> object is assigned to the state object.</span></span>  
  
 <span data-ttu-id="31e3b-150">El método especificado para `callback` debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-150">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-151">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-151">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-152">En el ejemplo de código siguiente se crea un nuevo temporizador, utilizando el propio temporizador como objeto de estado.</span><span class="sxs-lookup"><span data-stu-id="31e3b-152">The following code example creates a new timer, using the timer itself as the state object.</span></span> <span data-ttu-id="31e3b-153">El <xref:System.Threading.Timer.Change%2A> método se usa para iniciar el temporizador.</span><span class="sxs-lookup"><span data-stu-id="31e3b-153">The <xref:System.Threading.Timer.Change%2A> method is used to start the timer.</span></span> <span data-ttu-id="31e3b-154">Cuando se produce la devolución de llamada de temporizador, se utiliza el objeto de estado para desactivar el temporizador.</span><span class="sxs-lookup"><span data-stu-id="31e3b-154">When the timer callback occurs, the state object is used to turn the timer off.</span></span>  
  
 [!code-csharp[TimerSelfCtor#1](~/samples/snippets/csharp/VS_Snippets_Misc/timerSelfCtor/CS/source.cs#1)]
 [!code-vb[TimerSelfCtor#1](~/samples/snippets/visualbasic/VS_Snippets_Misc/timerSelfCtor/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Integer, period As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, int dueTime, int period);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="31e3b-155">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-155">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="31e3b-156">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-156">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="31e3b-157">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-157">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-158">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-158">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="31e3b-159">Especifique cero (0) para iniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-159">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-160">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-160">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-161">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-161">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-162">Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 32 bits con signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-162">Initializes a new instance of the <see langword="Timer" /> class, using a 32-bit signed integer to specify the time interval.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-163">El delegado especificado por la `callback` parámetro se invoca una vez después de `dueTime` transcurre y posteriormente cada vez que la `period` transcurra de intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="31e3b-163">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="31e3b-164">Si `dueTime` es cero (0), `callback` se invoca de inmediato.</span><span class="sxs-lookup"><span data-stu-id="31e3b-164">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="31e3b-165">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-165">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-166">Dado que la <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period` es menor que la resolución del reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-166">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="31e3b-167">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-167">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-168">El método especificado para `callback` debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-168">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-169">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-169">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-170">En el ejemplo de código siguiente se muestra cómo crear un `TimerCallback` delegar e inicializar una nueva instancia de la `Timer` clase.</span><span class="sxs-lookup"><span data-stu-id="31e3b-170">The following code example shows how to create a `TimerCallback` delegate and initialize a new instance of the `Timer` class.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-171">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-171">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31e3b-172">El parámetro <paramref name="callback" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-172">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As Long, period As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, long dueTime, long period);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="31e3b-173">Delegado de <see cref="T:System.Threading.TimerCallback" /> que representa un método que se debe ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-173">A <see cref="T:System.Threading.TimerCallback" /> delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="31e3b-174">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-174">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="31e3b-175">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-175">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-176">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-176">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="31e3b-177">Especifique cero (0) para iniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-177">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-178">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-178">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-179">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-179">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-180">Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 64 bits con signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-180">Initializes a new instance of the <see langword="Timer" /> class, using 64-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-181">El delegado especificado por la `callback` parámetro se invoca una vez después de `dueTime` transcurre y posteriormente cada vez que la `period` transcurra de intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="31e3b-181">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="31e3b-182">Si `dueTime` es cero (0), `callback` se invoca de inmediato.</span><span class="sxs-lookup"><span data-stu-id="31e3b-182">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="31e3b-183">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-183">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-184">Dado que la <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period` es menor que la resolución del reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-184">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="31e3b-185">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-185">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-186">El método especificado para `callback` debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-186">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-187">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-187">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-188">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-188">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31e3b-189">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-189">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As TimeSpan, period As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, TimeSpan dueTime, TimeSpan period);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="31e3b-190">Delegado que representa un método que se va a ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-190">A delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="31e3b-191">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-191">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="31e3b-192">Cantidad de tiempo de retraso antes de que el parámetro <c>callback</c> invoque sus métodos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-192">The amount of time to delay before the <c>callback</c> parameter invokes its methods.</span>
          </span>
          <span data-ttu-id="31e3b-193">Especifique menos un (-1) milisegundo para evitar que se inicie el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-193">Specify negative one (-1) milliseconds to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="31e3b-194">Especifique cero (0) para iniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-194">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-195">Intervalo de tiempo entre las distintas invocaciones de los métodos a los que hace referencia <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-195">The time interval between invocations of the methods referenced by <c>callback</c>.</span>
          </span>
          <span data-ttu-id="31e3b-196">Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-196">Specify negative one (-1) milliseconds to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-197">Inicializa una nueva instancia de la clase <see langword="Timer" />, utilizando valores de <see cref="T:System.TimeSpan" /> para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-197">Initializes a new instance of the <see langword="Timer" /> class, using <see cref="T:System.TimeSpan" /> values to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-198">El delegado especificado por la `callback` parámetro se invoca una vez después de `dueTime` transcurre y posteriormente cada vez que la `period` transcurra de intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="31e3b-198">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="31e3b-199">Si `dueTime` es cero (0), `callback` se invoca de inmediato.</span><span class="sxs-lookup"><span data-stu-id="31e3b-199">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="31e3b-200">Si `dueTime` es menos uno (-1) milisegundo, `callback` no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-200">If `dueTime` is negative one (-1) milliseconds, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-201">Dado que la <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period` es menor que la resolución del reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-201">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="31e3b-202">Si `period` es cero (0) o menos (-1) milisegundo y `dueTime` es positivo, `callback` se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-202">If `period` is zero (0) or negative one (-1) milliseconds and `dueTime` is positive, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-203">El método especificado para `callback` debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-203">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-204">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-204">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-205">En el ejemplo de código siguiente se muestra cómo crear un `TimerCallback` delegar e inicializar una nueva instancia de la `Timer` clase.</span><span class="sxs-lookup"><span data-stu-id="31e3b-205">The following code example shows how to create a `TimerCallback` delegate and initialize a new instance of the `Timer` class.</span></span>  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-206">El número de milisegundos del valor de <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />, o es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-206">The number of milliseconds in the value of <paramref name="dueTime" /> or <paramref name="period" /> is negative and not equal to <see cref="F:System.Threading.Timeout.Infinite" />, or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31e3b-207">El parámetro <paramref name="callback" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-207">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Timer (System.Threading.TimerCallback callback, object state, uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.TimerCallback callback, object state, unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.#ctor(System.Threading.TimerCallback,System.Object,System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (callback As TimerCallback, state As Object, dueTime As UInteger, period As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Timer(System::Threading::TimerCallback ^ callback, System::Object ^ state, System::UInt32 dueTime, System::UInt32 period);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="callback" Type="System.Threading.TimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="callback">
          <span data-ttu-id="31e3b-208">Delegado que representa un método que se va a ejecutar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-208">A delegate representing a method to be executed.</span>
          </span>
        </param>
        <param name="state">
          <span data-ttu-id="31e3b-209">Objeto que contiene información que debe utilizar el método de devolución de llamada, o <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-209">An object containing information to be used by the callback method, or <see langword="null" />.</span>
          </span>
        </param>
        <param name="dueTime">
          <span data-ttu-id="31e3b-210">Cantidad de tiempo de retraso, en milisegundos, antes de que se invoque <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-210">The amount of time to delay before <c>callback</c> is invoked, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-211">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que se inicie el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-211">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from starting.</span>
          </span>
          <span data-ttu-id="31e3b-212">Especifique cero (0) para iniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-212">Specify zero (0) to start the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-213">Intervalo de tiempo, en milisegundos, entre las distintas invocaciones de <c>callback</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-213">The time interval between invocations of <c>callback</c>, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-214">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-214">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-215">Inicializa una nueva instancia de la clase <see langword="Timer" /> utilizando un entero de 32 bits sin signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-215">Initializes a new instance of the <see langword="Timer" /> class, using 32-bit unsigned integers to measure time intervals.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-216">El delegado especificado por la `callback` parámetro se invoca una vez después de `dueTime` transcurre y posteriormente cada vez que la `period` transcurra de intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="31e3b-216">The delegate specified by the `callback` parameter is invoked once after `dueTime` elapses, and thereafter each time the `period` time interval elapses.</span></span>  
  
 <span data-ttu-id="31e3b-217">Si `dueTime` es cero (0), `callback` se invoca de inmediato.</span><span class="sxs-lookup"><span data-stu-id="31e3b-217">If `dueTime` is zero (0), `callback` is invoked immediately.</span></span> <span data-ttu-id="31e3b-218">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` no se invoca; el temporizador está deshabilitado, pero puede volver a habilitarse mediante una llamada a la <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-218">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is not invoked; the timer is disabled, but can be re-enabled by calling the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-219">Dado que la <xref:System.Threading.Timer> clase tiene la misma resolución que el reloj del sistema, que es aproximadamente 15 milisegundos en los sistemas Windows 7 y Windows 8, el `callback` delegado se ejecuta a intervalos definidos por la resolución del reloj del sistema si `period` es menor que la resolución del reloj del sistema.</span><span class="sxs-lookup"><span data-stu-id="31e3b-219">Because the <xref:System.Threading.Timer> class has the same resolution as the system clock, which is approximately 15 milliseconds on Windows 7 and Windows 8 systems, the `callback` delegate executes at intervals defined by the resolution of the system clock if `period` is less than the resolution of the system clock.</span></span> <span data-ttu-id="31e3b-220">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` se invoca una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar con el <xref:System.Threading.Timer.Change%2A> método.</span><span class="sxs-lookup"><span data-stu-id="31e3b-220">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, `callback` is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled using the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 <span data-ttu-id="31e3b-221">El método especificado para `callback` debe ser de reentrada, porque se llama en <xref:System.Threading.ThreadPool> subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-221">The method specified for `callback` should be reentrant, because it is called on <xref:System.Threading.ThreadPool> threads.</span></span> <span data-ttu-id="31e3b-222">El método se pueden ejecutar simultáneamente en dos subprocesos del grupo de subprocesos si el intervalo del temporizador es menor que el tiempo necesario para ejecutar el método, o si todos los subprocesos del grupo de subprocesos están en uso y el método se pone en cola varias veces.</span><span class="sxs-lookup"><span data-stu-id="31e3b-222">The method can be executed simultaneously on two thread pool threads if the timer interval is less than the time required to execute the method, or if all thread pool threads are in use and the method is queued multiple times.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-223">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-223">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31e3b-224">El parámetro <paramref name="callback" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-224">The <paramref name="callback" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Change">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31e3b-225">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-225">Changes the start time and the interval between method invocations for a timer.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (int dueTime, int period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int32 dueTime, int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Integer, period As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(int dueTime, int period);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int32" />
        <Parameter Name="period" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="31e3b-226">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-226">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-227">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-227">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="31e3b-228">Especifique cero (0) para reiniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-228">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-229">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-229">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-230">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-230">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-231">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits con signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-231">Changes the start time and the interval between method invocations for a timer, using 32-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31e3b-232">
            <see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-232">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-233">Se invoca el método de devolución de llamada una vez después de `dueTime` transcurra y posteriormente cada vez que el intervalo de tiempo especificado por `period` transcurre.</span><span class="sxs-lookup"><span data-stu-id="31e3b-233">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="31e3b-234">Si `dueTime` es cero (0), se invoca el método de devolución de llamada inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="31e3b-234">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="31e3b-235">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-235">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="31e3b-236">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-236">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="31e3b-237">El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-237">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-238">En el ejemplo de código siguiente se muestra cómo iniciar un `Timer` y, después de un número establecido de llamadas, cambiar su período.</span><span class="sxs-lookup"><span data-stu-id="31e3b-238">The following code example demonstrates how to start a `Timer` and, after a set number of invocations, change its period.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="31e3b-239">
            <see cref="T:System.Threading.Timer" /> ya se ha eliminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-239">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-240">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-240">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (long dueTime, long period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(int64 dueTime, int64 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As Long, period As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(long dueTime, long period);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.Int64" />
        <Parameter Name="period" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="31e3b-241">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-241">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-242">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-242">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="31e3b-243">Especifique cero (0) para reiniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-243">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-244">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-244">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-245">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-245">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-246">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 64 bits con signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-246">Changes the start time and the interval between method invocations for a timer, using 64-bit signed integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31e3b-247">
            <see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-247">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-248">Se invoca el método de devolución de llamada una vez después de `dueTime` transcurra y posteriormente cada vez que el intervalo de tiempo especificado por `period` transcurre.</span><span class="sxs-lookup"><span data-stu-id="31e3b-248">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="31e3b-249">Si `dueTime` es cero (0), se invoca el método de devolución de llamada inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="31e3b-249">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="31e3b-250">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-250">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="31e3b-251">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-251">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="31e3b-252">El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-252">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="31e3b-253">
            <see cref="T:System.Threading.Timer" /> ya se ha eliminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-253">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-254">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es menor que -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-254">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31e3b-255">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-255">The <paramref name="dueTime" /> or <paramref name="period" /> parameter is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (TimeSpan dueTime, TimeSpan period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(valuetype System.TimeSpan dueTime, valuetype System.TimeSpan period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.TimeSpan,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As TimeSpan, period As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(TimeSpan dueTime, TimeSpan period);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.TimeSpan" />
        <Parameter Name="period" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="31e3b-256">
            <see cref="T:System.TimeSpan" /> que representa el período tiempo de retraso antes de que se llame al método de devolución de llamada que se especificó cuando se creó <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-256">A <see cref="T:System.TimeSpan" /> representing the amount of time to delay before invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed.</span>
          </span>
          <span data-ttu-id="31e3b-257">Especifique menos un (-1) milisegundo para evitar que se reinicie el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-257">Specify negative one (-1) milliseconds to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="31e3b-258">Especifique cero (0) para reiniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-258">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-259">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-259">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed.</span>
          </span>
          <span data-ttu-id="31e3b-260">Especifique menos un (-1) milisegundo para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-260">Specify negative one (-1) milliseconds to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-261">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones del método para un temporizador, utilizando los valores de <see cref="T:System.TimeSpan" /> para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-261">Changes the start time and the interval between method invocations for a timer, using <see cref="T:System.TimeSpan" /> values to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31e3b-262">
            <see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-262">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-263">Se invoca el método de devolución de llamada una vez después de `dueTime` transcurra y posteriormente cada vez que el intervalo de tiempo especificado por `period` transcurre.</span><span class="sxs-lookup"><span data-stu-id="31e3b-263">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="31e3b-264">Si `dueTime` es cero (0), se invoca el método de devolución de llamada inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="31e3b-264">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="31e3b-265">Si `dueTime` es menos uno (-1) milisegundo, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-265">If `dueTime` is negative one (-1) milliseconds, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="31e3b-266">Si `period` es cero (0) o menos uno (-1) milisegundo, y `dueTime` es positivo, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador está deshabilitado, pero se puede volver a habilitar mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especifique un valor mayor que cero para `period`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-266">If `period` is zero (0) or negative one (-1) milliseconds, and `dueTime` is positive, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a value greater than zero for `period`.</span></span>  
  
 <span data-ttu-id="31e3b-267">El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-267">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-268">En el ejemplo de código siguiente se muestra cómo iniciar un `Timer` y, después de un número establecido de llamadas, cambiar su período.</span><span class="sxs-lookup"><span data-stu-id="31e3b-268">The following code example demonstrates how to start a `Timer` and, after a set number of invocations, change its period.</span></span>  
  
 [!code-cpp[System.Threading.Timer2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer2/CPP/source2.cpp#1)]
 [!code-csharp[System.Threading.Timer2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer2/CS/source2.cs#1)]
 [!code-vb[System.Threading.Timer2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer2/VB/source2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="31e3b-269">
            <see cref="T:System.Threading.Timer" /> ya se ha eliminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-269">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="31e3b-270">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es menor que -1, en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-270">The <paramref name="dueTime" /> or <paramref name="period" /> parameter, in milliseconds, is less than -1.</span>
          </span>
        </exception>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="31e3b-271">El parámetro <paramref name="dueTime" /> o <paramref name="period" /> es mayor que 4294967294, en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-271">The <paramref name="dueTime" /> or <paramref name="period" /> parameter, in milliseconds, is greater than 4294967294.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Change">
      <MemberSignature Language="C#" Value="public bool Change (uint dueTime, uint period);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Change(unsigned int32 dueTime, unsigned int32 period) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Change(System.UInt32,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Change (dueTime As UInteger, period As UInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Change(System::UInt32 dueTime, System::UInt32 period);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dueTime" Type="System.UInt32" />
        <Parameter Name="period" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="dueTime">
          <span data-ttu-id="31e3b-272">Período de tiempo de espera, en milisegundos, antes de que se invoque al método de devolución de llamada que se especificó en el momento de la construcción de <see cref="T:System.Threading.Timer" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-272">The amount of time to delay before the invoking the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-273">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para evitar que el temporizador se reinicie.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-273">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to prevent the timer from restarting.</span>
          </span>
          <span data-ttu-id="31e3b-274">Especifique cero (0) para reiniciar inmediatamente el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-274">Specify zero (0) to restart the timer immediately.</span>
          </span>
        </param>
        <param name="period">
          <span data-ttu-id="31e3b-275">Período de tiempo entre invocaciones del método de llamada especificado en el momento de la construcción de <see cref="T:System.Threading.Timer" />, en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-275">The time interval between invocations of the callback method specified when the <see cref="T:System.Threading.Timer" /> was constructed, in milliseconds.</span>
          </span>
          <span data-ttu-id="31e3b-276">Especifique <see cref="F:System.Threading.Timeout.Infinite" /> para deshabilitar la señalización periódica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-276">Specify <see cref="F:System.Threading.Timeout.Infinite" /> to disable periodic signaling.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-277">Cambia el tiempo de inicio y el intervalo entre las distintas invocaciones de método para un temporizador, utilizando enteros de 32 bits sin signo para medir los intervalos de tiempo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-277">Changes the start time and the interval between method invocations for a timer, using 32-bit unsigned integers to measure time intervals.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31e3b-278">
            <see langword="true" /> si el temporizador se actualizó correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-278">
              <see langword="true" /> if the timer was successfully updated; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-279">Se invoca el método de devolución de llamada una vez después de `dueTime` transcurra y posteriormente cada vez que el intervalo de tiempo especificado por `period` transcurre.</span><span class="sxs-lookup"><span data-stu-id="31e3b-279">The callback method is invoked once after `dueTime` elapses, and thereafter each time the time interval specified by `period` elapses.</span></span>  
  
 <span data-ttu-id="31e3b-280">Si `dueTime` es cero (0), se invoca el método de devolución de llamada inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="31e3b-280">If `dueTime` is zero (0), the callback method is invoked immediately.</span></span> <span data-ttu-id="31e3b-281">Si `dueTime` es <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, nunca se invoca el método de devolución de llamada; el temporizador está desactivado, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `dueTime`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-281">If `dueTime` is <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is never invoked; the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `dueTime`.</span></span>  
  
 <span data-ttu-id="31e3b-282">Si `period` es cero (0) o <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, y `dueTime` no <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, se invoca el método de devolución de llamada una vez; el comportamiento periódico del temporizador se deshabilita, pero puede volver a habilitarse mediante una llamada a <xref:System.Threading.Timer.Change%2A> y especificando un valor positivo para `period`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-282">If `period` is zero (0) or <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, and `dueTime` is not <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType>, the callback method is invoked once; the periodic behavior of the timer is disabled, but can be re-enabled by calling <xref:System.Threading.Timer.Change%2A> and specifying a positive value for `period`.</span></span>  
  
 <span data-ttu-id="31e3b-283">El <xref:System.Threading.Timer.Change%2A> método puede llamarse desde el <xref:System.Threading.TimerCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="31e3b-283">The <xref:System.Threading.Timer.Change%2A> method can be called from the <xref:System.Threading.TimerCallback> delegate.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">
          <span data-ttu-id="31e3b-284">
            <see cref="T:System.Threading.Timer" /> ya se ha eliminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-284">The <see cref="T:System.Threading.Timer" /> has already been disposed.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="31e3b-285">Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-285">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" />.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="31e3b-286">Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-286">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-287">Al llamar a `Dispose` permite que los recursos utilizados por el <xref:System.Threading.Timer> se reasignen para otros fines.</span><span class="sxs-lookup"><span data-stu-id="31e3b-287">Calling `Dispose` allows the resources used by the <xref:System.Threading.Timer> to be reallocated for other purposes.</span></span> <span data-ttu-id="31e3b-288">Para obtener más información acerca de `Dispose`, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="31e3b-288">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31e3b-289">Las devoluciones de llamada pueden producirse después de la <xref:System.Threading.Timer.Dispose> sobrecarga del método se ha llamado, porque el temporizador pone en cola las devoluciones de llamada para su ejecución por grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="31e3b-289">Callbacks can occur after the <xref:System.Threading.Timer.Dispose> method overload has been called, because the timer queues callbacks for execution by thread pool threads.</span></span> <span data-ttu-id="31e3b-290">Puede usar el <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método para esperar hasta que se completen todas las devoluciones de llamada.</span><span class="sxs-lookup"><span data-stu-id="31e3b-290">You can use the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload to wait until all callbacks have completed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="31e3b-291">En el ejemplo de código siguiente se muestra cómo liberar los recursos mantenidos por un `Timer`.</span><span class="sxs-lookup"><span data-stu-id="31e3b-291">The following code example shows how to free the resources held by a `Timer`.</span></span>  
  
 [!code-cpp[System.Threading.Timer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Timer/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Timer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Timer/CS/source.cs#1)]
 [!code-vb[System.Threading.Timer#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Timer/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public bool Dispose (System.Threading.WaitHandle notifyObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Dispose(class System.Threading.WaitHandle notifyObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Timer.Dispose(System.Threading.WaitHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Function Dispose (notifyObject As WaitHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Dispose(System::Threading::WaitHandle ^ notifyObject);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Timer</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="notifyObject" Type="System.Threading.WaitHandle" />
      </Parameters>
      <Docs>
        <param name="notifyObject">
          <span data-ttu-id="31e3b-292">
            <see cref="T:System.Threading.WaitHandle" /> que se va a señalar cuando <see langword="Timer" /> se haya eliminado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-292">The <see cref="T:System.Threading.WaitHandle" /> to be signaled when the <see langword="Timer" /> has been disposed of.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="31e3b-293">Libera todos los recursos utilizados por la instancia de <see cref="T:System.Threading.Timer" /> actual e indica el momento en el que se ha eliminado el temporizador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-293">Releases all resources used by the current instance of <see cref="T:System.Threading.Timer" /> and signals when the timer has been disposed of.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="31e3b-294">
            <see langword="true" /> si la función se realiza correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-294">
              <see langword="true" /> if the function succeeds; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="31e3b-295">Al llamar a `Dispose` permite que los recursos utilizados por el <xref:System.Threading.Timer> se reasignen para otros fines.</span><span class="sxs-lookup"><span data-stu-id="31e3b-295">Calling `Dispose` allows the resources used by the <xref:System.Threading.Timer> to be reallocated for other purposes.</span></span> <span data-ttu-id="31e3b-296">Para obtener más información acerca de `Dispose`, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="31e3b-296">For more information about `Dispose`, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 <span data-ttu-id="31e3b-297">Cuando este método finaliza, indica el <xref:System.Threading.WaitHandle> especificado por el `notifyObject` parámetro. Utilice esta sobrecarga de la <xref:System.Threading.Timer.Dispose%2A> método si desea poder bloquear hasta que esté seguro de que se ha eliminado el temporizador.</span><span class="sxs-lookup"><span data-stu-id="31e3b-297">When this method completes, it signals the <xref:System.Threading.WaitHandle> specified by the `notifyObject` parameter.Use this overload of the <xref:System.Threading.Timer.Dispose%2A> method if you want to be able to block until you are certain that the timer has been disposed.</span></span> <span data-ttu-id="31e3b-298">No se eliminó el temporizador hasta que se completen todas las devoluciones de llamada actualmente en cola.</span><span class="sxs-lookup"><span data-stu-id="31e3b-298">The timer is not disposed until all currently queued callbacks have completed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="31e3b-299">Si utiliza la devolución de llamada la <xref:System.Threading.Timer.Change%2A> método para establecer el `dueTime` en cero el parámetro, puede producirse una condición de carrera cuando la <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método se llama: si el temporizador pone en cola una devolución de llamada nueva antes de la <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> sobrecarga del método detecta que no hay ningún devoluciones de llamada en cola, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> seguirá bloqueando; en caso contrario, el temporizador se elimina mientras se está poniendo en cola la devolución de llamada nueva y un <xref:System.ObjectDisposedException> se produce cuando se llama a la devolución de llamada nuevo el <xref:System.Threading.Timer.Change%2A> (método).</span><span class="sxs-lookup"><span data-stu-id="31e3b-299">If the callback uses the <xref:System.Threading.Timer.Change%2A> method to set the `dueTime` parameter to zero, a race condition can occur when the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload is called: If the timer queues a new callback before the <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> method overload detects that there are no callbacks queued, <xref:System.Threading.Timer.Dispose%28System.Threading.WaitHandle%29> continues to block; otherwise, the timer is disposed while the new callback is being queued, and an <xref:System.ObjectDisposedException> is thrown when the new callback calls the <xref:System.Threading.Timer.Change%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="31e3b-300">El parámetro <paramref name="notifyObject" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="31e3b-300">The <paramref name="notifyObject" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>