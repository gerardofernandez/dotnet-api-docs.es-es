<Type Name="ThreadPool" FullName="System.Threading.ThreadPool">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfe939fdbc3c31c6797ac84b6e8ba1c1352523f9" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56386474" /></Metadata><TypeSignature Language="C#" Value="public static class ThreadPool" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit ThreadPool extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ThreadPool" />
  <TypeSignature Language="VB.NET" Value="Public Class ThreadPool" />
  <TypeSignature Language="C++ CLI" Value="public ref class ThreadPool abstract sealed" />
  <TypeSignature Language="F#" Value="type ThreadPool = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.ThreadPool</AssemblyName>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="cd72b-101">Proporciona un grupo de subprocesos que pueden usarse para ejecutar tareas, exponer elementos de trabajo, procesar la E/S asincrónica, esperar en nombre de otros subprocesos y procesar temporizadores.</span><span class="sxs-lookup"><span data-stu-id="cd72b-101">Provides a pool of threads that can be used to execute tasks, post work items, process asynchronous I/O, wait on behalf of other threads, and process timers.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-102">Muchas aplicaciones crean subprocesos que pasan mucho tiempo en estado inactivo, esperando a que se produzca un evento.</span><span class="sxs-lookup"><span data-stu-id="cd72b-102">Many applications create threads that spend a great deal of time in the sleeping state, waiting for an event to occur.</span></span> <span data-ttu-id="cd72b-103">Otros subprocesos pueden entrar en estado de inactividad y activarse periódicamente para sondear en busca de un cambio o actualizar la información de estado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-103">Other threads might enter a sleeping state only to be awakened periodically to poll for a change or update status information.</span></span> <span data-ttu-id="cd72b-104">El grupo de subprocesos permite usar subprocesos más eficaz, ya que proporciona la aplicación con un grupo de subprocesos de trabajo que están administrados por el sistema.</span><span class="sxs-lookup"><span data-stu-id="cd72b-104">The thread pool enables you to use threads more efficiently by providing your application with a pool of worker threads that are managed by the system.</span></span> <span data-ttu-id="cd72b-105">Ejemplos de operaciones que usan los subprocesos de grupo incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="cd72b-105">Examples of operations that use thread pool threads include the following:</span></span>  
  
-   <span data-ttu-id="cd72b-106">Cuando creas un <xref:System.Threading.Tasks.Task> o <xref:System.Threading.Tasks.Task%601> objeto para realizar alguna tarea de forma asincrónica, de forma predeterminada, la tarea está programada para ejecutarse en un subproceso ThreadPool.</span><span class="sxs-lookup"><span data-stu-id="cd72b-106">When you create a <xref:System.Threading.Tasks.Task> or <xref:System.Threading.Tasks.Task%601> object to perform some task asynchronously, by default the task is scheduled to run on a thread pool thread.</span></span>  
  
-   <span data-ttu-id="cd72b-107">Los temporizadores asincrónicos usar el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-107">Asynchronous timers use the thread pool.</span></span> <span data-ttu-id="cd72b-108">Subprocesos de grupo ejecutarán devoluciones de llamada de la <xref:System.Threading.Timer?displayProperty=nameWithType> clase y provocar eventos desde el <xref:System.Timers.Timer?displayProperty=nameWithType> clase.</span><span class="sxs-lookup"><span data-stu-id="cd72b-108">Thread pool threads execute callbacks from the <xref:System.Threading.Timer?displayProperty=nameWithType> class and raise events from the <xref:System.Timers.Timer?displayProperty=nameWithType> class.</span></span>  
  
-   <span data-ttu-id="cd72b-109">Al usar identificadores de espera registrada, un subproceso del sistema supervisa el estado de los identificadores de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-109">When you use registered wait handles, a system thread monitors the status of the wait handles.</span></span> <span data-ttu-id="cd72b-110">Cuando se completa una operación de espera, un subproceso del grupo de subprocesos de trabajo ejecuta la función de devolución de llamada correspondiente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-110">When a wait operation completes, a worker thread from the thread pool executes the corresponding callback function.</span></span>  
  
-   <span data-ttu-id="cd72b-111">Cuando se llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método para poner en cola un método para su ejecución en un subproceso ThreadPool.</span><span class="sxs-lookup"><span data-stu-id="cd72b-111">When you call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method to queue a method for execution on a thread pool thread.</span></span> <span data-ttu-id="cd72b-112">Para ello, pasando al método un <xref:System.Threading.WaitCallback> delegar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-112">You do this by passing the method a <xref:System.Threading.WaitCallback> delegate.</span></span>   <span data-ttu-id="cd72b-113">El delegado tiene la firma</span><span class="sxs-lookup"><span data-stu-id="cd72b-113">The delegate has the signature</span></span>  
  
    ```csharp  
    void WaitCallback(Object state)  
    ```  
  
    ```vb  
    Sub WaitCallback(state As Object)  
    ```  
  
     <span data-ttu-id="cd72b-114">donde `state` es un objeto que contiene datos para su uso por el delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-114">where `state` is an object that contains data to be used by the delegate.</span></span> <span data-ttu-id="cd72b-115">Los datos reales se pueden pasar al delegado mediante una llamada a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-115">The actual data can be passed to the delegate by calling the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-116">Los subprocesos en el grupo de subprocesos administrados son subprocesos en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="cd72b-116">The threads in the managed thread pool are background threads.</span></span> <span data-ttu-id="cd72b-117">Es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedades son `true`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-117">That is, their <xref:System.Threading.Thread.IsBackground%2A> properties are `true`.</span></span> <span data-ttu-id="cd72b-118">Esto significa que un <xref:System.Threading.ThreadPool> subproceso no mantendrá una aplicación que se ejecuta después de que han salido de todos los subprocesos de primer plano.</span><span class="sxs-lookup"><span data-stu-id="cd72b-118">This means that a <xref:System.Threading.ThreadPool> thread will not keep an application running after all foreground threads have exited.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd72b-119">Cuando el grupo de subprocesos reutiliza un subproceso, no elimina los datos de almacenamiento local de subprocesos o en los campos que se marcan con el <xref:System.ThreadStaticAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-119">When the thread pool reuses a thread, it does not clear the data in thread local storage or in fields that are marked with the <xref:System.ThreadStaticAttribute> attribute.</span></span> <span data-ttu-id="cd72b-120">Por lo tanto, cuando un método examina el almacenamiento local de subprocesos o campos que se marcan con el <xref:System.ThreadStaticAttribute> atributo, los valores que encuentra podrían quedar a través de un uso anterior de subproceso de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-120">Therefore, when a method examines thread local storage or fields that are marked with the <xref:System.ThreadStaticAttribute> attribute, the values it finds might be left over from an earlier use of the thread pool thread.</span></span>  
  
 <span data-ttu-id="cd72b-121">También puede poner en cola los elementos de trabajo que no están relacionadas con una operación de espera para el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-121">You can also queue work items that are not related to a wait operation to the thread pool.</span></span> <span data-ttu-id="cd72b-122">Para solicitar que un subproceso en el grupo de subprocesos controle un elemento de trabajo, llame a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-122">To request that a work item be handled by a thread in the thread pool, call the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="cd72b-123">Este método toma como parámetro una referencia al método o delegado que llamará el subproceso seleccionado del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-123">This method takes as a parameter a reference to the method or delegate that will be called by the thread selected from the thread pool.</span></span> <span data-ttu-id="cd72b-124">No hay ninguna manera de cancelar un elemento de trabajo después de que se ha puesto en cola.</span><span class="sxs-lookup"><span data-stu-id="cd72b-124">There is no way to cancel a work item after it has been queued.</span></span>  
  
 <span data-ttu-id="cd72b-125">Los temporizadores de la cola del temporizador y operaciones de espera registradas también utilizan el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-125">Timer-queue timers and registered wait operations also use the thread pool.</span></span> <span data-ttu-id="cd72b-126">Sus funciones de devolución de llamada se ponen en cola para el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-126">Their callback functions are queued to the thread pool.</span></span>  
  
 <span data-ttu-id="cd72b-127">Hay un grupo de subprocesos por proceso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-127">There is one thread pool per process.</span></span> <span data-ttu-id="cd72b-128">A partir de [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el tamaño predeterminado del grupo de subprocesos de un proceso depende de varios factores, como el tamaño del espacio de direcciones virtuales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-128">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the default size of the thread pool for a process depends on several factors, such as the size of the virtual address space.</span></span> <span data-ttu-id="cd72b-129">Un proceso puede llamar al método <xref:System.Threading.ThreadPool.GetMaxThreads%2A> para determinar el número de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-129">A process can call the <xref:System.Threading.ThreadPool.GetMaxThreads%2A> method to determine the number of threads.</span></span> <span data-ttu-id="cd72b-130">Se puede cambiar el número de subprocesos en el grupo de subprocesos mediante el uso de la <xref:System.Threading.ThreadPool.SetMaxThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-130">The number of threads in the thread pool can be changed by using the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> method.</span></span> <span data-ttu-id="cd72b-131">Cada subproceso utiliza el tamaño de pila predeterminado y se ejecuta con la prioridad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-131">Each thread uses the default stack size and runs at the default priority.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-132">Código no administrado que hospeda .NET Framework puede cambiar el tamaño del grupo de subprocesos mediante la `CorSetMaxThreads` función definida en el archivo mscoree.h.</span><span class="sxs-lookup"><span data-stu-id="cd72b-132">Unmanaged code that hosts the .NET Framework can change the size of the thread pool by using the `CorSetMaxThreads` function, defined in the mscoree.h file.</span></span>  
  
 <span data-ttu-id="cd72b-133">El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría.</span><span class="sxs-lookup"><span data-stu-id="cd72b-133">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="cd72b-134">Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas.</span><span class="sxs-lookup"><span data-stu-id="cd72b-134">When a minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="cd72b-135">A partir de [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos de trabajo para optimizar el rendimiento, definido como el número de tareas que se completan por unidad de tiempo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-135">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys worker threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="cd72b-136">Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-136">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-137">Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-137">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="cd72b-138">Puede utilizar el método <xref:System.Threading.ThreadPool.GetMinThreads%2A> para obtener estos valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-138">You can use the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method to obtain these minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-139">Puede usar el <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar el número mínimo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-139">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number of threads.</span></span> <span data-ttu-id="cd72b-140">Sin embargo, aumentar innecesariamente estos valores puede causar problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="cd72b-140">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="cd72b-141">Si se inician demasiadas tareas al mismo tiempo, puede que todas ellas parezcan funcionar con lentitud.</span><span class="sxs-lookup"><span data-stu-id="cd72b-141">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="cd72b-142">En la mayoría de los casos, el grupo de subprocesos funciona mejor con su propio algoritmo de asignación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-142">In most cases the thread pool will perform better with its own algorithm for allocating threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-143">En el ejemplo siguiente, el subproceso principal de la aplicación pone en cola un método denominado `ThreadProc` para ejecutar en un subproceso ThreadPool, se suspende durante un segundo y, a continuación, sale.</span><span class="sxs-lookup"><span data-stu-id="cd72b-143">In the following example, the main application thread  queues a method named `ThreadProc` to execute on a thread pool thread, sleeps for one second, and then exits.</span></span> <span data-ttu-id="cd72b-144">El `ThreadProc` método simplemente muestra un mensaje.</span><span class="sxs-lookup"><span data-stu-id="cd72b-144">The `ThreadProc` method simply displays a message.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 <span data-ttu-id="cd72b-145">Si el comentario de la llamada a la <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> método, el subproceso principal finaliza antes de método se ejecuta en el subproceso del grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-145">If you comment out the call to the <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> method, the main thread exits before         method runs on the thread pool thread.</span></span>  <span data-ttu-id="cd72b-146">El grupo de subprocesos usa subprocesos en segundo plano, que no mantienen la aplicación en ejecución si han finalizado todos los subprocesos de primer plano.</span><span class="sxs-lookup"><span data-stu-id="cd72b-146">The thread pool uses background         threads, which do not keep the application running if all foreground threads have terminated.</span></span>  <span data-ttu-id="cd72b-147">(Esto es un ejemplo sencillo de una condición de carrera).</span><span class="sxs-lookup"><span data-stu-id="cd72b-147">(This         is a simple example of a race condition.)</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="cd72b-148">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-148">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="cd72b-149">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="cd72b-149">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-150">La agrupación de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-150">The Managed Thread Pooling</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="BindHandle">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cd72b-151">Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-151">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (IntPtr osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(native int osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(IntPtr osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : nativeint -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.Obsolete("ThreadPool.BindHandle(IntPtr) has been deprecated.  Please use ThreadPool.BindHandle(SafeHandle) instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="cd72b-152"><see cref="T:System.IntPtr" /> que contiene el controlador.</span><span class="sxs-lookup"><span data-stu-id="cd72b-152">An <see cref="T:System.IntPtr" /> that holds the handle.</span></span> <span data-ttu-id="cd72b-153">El identificador debe haberse abierto para la E/S superpuesta en la parte no administrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-153">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="cd72b-154">Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-154">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="cd72b-155">Es <see langword="true" /> si el identificador está enlazado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-155"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-156">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-156">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="cd72b-157">Para poder llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-157">for the ability to call unmanaged code.</span></span> <span data-ttu-id="cd72b-158">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-158">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="BindHandle">
      <MemberSignature Language="C#" Value="public static bool BindHandle (System.Runtime.InteropServices.SafeHandle osHandle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool BindHandle(class System.Runtime.InteropServices.SafeHandle osHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.BindHandle(System.Runtime.InteropServices.SafeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function BindHandle (osHandle As SafeHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool BindHandle(System::Runtime::InteropServices::SafeHandle ^ osHandle);" />
      <MemberSignature Language="F#" Value="static member BindHandle : System.Runtime.InteropServices.SafeHandle -&gt; bool" Usage="System.Threading.ThreadPool.BindHandle osHandle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="osHandle" Type="System.Runtime.InteropServices.SafeHandle" />
      </Parameters>
      <Docs>
        <param name="osHandle"><span data-ttu-id="cd72b-159">Propiedad <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que contiene el identificador del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-159">A <see cref="T:System.Runtime.InteropServices.SafeHandle" /> that holds the operating system handle.</span></span> <span data-ttu-id="cd72b-160">El identificador debe haberse abierto para la E/S superpuesta en la parte no administrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-160">The handle must have been opened for overlapped I/O on the unmanaged side.</span></span></param>
        <summary><span data-ttu-id="cd72b-161">Enlaza un identificador del sistema operativo a <see cref="T:System.Threading.ThreadPool" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-161">Binds an operating system handle to the <see cref="T:System.Threading.ThreadPool" />.</span></span></summary>
        <returns><span data-ttu-id="cd72b-162">Es <see langword="true" /> si el identificador está enlazado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-162"><see langword="true" /> if the handle is bound; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-163">El `osHandle` parámetro debe ser un <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, que se deriva de la clase abstracta <xref:System.Runtime.InteropServices.SafeHandle> clase.</span><span class="sxs-lookup"><span data-stu-id="cd72b-163">The `osHandle` parameter should be a <xref:Microsoft.Win32.SafeHandles.SafeFileHandle>, which derives from the abstract <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cd72b-164"><paramref name="osHandle" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-164"><paramref name="osHandle" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="cd72b-165">Para poder llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-165">for the ability to call unmanaged code.</span></span> <span data-ttu-id="cd72b-166">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-166">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAvailableThreads">
      <MemberSignature Language="C#" Value="public static void GetAvailableThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetAvailableThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetAvailableThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetAvailableThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetAvailableThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetAvailableThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="cd72b-167">Número de subprocesos de trabajo disponibles.</span><span class="sxs-lookup"><span data-stu-id="cd72b-167">The number of available worker threads.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="cd72b-168">Número de subprocesos de E/S asincrónicos disponibles.</span><span class="sxs-lookup"><span data-stu-id="cd72b-168">The number of available asynchronous I/O threads.</span></span></param>
        <summary><span data-ttu-id="cd72b-169">Recupera la diferencia entre el número máximo de subprocesos de grupo de subprocesos devuelto por el método <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> y el número activo actualmente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-169">Retrieves the difference between the maximum number of thread pool threads returned by the <see cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" /> method, and the number currently active.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-170">Cuando <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> devuelve la variable especificada por `workerThreads` contiene el número de subprocesos de trabajo adicionales que pueden iniciarse y la variable especificada por `completionPortThreads` contiene el número de subprocesos de E/S asincrónicos adicionales que puede ser se inició.</span><span class="sxs-lookup"><span data-stu-id="cd72b-170">When <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> returns, the variable specified by `workerThreads` contains the number of additional worker threads that can be started, and the variable specified by `completionPortThreads` contains the number of additional asynchronous I/O threads that can be started.</span></span>  
  
 <span data-ttu-id="cd72b-171">Si no hay ningún subproceso disponible, las solicitudes de grupo de subprocesos adicionales permanecen en la cola hasta que haya disponibles subprocesos de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-171">If there are no available threads, additional thread pool requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-172">El ejemplo siguiente muestra el número de subprocesos de trabajo y subprocesos de E/S disponibles cuando se inicia una aplicación sencilla.</span><span class="sxs-lookup"><span data-stu-id="cd72b-172">The following example displays the number of worker threads and I/O threads available when a simple app is started.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/Example2.cs#2)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/Example2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMaxThreads">
      <MemberSignature Language="C#" Value="public static void GetMaxThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMaxThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMaxThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMaxThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMaxThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="cd72b-173">Número máximo de subprocesos de trabajo en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-173">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="cd72b-174">Número máximo de subprocesos de E/S asincrónicos en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-174">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="cd72b-175">Recupera el número de solicitudes al grupo de subprocesos que pueden estar activas al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-175">Retrieves the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="cd72b-176">Todas las solicitudes que pasen de ese número permanecen en la cola hasta que haya disponibles subprocesos de grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-176">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-177">Cuando <xref:System.Threading.ThreadPool.GetMaxThreads%2A> devuelve la variable especificada por `workerThreads` contiene el número máximo de subprocesos de trabajo permitidos en el grupo de subprocesos y la variable especificada por `completionPortThreads` contiene el número máximo de subprocesos de E/S asincrónicos permitidos en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-177">When <xref:System.Threading.ThreadPool.GetMaxThreads%2A> returns, the variable specified by `workerThreads` contains the maximum number of worker threads allowed in the thread pool, and the variable specified by `completionPortThreads` contains the maximum number of asynchronous I/O threads allowed in the thread pool.</span></span>  
  
 <span data-ttu-id="cd72b-178">Puede usar el <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> método para determinar el número real de subprocesos en el grupo de subprocesos en un momento dado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-178">You can use the <xref:System.Threading.ThreadPool.GetAvailableThreads%2A> method to determine the actual number of threads in the thread pool at any given time.</span></span>  
  
 <span data-ttu-id="cd72b-179">Puede usar el <xref:System.Threading.ThreadPool.SetMaxThreads%2A> para establecer el número máximo de subprocesos de trabajo y subprocesos de E/S asincrónicos en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-179">You can use the <xref:System.Threading.ThreadPool.SetMaxThreads%2A> to set the maximum number of worker threads and asynchronous I/O threads in the thread pool.</span></span>  
  
 <span data-ttu-id="cd72b-180">Puede poner en cola como muchas solicitudes del grupo de subprocesos como permita la memoria del sistema.</span><span class="sxs-lookup"><span data-stu-id="cd72b-180">You can queue as many thread pool requests as system memory allows.</span></span> <span data-ttu-id="cd72b-181">Si hay más solicitudes que subprocesos de grupo, las solicitudes adicionales permanecen en la cola hasta que haya disponibles subprocesos de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-181">If there are more requests than thread pool threads, the additional requests remain queued until thread pool threads become available.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-182">En el ejemplo de código siguiente se muestra cómo recuperar un recuento del número de subprocesos en el grupo de subprocesos máximo y está disponible.</span><span class="sxs-lookup"><span data-stu-id="cd72b-182">The following code example shows how to retrieve a count of the maximum and available number of threads in the thread pool.</span></span> <span data-ttu-id="cd72b-183">Un elemento de trabajo se pone en cola que usa `FileStream` para escribir en dos archivos de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="cd72b-183">A work item is queued that uses `FileStream` to asynchronously write to two files.</span></span> <span data-ttu-id="cd72b-184">Se superó el tiempo de los métodos de devolución de llamada se superpongan.</span><span class="sxs-lookup"><span data-stu-id="cd72b-184">The callback methods are timed to overlap.</span></span> <span data-ttu-id="cd72b-185">Un subproceso de trabajo controla el elemento de trabajo y, según la velocidad y el número de procesadores del equipo, uno o dos subprocesos de puerto de finalización controlan las operaciones de escritura.</span><span class="sxs-lookup"><span data-stu-id="cd72b-185">A worker thread handles the work item and, depending on the speed and number of processors on the computer, one or two completion port threads handle the write operations.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetAvailableThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetAvailableThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="GetMinThreads">
      <MemberSignature Language="C#" Value="public static void GetMinThreads (out int workerThreads, out int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void GetMinThreads([out] int32&amp; workerThreads, [out] int32&amp; completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub GetMinThreads (ByRef workerThreads As Integer, ByRef completionPortThreads As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void GetMinThreads([Runtime::InteropServices::Out] int % workerThreads, [Runtime::InteropServices::Out] int % completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member GetMinThreads :  *  -&gt; unit" Usage="System.Threading.ThreadPool.GetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" RefType="out" />
        <Parameter Name="completionPortThreads" Type="System.Int32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="cd72b-186">Cuando este método vuelve, contiene el número mínimo de subprocesos de trabajo que el grupo de subprocesos crea a petición.</span><span class="sxs-lookup"><span data-stu-id="cd72b-186">When this method returns, contains the minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="cd72b-187">Cuando este método vuelve, contiene el número mínimo de subprocesos de E/S asincrónicos que el grupo de subprocesos crea a petición.</span><span class="sxs-lookup"><span data-stu-id="cd72b-187">When this method returns, contains the minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="cd72b-188">Recupera el número mínimo de subprocesos que el grupo de subprocesos crea a petición, según se realizan nuevas solicitudes, antes de conmutar a un algoritmo para administrar la creación y destrucción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-188">Retrieves the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-189">El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría.</span><span class="sxs-lookup"><span data-stu-id="cd72b-189">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="cd72b-190">De forma predeterminada, el número mínimo de subprocesos se establece en el número de procesadores en un sistema.</span><span class="sxs-lookup"><span data-stu-id="cd72b-190">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="cd72b-191">Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas.</span><span class="sxs-lookup"><span data-stu-id="cd72b-191">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="cd72b-192">A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos con el fin de optimizar el rendimiento, que se define como el número de tareas que se completan por unidad de tiempo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-192">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="cd72b-193">Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-193">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-194">Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-194">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-195">El siguiente ejemplo establece el número mínimo de subprocesos de trabajo a cuatro y conserva el valor original para el número mínimo de subprocesos de finalización de E/S asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-195">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="QueueUserWorkItem">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cd72b-196">Pone en cola un método para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="cd72b-196">Queues a method for execution.</span></span> <span data-ttu-id="cd72b-197">El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-197">The method executes when a thread pool thread becomes available.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem callBack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="cd72b-198"><see cref="T:System.Threading.WaitCallback" /> que representa el método que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-198">A <see cref="T:System.Threading.WaitCallback" /> that represents the method to be executed.</span></span></param>
        <summary><span data-ttu-id="cd72b-199">Pone en cola un método para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="cd72b-199">Queues a method for execution.</span></span> <span data-ttu-id="cd72b-200">El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-200">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="cd72b-201"><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-201"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-202">Puede colocar datos requeridos por el método en cola en los campos de instancia de la clase en el que se define el método, o puede usar el <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> sobrecarga que acepta un objeto que contiene los datos necesarios.</span><span class="sxs-lookup"><span data-stu-id="cd72b-202">You can place data required by the queued method in the instance fields of the class in which the method is defined, or you can use the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29> overload that accepts an object containing the necessary data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-203">Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.WaitCallback> constructor y basta con usar el `AddressOf` operador al pasar el método de devolución de llamada a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-203">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="cd72b-204">Visual Basic llama automáticamente al constructor de delegado correcto.</span><span class="sxs-lookup"><span data-stu-id="cd72b-204">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-205">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-205">Version Information</span></span>  
 <span data-ttu-id="cd72b-206">En .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-206">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="cd72b-207">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-207">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-208">En el ejemplo siguiente se usa el <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> sobrecarga del método para poner en cola una tarea, que viene representado por la `ThreadProc` método, se debe ejecutar cuando un subproceso esté disponible.</span><span class="sxs-lookup"><span data-stu-id="cd72b-208">The following example uses the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29> method overload to queue a task, which is represented by the `ThreadProc` method, to execute when a thread becomes available.</span></span> <span data-ttu-id="cd72b-209">No hay información de la tarea se suministra con esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="cd72b-209">No task information is supplied with this overload.</span></span> <span data-ttu-id="cd72b-210">Por lo tanto, la información que está disponible para el `ThreadProc` método se limita a la que pertenece el método de objeto.</span><span class="sxs-lookup"><span data-stu-id="cd72b-210">Therefore, the information that is available to the `ThreadProc` method is limited to the object the method belongs to.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cd72b-211"><paramref name="callBack" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-211"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cd72b-212">Common Language Runtime (CLR) está en un host y el host no admite esta acción.</span><span class="sxs-lookup"><span data-stu-id="cd72b-212">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-213">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-213">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool QueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="cd72b-214"><see cref="T:System.Threading.WaitCallback" /> que representa el método que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-214">A <see cref="T:System.Threading.WaitCallback" /> representing the method to execute.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-215">Objeto que contiene los datos que va a usar el método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-215">An object containing data to be used by the method.</span></span></param>
        <summary><span data-ttu-id="cd72b-216">Pone un método en cola para su ejecución y especifica un objeto que contiene los datos que debe usar el método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-216">Queues a method for execution, and specifies an object containing data to be used by the method.</span></span> <span data-ttu-id="cd72b-217">El método se ejecuta cuando hay disponible un subproceso de grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-217">The method executes when a thread pool thread becomes available.</span></span></summary>
        <returns><span data-ttu-id="cd72b-218"><see langword="true" /> si el método se pone en la cola correctamente; se produce la excepción <see cref="T:System.NotSupportedException" /> si no se puede poner en la cola el elemento de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-218"><see langword="true" /> if the method is successfully queued; <see cref="T:System.NotSupportedException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-219">Si el método de devolución de llamada requiere datos complejos, puede definir una clase que contenga los datos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-219">If the callback method requires complex data, you can define a class to contain the data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="cd72b-220">Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.WaitCallback> constructor y basta con usar el `AddressOf` operador al pasar el método de devolución de llamada a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-220">Visual Basic users can omit the <xref:System.Threading.WaitCallback> constructor, and simply use the `AddressOf` operator when passing the callback method to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>.</span></span> <span data-ttu-id="cd72b-221">Visual Basic llama automáticamente al constructor de delegado correcto.</span><span class="sxs-lookup"><span data-stu-id="cd72b-221">Visual Basic automatically calls the correct delegate constructor.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-222">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-222">Version Information</span></span>  
 <span data-ttu-id="cd72b-223">En .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-223">In the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method.</span></span> <span data-ttu-id="cd72b-224">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-224">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-225">En el ejemplo siguiente se usa el grupo de subprocesos de .NET para calcular el `Fibonacci` resultado para cinco números entre 20 y 40.</span><span class="sxs-lookup"><span data-stu-id="cd72b-225">The following example uses the .NET thread pool to calculate the `Fibonacci` result for five numbers between 20 and 40.</span></span> <span data-ttu-id="cd72b-226">Cada resultado de `Fibonacci` se representa mediante la clase `Fibonacci`, que proporciona un método denominado `ThreadPoolCallback` que realiza el cálculo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-226">Each `Fibonacci` result is represented by the `Fibonacci` class, which provides a method named `ThreadPoolCallback` that performs the calculation.</span></span> <span data-ttu-id="cd72b-227">Se crea un objeto que representa cada valor de `Fibonacci` y el método `ThreadPoolCallback` se pasa a <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, que asigna un subproceso disponible en el grupo para ejecutar el método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-227">An object that represents each `Fibonacci` value is created, and the `ThreadPoolCallback` method is passed to <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A>, which assigns an available thread in the pool to execute the method.</span></span>  
  
 <span data-ttu-id="cd72b-228">Dado que cada `Fibonacci` objeto se asigna un valor semialeatorio para calcular y dado que cada subproceso compite para obtener tiempo de procesador, no puede saber de antemano cuánto tardará cinco calcular todos los resultados.</span><span class="sxs-lookup"><span data-stu-id="cd72b-228">Because each `Fibonacci` object is given a semi-random value to compute, and because each thread will be competing for processor time, you cannot know in advance how long it will take for all five results to be calculated.</span></span> <span data-ttu-id="cd72b-229">Por eso se pasa a cada objeto `Fibonacci` una instancia de la clase <xref:System.Threading.ManualResetEvent> durante la construcción.</span><span class="sxs-lookup"><span data-stu-id="cd72b-229">That is why each `Fibonacci` object is passed an instance of the <xref:System.Threading.ManualResetEvent> class during construction.</span></span> <span data-ttu-id="cd72b-230">Cada objeto indica que el objeto de evento proporcionado cuando su cálculo está completo, que permite que el subproceso principal bloquee la ejecución con <xref:System.Threading.WaitHandle.WaitAll%2A> hasta los cinco `Fibonacci` objetos hayan calculado un resultado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-230">Each object signals the provided event object when its calculation is complete, which allows the primary thread to block execution with <xref:System.Threading.WaitHandle.WaitAll%2A> until all five `Fibonacci` objects have calculated a result.</span></span> <span data-ttu-id="cd72b-231">El método `Main` muestra entonces cada resultado de `Fibonacci`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-231">The `Main` method then displays each `Fibonacci` result.</span></span>
  
 [!code-cpp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool QueueUserWorkItem1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool QueueUserWorkItem1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cd72b-232">Common Language Runtime (CLR) está en un host y el host no admite esta acción.</span><span class="sxs-lookup"><span data-stu-id="cd72b-232">The common language runtime (CLR) is hosted, and the host does not support this action.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cd72b-233"><paramref name="callBack" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-233"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-234">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-234">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="QueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool QueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool QueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.QueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function QueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool QueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member QueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.QueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" />
        <Parameter Name="state" Type="TState" />
        <Parameter Name="preferLocal" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="RegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cd72b-235">Registra un delegado que está esperando a una clase <see cref="T:System.Threading.WaitHandle" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-235">Registers a delegate that is waiting for a <see cref="T:System.Threading.WaitHandle" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-236">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-236">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-237">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-237">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-238">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-238">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-239">Objeto que se pasa al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-239">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-240">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-240">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-241">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-241">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-242">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-242">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-243">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-243"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-244">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits con signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-244">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="cd72b-245"><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-245">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-246">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-246">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-247">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-247">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-248">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-248">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="cd72b-249">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-249">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="cd72b-250">Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="cd72b-250">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cd72b-251">El objeto especificado está en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-251">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="cd72b-252">Transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-252">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="cd72b-253">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-253">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cd72b-254">Si el estado del objeto no esté señalizado, el método registra una operación de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-254">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="cd72b-255">La operación de espera se realiza mediante un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-255">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="cd72b-256">El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-256">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="cd72b-257">Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-257">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd72b-258">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-258">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="cd72b-259">En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-259">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="cd72b-260">Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-260">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cd72b-261">El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-261">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="cd72b-262">Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función.</span><span class="sxs-lookup"><span data-stu-id="cd72b-262">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="cd72b-263">Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-263">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="cd72b-264">La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-264">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="cd72b-265">Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-265">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="cd72b-266">Por ejemplo, el recuento de un semáforo se reduce en uno.</span><span class="sxs-lookup"><span data-stu-id="cd72b-266">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-267">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-267">Version Information</span></span>  
 <span data-ttu-id="cd72b-268">A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-268">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="cd72b-269">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-269">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-270">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-270">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-271">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-271">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-272">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-272">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-273">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-273">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-274">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-274">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-275">Objeto que se ha pasado al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-275">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-276">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-276">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-277">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-277">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-278">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-278">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-279">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-279"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-280">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 64 bits con signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-280">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="cd72b-281"><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-281">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-282">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-282">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-283">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-283">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-284">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-284">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="cd72b-285">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-285">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="cd72b-286">Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="cd72b-286">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cd72b-287">El objeto especificado está en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-287">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="cd72b-288">Transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-288">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="cd72b-289">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-289">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cd72b-290">Si el estado del objeto no esté señalizado, el método registra una operación de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-290">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="cd72b-291">La operación de espera se realiza mediante un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-291">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="cd72b-292">El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-292">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="cd72b-293">Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-293">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd72b-294">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-294">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="cd72b-295">En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-295">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="cd72b-296">Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-296">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cd72b-297">El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-297">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="cd72b-298">Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función.</span><span class="sxs-lookup"><span data-stu-id="cd72b-298">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="cd72b-299">Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-299">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="cd72b-300">La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-300">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="cd72b-301">Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-301">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="cd72b-302">Por ejemplo, el recuento de un semáforo se reduce en uno.</span><span class="sxs-lookup"><span data-stu-id="cd72b-302">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-303">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-303">Version Information</span></span>  
 <span data-ttu-id="cd72b-304">A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-304">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="cd72b-305">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-305">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-306">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-306">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-307">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-307">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-308">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-308">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-309">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-309">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-310">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-310">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-311">Objeto que se ha pasado al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-311">The object passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="cd72b-312">Tiempo de espera representado por <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-312">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="cd72b-313">Si <paramref name="timeout" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-313">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-314">Si <paramref name="timeout" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-314">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-315">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-315"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-316">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un valor <see cref="T:System.TimeSpan" /> como tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-316">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out.</span></span></summary>
        <returns><span data-ttu-id="cd72b-317"><see cref="T:System.Threading.RegisteredWaitHandle" /> que encapsula el identificador nativo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-317">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that encapsulates the native handle.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-318">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-318">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-319">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-319">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-320">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-320">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="cd72b-321">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-321">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="cd72b-322">Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="cd72b-322">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cd72b-323">El objeto especificado está en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-323">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="cd72b-324">Transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-324">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="cd72b-325">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-325">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cd72b-326">Si el estado del objeto no esté señalizado, el método registra una operación de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-326">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="cd72b-327">La operación de espera se realiza mediante un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-327">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="cd72b-328">El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-328">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="cd72b-329">Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-329">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd72b-330">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-330">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="cd72b-331">En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-331">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="cd72b-332">Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-332">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cd72b-333">El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-333">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="cd72b-334">Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función.</span><span class="sxs-lookup"><span data-stu-id="cd72b-334">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="cd72b-335">Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-335">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="cd72b-336">La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-336">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="cd72b-337">Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-337">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="cd72b-338">Por ejemplo, el recuento de un semáforo se reduce en uno.</span><span class="sxs-lookup"><span data-stu-id="cd72b-338">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-339">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-339">Version Information</span></span>  
 <span data-ttu-id="cd72b-340">A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-340">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="cd72b-341">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-341">In earlier versions, the principal information is not propagated.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-342">El parámetro <paramref name="timeout" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-342">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cd72b-343">El valor del parámetro <paramref name="timeout" /> es mayor que el valor de la propiedad <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-343">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-344">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-344">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="RegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle RegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.RegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function RegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ RegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member RegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.RegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-345">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-345">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-346">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-346">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-347">Delegado de <see cref="T:System.Threading.WaitOrTimerCallback" /> al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-347">The <see cref="T:System.Threading.WaitOrTimerCallback" /> delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-348">Objeto que se ha pasado al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-348">The object passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-349">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-349">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-350">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-350">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-351">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-351">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-352">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-352"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-353">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits sin signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-353">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span></summary>
        <returns><span data-ttu-id="cd72b-354"><see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-354">The <see cref="T:System.Threading.RegisteredWaitHandle" /> that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-355">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-355">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-356">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-356">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-357">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-357">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 <span data-ttu-id="cd72b-358">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método pone en cola el delegado especificado en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-358">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method queues the specified delegate to the thread pool.</span></span> <span data-ttu-id="cd72b-359">Un subproceso de trabajo ejecutará al delegado cuando se produce uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="cd72b-359">A worker thread will execute the delegate when one of the following occurs:</span></span>  
  
-   <span data-ttu-id="cd72b-360">El objeto especificado está en el estado señalado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-360">The specified object is in the signaled state.</span></span>  
  
-   <span data-ttu-id="cd72b-361">Transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-361">The time-out interval elapses.</span></span>  
  
 <span data-ttu-id="cd72b-362">El <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método comprueba el estado actual del objeto especificado <xref:System.Threading.WaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-362">The <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method checks the current state of the specified object's <xref:System.Threading.WaitHandle>.</span></span> <span data-ttu-id="cd72b-363">Si el estado del objeto no esté señalizado, el método registra una operación de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-363">If the object's state is unsignaled, the method registers a wait operation.</span></span> <span data-ttu-id="cd72b-364">La operación de espera se realiza mediante un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-364">The wait operation is performed by a thread from the thread pool.</span></span> <span data-ttu-id="cd72b-365">El delegado se ejecuta un subproceso de trabajo cuando se señaliza el estado del objeto o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-365">The delegate is executed by a worker thread when the object's state becomes signaled or the time-out interval elapses.</span></span> <span data-ttu-id="cd72b-366">Si el `timeOutInterval` parámetro no es 0 (cero) y el `executeOnlyOnce` parámetro es `false`, el temporizador se restablece cada vez que el evento está señalado o transcurre el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-366">If the `timeOutInterval` parameter is not 0 (zero) and the `executeOnlyOnce` parameter is `false`, the timer is reset every time the event is signaled or the time-out interval elapses.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="cd72b-367">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-367">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span> <span data-ttu-id="cd72b-368">En lugar de un <xref:System.Threading.Mutex>, utilice un <xref:System.Threading.Semaphore> con un recuento máximo de 1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-368">Instead of a <xref:System.Threading.Mutex>, use a <xref:System.Threading.Semaphore> with a maximum count of 1.</span></span>  
  
 <span data-ttu-id="cd72b-369">Para cancelar la operación de espera, llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-369">To cancel the wait operation, call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="cd72b-370">El subproceso espera usa Win32 `WaitForMultipleObjects` función para supervisar las operaciones de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-370">The wait thread uses the Win32 `WaitForMultipleObjects` function to monitor registered wait operations.</span></span> <span data-ttu-id="cd72b-371">Por lo tanto, si se debe utilizar el mismo identificador de sistema operativo nativo en varias llamadas a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, debe duplicar el identificador de Win32 `DuplicateHandle` función.</span><span class="sxs-lookup"><span data-stu-id="cd72b-371">Therefore, if you must use the same native operating system handle in multiple calls to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, you must duplicate the handle using the Win32 `DuplicateHandle` function.</span></span> <span data-ttu-id="cd72b-372">Tenga en cuenta que no se debe marcar un objeto de evento que se pasa a <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, ya que el subproceso de espera podría no detectar que el evento está señalado antes de restablecerse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-372">Note that you should not pulse an event object passed to <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A>, because the wait thread might not detect that the event is signaled before it is reset.</span></span>  
  
 <span data-ttu-id="cd72b-373">La función modifica el estado de algunos tipos de objetos de sincronización antes de devolverse.</span><span class="sxs-lookup"><span data-stu-id="cd72b-373">Before returning, the function modifies the state of some types of synchronization objects.</span></span> <span data-ttu-id="cd72b-374">Modificación se produce sólo para el objeto cuyo estado señalado provocó que se debe cumplir la condición de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-374">Modification occurs only for the object whose signaled state caused the wait condition to be satisfied.</span></span> <span data-ttu-id="cd72b-375">Por ejemplo, el recuento de un semáforo se reduce en uno.</span><span class="sxs-lookup"><span data-stu-id="cd72b-375">For example, the count of a semaphore is decreased by one.</span></span>  
  
## <a name="version-information"></a><span data-ttu-id="cd72b-376">Información de versión</span><span class="sxs-lookup"><span data-stu-id="cd72b-376">Version Information</span></span>  
 <span data-ttu-id="cd72b-377">A partir de .NET Framework versión 2.0, el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> valor de propiedad se propaga a los subprocesos de trabajo en una cola mediante el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-377">Starting with the .NET Framework version 2.0, the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property value is propagated to worker threads queued using the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method.</span></span> <span data-ttu-id="cd72b-378">En versiones anteriores, no se propaga la información de la entidad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-378">In earlier versions, the principal information is not propagated.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-379">El ejemplo siguiente muestra cómo usar el <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método para ejecutar un método de devolución de llamada especificada cuando se señala un identificador de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-379">The following example shows how to use the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method to execute a specified callback method when a specified wait handle is signaled.</span></span> <span data-ttu-id="cd72b-380">En este ejemplo, el método de devolución de llamada es `WaitProc`, y el identificador de espera es un <xref:System.Threading.AutoResetEvent>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-380">In this example, the callback method is `WaitProc`, and the wait handle is an <xref:System.Threading.AutoResetEvent>.</span></span>  
  
 <span data-ttu-id="cd72b-381">El ejemplo define un `TaskInfo` clase para contener la información que se pasa a la devolución de llamada cuando se ejecuta.</span><span class="sxs-lookup"><span data-stu-id="cd72b-381">The example defines a `TaskInfo` class to hold the information that is passed to the callback when it executes.</span></span> <span data-ttu-id="cd72b-382">El ejemplo se crea un `TaskInfo` de objeto y lo asigna algunos datos de cadena.</span><span class="sxs-lookup"><span data-stu-id="cd72b-382">The example creates a `TaskInfo` object and assigns it some string data.</span></span> <span data-ttu-id="cd72b-383">El <xref:System.Threading.RegisteredWaitHandle> devuelta por la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método se asigna a la `Handle` campo de la `TaskInfo` objeto para que el método de devolución de llamada tiene acceso a la <xref:System.Threading.RegisteredWaitHandle>.</span><span class="sxs-lookup"><span data-stu-id="cd72b-383">The <xref:System.Threading.RegisteredWaitHandle> that is returned by the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method is assigned to the `Handle` field of the `TaskInfo` object so that the callback method has access to the <xref:System.Threading.RegisteredWaitHandle>.</span></span>  
  
 <span data-ttu-id="cd72b-384">Además de especificar `TaskInfo` como el objeto debe pasar al método de devolución de llamada, la llamada a la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método especifica el <xref:System.Threading.AutoResetEvent> que esperará la tarea, un <xref:System.Threading.WaitOrTimerCallback> delegado que representa el `WaitProc` el método de devolución de llamada, un intervalo de tiempo de espera un segundo y varias devoluciones de llamada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-384">In addition to specifying `TaskInfo` as the object to pass to the callback method, the call to the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method specifies the <xref:System.Threading.AutoResetEvent> that the task will wait for, a <xref:System.Threading.WaitOrTimerCallback> delegate that represents the `WaitProc` callback method, a one second time-out interval, and multiple callbacks.</span></span>  
  
 <span data-ttu-id="cd72b-385">Cuando el subproceso principal señala el <xref:System.Threading.AutoResetEvent> mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método, el <xref:System.Threading.WaitOrTimerCallback> se invoca el delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-385">When the main thread signals the <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, the <xref:System.Threading.WaitOrTimerCallback> delegate is invoked.</span></span> <span data-ttu-id="cd72b-386">El `WaitProc` método pruebas <xref:System.Threading.RegisteredWaitHandle> para determinar si se ha producido un tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-386">The `WaitProc` method tests <xref:System.Threading.RegisteredWaitHandle> to determine whether a time-out occurred.</span></span> <span data-ttu-id="cd72b-387">Si la devolución de llamada se invocó porque se señaló el identificador de espera, el `WaitProc` anula el registro de método la <xref:System.Threading.RegisteredWaitHandle>, deteniendo las devoluciones de llamada adicionales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-387">If the callback was invoked because the wait handle was signaled, the `WaitProc` method unregisters the <xref:System.Threading.RegisteredWaitHandle>, stopping additional callbacks.</span></span> <span data-ttu-id="cd72b-388">En el caso de un tiempo de espera, la tarea sigue esperando.</span><span class="sxs-lookup"><span data-stu-id="cd72b-388">In the case of a time-out, the task continues to wait.</span></span> <span data-ttu-id="cd72b-389">El `WaitProc` método termina con la impresión de un mensaje en la consola.</span><span class="sxs-lookup"><span data-stu-id="cd72b-389">The `WaitProc` method ends by printing a message to the console.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool RegisterWaitForSingleObject0#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool RegisterWaitForSingleObject0/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-390">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-390">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-391">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-391">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetMaxThreads">
      <MemberSignature Language="C#" Value="public static bool SetMaxThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMaxThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMaxThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMaxThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMaxThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMaxThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMaxThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="cd72b-392">Número máximo de subprocesos de trabajo en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-392">The maximum number of worker threads in the thread pool.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="cd72b-393">Número máximo de subprocesos de E/S asincrónicos en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-393">The maximum number of asynchronous I/O threads in the thread pool.</span></span></param>
        <summary><span data-ttu-id="cd72b-394">Establece el número de solicitudes al grupo de subprocesos que pueden estar activas al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-394">Sets the number of requests to the thread pool that can be active concurrently.</span></span> <span data-ttu-id="cd72b-395">Todas las solicitudes que pasen de ese número permanecen en la cola hasta que haya disponibles subprocesos de grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-395">All requests above that number remain queued until thread pool threads become available.</span></span></summary>
        <returns><span data-ttu-id="cd72b-396">Es <see langword="true" /> si el cambio se realiza correctamente; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-396"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-397">No se puede establecer el número máximo de subprocesos de trabajo o subprocesos de finalización de E/S en un número menor que el número de procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-397">You cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the number of processors on the computer.</span></span> <span data-ttu-id="cd72b-398">Para determinar cuántos procesadores están presentes, recuperar el valor de la <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-398">To determine how many processors are present, retrieve the value of the <xref:System.Environment.ProcessorCount%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="cd72b-399">Además, no se puede establecer el número máximo de subprocesos de trabajo o subprocesos de finalización de E/S en un número menor que el correspondiente número mínimo de subprocesos de trabajo o subprocesos de finalización de E/S.</span><span class="sxs-lookup"><span data-stu-id="cd72b-399">In addition, you cannot set the maximum number of worker threads or I/O completion threads to a number smaller than the corresponding minimum number of worker threads or I/O completion threads.</span></span> <span data-ttu-id="cd72b-400">Para determinar el tamaño mínimo de subprocesos del grupo, llame a la <xref:System.Threading.ThreadPool.GetMinThreads%2A> método.</span><span class="sxs-lookup"><span data-stu-id="cd72b-400">To determine the minimum thread pool size,  call the <xref:System.Threading.ThreadPool.GetMinThreads%2A> method.</span></span>  
  
 <span data-ttu-id="cd72b-401">Si se hospeda common language runtime, por ejemplo mediante Internet Information Services (IIS) o SQL Server, el host puede limitar o evitar cambios en el tamaño del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-401">If the common language runtime is hosted, for example by Internet Information Services (IIS) or SQL Server, the host can limit or prevent changes to the thread pool size.</span></span>  
  
 <span data-ttu-id="cd72b-402">Tenga cuidado al cambiar el número máximo de subprocesos en el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-402">Use caution when changing the maximum number of threads in the thread pool.</span></span> <span data-ttu-id="cd72b-403">Mientras que podría beneficiarse del código, los cambios podrían tener un efecto adverso en bibliotecas de código que usar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-403">While your code might benefit, the changes might have an adverse effect on code libraries you use.</span></span>  
  
 <span data-ttu-id="cd72b-404">Establecer el tamaño del grupo de subprocesos demasiado grande puede provocar problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="cd72b-404">Setting the thread pool size too large can cause performance problems.</span></span> <span data-ttu-id="cd72b-405">Si se están ejecutando demasiados subprocesos al mismo tiempo, sobrecarga la conmutación de tareas se vuelve un factor importante.</span><span class="sxs-lookup"><span data-stu-id="cd72b-405">If too many threads are executing at the same time, the task switching overhead becomes a significant factor.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="cd72b-406">la capacidad para controlar los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-406">for the ability to control threads.</span></span> <span data-ttu-id="cd72b-407">Valor de permiso: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="cd72b-407">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="SetMinThreads">
      <MemberSignature Language="C#" Value="public static bool SetMinThreads (int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool SetMinThreads(int32 workerThreads, int32 completionPortThreads) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.SetMinThreads(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function SetMinThreads (workerThreads As Integer, completionPortThreads As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool SetMinThreads(int workerThreads, int completionPortThreads);" />
      <MemberSignature Language="F#" Value="static member SetMinThreads : int * int -&gt; bool" Usage="System.Threading.ThreadPool.SetMinThreads (workerThreads, completionPortThreads)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="workerThreads" Type="System.Int32" />
        <Parameter Name="completionPortThreads" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="workerThreads"><span data-ttu-id="cd72b-408">Número mínimo de subprocesos de trabajo que el grupo de subprocesos crea a petición.</span><span class="sxs-lookup"><span data-stu-id="cd72b-408">The minimum number of worker threads that the thread pool creates on demand.</span></span></param>
        <param name="completionPortThreads"><span data-ttu-id="cd72b-409">Número mínimo de subprocesos de E/S asincrónicos que el grupo de subprocesos crea a petición.</span><span class="sxs-lookup"><span data-stu-id="cd72b-409">The minimum number of asynchronous I/O threads that the thread pool creates on demand.</span></span></param>
        <summary><span data-ttu-id="cd72b-410">Establece el número mínimo de subprocesos que el grupo de subprocesos crea a petición, según se realizan nuevas solicitudes, antes de conmutar a un algoritmo para administrar la creación y destrucción de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-410">Sets the minimum number of threads the thread pool creates on demand, as new requests are made, before switching to an algorithm for managing thread creation and destruction.</span></span></summary>
        <returns><span data-ttu-id="cd72b-411">Es <see langword="true" /> si el cambio se realiza correctamente; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-411"><see langword="true" /> if the change is successful; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-412">El grupo de subprocesos proporciona nuevos subprocesos de trabajo o subprocesos de finalización de E/S a petición hasta que alcanza el valor mínimo para cada categoría.</span><span class="sxs-lookup"><span data-stu-id="cd72b-412">The thread pool provides new worker threads or I/O completion threads on demand until it reaches the minimum for each category.</span></span> <span data-ttu-id="cd72b-413">Cuando se alcanza el mínimo, el grupo de subprocesos puede crear subprocesos adicionales en esa categoría o espere hasta que se completen algunas tareas.</span><span class="sxs-lookup"><span data-stu-id="cd72b-413">When the minimum is reached, the thread pool can create additional threads in that category or wait until some tasks complete.</span></span> <span data-ttu-id="cd72b-414">A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el grupo de subprocesos crea y destruye subprocesos con el fin de optimizar el rendimiento, que se define como el número de tareas que se completan por unidad de tiempo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-414">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the thread pool creates and destroys threads in order to optimize throughput, which is defined as the number of tasks that complete per unit of time.</span></span> <span data-ttu-id="cd72b-415">Si hay demasiados pocos subprocesos, puede que los recursos disponibles no se usen de manera óptima, mientras que si hay demasiados subprocesos, puede aumentar la contención de recursos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-415">Too few threads might not make optimal use of available resources, whereas too many threads could increase resource contention.</span></span>  
  
 <span data-ttu-id="cd72b-416">Cuando la demanda es baja, el número real de subprocesos del grupo de subprocesos puede descender por debajo de los valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-416">When demand is low, the actual number of thread pool threads can fall below the minimum values.</span></span>  
  
 <span data-ttu-id="cd72b-417">Si especifica un número negativo o un número mayor que el número máximo de subprocesos de ThreadPool active (obtenidos mediante <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> devuelve `false` y no cambia ninguno de los valores mínimos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-417">If you specify a negative number or a number larger than the maximum number of active thread pool threads (obtained using <xref:System.Threading.ThreadPool.GetMaxThreads%2A>), <xref:System.Threading.ThreadPool.SetMinThreads%2A> returns `false` and does not change either of the minimum values.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-418">De forma predeterminada, el número mínimo de subprocesos se establece en el número de procesadores en un sistema.</span><span class="sxs-lookup"><span data-stu-id="cd72b-418">By default, the minimum number of threads is set to the number of processors on a system.</span></span> <span data-ttu-id="cd72b-419">Puede usar el <xref:System.Threading.ThreadPool.SetMinThreads%2A> método para aumentar la ofthreads número mínimo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-419">You can use the <xref:System.Threading.ThreadPool.SetMinThreads%2A> method to increase the minimum number ofthreads.</span></span> <span data-ttu-id="cd72b-420">Sin embargo, aumentar innecesariamente estos valores puede causar problemas de rendimiento.</span><span class="sxs-lookup"><span data-stu-id="cd72b-420">However, unnecessarily increasing these values can cause performance problems.</span></span> <span data-ttu-id="cd72b-421">Si se inician demasiadas tareas al mismo tiempo, puede que todas ellas parezcan funcionar con lentitud.</span><span class="sxs-lookup"><span data-stu-id="cd72b-421">If too many tasks start at the same time, all of them might appear to be slow.</span></span> <span data-ttu-id="cd72b-422">En la mayoría de los casos, el grupo de subprocesos funcionará mejor con su propio algoritmo de asignación de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-422">In most cases, the thread pool will perform better with its own algorithm for allocating threads.</span></span> <span data-ttu-id="cd72b-423">A menos que el número de procesadores también puede afectar negativamente al rendimiento, lo que reduce al mínimo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-423">Reducing the minimum to less than the number of processors can also hurt performance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="cd72b-424">El siguiente ejemplo establece el número mínimo de subprocesos de trabajo a cuatro y conserva el valor original para el número mínimo de subprocesos de finalización de E/S asincrónicos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-424">The following example sets the minimum number of worker threads to four, and preserves the original value for the minimum number of asynchronous I/O completion threads.</span></span>  
  
 [!code-cpp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/CS/source.cs#1)]
 [!code-vb[System.Threading.ThreadPool.GetSetMinThreads#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ThreadPool.GetSetMinThreads/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="cd72b-425">la capacidad para controlar los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-425">for the ability to control threads.</span></span> <span data-ttu-id="cd72b-426">Valor de permiso: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="cd72b-426">Permission value: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <altmember cref="M:System.Threading.ThreadPool.GetMinThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetMaxThreads(System.Int32@,System.Int32@)" />
        <altmember cref="M:System.Threading.ThreadPool.GetAvailableThreads(System.Int32@,System.Int32@)" />
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueNativeOverlapped">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueNativeOverlapped (System.Threading.NativeOverlapped* overlapped);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueNativeOverlapped(valuetype System.Threading.NativeOverlapped* overlapped) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped(System.Threading.NativeOverlapped*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueNativeOverlapped(System::Threading::NativeOverlapped* overlapped);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueNativeOverlapped : nativeptr&lt;System.Threading.NativeOverlapped&gt; -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueNativeOverlapped overlapped" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="overlapped" Type="System.Threading.NativeOverlapped*" />
      </Parameters>
      <Docs>
        <param name="overlapped"><span data-ttu-id="cd72b-427">Estructura <see cref="T:System.Threading.NativeOverlapped" /> que se va a poner en cola.</span><span class="sxs-lookup"><span data-stu-id="cd72b-427">The <see cref="T:System.Threading.NativeOverlapped" /> structure to queue.</span></span></param>
        <summary><span data-ttu-id="cd72b-428">Pone en cola una operación de E/S superpuesta para que se ejecute.</span><span class="sxs-lookup"><span data-stu-id="cd72b-428">Queues an overlapped I/O operation for execution.</span></span></summary>
        <returns><span data-ttu-id="cd72b-429">Es <see langword="true" /> si la operación se puso correctamente en la cola de un puerto de finalización de E/S; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-429"><see langword="true" /> if the operation was successfully queued to an I/O completion port; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-430">Para obtener información acerca de cómo utilizar Win32 nativa superpuesta E/S, vea el <xref:System.Threading.Overlapped> (clase), el <xref:System.Threading.NativeOverlapped> estructura y el `OVERLAPPED` estructura en Platform SDK de Win32.</span><span class="sxs-lookup"><span data-stu-id="cd72b-430">For information about using native Win32 overlapped I/O, see the <xref:System.Threading.Overlapped> class, the <xref:System.Threading.NativeOverlapped> structure, and the `OVERLAPPED` structure in the Win32 Platform SDK.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-431">Mediante el <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> método podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-431">Using the <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A> method could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-432">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-432">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-433">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, la pila del subproceso de grupo no tiene el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-433">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueNativeOverlapped%2A>, the stack of the thread pool thread does not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-434">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-434">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-435">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-436">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.IThreadPoolWorkItem callBack, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.IThreadPoolWorkItem callBack, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.IThreadPoolWorkItem,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As IThreadPoolWorkItem, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::IThreadPoolWorkItem ^ callBack, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.IThreadPoolWorkItem * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.IThreadPoolWorkItem" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="callBack">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem (System.Threading.WaitCallback callBack, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem(class System.Threading.WaitCallback callBack, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem(System.Threading.WaitCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem (callBack As WaitCallback, state As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool UnsafeQueueUserWorkItem(System::Threading::WaitCallback ^ callBack, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : System.Threading.WaitCallback * obj -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBack" Type="System.Threading.WaitCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callBack"><span data-ttu-id="cd72b-437"><see cref="T:System.Threading.WaitCallback" /> que representa el delegado al que se va a invocar cuando un subproceso del grupo de subprocesos seleccione el elemento de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-437">A <see cref="T:System.Threading.WaitCallback" /> that represents the delegate to invoke when a thread in the thread pool picks up the work item.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-438">Objeto que se pasa al delegado cuando se atiende desde el grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-438">The object that is passed to the delegate when serviced from the thread pool.</span></span></param>
        <summary><span data-ttu-id="cd72b-439">Pone en cola el delegado especificado en el grupo de subprocesos, pero no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-439">Queues the specified delegate to the thread pool, but does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="cd72b-440"><see langword="true" /> si el método se ejecuta correctamente; se produce la excepción <see cref="T:System.OutOfMemoryException" /> si el elemento de trabajo no se puede poner en la cola.</span><span class="sxs-lookup"><span data-stu-id="cd72b-440"><see langword="true" /> if the method succeeds; <see cref="T:System.OutOfMemoryException" /> is thrown if the work item could not be queued.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-441">A diferencia de la <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> método <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-441">Unlike the <xref:System.Threading.ThreadPool.QueueUserWorkItem%2A> method, <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="cd72b-442">Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-442">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-443">Uso de <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-443">Using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-444">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-444">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-445">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-445">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeQueueUserWorkItem%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-446">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-446">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-447">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-447">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="cd72b-448">Se ha encontrado una condición de falta de memoria.</span><span class="sxs-lookup"><span data-stu-id="cd72b-448">An out-of-memory condition was encountered.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="cd72b-449">No se pudo poner en la cola el elemento de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-449">The work item could not be queued.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="cd72b-450"><paramref name="callBack" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-450"><paramref name="callBack" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-451">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-451">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-452">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-452">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-453">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-453">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeQueueUserWorkItem&lt;TState&gt;">
      <MemberSignature Language="C#" Value="public static bool UnsafeQueueUserWorkItem&lt;TState&gt; (Action&lt;TState&gt; callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool UnsafeQueueUserWorkItem&lt;TState&gt;(class System.Action`1&lt;!!TState&gt; callBack, !!TState state, bool preferLocal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeQueueUserWorkItem``1(System.Action{``0},``0,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeQueueUserWorkItem(Of TState) (callBack As Action(Of TState), state As TState, preferLocal As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename TState&gt;&#xA; static bool UnsafeQueueUserWorkItem(Action&lt;TState&gt; ^ callBack, TState state, bool preferLocal);" />
      <MemberSignature Language="F#" Value="static member UnsafeQueueUserWorkItem : Action&lt;'State&gt; * 'State * bool -&gt; bool" Usage="System.Threading.ThreadPool.UnsafeQueueUserWorkItem (callBack, state, preferLocal)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="TState" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="callBack" Type="System.Action&lt;TState&gt;" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="state" Type="TState" Index="1" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="preferLocal" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <typeparam name="TState">To be added.</typeparam>
        <param name="callBack">To be added.</param>
        <param name="state">To be added.</param>
        <param name="preferLocal">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="UnsafeRegisterWaitForSingleObject">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="cd72b-454">Registra un delegado para que espere a <see cref="T:System.Threading.WaitHandle" />, pero no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-454">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, but does not propagate the calling stack to the worker thread.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Integer, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, int millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-455">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-455">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-456">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-456">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-457">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-457">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-458">Objeto que se pasa al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-458">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-459">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-459">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-460">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-460">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-461">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-461">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-462">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-462"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-463">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y usa un entero de 32 bits con signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-463">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, using a 32-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-464">Este método no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-464">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="cd72b-465">Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-465">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-466">A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-466">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="cd72b-467">Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-467">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-468">Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-468">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-469">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-469">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-470">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-470">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-471">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-471">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="cd72b-472">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-472">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="cd72b-473">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-473">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-474">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-474">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-475">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-475">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-476">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-476">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-477">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-477">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-478">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-478">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-479">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-479">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-480">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-480">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, int64 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As Long, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, long millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * int64 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.Int64" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-481">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-481">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-482">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-482">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-483">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-483">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-484">Objeto que se pasa al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-484">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-485">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-485">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-486">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-486">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-487">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-487">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-488">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-488"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-489">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 64 bits con signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-489">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 64-bit signed integer for the time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-490">Este método no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-490">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="cd72b-491">Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-491">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-492">A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-492">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="cd72b-493">Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-493">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-494">Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-494">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-495">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-495">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-496">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-496">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-497">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-497">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="cd72b-498">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-498">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="cd72b-499">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-499">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-500">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-500">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-501">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-501">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-502">El parámetro <paramref name="millisecondsTimeOutInterval" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-502">The <paramref name="millisecondsTimeOutInterval" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-503">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-503">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-504">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-504">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-505">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-505">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-506">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-506">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, valuetype System.TimeSpan timeout, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, timeout As TimeSpan, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, TimeSpan timeout, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * TimeSpan * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, timeout, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-507">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-507">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-508">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-508">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-509">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-509">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-510">Objeto que se pasa al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-510">The object that is passed to the delegate.</span></span></param>
        <param name="timeout"><span data-ttu-id="cd72b-511">Tiempo de espera representado por <see cref="T:System.TimeSpan" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-511">The time-out represented by a <see cref="T:System.TimeSpan" />.</span></span> <span data-ttu-id="cd72b-512">Si <paramref name="timeout" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-512">If <paramref name="timeout" /> is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-513">Si <paramref name="timeout" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-513">If <paramref name="timeout" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-514">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-514"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-515">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un valor <see cref="T:System.TimeSpan" /> como tiempo de espera. Este método no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-515">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a <see cref="T:System.TimeSpan" /> value for the time-out. This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="cd72b-516">Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-516">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-517">A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-517">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="cd72b-518">Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-518">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-519">Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-519">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-520">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-520">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-521">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-521">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-522">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-522">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="cd72b-523">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-523">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="cd72b-524">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-524">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-525">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-525">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-526">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-526">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="cd72b-527">El parámetro <paramref name="timeout" /> es menor que -1.</span><span class="sxs-lookup"><span data-stu-id="cd72b-527">The <paramref name="timeout" /> parameter is less than -1.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="cd72b-528">El valor del parámetro <paramref name="timeout" /> es mayor que el valor de la propiedad <see cref="F:System.Int32.MaxValue" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-528">The <paramref name="timeout" /> parameter is greater than <see cref="F:System.Int32.MaxValue" />.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-529">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-529">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-530">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-530">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-531">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-531">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-532">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-532">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="UnsafeRegisterWaitForSingleObject">
      <MemberSignature Language="C#" Value="public static System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject (System.Threading.WaitHandle waitObject, System.Threading.WaitOrTimerCallback callBack, object state, uint millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.RegisteredWaitHandle UnsafeRegisterWaitForSingleObject(class System.Threading.WaitHandle waitObject, class System.Threading.WaitOrTimerCallback callBack, object state, unsigned int32 millisecondsTimeOutInterval, bool executeOnlyOnce) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject(System.Threading.WaitHandle,System.Threading.WaitOrTimerCallback,System.Object,System.UInt32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function UnsafeRegisterWaitForSingleObject (waitObject As WaitHandle, callBack As WaitOrTimerCallback, state As Object, millisecondsTimeOutInterval As UInteger, executeOnlyOnce As Boolean) As RegisteredWaitHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::RegisteredWaitHandle ^ UnsafeRegisterWaitForSingleObject(System::Threading::WaitHandle ^ waitObject, System::Threading::WaitOrTimerCallback ^ callBack, System::Object ^ state, System::UInt32 millisecondsTimeOutInterval, bool executeOnlyOnce);" />
      <MemberSignature Language="F#" Value="static member UnsafeRegisterWaitForSingleObject : System.Threading.WaitHandle * System.Threading.WaitOrTimerCallback * obj * uint32 * bool -&gt; System.Threading.RegisteredWaitHandle" Usage="System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject (waitObject, callBack, state, millisecondsTimeOutInterval, executeOnlyOnce)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.ThreadPool</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.RegisteredWaitHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="waitObject" Type="System.Threading.WaitHandle" />
        <Parameter Name="callBack" Type="System.Threading.WaitOrTimerCallback" />
        <Parameter Name="state" Type="System.Object" />
        <Parameter Name="millisecondsTimeOutInterval" Type="System.UInt32" />
        <Parameter Name="executeOnlyOnce" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="waitObject"><span data-ttu-id="cd72b-533">La clase <see cref="T:System.Threading.WaitHandle" /> que se va a registrar.</span><span class="sxs-lookup"><span data-stu-id="cd72b-533">The <see cref="T:System.Threading.WaitHandle" /> to register.</span></span> <span data-ttu-id="cd72b-534">Use un <see cref="T:System.Threading.WaitHandle" /> diferente de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="cd72b-534">Use a <see cref="T:System.Threading.WaitHandle" /> other than <see cref="T:System.Threading.Mutex" />.</span></span></param>
        <param name="callBack"><span data-ttu-id="cd72b-535">Delegado al que se llamará cuando el parámetro <paramref name="waitObject" /> esté marcado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-535">The delegate to call when the <paramref name="waitObject" /> parameter is signaled.</span></span></param>
        <param name="state"><span data-ttu-id="cd72b-536">Objeto que se pasa al delegado.</span><span class="sxs-lookup"><span data-stu-id="cd72b-536">The object that is passed to the delegate.</span></span></param>
        <param name="millisecondsTimeOutInterval"><span data-ttu-id="cd72b-537">Tiempo de espera en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-537">The time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-538">Si el valor del parámetro <paramref name="millisecondsTimeOutInterval" /> es 0 (cero), la función comprueba el estado del objeto y regresa inmediatamente. </span><span class="sxs-lookup"><span data-stu-id="cd72b-538">If the <paramref name="millisecondsTimeOutInterval" /> parameter is 0 (zero), the function tests the object's state and returns immediately.</span></span> <span data-ttu-id="cd72b-539">Si <paramref name="millisecondsTimeOutInterval" /> es -1, el intervalo de tiempo de espera de la función nunca transcurre.</span><span class="sxs-lookup"><span data-stu-id="cd72b-539">If <paramref name="millisecondsTimeOutInterval" /> is -1, the function's time-out interval never elapses.</span></span></param>
        <param name="executeOnlyOnce"><span data-ttu-id="cd72b-540">Es <see langword="true" /> para indicar que el subproceso no esperará en el parámetro <paramref name="waitObject" /> después de haber llamado al delegado; es <see langword="false" /> para indicar que el temporizador se restablecerá cada vez que se complete la operación de espera, hasta que se anule el registro de la espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-540"><see langword="true" /> to indicate that the thread will no longer wait on the <paramref name="waitObject" /> parameter after the delegate has been called; <see langword="false" /> to indicate that the timer is reset every time the wait operation completes until the wait is unregistered.</span></span></param>
        <summary><span data-ttu-id="cd72b-541">Registra un delegado para que espere a la clase <see cref="T:System.Threading.WaitHandle" /> y especifica un entero de 32 bits sin signo como tiempo de espera, en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="cd72b-541">Registers a delegate to wait for a <see cref="T:System.Threading.WaitHandle" />, specifying a 32-bit unsigned integer for the time-out in milliseconds.</span></span> <span data-ttu-id="cd72b-542">Este método no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-542">This method does not propagate the calling stack to the worker thread.</span></span></summary>
        <returns><span data-ttu-id="cd72b-543">Objeto <see cref="T:System.Threading.RegisteredWaitHandle" /> que puede usarse para cancelar la operación de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-543">The <see cref="T:System.Threading.RegisteredWaitHandle" /> object that can be used to cancel the registered wait operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="cd72b-544">A diferencia de la <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> método <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> no propaga la pila de llamadas al subproceso de trabajo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-544">Unlike the <xref:System.Threading.ThreadPool.RegisterWaitForSingleObject%2A> method, <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> does not propagate the calling stack to the worker thread.</span></span> <span data-ttu-id="cd72b-545">Esto permite que el código pierda la pila de llamadas y, por tanto, para elevar sus privilegios de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-545">This allows code to lose the calling stack and thereby to elevate its security privileges.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="cd72b-546">Uso de <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> podría abrir accidentalmente un agujero de seguridad.</span><span class="sxs-lookup"><span data-stu-id="cd72b-546">Using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A> could inadvertently open up a security hole.</span></span> <span data-ttu-id="cd72b-547">Seguridad de acceso del código basa sus comprobaciones de permisos en los permisos de todos los llamadores situados en la pila.</span><span class="sxs-lookup"><span data-stu-id="cd72b-547">Code access security bases its permission checks on the permissions of all the callers on the stack.</span></span> <span data-ttu-id="cd72b-548">Cuando trabajo en cola en un subproceso de grupo de subprocesos con <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, la pila del subproceso de grupo no tendrán el contexto de los llamadores reales.</span><span class="sxs-lookup"><span data-stu-id="cd72b-548">When work is queued on a thread pool thread using <xref:System.Threading.ThreadPool.UnsafeRegisterWaitForSingleObject%2A>, the stack of the thread pool thread will not have the context of the actual callers.</span></span> <span data-ttu-id="cd72b-549">Código malintencionado podría ser capaz de aprovechar esto para evitar las comprobaciones de permiso.</span><span class="sxs-lookup"><span data-stu-id="cd72b-549">Malicious code might be able exploit this to avoid permission checks.</span></span>  
  
 <span data-ttu-id="cd72b-550">Mediante un <xref:System.Threading.Mutex> para `waitObject` no proporciona la exclusión mutua para las devoluciones de llamada porque la API de Win32 subyacente usa el valor predeterminado `WT_EXECUTEDEFAULT` marca, por lo que se envía cada devolución de llamada en un subproceso independiente de grupo.</span><span class="sxs-lookup"><span data-stu-id="cd72b-550">Using a <xref:System.Threading.Mutex> for `waitObject` does not provide mutual exclusion for the callbacks because the underlying Win32 API uses the default `WT_EXECUTEDEFAULT` flag, so each callback is dispatched on a separate thread pool thread.</span></span>  
  
 <span data-ttu-id="cd72b-551">Cuando haya terminado con el <xref:System.Threading.RegisteredWaitHandle> devuelto por este método, llame a su <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método para liberar las referencias al identificador de espera.</span><span class="sxs-lookup"><span data-stu-id="cd72b-551">When you are finished using the <xref:System.Threading.RegisteredWaitHandle> that is returned by this method, call its <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method to release references to the wait handle.</span></span> <span data-ttu-id="cd72b-552">Se recomienda que siempre llame a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método, incluso si se especifica `true` para `executeOnlyOnce`.</span><span class="sxs-lookup"><span data-stu-id="cd72b-552">We recommend that you always call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method, even if you specify `true` for `executeOnlyOnce`.</span></span> <span data-ttu-id="cd72b-553">Colección de elementos no utilizados resulta más eficaz si se llama a la <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> método en lugar de según el finalizador del controlador de espera registrada.</span><span class="sxs-lookup"><span data-stu-id="cd72b-553">Garbage collection works more efficiently if you call the <xref:System.Threading.RegisteredWaitHandle.Unregister%2A?displayProperty=nameWithType> method instead of depending on the registered wait handle's finalizer.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="cd72b-554">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="cd72b-554">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="cd72b-555">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="cd72b-555">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="cd72b-556">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="cd72b-556">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="cd72b-557">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="cd72b-557">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>