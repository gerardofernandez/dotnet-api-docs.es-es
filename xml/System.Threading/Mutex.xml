<Type Name="Mutex" FullName="System.Threading.Mutex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="75309784a7f2ba45e91d42b9f73bf62285725b43" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52200785" /></Metadata><TypeSignature Language="C#" Value="public sealed class Mutex : System.Threading.WaitHandle" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit Mutex extends System.Threading.WaitHandle" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Mutex" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Mutex&#xA;Inherits WaitHandle" />
  <TypeSignature Language="C++ CLI" Value="public ref class Mutex sealed : System::Threading::WaitHandle" />
  <TypeSignature Language="F#" Value="type Mutex = class&#xA;    inherit WaitHandle" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Threading.WaitHandle</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="9313f-101">Primitiva de sincronización que puede usarse también para la sincronización entre procesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-101">A synchronization primitive that can also be used for interprocess synchronization.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-102">Cuando dos o más subprocesos deben tener acceso a un recurso compartido al mismo tiempo, el sistema necesita un mecanismo de sincronización para asegurarse de que solo un subproceso a la vez usa el recurso.</span><span class="sxs-lookup"><span data-stu-id="9313f-102">When two or more threads need to access a shared resource at the same time, the system needs a synchronization mechanism to ensure that only one thread at a time uses the resource.</span></span> <span data-ttu-id="9313f-103"><xref:System.Threading.Mutex> es una sincronización primitiva que concede acceso exclusivo al recurso compartido a un solo subproceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-103"><xref:System.Threading.Mutex> is a synchronization primitive that grants exclusive access to the shared resource to only one thread.</span></span> <span data-ttu-id="9313f-104">Si un subproceso adquiere una exclusión mutua, el segundo subproceso que desea adquirir la exclusión mutua del que se suspende hasta que el primer subproceso libera la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-104">If a thread acquires a mutex, the second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="9313f-105">Este tipo implementa la <xref:System.IDisposable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="9313f-105">This type implements the <xref:System.IDisposable> interface.</span></span> <span data-ttu-id="9313f-106">Cuando haya terminado de utilizar el tipo, debe deshacerse de él directa o indirectamente.</span><span class="sxs-lookup"><span data-stu-id="9313f-106">When you have finished using the type, you should dispose of it either directly or indirectly.</span></span> <span data-ttu-id="9313f-107">Para deshacerse del tipo directamente, llame a su <xref:System.IDisposable.Dispose%2A> método en un `try` / `catch` bloque.</span><span class="sxs-lookup"><span data-stu-id="9313f-107">To dispose of the type directly, call its <xref:System.IDisposable.Dispose%2A> method in a `try`/`catch` block.</span></span> <span data-ttu-id="9313f-108">Para deshacerse de él, indirectamente, usar una construcción de lenguaje, como `using` (en C#) o `Using` (en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="9313f-108">To dispose of it indirectly, use a language construct such as `using` (in C#) or `Using` (in Visual Basic).</span></span> <span data-ttu-id="9313f-109">Para obtener más información, vea la sección "Uso de un objeto que implementa IDisposable" en el <xref:System.IDisposable> tema de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="9313f-109">For more information, see the "Using an Object that Implements IDisposable" section in the <xref:System.IDisposable> interface topic.</span></span>  
  
 <span data-ttu-id="9313f-110">Puede usar el <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> método para solicitar la propiedad de una exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-110">You can use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method to request ownership of a mutex.</span></span> <span data-ttu-id="9313f-111">El subproceso que realiza la llamada se bloquea hasta que se produzca uno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="9313f-111">The calling thread blocks until one of the following occurs:</span></span>  
  
-   <span data-ttu-id="9313f-112">La exclusión mutua se señala para indicar que no pertenece.</span><span class="sxs-lookup"><span data-stu-id="9313f-112">The mutex is signaled to indicate that it is not owned.</span></span> <span data-ttu-id="9313f-113">Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `true`, y el subproceso de llamada asume la propiedad de la exclusión mutua y accede al recurso protegido por la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-113">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `true`, and the calling thread assumes ownership of the mutex and accesses the resource protected by the mutex.</span></span> <span data-ttu-id="9313f-114">Cuando haya terminado de obtener acceso al recurso, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-114">When it has finished accessing the resource, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the mutex.</span></span> <span data-ttu-id="9313f-115">El primer ejemplo en la sección de ejemplos muestra este modelo.</span><span class="sxs-lookup"><span data-stu-id="9313f-115">The first example in the Examples section illustrates this pattern.</span></span>  
  
-   <span data-ttu-id="9313f-116">El intervalo de tiempo de espera especificado en la llamada a un <xref:System.Threading.WaitHandle.WaitOne%2A> método que tiene un `millisecondsTimeout` o `timeout` parámetro ha transcurrido.</span><span class="sxs-lookup"><span data-stu-id="9313f-116">The time-out interval specified in the call to a <xref:System.Threading.WaitHandle.WaitOne%2A> method that has a `millisecondsTimeout` or `timeout` parameter has elapsed.</span></span> <span data-ttu-id="9313f-117">Cuando esto sucede, el <xref:System.Threading.WaitHandle.WaitOne%2A> devuelve del método `false`, y el subproceso que realiza la llamada realiza ningún intento adicional para adquirir posesión de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-117">When this happens, the <xref:System.Threading.WaitHandle.WaitOne%2A> method returns `false`, and the calling thread makes no further attempt to acquire ownership of the mutex.</span></span> <span data-ttu-id="9313f-118">En este caso, debe estructurar el código para que se deniega el acceso al recurso protegido por la exclusión mutua al subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-118">In this case, you should structure your code so that access to the resource that is protected by the mutex is denied to the calling thread.</span></span> <span data-ttu-id="9313f-119">Dado que el subproceso nunca haya adquirido la propiedad de la exclusión mutua, no debe llamar el <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-119">Because the thread never acquired ownership of the mutex, it must not call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span> <span data-ttu-id="9313f-120">El segundo ejemplo en la sección de ejemplos muestra este modelo.</span><span class="sxs-lookup"><span data-stu-id="9313f-120">The second example in the Examples section illustrates this pattern.</span></span>  
  
 <span data-ttu-id="9313f-121">La <xref:System.Threading.Mutex> clase exige la identidad del subproceso, por lo que se puede liberar una exclusión mutua sólo por el subproceso que lo adquirió.</span><span class="sxs-lookup"><span data-stu-id="9313f-121">The <xref:System.Threading.Mutex> class enforces thread identity, so a mutex can be released only by the thread that acquired it.</span></span> <span data-ttu-id="9313f-122">Por el contrario, el <xref:System.Threading.Semaphore> clase no exige la identidad del subproceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-122">By contrast, the <xref:System.Threading.Semaphore> class does not enforce thread identity.</span></span> <span data-ttu-id="9313f-123">Una exclusión mutua también se puede pasar entre los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="9313f-123">A mutex can also be passed across application domain boundaries.</span></span>  
  
 <span data-ttu-id="9313f-124">El subproceso que posee una exclusión mutua puede solicitar la misma exclusión mutua en llamadas repetidas a <xref:System.Threading.WaitHandle.WaitOne%2A> sin bloquear su ejecución.</span><span class="sxs-lookup"><span data-stu-id="9313f-124">The thread that owns a mutex can request the same mutex in repeated calls to <xref:System.Threading.WaitHandle.WaitOne%2A> without blocking its execution.</span></span> <span data-ttu-id="9313f-125">Sin embargo, el subproceso debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método el mismo número de veces para liberar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-125">However, the thread must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="9313f-126">Dado que el <xref:System.Threading.Mutex> clase hereda de <xref:System.Threading.WaitHandle>, también se puede llamar a estático <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> y <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> métodos para sincronizar el acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="9313f-126">Because the <xref:System.Threading.Mutex> class inherits from <xref:System.Threading.WaitHandle>, you can also call the static <xref:System.Threading.WaitHandle.WaitAll%2A?displayProperty=nameWithType> and <xref:System.Threading.WaitHandle.WaitAny%2A?displayProperty=nameWithType> methods to synchronize access to a protected resource.</span></span>  
  
 <span data-ttu-id="9313f-127">Si un subproceso finaliza mientras posee una exclusión mutua, se dice que la exclusión mutua abandonada.</span><span class="sxs-lookup"><span data-stu-id="9313f-127">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="9313f-128">El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad.</span><span class="sxs-lookup"><span data-stu-id="9313f-128">The state of the mutex is set to signaled, and the next waiting thread gets ownership.</span></span> <span data-ttu-id="9313f-129">A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el subproceso siguiente que adquiere la exclusión mutua abandonada.</span><span class="sxs-lookup"><span data-stu-id="9313f-129">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the abandoned mutex.</span></span> <span data-ttu-id="9313f-130">Antes de la versión 2.0 de .NET Framework, se produjo ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="9313f-130">Before version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9313f-131">A menudo, un mutex abandonado indica un error grave en el código.</span><span class="sxs-lookup"><span data-stu-id="9313f-131">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="9313f-132">Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no esté en un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="9313f-132">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="9313f-133">El siguiente subproceso que solicita la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.</span><span class="sxs-lookup"><span data-stu-id="9313f-133">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="9313f-134">En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="9313f-134">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
 <span data-ttu-id="9313f-135">Las exclusiones mutuas son de dos tipos: exclusiones mutuas locales, que son y sin nombre exclusiones mutuas del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-135">Mutexes are of two types: local mutexes, which are unnamed, and named system mutexes.</span></span> <span data-ttu-id="9313f-136">Una exclusión mutua local solo existe dentro del proceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-136">A local mutex exists only within your process.</span></span> <span data-ttu-id="9313f-137">Se puede usar cualquier subproceso del proceso que tenga una referencia a la <xref:System.Threading.Mutex> objeto que representa la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-137">It can be used by any thread in your process that has a reference to the <xref:System.Threading.Mutex> object that represents the mutex.</span></span> <span data-ttu-id="9313f-138">Cada uno sin nombre <xref:System.Threading.Mutex> objeto representa una exclusión mutua local independiente.</span><span class="sxs-lookup"><span data-stu-id="9313f-138">Each unnamed <xref:System.Threading.Mutex> object represents a separate local mutex.</span></span>  
  
 <span data-ttu-id="9313f-139">Las exclusiones mutuas son visibles en todo el sistema operativo y pueden utilizarse para sincronizar las actividades de procesos de sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-139">Named system mutexes are visible throughout the operating system, and can be used to synchronize the activities of processes.</span></span> <span data-ttu-id="9313f-140">Puede crear un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre mediante un constructor que acepta un nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-140">You can create a <xref:System.Threading.Mutex> object that represents a named system mutex by using a constructor that accepts a name.</span></span> <span data-ttu-id="9313f-141">Se puede crear el objeto del sistema operativo al mismo tiempo, o puede existir antes de la creación de la <xref:System.Threading.Mutex> objeto.</span><span class="sxs-lookup"><span data-stu-id="9313f-141">The operating-system object can be created at the same time, or it can exist before the creation of the <xref:System.Threading.Mutex> object.</span></span> <span data-ttu-id="9313f-142">Puede crear varios objetos <xref:System.Threading.Mutex> que representen la misma exclusión mutua del sistema con nombre y puede usar el método <xref:System.Threading.Mutex.OpenExisting%2A> para abrir una exclusión mutua del sistema con nombre existente.</span><span class="sxs-lookup"><span data-stu-id="9313f-142">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex, and you can use the <xref:System.Threading.Mutex.OpenExisting%2A> method to open an existing named system mutex.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9313f-143">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="9313f-143">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="9313f-144">Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-144">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="9313f-145">Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó.</span><span class="sxs-lookup"><span data-stu-id="9313f-145">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="9313f-146">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</span><span class="sxs-lookup"><span data-stu-id="9313f-146">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="9313f-147">Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="9313f-147">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="9313f-148">Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-148">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="9313f-149">Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-149">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

  
## Examples  
 <span data-ttu-id="9313f-150">Este ejemplo se muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="9313f-150">This example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="9313f-151">Dado que cada subproceso que realiza la llamada se bloquea hasta que obtiene la propiedad de la exclusión mutua, debe llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método para liberar la propiedad del subproceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-151">Because each calling thread is blocked until it acquires ownership of the mutex, it must call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method to release ownership of the thread.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Mutex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="9313f-152">En el ejemplo siguiente, cada subproceso llama a la <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> método para adquirir la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-152">In the following example, each thread calls the <xref:System.Threading.WaitHandle.WaitOne%28System.Int32%29> method to acquire the mutex.</span></span> <span data-ttu-id="9313f-153">Si transcurre el intervalo de tiempo de espera, el método devuelve `false`, y el subproceso no adquiere la exclusión mutua ni obtiene acceso al recurso que protege la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-153">If the time-out interval elapses, the method returns `false`, and the thread neither acquires the mutex nor gains access to the resource the mutex protects.</span></span> <span data-ttu-id="9313f-154">El <xref:System.Threading.Mutex.ReleaseMutex%2A> se llama al método sólo por el subproceso que adquiere la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-154">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is called only by the thread that acquires the mutex.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="9313f-155">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-155">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.Threading.WaitHandle" />
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-156">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-156">Managed Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-157">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-157">Mutexes</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9313f-158">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-158">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9313f-159">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con propiedades predeterminadas.</span><span class="sxs-lookup"><span data-stu-id="9313f-159">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with default properties.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-160">Llamar a esta sobrecarga del constructor es igual que llamar a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> sobrecarga de constructor y especificando `false` para la propiedad inicial de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-160">Calling this constructor overload is the same as calling the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor overload and specifying `false` for initial ownership of the mutex.</span></span> <span data-ttu-id="9313f-161">Es decir, el subproceso que realiza la llamada no posee la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-161">That is, the calling thread does not own the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-162">El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="9313f-162">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="9313f-163">El subproceso que crea la exclusión mutua no posee lo inicialmente.</span><span class="sxs-lookup"><span data-stu-id="9313f-163">The thread that creates the mutex does not own it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-164">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-164">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-165">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-165">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex initiallyOwned" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="9313f-166"><see langword="true" /> para otorgar la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada, en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-166"><see langword="true" /> to give the calling thread initial ownership of the mutex; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="9313f-167">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-167">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="9313f-168">El siguiente ejemplo de código muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="9313f-168">The following code example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="9313f-169">El subproceso que crea el <xref:System.Threading.Mutex> inicialmente lo posee.</span><span class="sxs-lookup"><span data-stu-id="9313f-169">The thread that creates the <xref:System.Threading.Mutex> owns it initially.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 1Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 1Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-170">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-170">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-171">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-171">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="9313f-172"><see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-172"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="9313f-173">Nombre del objeto <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-173">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="9313f-174">Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-174">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <summary><span data-ttu-id="9313f-175">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua y una cadena que representa el nombre de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-175">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, and a string that is the name of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-176">Si `name` no `null` y `initiallyOwned` es `true`, el subproceso de llamada posee la exclusión mutua sólo si la exclusión mutua del sistema con nombre se creó como resultado de esta llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-176">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the mutex only if the named system mutex was created as a result of this call.</span></span> <span data-ttu-id="9313f-177">Dado que no hay ningún mecanismo para determinar si se creó la exclusión mutua del sistema con nombre, es mejor especificar `false` para `initiallyOwned` al llamar a esta sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="9313f-177">Since there is no mechanism for determining whether the named system mutex was created, it is better to specify `false` for `initiallyOwned` when calling this constructor overload.</span></span> <span data-ttu-id="9313f-178">Puede usar el <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor si tiene que determinar la propiedad inicial.</span><span class="sxs-lookup"><span data-stu-id="9313f-178">You can use the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%2CSystem.String%2CSystem.Boolean%40%29> constructor if you need to determine initial ownership.</span></span>  
  
 <span data-ttu-id="9313f-179">Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-179">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="9313f-180">Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-180">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-181">Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="9313f-181">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="9313f-182">Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-182">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-183">Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="9313f-183">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="9313f-184">En este caso, `createdNew` siempre `true`.</span><span class="sxs-lookup"><span data-stu-id="9313f-184">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="9313f-185">Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-185">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9313f-186">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="9313f-186">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="9313f-187">Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-187">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="9313f-188">Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó.</span><span class="sxs-lookup"><span data-stu-id="9313f-188">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="9313f-189">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</span><span class="sxs-lookup"><span data-stu-id="9313f-189">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="9313f-190">Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="9313f-190">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="9313f-191">Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-191">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="9313f-192">Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-192">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  
  
[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]

## Examples  
 <span data-ttu-id="9313f-193">El ejemplo siguiente muestra cómo se usa una exclusión mutua con nombre para señalar los subprocesos que se ejecutan en dos procesos separados.</span><span class="sxs-lookup"><span data-stu-id="9313f-193">The following example shows how a named mutex is used to signal between threads running in two separate processes.</span></span>  
  
 <span data-ttu-id="9313f-194">Ejecutar este programa desde dos o más ventanas de comandos.</span><span class="sxs-lookup"><span data-stu-id="9313f-194">Run this program from two or more command windows.</span></span> <span data-ttu-id="9313f-195">Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre `MyMutex`.</span><span class="sxs-lookup"><span data-stu-id="9313f-195">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex `MyMutex`.</span></span> <span data-ttu-id="9313f-196">La exclusión mutua con nombre es un objeto de sistema cuya duración está limitada por la duración de la <xref:System.Threading.Mutex> objetos que representan a él.</span><span class="sxs-lookup"><span data-stu-id="9313f-196">The named mutex is a system object whose lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="9313f-197">La exclusión mutua con nombre se crea cuando el primer proceso crea su <xref:System.Threading.Mutex> objeto; en este ejemplo, la exclusión mutua con nombre es propiedad del primer proceso que ejecuta el programa.</span><span class="sxs-lookup"><span data-stu-id="9313f-197">The named mutex is created when the first process creates its <xref:System.Threading.Mutex> object; in this example, the named mutex is owned by the first process that runs the program.</span></span> <span data-ttu-id="9313f-198">La exclusión mutua con nombre se destruye cuando todas la <xref:System.Threading.Mutex> objetos que representan lo que se han liberado.</span><span class="sxs-lookup"><span data-stu-id="9313f-198">The named mutex is destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span>  
  
 <span data-ttu-id="9313f-199">En este ejemplo utilizada la sobrecarga del constructor no puede determinar el subproceso que realiza la llamada si se ha concedido la propiedad inicial de la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-199">The constructor overload used in this example cannot tell the calling thread whether initial ownership of the named mutex was granted.</span></span> <span data-ttu-id="9313f-200">No debe utilizar este constructor para solicitar la propiedad inicial a menos que puede estar seguro de que el subproceso va a crear la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-200">You should not use this constructor to request initial ownership unless you can be certain that the thread will create the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 2Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 2Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-201">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-201">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-202">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-202">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="9313f-203">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-203">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-204"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-204"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-205">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-205">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-206">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-206">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-207">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-207">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-208">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-208">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (initiallyOwned As Boolean, name As String, ByRef createdNew As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="9313f-209"><see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-209"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="9313f-210">Nombre del objeto <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-210">The name of the <see cref="T:System.Threading.Mutex" />.</span></span> <span data-ttu-id="9313f-211">Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-211">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="9313f-212">Cuando se devuelve este método, contiene un valor booleano que es <see langword="true" /> si se creó una exclusión mutua local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía.</span><span class="sxs-lookup"><span data-stu-id="9313f-212">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="9313f-213">Este parámetro se pasa sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="9313f-213">This parameter is passed uninitialized.</span></span></param>
        <summary><span data-ttu-id="9313f-214">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua, una cadena que es el nombre de la exclusión mutua y un valor booleano que, cuando se devuelva el método, indicará si se concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-214">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-215">Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre sólo si `createdNew` es `true` después de la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-215">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="9313f-216">En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-216">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-217">Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-217">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="9313f-218">Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-218">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-219">Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> derechos, que se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="9313f-219">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType> rights, an exception is thrown.</span></span> <span data-ttu-id="9313f-220">Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-220">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-221">Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="9313f-221">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="9313f-222">En este caso, `createdNew` siempre `true`.</span><span class="sxs-lookup"><span data-stu-id="9313f-222">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="9313f-223">Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-223">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9313f-224">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="9313f-224">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="9313f-225">Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-225">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="9313f-226">Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó.</span><span class="sxs-lookup"><span data-stu-id="9313f-226">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="9313f-227">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</span><span class="sxs-lookup"><span data-stu-id="9313f-227">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="9313f-228">Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="9313f-228">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="9313f-229">Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-229">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="9313f-230">Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-230">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]   
  
## Examples  
 <span data-ttu-id="9313f-231">El ejemplo de código siguiente muestra cómo se usa una exclusión mutua con nombre para señalar entre procesos o subprocesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-231">The following code example shows how a named mutex is used to signal between processes or threads.</span></span> <span data-ttu-id="9313f-232">Ejecutar este programa desde dos o más ventanas de comandos.</span><span class="sxs-lookup"><span data-stu-id="9313f-232">Run this program from two or more command windows.</span></span> <span data-ttu-id="9313f-233">Cada proceso crea un <xref:System.Threading.Mutex> objeto que representa la exclusión mutua con nombre "MyMutex".</span><span class="sxs-lookup"><span data-stu-id="9313f-233">Each process creates a <xref:System.Threading.Mutex> object that represents the named mutex "MyMutex".</span></span> <span data-ttu-id="9313f-234">La exclusión mutua con nombre es un objeto del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-234">The named mutex is a system object.</span></span> <span data-ttu-id="9313f-235">En este ejemplo, su duración está limitada por la duración de la <xref:System.Threading.Mutex> objetos que representan a él.</span><span class="sxs-lookup"><span data-stu-id="9313f-235">In this example, its lifetime is bounded by the lifetimes of the <xref:System.Threading.Mutex> objects that represent it.</span></span> <span data-ttu-id="9313f-236">La exclusión mutua con nombre se crea cuando el primer proceso crea su local <xref:System.Threading.Mutex> objeto y se destruye cuando todas la <xref:System.Threading.Mutex> objetos que representan lo que se han liberado.</span><span class="sxs-lookup"><span data-stu-id="9313f-236">The named mutex is created when the first process creates its local <xref:System.Threading.Mutex> object, and destroyed when all the <xref:System.Threading.Mutex> objects that represent it have been released.</span></span> <span data-ttu-id="9313f-237">El primer proceso posee inicialmente la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-237">The named mutex is initially owned by the first process.</span></span> <span data-ttu-id="9313f-238">El segundo proceso y todos los procesos posteriores esperan procesos anteriores liberar la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-238">The second process and any subsequent processes wait for earlier processes to release the named mutex.</span></span>  
  
 [!code-cpp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex 3Arg Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex 3Arg Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-239">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-239">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-240">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-240">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="9313f-241">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-241">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-242"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-242"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-243">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-243">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-244">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-244">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-245">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-245">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-246">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-246">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Mutex (bool initiallyOwned, string name, out bool createdNew, System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(bool initiallyOwned, string name, [out] bool&amp; createdNew, class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.#ctor(System.Boolean,System.String,System.Boolean@,System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Mutex(bool initiallyOwned, System::String ^ name, [Runtime::InteropServices::Out] bool % createdNew, System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="new System.Threading.Mutex : bool * string *  * System.Security.AccessControl.MutexSecurity -&gt; System.Threading.Mutex" Usage="new System.Threading.Mutex (initiallyOwned, name, createdNew, mutexSecurity)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="initiallyOwned" Type="System.Boolean" />
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="createdNew" Type="System.Boolean" RefType="out" />
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="initiallyOwned"><span data-ttu-id="9313f-247"><see langword="true" /> para otorgar al subproceso que realiza la llamada la propiedad inicial de la exclusión mutua del sistema con nombre si esta se crea como resultado de dicha llamada; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-247"><see langword="true" /> to give the calling thread initial ownership of the named system mutex if the named system mutex is created as a result of this call; otherwise, <see langword="false" />.</span></span></param>
        <param name="name"><span data-ttu-id="9313f-248">Nombre de la exclusión mutua del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-248">The name of the system mutex.</span></span> <span data-ttu-id="9313f-249">Si el valor es <see langword="null" />, <see cref="T:System.Threading.Mutex" /> no tiene nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-249">If the value is <see langword="null" />, the <see cref="T:System.Threading.Mutex" /> is unnamed.</span></span></param>
        <param name="createdNew"><span data-ttu-id="9313f-250">Cuando se devuelve este método, contiene un valor booleano que es <see langword="true" /> si se creó una exclusión mutua local (es decir, si <paramref name="name" /> es <see langword="null" /> o una cadena vacía) o si se creó la exclusión mutua del sistema con nombre especificada; el valor es <see langword="false" /> si la exclusión mutua del sistema con nombre especificada ya existía.</span><span class="sxs-lookup"><span data-stu-id="9313f-250">When this method returns, contains a Boolean that is <see langword="true" /> if a local mutex was created (that is, if <paramref name="name" /> is <see langword="null" /> or an empty string) or if the specified named system mutex was created; <see langword="false" /> if the specified named system mutex already existed.</span></span> <span data-ttu-id="9313f-251">Este parámetro se pasa sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="9313f-251">This parameter is passed uninitialized.</span></span></param>
        <param name="mutexSecurity"><span data-ttu-id="9313f-252">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-252">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="9313f-253">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Mutex" /> con un valor booleano que indica si el subproceso que realiza la llamada debe tener la propiedad inicial de la exclusión mutua; una cadena que es el nombre de la exclusión mutua; una variable booleana que, cuando se devuelva el método, indicará si se le concedió la propiedad inicial de la exclusión mutua al subproceso que realiza la llamada; y la seguridad del control de acceso que se va a aplicar a la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-253">Initializes a new instance of the <see cref="T:System.Threading.Mutex" /> class with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, a string that is the name of the mutex, a Boolean variable that, when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the access control security to be applied to the named mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-254">Si `name` no `null` y `initiallyOwned` es `true`, el subproceso que realiza la llamada posee la exclusión mutua con nombre sólo si `createdNew` es `true` después de la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-254">If `name` is not `null` and `initiallyOwned` is `true`, the calling thread owns the named mutex only if `createdNew` is `true` after the call.</span></span> <span data-ttu-id="9313f-255">En caso contrario, el subproceso puede solicitar la exclusión mutua mediante una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-255">Otherwise the thread can request the mutex by calling the <xref:System.Threading.WaitHandle.WaitOne%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-256">Utilice este constructor para aplicar la seguridad de control de acceso a una exclusión mutua del sistema con nombre cuando se crea, impide que otro código tome el control de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-256">Use this constructor to apply access control security to a named system mutex when it is created, preventing other code from taking control of the mutex.</span></span>  
  
 <span data-ttu-id="9313f-257">Este constructor inicializa un <xref:System.Threading.Mutex> objeto que representa una exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-257">This constructor initializes a <xref:System.Threading.Mutex> object that represents a named system mutex.</span></span> <span data-ttu-id="9313f-258">Puede crear varias <xref:System.Threading.Mutex> objetos que representan el mismo nombre de exclusión mutua del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-258">You can create multiple <xref:System.Threading.Mutex> objects that represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-259">Si la exclusión mutua del sistema con nombre no existe, se crea con la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="9313f-259">If the named system mutex does not exist, it is created with the specified access control security.</span></span> <span data-ttu-id="9313f-260">Si la exclusión mutua con nombre existe, se omite la seguridad de control de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="9313f-260">If the named mutex exists, the specified access control security is ignored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9313f-261">El llamador tiene control total sobre el recién creado <xref:System.Threading.Mutex> objeto incluso si `mutexSecurity` deniega o se produce un error al otorgar algunos derechos de acceso al usuario actual.</span><span class="sxs-lookup"><span data-stu-id="9313f-261">The caller has full control over the newly created <xref:System.Threading.Mutex> object even if `mutexSecurity` denies or fails to grant some access rights to the current user.</span></span> <span data-ttu-id="9313f-262">Sin embargo, si el usuario actual intenta obtener otro <xref:System.Threading.Mutex> representar la misma exclusión mutua con nombre, ya sea mediante un constructor de objeto o el <xref:System.Threading.Mutex.OpenExisting%2A> método, se aplica la seguridad de control de acceso de Windows.</span><span class="sxs-lookup"><span data-stu-id="9313f-262">However, if the current user attempts to get another <xref:System.Threading.Mutex> object to represent the same named mutex, using either a constructor or the <xref:System.Threading.Mutex.OpenExisting%2A> method, Windows access control security is applied.</span></span>  
  
 <span data-ttu-id="9313f-263">Si la exclusión mutua con nombre ya se ha creado con la seguridad de control de acceso y el llamador no tiene <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="9313f-263">If the named mutex has already been created with access control security, and the caller does not have <xref:System.Security.AccessControl.MutexRights.FullControl?displayProperty=nameWithType>, an exception is thrown.</span></span> <span data-ttu-id="9313f-264">Para abrir una exclusión mutua con nombre sólo con los permisos necesarios para sincronizar las actividades del subproceso existente, consulte el <xref:System.Threading.Mutex.OpenExisting%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-264">To open an existing named mutex with only those permissions needed for synchronizing thread activities, see the <xref:System.Threading.Mutex.OpenExisting%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-265">Si especifica `null` o una cadena vacía para `name`, se crea una exclusión mutua local, como si hubiera llamado a la <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="9313f-265">If you specify `null` or an empty string for `name`, a local mutex is created, as if you had called the <xref:System.Threading.Mutex.%23ctor%28System.Boolean%29> constructor.</span></span> <span data-ttu-id="9313f-266">En este caso, `createdNew` siempre `true`.</span><span class="sxs-lookup"><span data-stu-id="9313f-266">In this case, `createdNew` is always `true`.</span></span>  
  
 <span data-ttu-id="9313f-267">Dado que todo el sistema, exclusiones mutuas pueden utilizarse para coordinar el uso de recursos a través de los límites del proceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-267">Because they are system-wide, named mutexes can be used to coordinate resource use across process boundaries.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="9313f-268">En un servidor que ejecuta Servicios de Terminal Server, una exclusión mutua del sistema con nombre puede tener dos niveles de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="9313f-268">On a server that is running Terminal Services, a named system mutex can have two levels of visibility.</span></span> <span data-ttu-id="9313f-269">Si su nombre comienza con el prefijo "Global\\", la exclusión mutua está visible en todas las sesiones de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-269">If its name begins with the prefix "Global\\", the mutex is visible in all terminal server sessions.</span></span> <span data-ttu-id="9313f-270">Si su nombre comienza con el prefijo "Local\\", la exclusión mutua solo es visible en la sesión de terminal server donde se creó.</span><span class="sxs-lookup"><span data-stu-id="9313f-270">If its name begins with the prefix "Local\\", the mutex is visible only in the terminal server session where it was created.</span></span> <span data-ttu-id="9313f-271">En ese caso, puede existir una exclusión mutua independiente con el mismo nombre en cada una de las demás sesiones de terminal server en el servidor.</span><span class="sxs-lookup"><span data-stu-id="9313f-271">In that case, a separate mutex with the same name can exist in each of the other terminal server sessions on the server.</span></span> <span data-ttu-id="9313f-272">Si no especifica un prefijo al crear una exclusión mutua con nombre, toma el prefijo "Local\\".</span><span class="sxs-lookup"><span data-stu-id="9313f-272">If you do not specify a prefix when you create a named mutex, it takes the prefix "Local\\".</span></span> <span data-ttu-id="9313f-273">Dentro de una sesión de terminal server, dos exclusiones mutuas cuyos nombres difieren solo por sus prefijos son independientes de las exclusiones mutuas y ambos son visibles para todos los procesos en la sesión de terminal server.</span><span class="sxs-lookup"><span data-stu-id="9313f-273">Within a terminal server session, two mutexes whose names differ only by their prefixes are separate mutexes, and both are visible to all processes in the terminal server session.</span></span> <span data-ttu-id="9313f-274">Es decir, los nombres de prefijo "Global\\" y "Local\\" describe el ámbito del nombre de exclusión mutua con respecto a las sesiones de terminal server, no en relación con los procesos.</span><span class="sxs-lookup"><span data-stu-id="9313f-274">That is, the prefix names "Global\\" and "Local\\" describe the scope of the mutex name relative to terminal server sessions, not relative to processes.</span></span>  

[!INCLUDE[backslash-mutex-note](~/includes/backslash-mutex.md)]  
   
  
## Examples  
 <span data-ttu-id="9313f-275">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-275">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="9313f-276">El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-276">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="9313f-277">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-277">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="9313f-278">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="9313f-278">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="9313f-279">Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-279">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9313f-280">Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9313f-280">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9313f-281">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-281">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-282">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-282">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-283">La exclusión mutua con nombre existe y tiene seguridad de control de acceso, pero el usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-283">The named mutex exists and has access control security, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.FullControl" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="9313f-284">No se puede crear la exclusión mutua con nombre, porque puede que un identificador de espera de un tipo diferente tenga el mismo nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-284">The named mutex cannot be created, perhaps because a wait handle of a different type has the same name.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-285"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-285"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-286">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-286">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-287">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-287">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetAccessControl">
      <MemberSignature Language="C#" Value="public System.Security.AccessControl.MutexSecurity GetAccessControl ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Security.AccessControl.MutexSecurity GetAccessControl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.GetAccessControl" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAccessControl () As MutexSecurity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Security::AccessControl::MutexSecurity ^ GetAccessControl();" />
      <MemberSignature Language="F#" Value="member this.GetAccessControl : unit -&gt; System.Security.AccessControl.MutexSecurity" Usage="mutex.GetAccessControl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.AccessControl.MutexSecurity</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9313f-288">Obtiene un objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-288">Gets a <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></summary>
        <returns><span data-ttu-id="9313f-289">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad de control de acceso para la exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-289">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security for the named mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-290">El <xref:System.Threading.Mutex.GetAccessControl%2A> método utiliza la siguiente combinación de indicadores (combinados con la operación OR bit a bit) para buscar los permisos: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, y <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9313f-290">The <xref:System.Threading.Mutex.GetAccessControl%2A> method uses the following combination of flags (combined using the bitwise OR operation) to search for permissions: <xref:System.Security.AccessControl.AccessControlSections.Access?displayProperty=nameWithType>, <xref:System.Security.AccessControl.AccessControlSections.Owner?displayProperty=nameWithType>, and <xref:System.Security.AccessControl.AccessControlSections.Group?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="9313f-291">El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> llamar a este método y la exclusión mutua debe haberse abierto con <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9313f-291">The user must have <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType> to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ReadPermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-292">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-292">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="9313f-293">El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-293">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="9313f-294">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-294">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="9313f-295">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="9313f-295">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="9313f-296">Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, mediante el <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="9313f-296">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="9313f-297">Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9313f-297">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9313f-298">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-298">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-299">El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre, pero el usuario no dispone de derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-299">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, but the user does not have <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span>  
  
<span data-ttu-id="9313f-300">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-300">-or-</span></span> 
<span data-ttu-id="9313f-301">El objeto <see cref="T:System.Threading.Mutex" /> actual representa una exclusión mutua del sistema con nombre y no se abrió con derechos <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-301">The current <see cref="T:System.Threading.Mutex" /> object represents a named system mutex, and was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ReadPermissions" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="9313f-302">No se admite para Windows 98 o Windows Millennium Edition.</span><span class="sxs-lookup"><span data-stu-id="9313f-302">Not supported for Windows 98 or Windows Millennium Edition.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="OpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9313f-303">Abre una exclusión mutua con nombre especificada, si ya existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-303">Opens a specified named mutex, if it already exists.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9313f-304">Nombre de la exclusión mutua del sistema que se va a abrir.</span><span class="sxs-lookup"><span data-stu-id="9313f-304">The name of the system mutex to open.</span></span></param>
        <summary><span data-ttu-id="9313f-305">Abre la exclusión mutua con nombre especificada, si ya existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-305">Opens the specified named mutex, if it already exists.</span></span></summary>
        <returns><span data-ttu-id="9313f-306">Objeto que representa la exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-306">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-307">El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir especificado con el nombre de exclusión mutua del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-307">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open the specified named system mutex.</span></span> <span data-ttu-id="9313f-308">Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-308">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="9313f-309">Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="9313f-309">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9313f-310">Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-310">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-311">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="9313f-311">This method overload is equivalent to calling the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span>  
  
 <span data-ttu-id="9313f-312">Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere en la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-312">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-313">Este método no solicitar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-313">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-314">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-314">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="9313f-315">El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-315">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="9313f-316">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-316">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="9313f-317">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="9313f-317">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="9313f-318">Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-318">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9313f-319">Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9313f-319">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9313f-320">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-320">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-321"><paramref name="name" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="9313f-321"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="9313f-322">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-322">-or-</span></span> 
 <span data-ttu-id="9313f-323"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-323"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9313f-324">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-324"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="9313f-325">La excepción mutua con nombre no existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-325">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-326">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-326">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-327">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</span><span class="sxs-lookup"><span data-stu-id="9313f-327">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-328">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-328">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-329">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-329">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="OpenExisting">
      <MemberSignature Language="C#" Value="public static System.Threading.Mutex OpenExisting (string name, System.Security.AccessControl.MutexRights rights);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Threading.Mutex OpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.OpenExisting(System.String,System.Security.AccessControl.MutexRights)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function OpenExisting (name As String, rights As MutexRights) As Mutex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Threading::Mutex ^ OpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights);" />
      <MemberSignature Language="F#" Value="static member OpenExisting : string * System.Security.AccessControl.MutexRights -&gt; System.Threading.Mutex" Usage="System.Threading.Mutex.OpenExisting (name, rights)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Mutex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9313f-330">Nombre de la exclusión mutua del sistema que se va a abrir.</span><span class="sxs-lookup"><span data-stu-id="9313f-330">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="9313f-331">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span><span class="sxs-lookup"><span data-stu-id="9313f-331">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <summary><span data-ttu-id="9313f-332">Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado.</span><span class="sxs-lookup"><span data-stu-id="9313f-332">Opens the specified named mutex, if it already exists, with the desired security access.</span></span></summary>
        <returns><span data-ttu-id="9313f-333">Objeto que representa la exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-333">An object that represents the named system mutex.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-334">El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-334">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-335">El <xref:System.Threading.Mutex.OpenExisting%2A> método intenta abrir una exclusión mutua con nombre existente.</span><span class="sxs-lookup"><span data-stu-id="9313f-335">The <xref:System.Threading.Mutex.OpenExisting%2A> method tries to open an existing named mutex.</span></span> <span data-ttu-id="9313f-336">Si la exclusión mutua del sistema no existe, este método produce una excepción en lugar de crear el objeto del sistema.</span><span class="sxs-lookup"><span data-stu-id="9313f-336">If the system mutex does not exist, this method throws an exception instead of creating the system object.</span></span> <span data-ttu-id="9313f-337">Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="9313f-337">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9313f-338">Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-338">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-339">Este método no solicitar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-339">This method does not request ownership of the mutex.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-340">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-340">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="9313f-341">El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-341">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="9313f-342">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-342">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="9313f-343">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="9313f-343">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="9313f-344">Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-344">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions.</span></span>  
  
 <span data-ttu-id="9313f-345">Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9313f-345">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9313f-346">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-346">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-347"><paramref name="name" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="9313f-347"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="9313f-348">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-348">-or-</span></span> 
 <span data-ttu-id="9313f-349"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-349"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9313f-350">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-350"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Threading.WaitHandleCannotBeOpenedException"><span data-ttu-id="9313f-351">La excepción mutua con nombre no existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-351">The named mutex does not exist.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-352">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-352">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-353">La exclusión mutua con nombre existe, pero el usuario no dispone del acceso de seguridad deseado.</span><span class="sxs-lookup"><span data-stu-id="9313f-353">The named mutex exists, but the user does not have the desired security access.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-354">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-354">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-355">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-355">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseMutex">
      <MemberSignature Language="C#" Value="public void ReleaseMutex ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseMutex() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.ReleaseMutex" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseMutex ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseMutex();" />
      <MemberSignature Language="F#" Value="member this.ReleaseMutex : unit -&gt; unit" Usage="mutex.ReleaseMutex " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="9313f-356">Libera una vez la instancia de <see cref="T:System.Threading.Mutex" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-356">Releases the <see cref="T:System.Threading.Mutex" /> once.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-357">Cada vez que un subproceso adquiere una exclusión mutua (por ejemplo, mediante una llamada a su <xref:System.Threading.WaitHandle.WaitOne%2A> método), debe llamar posteriormente a <xref:System.Threading.Mutex.ReleaseMutex%2A> para ceder la propiedad de la exclusión mutua y desbloquear los otros subprocesos que intentan obtener la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-357">Whenever a thread acquires a mutex (for example, by calling its <xref:System.Threading.WaitHandle.WaitOne%2A> method), it must subsequently call <xref:System.Threading.Mutex.ReleaseMutex%2A> to relinquish ownership of the mutex and unblock other threads that are trying to gain ownership of the mutex.</span></span> <span data-ttu-id="9313f-358">Si se produce un error al intentar obtener la propiedad de la exclusión mutua (por ejemplo, cuando una llamada a la <xref:System.Threading.WaitHandle.WaitOne%2A> método con un `millisecondsTimeout` o un `timeout` parámetro devuelve `false` porque la solicitud agota el tiempo), el subproceso no debería llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A>, en este caso, el subproceso también no debería poder tener acceso al recurso protegido por la exclusión mutua, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="9313f-358">If the attempt to get ownership of the mutex fails (for example, when a call to the <xref:System.Threading.WaitHandle.WaitOne%2A> method with a `millisecondsTimeout` or a `timeout` parameter returns `false` because the request times out), the thread shouldn't call <xref:System.Threading.Mutex.ReleaseMutex%2A>, In this case, the thread should also not be allowed to access the resource protected by the mutex, as the following example shows.</span></span>  
  
 [!code-csharp[System.Threading.Mutex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.mutex.class/cs/example2.cs#2)]
 [!code-vb[System.Threading.Mutex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.mutex.class/vb/example2.vb#2)]  
  
 <span data-ttu-id="9313f-359">Un subproceso que posee una exclusión mutua puede especificar la misma exclusión mutua en espera repetidas llamadas a funciones sin bloquear su ejecución.</span><span class="sxs-lookup"><span data-stu-id="9313f-359">A thread that owns a mutex can specify the same mutex in repeated wait function calls without blocking its execution.</span></span> <span data-ttu-id="9313f-360">El número de llamadas se mantiene por common language runtime.</span><span class="sxs-lookup"><span data-stu-id="9313f-360">The number of calls is kept by the common language runtime.</span></span> <span data-ttu-id="9313f-361">El subproceso debe llamar a <xref:System.Threading.Mutex.ReleaseMutex%2A> el mismo número de veces para liberar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-361">The thread must call <xref:System.Threading.Mutex.ReleaseMutex%2A> the same number of times to release ownership of the mutex.</span></span>  
  
 <span data-ttu-id="9313f-362">Si un subproceso finaliza mientras posee una exclusión mutua, se dice que la exclusión mutua abandonada.</span><span class="sxs-lookup"><span data-stu-id="9313f-362">If a thread terminates while owning a mutex, the mutex is said to be abandoned.</span></span> <span data-ttu-id="9313f-363">El estado de la exclusión mutua se establece en señalado y el siguiente subproceso en espera obtiene la propiedad.</span><span class="sxs-lookup"><span data-stu-id="9313f-363">The state of the mutex is set to signaled and the next waiting thread gets ownership.</span></span> <span data-ttu-id="9313f-364">Si nadie posee la exclusión mutua, el estado de la exclusión mutua se señala.</span><span class="sxs-lookup"><span data-stu-id="9313f-364">If no one owns the mutex, the state of the mutex is signaled.</span></span> <span data-ttu-id="9313f-365">A partir de la versión 2.0 de .NET Framework, un <xref:System.Threading.AbandonedMutexException> se produce en el subproceso siguiente que adquiere la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-365">Beginning in version 2.0 of the .NET Framework, an <xref:System.Threading.AbandonedMutexException> is thrown in the next thread that acquires the mutex.</span></span> <span data-ttu-id="9313f-366">Antes de la versión 2.0 de .NET Framework, se produjo ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="9313f-366">Prior to version 2.0 of the .NET Framework, no exception was thrown.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="9313f-367">A menudo, un mutex abandonado indica un error grave en el código.</span><span class="sxs-lookup"><span data-stu-id="9313f-367">An abandoned mutex often indicates a serious error in the code.</span></span> <span data-ttu-id="9313f-368">Cuando un subproceso sale sin liberar la exclusión mutua, las estructuras de datos protegidas por el mutex no esté en un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="9313f-368">When a thread exits without releasing the mutex, the data structures protected by the mutex might not be in a consistent state.</span></span> <span data-ttu-id="9313f-369">El siguiente subproceso que solicita la propiedad de la exclusión mutua puede controlar esta excepción y continuar si se puede comprobar la integridad de las estructuras de datos.</span><span class="sxs-lookup"><span data-stu-id="9313f-369">The next thread to request ownership of the mutex can handle this exception and proceed, if the integrity of the data structures can be verified.</span></span>  
  
 <span data-ttu-id="9313f-370">En el caso de una exclusión mutua en todo el sistema, una exclusión mutua abandonada podría indicar que una aplicación finalizó inesperadamente (por ejemplo, con el Administrador de tareas de Windows).</span><span class="sxs-lookup"><span data-stu-id="9313f-370">In the case of a system-wide mutex, an abandoned mutex might indicate that an application has been terminated abruptly (for example, by using Windows Task Manager).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-371">El ejemplo siguiente muestra cómo una variable local <xref:System.Threading.Mutex> objeto se usa para sincronizar el acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="9313f-371">The following example shows how a local <xref:System.Threading.Mutex> object is used to synchronize access to a protected resource.</span></span> <span data-ttu-id="9313f-372">El subproceso que crea la exclusión mutua no posee lo inicialmente.</span><span class="sxs-lookup"><span data-stu-id="9313f-372">The thread that creates the mutex does not own it initially.</span></span> <span data-ttu-id="9313f-373">El <xref:System.Threading.Mutex.ReleaseMutex%2A> método se utiliza para liberar la exclusión mutua cuando ya no es necesaria.</span><span class="sxs-lookup"><span data-stu-id="9313f-373">The <xref:System.Threading.Mutex.ReleaseMutex%2A> method is used to release the mutex when it is no longer needed.</span></span>  
  
 [!code-cpp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CPP/class1.cpp#1)]
 [!code-csharp[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/CS/class1.cs#1)]
 [!code-vb[System.Threading.Mutex Default Ctor Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex Default Ctor Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException"><span data-ttu-id="9313f-374">El subproceso que realiza la llamada no posee la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-374">The calling thread does not own the mutex.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="9313f-375">Ya se ha eliminado la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="9313f-375">The current instance has already been disposed.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/index.md"><span data-ttu-id="9313f-376">Subprocesamiento administrado</span><span class="sxs-lookup"><span data-stu-id="9313f-376">Managed Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/mutexes.md"><span data-ttu-id="9313f-377">Mutexes</span><span class="sxs-lookup"><span data-stu-id="9313f-377">Mutexes</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetAccessControl">
      <MemberSignature Language="C#" Value="public void SetAccessControl (System.Security.AccessControl.MutexSecurity mutexSecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAccessControl(class System.Security.AccessControl.MutexSecurity mutexSecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.SetAccessControl(System.Security.AccessControl.MutexSecurity)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAccessControl(System::Security::AccessControl::MutexSecurity ^ mutexSecurity);" />
      <MemberSignature Language="F#" Value="member this.SetAccessControl : System.Security.AccessControl.MutexSecurity -&gt; unit" Usage="mutex.SetAccessControl mutexSecurity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="mutexSecurity" Type="System.Security.AccessControl.MutexSecurity" />
      </Parameters>
      <Docs>
        <param name="mutexSecurity"><span data-ttu-id="9313f-378">Objeto <see cref="T:System.Security.AccessControl.MutexSecurity" /> que representa la seguridad del control de acceso que se va a aplicar a la exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-378">A <see cref="T:System.Security.AccessControl.MutexSecurity" /> object that represents the access control security to be applied to the named system mutex.</span></span></param>
        <summary><span data-ttu-id="9313f-379">Establece la seguridad de control de acceso para una exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-379">Sets the access control security for a named system mutex.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-380">El usuario debe tener <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> derechos para llamar a este método y la exclusión mutua deben haberse abiertos con <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="9313f-380">The user must have <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType> rights to call this method, and the mutex must have been opened with <xref:System.Security.AccessControl.MutexRights.ChangePermissions?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="9313f-381">En el ejemplo de código siguiente se muestra el comportamiento entre procesos de una exclusión mutua con nombre con seguridad de control de acceso.</span><span class="sxs-lookup"><span data-stu-id="9313f-381">The following code example demonstrates the cross-process behavior of a named mutex with access control security.</span></span> <span data-ttu-id="9313f-382">El ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método para probar la existencia de una exclusión mutua con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-382">The example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload to test for the existence of a named mutex.</span></span>  
  
 <span data-ttu-id="9313f-383">Si la exclusión mutua no existe, se crea con la propiedad inicial y la seguridad de control de acceso que impide que el usuario actual el derecho a usar la exclusión mutua, pero le concede el derecho para leer y cambiar los permisos de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-383">If the mutex does not exist, it is created with initial ownership and access control security that denies the current user the right to use the mutex, but grants the right to read and change permissions on the mutex.</span></span>  
  
 <span data-ttu-id="9313f-384">Si ejecuta el ejemplo compilado desde dos ventanas de comandos, la segunda copia producirá una excepción de infracción de acceso en la llamada a <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span><span class="sxs-lookup"><span data-stu-id="9313f-384">If you run the compiled example from two command windows, the second copy will throw an access violation exception on the call to <xref:System.Threading.Mutex.OpenExisting%28System.String%29>.</span></span> <span data-ttu-id="9313f-385">Se detectó la excepción y el ejemplo se usa el <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método para abrir la exclusión mutua con los derechos necesarios para leer y cambiar los permisos, mediante el <xref:System.Threading.Mutex.GetAccessControl%2A> y <xref:System.Threading.Mutex.SetAccessControl%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="9313f-385">The exception is caught, and the example uses the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload to open the mutex with the rights needed to read and change the permissions, using the <xref:System.Threading.Mutex.GetAccessControl%2A> and <xref:System.Threading.Mutex.SetAccessControl%2A> methods.</span></span>  
  
 <span data-ttu-id="9313f-386">Después de cambian los permisos, se abre la exclusión mutua con los derechos necesarios para escribir y liberarlo.</span><span class="sxs-lookup"><span data-stu-id="9313f-386">After the permissions are changed, the mutex is opened with the rights required to enter and release it.</span></span> <span data-ttu-id="9313f-387">Si ejecuta el ejemplo compilado desde una tercera ventana de comandos, se ejecuta con los nuevos permisos.</span><span class="sxs-lookup"><span data-stu-id="9313f-387">If you run the compiled example from a third command window, it runs using the new permissions.</span></span>  
  
 [!code-cpp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/CS/source.cs#1)]
 [!code-vb[System.Threading.Mutex.ctor named 4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Mutex.ctor named 4/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9313f-388">El valor de <paramref name="mutexSecurity" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-388"><paramref name="mutexSecurity" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-389">El usuario no tiene <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-389">The user does not have <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span>  
  
<span data-ttu-id="9313f-390">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-390">-or-</span></span> 
<span data-ttu-id="9313f-391">La exclusión mutua no se abrió con permisos <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-391">The mutex was not opened with <see cref="F:System.Security.AccessControl.MutexRights.ChangePermissions" />.</span></span></exception>
        <exception cref="T:System.SystemException"><span data-ttu-id="9313f-392">El objeto <see cref="T:System.Threading.Mutex" /> actual no representa una exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-392">The current <see cref="T:System.Threading.Mutex" /> object does not represent a named system mutex.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryOpenExisting">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="9313f-393">Abre una exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="9313f-393">Opens a specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9313f-394">Nombre de la exclusión mutua del sistema que se va a abrir.</span><span class="sxs-lookup"><span data-stu-id="9313f-394">The name of the system mutex to open.</span></span></param>
        <param name="result"><span data-ttu-id="9313f-395">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-395">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="9313f-396">Este parámetro se trata como sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="9313f-396">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="9313f-397">Abre la exclusión mutua con nombre especificada, si ya existe, y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="9313f-397">Opens the specified named mutex, if it already exists, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="9313f-398"><see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-398"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-399">Si la exclusión mutua con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="9313f-399">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="9313f-400">Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="9313f-400">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9313f-401">Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-401">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="9313f-402">Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-402">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-403">Esta sobrecarga del método es equivalente a llamar a la <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> sobrecarga del método y especificando <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> y <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> derechos, que se combinan mediante la operación OR bit a bit.</span><span class="sxs-lookup"><span data-stu-id="9313f-403">This method overload is equivalent to calling the <xref:System.Threading.Mutex.TryOpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%2CSystem.Threading.Mutex%40%29> method overload and specifying <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> and <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> rights, combined by using the bitwise OR operation.</span></span> <span data-ttu-id="9313f-404">Especificar el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca permite que un subproceso espere en la exclusión mutua y especificando el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca permite que un subproceso llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-404">Specifying the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag allows a thread to wait on the mutex, and specifying the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag allows a thread to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-405">Este método no solicitar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-405">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-406"><paramref name="name" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="9313f-406"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="9313f-407">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-407">-or-</span></span> 
 <span data-ttu-id="9313f-408"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-408"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9313f-409">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-409"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-410">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-410">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-411">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</span><span class="sxs-lookup"><span data-stu-id="9313f-411">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-412">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-412">requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-413">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-413">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="TryOpenExisting">
      <MemberSignature Language="C#" Value="public static bool TryOpenExisting (string name, System.Security.AccessControl.MutexRights rights, out System.Threading.Mutex result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryOpenExisting(string name, valuetype System.Security.AccessControl.MutexRights rights, [out] class System.Threading.Mutex&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Mutex.TryOpenExisting(System.String,System.Security.AccessControl.MutexRights,System.Threading.Mutex@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryOpenExisting (name As String, rights As MutexRights, ByRef result As Mutex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryOpenExisting(System::String ^ name, System::Security::AccessControl::MutexRights rights, [Runtime::InteropServices::Out] System::Threading::Mutex ^ % result);" />
      <MemberSignature Language="F#" Value="static member TryOpenExisting : string * System.Security.AccessControl.MutexRights *  -&gt; bool" Usage="System.Threading.Mutex.TryOpenExisting (name, rights, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="rights" Type="System.Security.AccessControl.MutexRights" />
        <Parameter Name="result" Type="System.Threading.Mutex" RefType="out" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="9313f-414">Nombre de la exclusión mutua del sistema que se va a abrir.</span><span class="sxs-lookup"><span data-stu-id="9313f-414">The name of the system mutex to open.</span></span></param>
        <param name="rights"><span data-ttu-id="9313f-415">Combinación bit a bit de los valores de la enumeración que representan el acceso de seguridad deseado.</span><span class="sxs-lookup"><span data-stu-id="9313f-415">A bitwise combination of the enumeration values that represent the desired security access.</span></span></param>
        <param name="result"><span data-ttu-id="9313f-416">Cuando este método vuelve, contiene un objeto <see cref="T:System.Threading.Mutex" /> que representa la exclusión mutua con nombre si la llamada se realizó correctamente, o <see langword="null" /> si se produjo un error en la llamada.</span><span class="sxs-lookup"><span data-stu-id="9313f-416">When this method returns, contains a <see cref="T:System.Threading.Mutex" /> object that represents the named mutex if the call succeeded, or <see langword="null" /> if the call failed.</span></span> <span data-ttu-id="9313f-417">Este parámetro se trata como sin inicializar.</span><span class="sxs-lookup"><span data-stu-id="9313f-417">This parameter is treated as uninitialized.</span></span></param>
        <summary><span data-ttu-id="9313f-418">Abre la exclusión mutua con nombre especificada, si ya existe, con el acceso de seguridad deseado y devuelve un valor que indica si la operación se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="9313f-418">Opens the specified named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="9313f-419"><see langword="true" /> si la exclusión mutua con nombre se abrió correctamente; si no, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-419"><see langword="true" /> if the named mutex was opened successfully; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="9313f-420">Si la exclusión mutua con nombre no existe, este método no la crea.</span><span class="sxs-lookup"><span data-stu-id="9313f-420">If the named mutex does not exist, this method does not create it.</span></span> <span data-ttu-id="9313f-421">Para crear la exclusión mutua del sistema cuando no existe, use uno de los <xref:System.Threading.Mutex.%23ctor%2A> constructores que tiene un `name` parámetro.</span><span class="sxs-lookup"><span data-stu-id="9313f-421">To create the system mutex when it does not already exist, use one of the <xref:System.Threading.Mutex.%23ctor%2A> constructors that has a `name` parameter.</span></span>  
  
 <span data-ttu-id="9313f-422">Si no está seguro de si existe una exclusión mutua con nombre, utilice esta sobrecarga del método en lugar de la <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> sobrecarga del método que produce una excepción si la exclusión mutua no existe.</span><span class="sxs-lookup"><span data-stu-id="9313f-422">If you are uncertain whether a named mutex exists, use this method overload instead of the <xref:System.Threading.Mutex.OpenExisting%28System.String%2CSystem.Security.AccessControl.MutexRights%29> method overload, which throws an exception if the mutex does not exist.</span></span>  
  
 <span data-ttu-id="9313f-423">El `rights` parámetro debe incluir el <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> marca para permitir que los subprocesos esperen en la exclusión mutua y el <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> marca para permitir que los subprocesos llamar a la <xref:System.Threading.Mutex.ReleaseMutex%2A> método.</span><span class="sxs-lookup"><span data-stu-id="9313f-423">The `rights` parameter must include the <xref:System.Security.AccessControl.MutexRights.Synchronize?displayProperty=nameWithType> flag to allow threads to wait on the mutex, and the <xref:System.Security.AccessControl.MutexRights.Modify?displayProperty=nameWithType> flag to allow threads to call the <xref:System.Threading.Mutex.ReleaseMutex%2A> method.</span></span>  
  
 <span data-ttu-id="9313f-424">Varias llamadas a este método que usan el mismo valor para `name` necesariamente no devolver el mismo <xref:System.Threading.Mutex> objeto, aunque los objetos devueltos representan la misma exclusión mutua del sistema con nombre.</span><span class="sxs-lookup"><span data-stu-id="9313f-424">Multiple calls to this method that use the same value for `name` do not necessarily return the same <xref:System.Threading.Mutex> object, even though the objects that are returned represent the same named system mutex.</span></span>  
  
 <span data-ttu-id="9313f-425">Este método no solicitar la propiedad de la exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="9313f-425">This method does not request ownership of the mutex.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="9313f-426"><paramref name="name" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="9313f-426"><paramref name="name" /> is an empty string.</span></span>  
  
<span data-ttu-id="9313f-427">O bien</span><span class="sxs-lookup"><span data-stu-id="9313f-427">-or-</span></span> 
 <span data-ttu-id="9313f-428"><paramref name="name" /> tiene más de 260 caracteres.</span><span class="sxs-lookup"><span data-stu-id="9313f-428"><paramref name="name" /> is longer than 260 characters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="9313f-429">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="9313f-429"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.IOException"><span data-ttu-id="9313f-430">Error de Win32.</span><span class="sxs-lookup"><span data-stu-id="9313f-430">A Win32 error occurred.</span></span></exception>
        <exception cref="T:System.UnauthorizedAccessException"><span data-ttu-id="9313f-431">La exclusión mutua con nombre existe, pero el usuario no tiene el acceso de seguridad necesario para usarla.</span><span class="sxs-lookup"><span data-stu-id="9313f-431">The named mutex exists, but the user does not have the security access required to use it.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="9313f-432">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="9313f-432">requires full trust for the immediate caller.</span></span> <span data-ttu-id="9313f-433">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="9313f-433">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>