<Type Name="Monitor" FullName="System.Threading.Monitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="df70f7cc62e1ef013835d69cf0220d9e8b42bc5a" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48729805" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class Monitor" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit Monitor extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Monitor" />
  <TypeSignature Language="VB.NET" Value="Public Class Monitor" />
  <TypeSignature Language="C++ CLI" Value="public ref class Monitor abstract sealed" />
  <TypeSignature Language="F#" Value="type Monitor = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="d7e10-101">Proporciona un mecanismo que sincroniza el acceso a los objetos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d7e10-101">Provides a mechanism that synchronizes access to objects.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-102">El <xref:System.Threading.Monitor> clase le permite sincronizar el acceso a una región de código mediante la obtención y liberación de un bloqueo en un objeto determinado mediante una llamada a la <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, y <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-102">The <xref:System.Threading.Monitor> class allows you to synchronize access to a region of code by taking and releasing a lock on a particular object by calling the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.TryEnter%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> methods.</span></span> <span data-ttu-id="d7e10-103">Los bloqueos de objeto proporcionan la capacidad para restringir el acceso a un bloque de código, normalmente denominado una sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-103">Object locks provide the ability to restrict access to a block of code, commonly called a critical section.</span></span> <span data-ttu-id="d7e10-104">Mientras un subproceso posee el bloqueo de un objeto, ningún otro subproceso puede adquirir ese bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-104">While a thread owns the lock for an object, no other thread can acquire that lock.</span></span> <span data-ttu-id="d7e10-105">También puede usar el <xref:System.Threading.Monitor> clase para asegurarse de que ningún otro subproceso puede tener acceso a una sección de la aplicación de código que se está ejecutando por el propietario del bloqueo, a menos que el otro subproceso está ejecutando el código que usa un objeto bloqueado distinto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-105">You can also use the <xref:System.Threading.Monitor> class to ensure that no other thread is allowed to access a section of application code being executed by the lock owner, unless the other thread is executing the code using a different locked object.</span></span>  
  
 <span data-ttu-id="d7e10-106">En este artículo:</span><span class="sxs-lookup"><span data-stu-id="d7e10-106">In this article:</span></span>  
  
 <span data-ttu-id="d7e10-107">[La clase Monitor: información general](#Overview) </span><span class="sxs-lookup"><span data-stu-id="d7e10-107">[The Monitor class: An overview](#Overview) </span></span>  
 <span data-ttu-id="d7e10-108">[El objeto de bloqueo](#Lock) </span><span class="sxs-lookup"><span data-stu-id="d7e10-108">[The lock object](#Lock) </span></span>  
 <span data-ttu-id="d7e10-109">[La sección crítica](#CriticalSection) </span><span class="sxs-lookup"><span data-stu-id="d7e10-109">[The critical section](#CriticalSection) </span></span>  
 <span data-ttu-id="d7e10-110">[Pulse, PulseAll y espera](#Pulse) </span><span class="sxs-lookup"><span data-stu-id="d7e10-110">[Pulse, PulseAll, and Wait](#Pulse) </span></span>  
 [<span data-ttu-id="d7e10-111">Monitores y los identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="d7e10-111">Monitors and wait handles</span></span>](#WaitHandles)  
  
<a name="Overview"></a>   
## <a name="the-monitor-class-an-overview"></a><span data-ttu-id="d7e10-112">La clase Monitor: información general</span><span class="sxs-lookup"><span data-stu-id="d7e10-112">The Monitor class: An overview</span></span>  
 <span data-ttu-id="d7e10-113"><xref:System.Threading.Monitor> tiene las siguientes características:</span><span class="sxs-lookup"><span data-stu-id="d7e10-113"><xref:System.Threading.Monitor> has the following features:</span></span>  
  
-   <span data-ttu-id="d7e10-114">Está asociado con un objeto a petición.</span><span class="sxs-lookup"><span data-stu-id="d7e10-114">It is associated with an object on demand.</span></span>  
  
-   <span data-ttu-id="d7e10-115">Es independiente, lo que significa que puede llamarse directamente desde cualquier contexto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-115">It is unbound, which means it can be called directly from any context.</span></span>  
  
-   <span data-ttu-id="d7e10-116">Una instancia de la <xref:System.Threading.Monitor> no se puede crear la clase; los métodos de la <xref:System.Threading.Monitor> clase son todos estáticos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-116">An instance of the <xref:System.Threading.Monitor> class cannot be created; the methods of the <xref:System.Threading.Monitor> class are all static.</span></span> <span data-ttu-id="d7e10-117">Cada método se pasa el objeto sincronizado que controla el acceso a la sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-117">Each method is passed the synchronized object that controls access to the critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-118">Use la <xref:System.Threading.Monitor> clase para objetos de bloqueo que no sean cadenas (es decir, tipos de referencia distinto <xref:System.String>), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-118">Use the <xref:System.Threading.Monitor> class to lock objects other than strings (that is, reference types other than <xref:System.String>), not value types.</span></span> <span data-ttu-id="d7e10-119">Para obtener más información, vea las sobrecargas de los <xref:System.Threading.Monitor.Enter%2A> método y [el objeto de bloqueo](#Lock) sección más adelante en este artículo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-119">For details, see the overloads of the <xref:System.Threading.Monitor.Enter%2A> method and [The lock object](#Lock) section later in this article.</span></span>  
  
 <span data-ttu-id="d7e10-120">En la tabla siguiente se describe las acciones que pueden realizarse por los subprocesos que tienen acceso a los objetos sincronizados:</span><span class="sxs-lookup"><span data-stu-id="d7e10-120">The following table describes the actions that can be taken by threads that access synchronized objects:</span></span>  
  
|<span data-ttu-id="d7e10-121">Acción</span><span class="sxs-lookup"><span data-stu-id="d7e10-121">Action</span></span>|<span data-ttu-id="d7e10-122">Descripción</span><span class="sxs-lookup"><span data-stu-id="d7e10-122">Description</span></span>|  
|------------|-----------------|  
|<span data-ttu-id="d7e10-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span><span class="sxs-lookup"><span data-stu-id="d7e10-123"><xref:System.Threading.Monitor.Enter%2A>, <xref:System.Threading.Monitor.TryEnter%2A></span></span>|<span data-ttu-id="d7e10-124">Adquiere un bloqueo de un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-124">Acquires a lock for an object.</span></span> <span data-ttu-id="d7e10-125">Esta acción también marca el principio de una sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-125">This action also marks the beginning of a critical section.</span></span> <span data-ttu-id="d7e10-126">Ningún otro subproceso puede entrar en la sección crítica, a menos que se ejecuta las instrucciones que aparecen en la sección crítica utilizando un objeto bloqueado distinto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-126">No other thread can enter the critical section unless it is executing the instructions in the critical section using a different locked object.</span></span>|  
|<xref:System.Threading.Monitor.Wait%2A>|<span data-ttu-id="d7e10-127">Libera el bloqueo en un objeto con el fin de permitir que otros subprocesos de bloqueo y obtener acceso al objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-127">Releases the lock on an object in order to permit other threads to lock and access the object.</span></span> <span data-ttu-id="d7e10-128">Espera a que el subproceso de llamada mientras otro subproceso tiene acceso al objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-128">The calling thread waits while another thread accesses the object.</span></span> <span data-ttu-id="d7e10-129">Las señales de pulsos se usan para notificar a los subprocesos en espera sobre los cambios en el estado de un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-129">Pulse signals are used to notify waiting threads about changes to an object's state.</span></span>|  
|<span data-ttu-id="d7e10-130"><xref:System.Threading.Monitor.Pulse%2A> (señal), <xref:System.Threading.Monitor.PulseAll%2A></span><span class="sxs-lookup"><span data-stu-id="d7e10-130"><xref:System.Threading.Monitor.Pulse%2A> (signal), <xref:System.Threading.Monitor.PulseAll%2A></span></span>|<span data-ttu-id="d7e10-131">Envía una señal a uno o varios subprocesos en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-131">Sends a signal to one or more waiting threads.</span></span> <span data-ttu-id="d7e10-132">La señal notifica a un subproceso en espera que se ha cambiado el estado del objeto bloqueado, y el propietario del bloqueo está listo para liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-132">The signal notifies a waiting thread that the state of the locked object has changed, and the owner of the lock is ready to release the lock.</span></span> <span data-ttu-id="d7e10-133">El subproceso en espera se coloca en la cola del objeto listo para que pueda recibir el bloqueo para el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-133">The waiting thread is placed in the object's ready queue so that it might eventually receive the lock for the object.</span></span> <span data-ttu-id="d7e10-134">Una vez que el subproceso tiene el bloqueo, puede comprobar el estado nueva del objeto para ver si se ha alcanzado el estado necesario.</span><span class="sxs-lookup"><span data-stu-id="d7e10-134">Once the thread has the lock, it can check the new state of the object to see if the required state has been reached.</span></span>|  
|<xref:System.Threading.Monitor.Exit%2A>|<span data-ttu-id="d7e10-135">Libera el bloqueo en un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-135">Releases the lock on an object.</span></span> <span data-ttu-id="d7e10-136">Esta acción también marca el final de una sección crítica protegida por el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-136">This action also marks the end of a critical section protected by the locked object.</span></span>|  
  
 <span data-ttu-id="d7e10-137">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], hay dos conjuntos de sobrecargas para el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.TryEnter%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-137">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], there are two sets of overloads for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.TryEnter%2A> methods.</span></span> <span data-ttu-id="d7e10-138">Un conjunto de sobrecargas tiene un `ref` (en C#) o `ByRef` (en Visual Basic) <xref:System.Boolean> parámetro que se establece de forma atómica en `true` si se adquiere el bloqueo, incluso si se produce una excepción al adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-138">One set of overloads has a `ref` (in C#) or `ByRef` (in Visual Basic) <xref:System.Boolean> parameter that is atomically set to `true` if the lock is acquired, even if an exception is thrown when acquiring the lock.</span></span> <span data-ttu-id="d7e10-139">Use estas sobrecargas si es fundamental para liberar el bloqueo en todos los casos, incluso cuando los recursos que se está protegiendo el bloqueo no esté en un estado coherente.</span><span class="sxs-lookup"><span data-stu-id="d7e10-139">Use these overloads if it is critical to release the lock in all cases, even when the resources the lock is protecting might not be in a consistent state.</span></span>  
  
<a name="Lock"></a>   
## <a name="the-lock-object"></a><span data-ttu-id="d7e10-140">El objeto de bloqueo</span><span class="sxs-lookup"><span data-stu-id="d7e10-140">The lock object</span></span>  
 <span data-ttu-id="d7e10-141">La clase Monitor consta de `static` (en C#) o `Shared` (en Visual Basic) entre los métodos que operan en un objeto que controla el acceso a la sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-141">The Monitor class consists of `static` (in C#) or  `Shared` (in Visual Basic) methods that operate on an object that controls access to the critical section.</span></span>  <span data-ttu-id="d7e10-142">La siguiente información se mantiene para cada objeto sincronizado:</span><span class="sxs-lookup"><span data-stu-id="d7e10-142">The following information is maintained for each synchronized object:</span></span>  
  
-   <span data-ttu-id="d7e10-143">Una referencia al subproceso que actualmente mantiene el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-143">A reference to the thread that currently holds the lock.</span></span>  
  
-   <span data-ttu-id="d7e10-144">Una referencia a una cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-144">A reference to a ready queue, which contains the threads that are ready to obtain the lock.</span></span>  
  
-   <span data-ttu-id="d7e10-145">Una referencia a una cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-145">A reference to a waiting queue, which contains the threads that are waiting for notification of a change in the state of the locked object.</span></span>  
  
 <span data-ttu-id="d7e10-146"><xref:System.Threading.Monitor> bloquea objetos (es decir, tipos de referencia), no tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-146"><xref:System.Threading.Monitor> locks objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-147">Aunque puede pasar un tipo de valor a <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, se somete a una conversión boxing independiente para cada llamada.</span><span class="sxs-lookup"><span data-stu-id="d7e10-147">While you can pass a value type to <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, it is boxed separately for each call.</span></span> <span data-ttu-id="d7e10-148">Puesto que cada llamada crea un objeto independiente, <xref:System.Threading.Monitor.Enter%2A> nunca bloquea y el código al que supuestamente protege no está sincronizado realmente.</span><span class="sxs-lookup"><span data-stu-id="d7e10-148">Since each call creates a separate object, <xref:System.Threading.Monitor.Enter%2A> never blocks, and the code it is supposedly protecting is not really synchronized.</span></span> <span data-ttu-id="d7e10-149">Además, el objeto que se pasa a <xref:System.Threading.Monitor.Exit%2A> es diferente del objeto que se pasa a <xref:System.Threading.Monitor.Enter%2A>, por lo que <xref:System.Threading.Monitor> produce la excepción <xref:System.Threading.SynchronizationLockException> con el mensaje “El método de sincronización del objeto se ha llamado desde un bloque de códigos sin sincronizar.”.</span><span class="sxs-lookup"><span data-stu-id="d7e10-149">In addition, the object passed to <xref:System.Threading.Monitor.Exit%2A> is different from the object passed to <xref:System.Threading.Monitor.Enter%2A>, so <xref:System.Threading.Monitor> throws <xref:System.Threading.SynchronizationLockException> exception with the message "Object synchronization method was called from an unsynchronized block of code."</span></span>  
  
 <span data-ttu-id="d7e10-150">El siguiente ejemplo ilustra este problema.</span><span class="sxs-lookup"><span data-stu-id="d7e10-150">The following example illustrates this problem.</span></span> <span data-ttu-id="d7e10-151">Inicia diez tareas, cada una de los cuales solo se suspende durante 250 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-151">It launches ten tasks, each of which just sleeps for 250 milliseconds.</span></span> <span data-ttu-id="d7e10-152">A continuación, cada tarea actualiza una variable de contador, `nTasks`, pensada para contar el número de tareas que realmente se iniciaron y ejecutaron.</span><span class="sxs-lookup"><span data-stu-id="d7e10-152">Each task then updates a counter variable, `nTasks`, which is intended to count the number of tasks that actually launched and executed.</span></span> <span data-ttu-id="d7e10-153">Dado que `nTasks` es una variable global que pueden actualizar varias tareas al mismo tiempo, se usa un monitor para protegerla frente a modificaciones simultáneas de varias tareas.</span><span class="sxs-lookup"><span data-stu-id="d7e10-153">Because `nTasks` is a global variable that can be updated by multiple tasks simultaneously, a monitor is used to protect it from simultaneous modification by multiple tasks.</span></span> <span data-ttu-id="d7e10-154">Sin embargo, como muestra la salida del ejemplo, cada una de las tareas produce una excepción <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-154">However, as the output from the example shows, each of the tasks throws a <xref:System.Threading.SynchronizationLockException> exception.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#2](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badlock1.cs#2)]
 [!code-vb[Conceptual.Monitors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badlock1.vb#2)]  
  
 <span data-ttu-id="d7e10-155">Cada tarea produce una excepción <xref:System.Threading.SynchronizationLockException> porque la variable `nTasks` es objeto de a una conversión boxing antes de llamar al método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> en cada tarea.</span><span class="sxs-lookup"><span data-stu-id="d7e10-155">Each task throws a <xref:System.Threading.SynchronizationLockException> exception because the `nTasks` variable is boxed before the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method in each task.</span></span> <span data-ttu-id="d7e10-156">En otras palabras, a cada llamada al método se le pasa una variable independiente, que es independiente del resto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-156">In other words, each method call is passed a separate variable that is independent of the others.</span></span> <span data-ttu-id="d7e10-157">`nTasks` se vuelve a someter a una conversión boxing en la llamada al método <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-157">`nTasks` is boxed again in the call to the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d7e10-158">Una vez más, esto crea diez nuevas variables sometidas a conversión boxing, que son independientes entre sí, `nTasks`, y las diez variables creadas en la llamada al método <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> y sometidas a una conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="d7e10-158">Once again, this creates ten new boxed variables, which are independent of each other, `nTasks`, and the ten boxed variables created in the call to the <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d7e10-159">A continuación, se produce la excepción porque el código está intentando liberar un bloqueo en una variable recién creada que no se ha bloqueado anteriormente.</span><span class="sxs-lookup"><span data-stu-id="d7e10-159">The exception is thrown, then, because our code is attempting to release a lock on a newly created variable that was not previously locked.</span></span>  
  
 <span data-ttu-id="d7e10-160">Aunque puede aplicar una conversión boxing a una variable de tipo de valor antes de llamar a <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A>, tal como se muestra en el siguiente ejemplo, y pasar el mismo objeto sometido a conversión boxing a ambos métodos, hacerlo no ofrece ninguna ventaja.</span><span class="sxs-lookup"><span data-stu-id="d7e10-160">Although you can box a value type variable before calling <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A>, as shown in the following example, and pass the same boxed object to both methods, there is no advantage to doing this.</span></span> <span data-ttu-id="d7e10-161">Los cambios realizados en la variable sometida a conversión unboxing no se reflejan en la copia sometida a conversión boxing, y no hay ninguna forma de cambiar el valor de la copia de sometida a conversión boxing.</span><span class="sxs-lookup"><span data-stu-id="d7e10-161">Changes to the unboxed variable are not reflected in the boxed copy, and there is no way to change the value of the boxed copy.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#3](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/badbox1.cs#3)]
 [!code-vb[Conceptual.Monitors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/badbox1.vb#3)]  
  
 <span data-ttu-id="d7e10-162">Al seleccionar un objeto en el que se va a sincronizar, debe bloquear solo en objetos privados o internos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-162">When selecting an object on which to synchronize, you should lock only on private or internal objects.</span></span> <span data-ttu-id="d7e10-163">El bloqueo de objetos externos, se podría producir interbloqueos, porque el código relacionado con podría elegir los mismos objetos para bloquear para distintos fines.</span><span class="sxs-lookup"><span data-stu-id="d7e10-163">Locking on external objects might result in deadlocks, because unrelated code could choose the same objects to lock on for different purposes.</span></span>  
  
 <span data-ttu-id="d7e10-164">Tenga en cuenta que puede sincronizar en un objeto en varios dominios de aplicación si el objeto usado para el bloqueo deriva <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-164">Note that you can synchronize on an object in multiple application domains if the object used for the lock derives from <xref:System.MarshalByRefObject>.</span></span>  
  
<a name="CriticalSection"></a>   
## <a name="the-critical-section"></a><span data-ttu-id="d7e10-165">La sección crítica</span><span class="sxs-lookup"><span data-stu-id="d7e10-165">The critical section</span></span>  
 <span data-ttu-id="d7e10-166">Use la <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos para marcar el principio y al final de una sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-166">Use the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods to mark the beginning and end of a critical section.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-167">La funcionalidad proporcionada por el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos es idéntica a la que ofrece el [bloqueo](~/docs/csharp/language-reference/keywords/lock-statement.md) instrucción en C# y el [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrucción en Visual Basic, salvo que el construcciones de lenguaje encapsulado el <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> sobrecarga del método y el <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> método en un `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="d7e10-167">The functionality provided by the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods is identical to that provided by the [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement in C# and the [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement in Visual Basic, except that the language constructs wrap the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29?displayProperty=nameWithType> method overload and the <xref:System.Threading.Monitor.Exit%2A?displayProperty=nameWithType> method in a `try`…`finally`</span></span> <span data-ttu-id="d7e10-168">bloque para asegurarse de que se libera el monitor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-168">block to ensure that the monitor is released.</span></span>  
  
 <span data-ttu-id="d7e10-169">Si la sección crítica es un conjunto de instrucciones contiguas, a continuación, el bloqueo adquirido por el <xref:System.Threading.Monitor.Enter%2A> método garantiza que solo un subproceso puede ejecutar el código delimitado con el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-169">If the critical section is a set of contiguous instructions, then the lock acquired by the <xref:System.Threading.Monitor.Enter%2A> method guarantees that only a single thread can execute the enclosed code with the locked object.</span></span> <span data-ttu-id="d7e10-170">En este caso, se recomienda colocar ese código en un `try` bloquear y realizar una llamada a la <xref:System.Threading.Monitor.Exit%2A> método en un `finally` bloque.</span><span class="sxs-lookup"><span data-stu-id="d7e10-170">In this case, we recommend that you place that code in a `try` block and place the call to the <xref:System.Threading.Monitor.Exit%2A> method in a `finally` block.</span></span> <span data-ttu-id="d7e10-171">Esto garantiza la liberación del bloqueo aunque se produzca una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-171">This ensures that the lock is released even if an exception occurs.</span></span> <span data-ttu-id="d7e10-172">El siguiente fragmento de código muestra este patrón.</span><span class="sxs-lookup"><span data-stu-id="d7e10-172">The following code fragment illustrates this pattern.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#2)]
 [!code-vb[System.Threading.Monitor.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#2)]  
  
 <span data-ttu-id="d7e10-173">Esta función normalmente se utiliza para sincronizar el acceso a ningún elemento estático o un método de instancia de una clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-173">This facility is typically used to synchronize access to a static or instance method of a class.</span></span>  
  
 <span data-ttu-id="d7e10-174">Si una sección crítica abarca todo un método, la utilidad de bloqueo puede lograrse mediante la colocación de la <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> en el método y especificando el <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> valor en el constructor de <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-174">If a critical section spans an entire method, the locking facility can be achieved by placing the <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType> on the method, and specifying the <xref:System.Runtime.CompilerServices.MethodImplOptions.Synchronized> value in the constructor of <xref:System.Runtime.CompilerServices.MethodImplAttribute?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d7e10-175">Cuando se utiliza este atributo, el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> no son necesarias las llamadas a métodos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-175">When you use this attribute, the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> method calls are not needed.</span></span> <span data-ttu-id="d7e10-176">El siguiente fragmento de código muestra este patrón:</span><span class="sxs-lookup"><span data-stu-id="d7e10-176">The following code fragment illustrates this pattern:</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/Pattern2.cs#3)]
 [!code-vb[System.Threading.Monitor.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/Pattern2.vb#3)]  
  
 <span data-ttu-id="d7e10-177">Tenga en cuenta que el atributo hace que el subproceso actual mantiene el bloqueo hasta que el método devuelve; Si el bloqueo puede liberarse antes, utilice la <xref:System.Threading.Monitor> clase C#, [bloqueo](~/docs/csharp/language-reference/keywords/lock-statement.md) instrucción o Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) instrucción dentro del método en lugar del atributo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-177">Note that the attribute causes the current thread to hold the lock until the method returns; if the lock can be released sooner, use the <xref:System.Threading.Monitor> class, the C# [lock](~/docs/csharp/language-reference/keywords/lock-statement.md) statement, or the Visual Basic [SyncLock](~/docs/visual-basic/language-reference/statements/synclock-statement.md) statement inside of the method instead of the attribute.</span></span>  
  
 <span data-ttu-id="d7e10-178">Aunque es posible que el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> las instrucciones que bloquear y liberar un objeto determinado para cruzar los límites de clase y miembro, no se recomienda esta práctica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-178">While it is possible for the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> statements that lock and release a given object to cross member or class boundaries or both, this practice is not recommended.</span></span>  
  
<a name="Pulse"></a>   
## <a name="pulse-pulseall-and-wait"></a><span data-ttu-id="d7e10-179">Pulse, PulseAll y espera</span><span class="sxs-lookup"><span data-stu-id="d7e10-179">Pulse, PulseAll, and Wait</span></span>  
 <span data-ttu-id="d7e10-180">Una vez que un subproceso posee el bloqueo y ha entrado en la sección crítica que protege el bloqueo, puede llamar a la <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, y <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> métodos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-180">Once a thread owns the lock and has entered the critical section that the lock protects, it can call the <xref:System.Threading.Monitor.Wait%2A?displayProperty=nameWithType>, <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType>, and <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="d7e10-181">Cuando el subproceso que contiene las llamadas de bloqueo <xref:System.Threading.Monitor.Wait%2A>, se libera el bloqueo y el subproceso se agrega a la cola de espera del objeto sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-181">When the thread that holds the lock calls <xref:System.Threading.Monitor.Wait%2A>, the lock is released and the thread is added to the waiting queue of the synchronized object.</span></span> <span data-ttu-id="d7e10-182">El primer subproceso en la cola de subprocesos listos, si los hay, adquiere el bloqueo y entra en la sección crítica.</span><span class="sxs-lookup"><span data-stu-id="d7e10-182">The first thread in the ready queue, if any, acquires the lock and enters the critical section.</span></span> <span data-ttu-id="d7e10-183">El subproceso se mueve desde la cola de espera para la cola lista cuando ya sea el <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (para mover, el subproceso debe estar en el encabezado de la cola de espera) o el <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> se llama al método por el subproceso que mantiene el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-183">The thread is moved from the waiting queue to the ready queue when either the <xref:System.Threading.Monitor.Pulse%2A?displayProperty=nameWithType> (to be moved, the thread must be at the head of the waiting queue) or the <xref:System.Threading.Monitor.PulseAll%2A?displayProperty=nameWithType> method is called by the thread that holds the lock.</span></span> <span data-ttu-id="d7e10-184">El <xref:System.Threading.Monitor.Wait%2A> método devuelve cuando el subproceso que realiza la llamada vuelve a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-184">The <xref:System.Threading.Monitor.Wait%2A> method returns when the calling thread reacquires the lock.</span></span>  
  
 <span data-ttu-id="d7e10-185">Cuando el subproceso que contiene las llamadas de bloqueo <xref:System.Threading.Monitor.Pulse%2A>, el subproceso en el encabezado de la cola de espera se mueve a la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-185">When the thread that holds the lock calls <xref:System.Threading.Monitor.Pulse%2A>, the thread at the head of the waiting queue is moved to the ready queue.</span></span> <span data-ttu-id="d7e10-186">La llamada a la <xref:System.Threading.Monitor.PulseAll%2A> método mueve todos los subprocesos de la cola de espera a la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-186">The call to the <xref:System.Threading.Monitor.PulseAll%2A> method moves all the threads from the waiting queue to the ready queue.</span></span>  
  
<a name="WaitHandles"></a>   
## <a name="monitors-and-wait-handles"></a><span data-ttu-id="d7e10-187">Monitores y los identificadores de espera</span><span class="sxs-lookup"><span data-stu-id="d7e10-187">Monitors and wait handles</span></span>  
 <span data-ttu-id="d7e10-188">Es importante tener en cuenta la distinción entre el uso de la <xref:System.Threading.Monitor> clase y <xref:System.Threading.WaitHandle> objetos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-188">It is important to note the distinction between the use of the <xref:System.Threading.Monitor> class and <xref:System.Threading.WaitHandle> objects.</span></span>  
  
-   <span data-ttu-id="d7e10-189">La <xref:System.Threading.Monitor> clase es puramente administrados, son totalmente portátiles y podrían ser más eficaces en cuanto a los requisitos de recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-189">The <xref:System.Threading.Monitor> class is purely managed, fully portable, and might be more efficient in terms of operating-system resource requirements.</span></span>  
  
-   <span data-ttu-id="d7e10-190">Los objetos <xref:System.Threading.WaitHandle> representan objetos del sistema operativo que pueden esperar, que son útiles para la sincronización entre el código administrado y el no administrado y exponen algunas características avanzadas del sistema operativo, como la capacidad de esperar muchos objetos a la vez.</span><span class="sxs-lookup"><span data-stu-id="d7e10-190"><xref:System.Threading.WaitHandle> objects represent operating-system waitable objects, are useful for synchronizing between managed and unmanaged code, and expose some advanced operating-system features like the ability to wait on many objects at once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-191">En el ejemplo siguiente se usa el <xref:System.Threading.Monitor> clase para sincronizar el acceso a una sola instancia de un generador de números aleatorios, representado por la <xref:System.Random> clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-191">The following example uses the <xref:System.Threading.Monitor> class to synchronize access to a single instance of a random number generator represented by the <xref:System.Random> class.</span></span> <span data-ttu-id="d7e10-192">El ejemplo crea diez tareas, cada uno de los cuales se ejecuta de forma asincrónica en un subproceso ThreadPool.</span><span class="sxs-lookup"><span data-stu-id="d7e10-192">The example creates ten tasks, each of which executes asynchronously on a thread pool thread.</span></span> <span data-ttu-id="d7e10-193">Cada tarea genera números aleatorios 10.000, calcula su Media y actualiza dos variables de nivel de procedimiento que mantienen un total acumulado del número de números aleatorios generados y su suma.</span><span class="sxs-lookup"><span data-stu-id="d7e10-193">Each task generates 10,000 random numbers, calculates their average, and updates two procedure-level variables that maintain a running total of the number of random numbers generated and their sum.</span></span> <span data-ttu-id="d7e10-194">Después de que se han ejecutado todas las tareas, estos dos valores, a continuación, se utilizan para calcular la media general.</span><span class="sxs-lookup"><span data-stu-id="d7e10-194">After all tasks have executed, these two values are then used to calculate the overall mean.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.class/cs/example1.cs#1)]
 [!code-vb[System.Threading.Monitor.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.class/vb/example1.vb#1)]  
  
 <span data-ttu-id="d7e10-195">Dado que se pueden acceder desde cualquier tarea que se ejecuta en un subproceso ThreadPool, acceder a las variables `total` y `n` también deben estar sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="d7e10-195">Because they can be accessed from any task running on a thread pool thread, access to the variables `total` and `n` must also be synchronized.</span></span> <span data-ttu-id="d7e10-196">El <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> método se usa para este propósito.</span><span class="sxs-lookup"><span data-stu-id="d7e10-196">The <xref:System.Threading.Interlocked.Add%2A?displayProperty=nameWithType> method is used for this purpose.</span></span>  
  
 <span data-ttu-id="d7e10-197">En el ejemplo siguiente se muestra el uso combinado de la <xref:System.Threading.Monitor> clase (implementada con el `lock` o `SyncLock` construcción de lenguaje), el <xref:System.Threading.Interlocked> (clase) y el <xref:System.Threading.AutoResetEvent> clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-197">The following example demonstrates the combined use of the <xref:System.Threading.Monitor> class (implemented with the `lock` or `SyncLock` language construct), the <xref:System.Threading.Interlocked> class, and the <xref:System.Threading.AutoResetEvent> class.</span></span> <span data-ttu-id="d7e10-198">Define dos `internal` (en C#) o `Friend` (en Visual Basic), las clases de `SyncResource` y `UnSyncResource`, que proporcionan respectivamente acceso sincronizado y sin sincronizar a un recurso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-198">It defines two `internal` (in C#) or `Friend` (in Visual Basic) classes, `SyncResource` and `UnSyncResource`, that respectively provide synchronized and unsynchronized access to a resource.</span></span> <span data-ttu-id="d7e10-199">Para asegurarse de que el ejemplo ilustra la diferencia entre el acceso sincronizado y sin sincronizar (que podría ser el caso si cada llamada al método se realiza rápidamente), el método incluye un retraso aleatorio: para subprocesos cuya <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propiedad es par, el las llamadas al método <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> para insertar un retraso de 2.000 milisegundos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-199">To ensure that the example illustrates the difference between the synchronized and unsynchronized access (which could be the case if each method call completes rapidly), the method includes a random delay: for threads whose <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property is even, the method calls <xref:System.Threading.Thread.Sleep%2A?displayProperty=nameWithType> to introduce a delay of 2,000 milliseconds.</span></span> <span data-ttu-id="d7e10-200">Tenga en cuenta que, dado el `SyncResource` clase no es pública, ninguno de los códigos de cliente toma un bloqueo en el recurso sincronizado, la propia clase interna que adopta el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-200">Note that, because the `SyncResource` class is not public, none of the client code takes a lock on the synchronized resource; the internal class itself takes the lock.</span></span> <span data-ttu-id="d7e10-201">Esto evita que cualquier código malintencionado se haga cargo de un bloqueo en un objeto público.</span><span class="sxs-lookup"><span data-stu-id="d7e10-201">This prevents malicious code from taking a lock on a public object.</span></span>  
  
 [!code-csharp[Conceptual.Monitors#1](~/samples/snippets/csharp/VS_Snippets_CLR/conceptual.monitors/cs/source.cs#1)]
 [!code-vb[Conceptual.Monitors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/conceptual.monitors/vb/source.vb#1)]  
  
 <span data-ttu-id="d7e10-202">El ejemplo define una variable, `numOps`, que define el número de subprocesos que intentarán tener acceso al recurso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-202">The example defines a variable, `numOps`, that defines the number of threads that will attempt to access the resource.</span></span> <span data-ttu-id="d7e10-203">El subproceso de la aplicación llama a la <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> método sincronizado y no sincronizadas tener acceso a cinco veces cada uno.</span><span class="sxs-lookup"><span data-stu-id="d7e10-203">The application thread calls the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method for synchronized and unsynchronized access five times each.</span></span> <span data-ttu-id="d7e10-204">El <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> método tiene un único parámetro, un delegado que no acepta parámetros y no devuelve ningún valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-204">The <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%29?displayProperty=nameWithType> method has a single parameter, a delegate that accepts no parameters and returns no value.</span></span> <span data-ttu-id="d7e10-205">Para obtener acceso sincronizado, invoca el `SyncUpdateResource` método; para el acceso sincronizado, invoca el `UnSyncUpdateResource` método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-205">For synchronized access, it invokes the `SyncUpdateResource` method; for unsynchronized access, it invokes the `UnSyncUpdateResource` method.</span></span> <span data-ttu-id="d7e10-206">Después de cada conjunto de llamadas de método, el subproceso de la aplicación llama a la [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) método para que así se bloquee hasta que la <xref:System.Threading.AutoResetEvent> se señala la instancia.</span><span class="sxs-lookup"><span data-stu-id="d7e10-206">After each set of method calls, the application thread calls the [AutoResetEvent.WaitOne](xref:System.Threading.WaitHandle.WaitOne*) method so that it blocks until the <xref:System.Threading.AutoResetEvent> instance is signaled.</span></span>  
  
 <span data-ttu-id="d7e10-207">Cada llamada a la `SyncUpdateResource` llamadas de método interno `SyncResource.Access` método y, a continuación, llama a la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método para reducir el `numOps` contador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-207">Each call to the `SyncUpdateResource` method calls the internal `SyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="d7e10-208">El <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método se usa para reducir el contador, porque de lo contrario, no puede estar seguro de que un segundo subproceso acceso al valor reducido del primer subproceso antes de valor se ha almacenado en la variable.</span><span class="sxs-lookup"><span data-stu-id="d7e10-208">The <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter, because otherwise you cannot be certain that a second thread will access the value before a first thread's decremented value has been stored in the variable.</span></span> <span data-ttu-id="d7e10-209">Cuando el último sincroniza disminuye de subproceso de trabajo en el contador a cero, que indica que todos los subprocesos sincronizados han accedido al recurso, el `SyncUpdateResource` llamadas al método el <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> método, que indica al subproceso principal para continuar ejecución.</span><span class="sxs-lookup"><span data-stu-id="d7e10-209">When the last synchronized worker thread decrements the counter to zero, indicating that all synchronized threads have completed accessing the resource, the `SyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="d7e10-210">Cada llamada a la `UnSyncUpdateResource` llamadas de método interno `UnSyncResource.Access` método y, a continuación, llama a la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método para reducir el `numOps` contador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-210">Each call to the `UnSyncUpdateResource` method calls the internal `UnSyncResource.Access` method and then calls the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method to decrement the `numOps` counter.</span></span> <span data-ttu-id="d7e10-211">Una vez más, la <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> método se usa para reducir el contador para asegurarse de que un segundo subproceso no tiene acceso el valor antes de que se ha asignado el valor reducido del primer subproceso a la variable.</span><span class="sxs-lookup"><span data-stu-id="d7e10-211">Once again, the <xref:System.Threading.Interlocked.Decrement%2A?displayProperty=nameWithType> method Is used to decrement the counter to ensure that a second thread does not access the value before a first thread's decremented value has been assigned to the variable.</span></span> <span data-ttu-id="d7e10-212">Cuando el último no sincronizadas disminuye de subproceso de trabajo que el contador a cero, que indica que no hay más subprocesos no sincronizados necesita tener acceso al recurso, el `UnSyncUpdateResource` llamadas al método el <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> método, que indica al subproceso principal para continuar la ejecución .</span><span class="sxs-lookup"><span data-stu-id="d7e10-212">When the last unsynchronized worker thread decrements the counter to zero, indicating that no more unsynchronized threads need to access the resource, the `UnSyncUpdateResource` method calls the <xref:System.Threading.EventWaitHandle.Set%2A?displayProperty=nameWithType> method, which signals the main thread to continue execution.</span></span>  
  
 <span data-ttu-id="d7e10-213">Como se muestra en el resultado del ejemplo, el acceso sincronizado garantiza que el subproceso de llamada saldrá del recurso protegido antes de que otro subproceso pueda tener acceso a él; así pues, cada subproceso esperará a su predecesor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-213">As the output from  the example shows, synchronized access ensures that the calling thread exits the protected resource before another thread can access it; each thread waits on its predecessor.</span></span> <span data-ttu-id="d7e10-214">Por otro lado, sin bloqueo, el `UnSyncResource.Access` se llama al método en el orden en que los subprocesos accedan a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-214">On the other hand, without the lock, the `UnSyncResource.Access` method is called in the order in which threads reach it.</span></span>  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="d7e10-215">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="d7e10-215">This type is thread safe.</span>
      </span>
    </threadsafe>
    <altmember cref="T:System.Threading.Thread" />
    <related type="Article" href="~/docs/standard/threading/index.md">
      <span data-ttu-id="d7e10-216">Subprocesamiento administrado</span>
      <span class="sxs-lookup">
        <span data-stu-id="d7e10-216">Managed Threading</span>
      </span>
    </related>
    <related type="Article" href="~/docs/standard/threading/threading-objects-and-features.md">
      <span data-ttu-id="d7e10-217">Objetos y características de subprocesos</span>
      <span class="sxs-lookup">
        <span data-stu-id="d7e10-217">Threading Objects and Features</span>
      </span>
    </related>
  </Docs>
  <Members>
    <MemberGroup MemberName="Enter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d7e10-218">Adquiere un bloqueo exclusivo en un objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-218">Acquires an exclusive lock on a specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Enter : obj -&gt; unit" Usage="System.Threading.Monitor.Enter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-219">Objeto en el que se va a adquirir el bloqueo de monitor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-219">The object on which to acquire the monitor lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-220">Adquiere un bloqueo exclusivo en el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-220">Acquires an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-221">Use `Enter` para adquirir el <xref:System.Threading.Monitor> en el objeto pasado como parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-221">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the parameter.</span></span> <span data-ttu-id="d7e10-222">Si otro subproceso ha ejecutado un `Enter` en el objeto, pero no se ha ejecutado el correspondiente <xref:System.Threading.Monitor.Exit%2A>, se bloqueará el subproceso actual hasta que el otro subproceso libere el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-222">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="d7e10-223">Es válido para el mismo subproceso que invoca `Enter` más de una vez sin bloquearse; sin embargo, un número igual de `Exit` se deben invocar las llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-223">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="d7e10-224">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-224">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-225">Cuando se pasa una variable de tipo de valor a `Enter`, se aplica como un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-225">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="d7e10-226">Si se pasa a la misma variable a `Enter` nuevo, se aplica como un objeto independiente y no bloquea el subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-226">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="d7e10-227">En este caso, el código que `Monitor` es supuestamente protege no está protegido.</span><span class="sxs-lookup"><span data-stu-id="d7e10-227">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="d7e10-228">Además, al pasar la variable a `Exit`, se crea otro objeto independiente.</span><span class="sxs-lookup"><span data-stu-id="d7e10-228">Furthermore, when you pass the variable to `Exit`, still another separate object is created.</span></span> <span data-ttu-id="d7e10-229">Puesto que el objeto pasado a `Exit` es diferente del objeto pasado a `Enter`, `Monitor` produce <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-229">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="d7e10-230">Para obtener más información, vea el tema conceptual [monitores](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="d7e10-230">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="d7e10-231"><xref:System.Threading.Thread.Interrupt%2A> puede interrumpir los subprocesos que esperan para escribir un `Monitor` en un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-231"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="d7e10-232">Un <xref:System.Threading.ThreadInterruptedException> se iniciará.</span><span class="sxs-lookup"><span data-stu-id="d7e10-232">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
 <span data-ttu-id="d7e10-233">Uso de C# `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="d7e10-233">Use a C# `try`…`finally`</span></span> <span data-ttu-id="d7e10-234">bloque (`Try`...`Finally`</span><span class="sxs-lookup"><span data-stu-id="d7e10-234">block (`Try`…`Finally`</span></span> <span data-ttu-id="d7e10-235">en Visual Basic) para asegurarse de que el monitor de versión o utilizar el C# `lock` instrucción (`SyncLock` instrucción en Visual Basic), que encapsula el <xref:System.Threading.Monitor.Enter%2A> y <xref:System.Threading.Monitor.Exit%2A> métodos en un `try`...`finally`</span><span class="sxs-lookup"><span data-stu-id="d7e10-235">in Visual Basic) to ensure that you release the monitor, or use the C# `lock` statement (`SyncLock` statement in Visual Basic), which wraps the <xref:System.Threading.Monitor.Enter%2A> and <xref:System.Threading.Monitor.Exit%2A> methods in a `try`…`finally`</span></span> <span data-ttu-id="d7e10-236">bloque.</span><span class="sxs-lookup"><span data-stu-id="d7e10-236">block.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-237">En el siguiente ejemplo se muestra cómo se utiliza el método `Enter`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-237">The following example demonstrates how to use the `Enter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-238">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-238">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-239">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-239">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Enter">
      <MemberSignature Language="C#" Value="public static void Enter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Enter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Enter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Enter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Enter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member Enter : obj *  -&gt; unit" Usage="System.Threading.Monitor.Enter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-240">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-240">The object on which to wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="d7e10-241">Resultado del intento de adquirir el bloqueo, pasado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-241">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="d7e10-242">La entrada debe ser <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-242">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-243">El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-243">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-244">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-244">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
          <span data-ttu-id="d7e10-245">Nota   Si no se produce ninguna excepción, el resultado de este método siempre es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-245">Note   If no exception occurs, the output of this method is always <see langword="true" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-246">Adquiere un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-246">Acquires an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-247">Use `Enter` para adquirir el <xref:System.Threading.Monitor> en el objeto pasado como el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-247">Use `Enter` to acquire the <xref:System.Threading.Monitor> on the object passed as the `obj` parameter.</span></span> <span data-ttu-id="d7e10-248">Si otro subproceso ha ejecutado un `Enter` en el objeto, pero no se ha ejecutado el correspondiente <xref:System.Threading.Monitor.Exit%2A>, se bloqueará el subproceso actual hasta que el otro subproceso libere el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-248">If another thread has executed an `Enter` on the object but has not yet executed the corresponding <xref:System.Threading.Monitor.Exit%2A>, the current thread will block until the other thread releases the object.</span></span> <span data-ttu-id="d7e10-249">Es válido para el mismo subproceso que invoca `Enter` más de una vez sin bloquearse; sin embargo, un número igual de `Exit` se deben invocar las llamadas antes de que se desbloqueen otros subprocesos en espera en el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-249">It is legal for the same thread to invoke `Enter` more than once without it blocking; however, an equal number of `Exit` calls must be invoked before other threads waiting on the object will unblock.</span></span>  
  
 <span data-ttu-id="d7e10-250">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice.</span><span class="sxs-lookup"><span data-stu-id="d7e10-250">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="d7e10-251">Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-251">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span> <span data-ttu-id="d7e10-252">Si este método devuelve sin producir una excepción, la variable especificada para el `lockTaken` parámetro siempre es `true`, y no es necesario para probarla.</span><span class="sxs-lookup"><span data-stu-id="d7e10-252">If this method returns without throwing an exception, the variable specified for the `lockTaken` parameter is always `true`, and there is no need to test it.</span></span>  
  
 <span data-ttu-id="d7e10-253">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-253">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-254">Cuando se pasa una variable de tipo de valor a `Enter`, se aplica como un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-254">When you pass a value type variable to `Enter`, it is boxed as an object.</span></span> <span data-ttu-id="d7e10-255">Si se pasa a la misma variable a `Enter` nuevo, se aplica como un objeto independiente y no bloquea el subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-255">If you pass the same variable to `Enter` again, it is boxed as a separate object, and the thread does not block.</span></span> <span data-ttu-id="d7e10-256">En este caso, el código que `Monitor` es supuestamente protege no está protegido.</span><span class="sxs-lookup"><span data-stu-id="d7e10-256">In this case, the code that `Monitor` is supposedly protecting is not protected.</span></span> <span data-ttu-id="d7e10-257">Además, al pasar la variable a `Exit`, se crea otro objeto independiente.</span><span class="sxs-lookup"><span data-stu-id="d7e10-257">Furthermore, when you pass the variable to `Exit`, another separate object is created.</span></span> <span data-ttu-id="d7e10-258">Puesto que el objeto pasado a `Exit` es diferente del objeto pasado a `Enter`, `Monitor` produce <xref:System.Threading.SynchronizationLockException>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-258">Because the object passed to `Exit` is different from the object passed to `Enter`, `Monitor` throws <xref:System.Threading.SynchronizationLockException>.</span></span> <span data-ttu-id="d7e10-259">Para obtener más información, vea el tema conceptual [monitores](xref:System.Threading.Monitor).</span><span class="sxs-lookup"><span data-stu-id="d7e10-259">For more information, see the conceptual topic [Monitors](xref:System.Threading.Monitor).</span></span>  
  
 <span data-ttu-id="d7e10-260"><xref:System.Threading.Thread.Interrupt%2A> puede interrumpir los subprocesos que esperan para escribir un `Monitor` en un objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-260"><xref:System.Threading.Thread.Interrupt%2A> can interrupt threads that are waiting to enter a `Monitor` on an object.</span></span> <span data-ttu-id="d7e10-261">Un <xref:System.Threading.ThreadInterruptedException> se iniciará.</span><span class="sxs-lookup"><span data-stu-id="d7e10-261">A <xref:System.Threading.ThreadInterruptedException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-262">El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-262">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="d7e10-263">Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-263">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#2)]
 [!code-vb[System.Threading.Monitor.Enter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d7e10-264">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-264">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-265">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-265">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Exit">
      <MemberSignature Language="C#" Value="public static void Exit (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Exit(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Exit(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Exit (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Exit(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Exit : obj -&gt; unit" Usage="System.Threading.Monitor.Exit obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-266">Objeto en el que se va a liberar el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-266">The object on which to release the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-267">Libera un bloqueo exclusivo en el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-267">Releases an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-268">El subproceso que realiza la llamada debe tener el bloqueo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-268">The calling thread must own the lock on the `obj` parameter.</span></span> <span data-ttu-id="d7e10-269">Si el subproceso de llamada posee el bloqueo en el objeto especificado y ha realizado un número igual de `Exit` y <xref:System.Threading.Monitor.Enter%2A> llama para el objeto, a continuación, se libera el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-269">If the calling thread owns the lock on the specified object, and has made an equal number of `Exit` and <xref:System.Threading.Monitor.Enter%2A> calls for the object, then the lock is released.</span></span> <span data-ttu-id="d7e10-270">Si el subproceso de llamada no se ha invocado `Exit` tantas veces como `Enter`, no se libera el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-270">If the calling thread has not invoked `Exit` as many times as `Enter`, the lock is not released.</span></span>  
  
 <span data-ttu-id="d7e10-271">Si se libera el bloqueo y otros subprocesos están en la cola de subprocesos listos para el objeto, uno de los subprocesos adquiere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-271">If the lock is released and other threads are in the ready queue for the object, one of the threads acquires the lock.</span></span> <span data-ttu-id="d7e10-272">Si hay otros subprocesos en la cola de espera para adquirir el bloqueo, no pasan automáticamente a la cola lista cuando el propietario del bloqueo llama `Exit`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-272">If other threads are in the waiting queue waiting to acquire the lock, they are not automatically moved to the ready queue when the owner of the lock calls `Exit`.</span></span> <span data-ttu-id="d7e10-273">Para mover uno o varios subprocesos en espera en la cola de subprocesos listos, llame a <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> antes de invocar `Exit`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-273">To move one or more waiting threads into the ready queue, call <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> before invoking `Exit`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-274">En el siguiente ejemplo se muestra cómo se utiliza el método `Exit`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-274">The following example demonstrates how to use the `Exit` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-275">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-275">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-276">El subproceso actual no posee el bloqueo para el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-276">The current thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-277">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-277">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="IsEntered">
      <MemberSignature Language="C#" Value="public static bool IsEntered (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsEntered(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.IsEntered(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsEntered (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsEntered(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member IsEntered : obj -&gt; bool" Usage="System.Threading.Monitor.IsEntered obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-278">El objeto que se va a probar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-278">The object to test.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-279">Determina si el subproceso actual mantiene el bloqueo en el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-279">Determines whether the current thread holds the lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-280">Es <see langword="true" /> si el subproceso actual mantiene el bloqueo en <paramref name="obj" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-280">
              <see langword="true" /> if the current thread holds the lock on <paramref name="obj" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-281">Este método solo funciona para los bloqueos adquiridos mediante el uso de los métodos de la <xref:System.Threading.Monitor> clase, o mediante C# `lock` instrucción o Visual Basic `SyncLock` instrucción, que se implementan con <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-281">This method works only for locks that are acquired by using the methods of the <xref:System.Threading.Monitor> class, or by using the C# `lock` statement or the Visual Basic `SyncLock` statement, which are implemented with <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="d7e10-282">Utilice este método con las herramientas de diagnóstico, como la <xref:System.Diagnostics.Debug.Assert%2A> método y el <xref:System.Diagnostics.Contracts.Contract> (clase), para depurar problemas de bloqueo que implican la <xref:System.Threading.Monitor> clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-282">Use this method with diagnostic tools, such as the <xref:System.Diagnostics.Debug.Assert%2A> method and the <xref:System.Diagnostics.Contracts.Contract> class, to debug locking issues that involve the <xref:System.Threading.Monitor> class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-283">
            <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-283">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Pulse">
      <MemberSignature Language="C#" Value="public static void Pulse (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Pulse(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Pulse(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Pulse (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Pulse(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Pulse : obj -&gt; unit" Usage="System.Threading.Monitor.Pulse obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-284">Objeto que está esperando un subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-284">The object a thread is waiting for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-285">Notifica un cambio de estado del objeto bloqueado al subproceso que se encuentra en la cola de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-285">Notifies a thread in the waiting queue of a change in the locked object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-286">Solo el propietario actual del bloqueo puede señalar a un objeto de espera mediante `Pulse`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-286">Only the current owner of the lock can signal a waiting object using `Pulse`.</span></span>  
  
 <span data-ttu-id="d7e10-287">El subproceso que actualmente posee el bloqueo en el objeto especificado invoca este método para señalar el siguiente subproceso en línea para adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-287">The thread that currently owns the lock on the specified object invokes this method to signal the next thread in line for the lock.</span></span> <span data-ttu-id="d7e10-288">Al recibir el pulso, el subproceso en espera se mueve a la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-288">Upon receiving the pulse, the waiting thread is moved to the ready queue.</span></span> <span data-ttu-id="d7e10-289">Cuando el subproceso que invoca `Pulse` libera el bloqueo, el siguiente subproceso en la cola de subprocesos listos (que no es necesariamente el subproceso que ha recibido el pulso) adquiere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-289">When the thread that invoked `Pulse` releases the lock, the next thread in the ready queue (which is not necessarily the thread that was pulsed) acquires the lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="d7e10-290">El <xref:System.Threading.Monitor> clase mantienen el estado que indica que el <xref:System.Threading.Monitor.Pulse%2A> ha llamado al método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-290">The <xref:System.Threading.Monitor> class does not maintain state indicating that the <xref:System.Threading.Monitor.Pulse%2A> method has been called.</span></span> <span data-ttu-id="d7e10-291">Por lo tanto, si se llama a <xref:System.Threading.Monitor.Pulse%2A> cuando no hay ningún subproceso en espera, el siguiente subproceso que llama a <xref:System.Threading.Monitor.Wait%2A> bloques como si <xref:System.Threading.Monitor.Pulse%2A> nunca hubiera llamado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-291">Thus, if you call <xref:System.Threading.Monitor.Pulse%2A> when no threads are waiting, the next thread that calls <xref:System.Threading.Monitor.Wait%2A> blocks as if <xref:System.Threading.Monitor.Pulse%2A> had never been called.</span></span> <span data-ttu-id="d7e10-292">Si usan dos subprocesos <xref:System.Threading.Monitor.Pulse%2A> y <xref:System.Threading.Monitor.Wait%2A> para interactuar, esto podría provocar un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-292">If two threads are using <xref:System.Threading.Monitor.Pulse%2A> and <xref:System.Threading.Monitor.Wait%2A> to interact, this could result in a deadlock.</span></span> <span data-ttu-id="d7e10-293">Compare esto con el comportamiento de la <xref:System.Threading.AutoResetEvent> clase: si señalar un <xref:System.Threading.AutoResetEvent> mediante una llamada a su <xref:System.Threading.EventWaitHandle.Set%2A> método y no hay ningún subproceso en espera, el <xref:System.Threading.AutoResetEvent> permanece en un estado señalado hasta que un subproceso llama <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, o <xref:System.Threading.WaitHandle.WaitAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-293">Contrast this with the behavior of the <xref:System.Threading.AutoResetEvent> class: If you signal an <xref:System.Threading.AutoResetEvent> by calling its <xref:System.Threading.EventWaitHandle.Set%2A> method, and there are no threads waiting, the <xref:System.Threading.AutoResetEvent> remains in a signaled state until a thread calls <xref:System.Threading.WaitHandle.WaitOne%2A>, <xref:System.Threading.WaitHandle.WaitAny%2A>, or <xref:System.Threading.WaitHandle.WaitAll%2A>.</span></span> <span data-ttu-id="d7e10-294">El <xref:System.Threading.AutoResetEvent> libera ese subproceso y vuelve al estado no señalizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-294">The <xref:System.Threading.AutoResetEvent> releases that thread and returns to the unsignaled state.</span></span>  
  
 <span data-ttu-id="d7e10-295">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-295">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-296">El `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, y <xref:System.Threading.Monitor.Wait%2A> métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-296">The `Pulse`, <xref:System.Threading.Monitor.PulseAll%2A>, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-297">Para marcar varios subprocesos, utilice el <xref:System.Threading.Monitor.PulseAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-297">To signal multiple threads, use the <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-298">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-298">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-299">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-299">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-300">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-300">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="PulseAll">
      <MemberSignature Language="C#" Value="public static void PulseAll (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void PulseAll(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.PulseAll(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub PulseAll (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void PulseAll(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member PulseAll : obj -&gt; unit" Usage="System.Threading.Monitor.PulseAll obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-301">Objeto que envía el pulso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-301">The object that sends the pulse.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-302">Notifica un cambio de estado del objeto a todos los subprocesos que se encuentran en espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-302">Notifies all waiting threads of a change in the object's state.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-303">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método para indicar todos los subprocesos en espera para adquirir el bloqueo en el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-303">The thread that currently owns the lock on the specified object invokes this method to signal all threads waiting to acquire the lock on the object.</span></span> <span data-ttu-id="d7e10-304">Una vez que se envía una señal, los subprocesos en espera se mueven a la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-304">After the signal is sent, the waiting threads are moved to the ready queue.</span></span> <span data-ttu-id="d7e10-305">Cuando el subproceso que invoca `PulseAll` libera el bloqueo, el siguiente subproceso en la cola de subprocesos listos adquiere el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-305">When the thread that invoked `PulseAll` releases the lock, the next thread in the ready queue acquires the lock.</span></span>  
  
 <span data-ttu-id="d7e10-306">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-306">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-307">El <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, y <xref:System.Threading.Monitor.Wait%2A> métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-307">The <xref:System.Threading.Monitor.Pulse%2A>, `PulseAll`, and <xref:System.Threading.Monitor.Wait%2A> methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-308">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-308">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 <span data-ttu-id="d7e10-309">Para marcar un único subproceso, utilice el `Pulse` método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-309">To signal a single thread, use the `Pulse` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-310">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-310">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-311">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-311">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-312">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-312">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryEnter">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d7e10-313">Intenta adquirir un bloqueo exclusivo en el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-313">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj -&gt; bool" Usage="System.Threading.Monitor.TryEnter obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-314">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-314">The object on which to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-315">Intenta adquirir un bloqueo exclusivo en el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-315">Attempts to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-316">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-316">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-317">Si es correcto, este método adquiere un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-317">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="d7e10-318">Este método devuelve inmediatamente, si el bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="d7e10-318">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="d7e10-319">Este método es similar a <xref:System.Threading.Monitor.Enter%2A>, pero nunca se bloqueará el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="d7e10-319">This method is similar to <xref:System.Threading.Monitor.Enter%2A>, but it will never block the current thread.</span></span> <span data-ttu-id="d7e10-320">Si el subproceso no se puede escribir sin bloqueo, el método devuelve `false,`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-320">If the thread cannot enter without blocking, the method returns `false,`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-321">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-321">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-322">Para obtener más información, consulte el <xref:System.Threading.Monitor> artículo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-322">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="d7e10-323">Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-323">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="d7e10-324">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-324">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-325">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-325">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#1)]
 [!code-vb[System.Threading.Monitor.TryEnter#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-326">En el ejemplo de código siguiente se muestra cómo utilizar el método `TryEnter`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-326">The following code example demonstrates how to use the `TryEnter` method.</span></span>  
  
 [!code-cpp[MonitorExmpl2#1](~/samples/snippets/cpp/VS_Snippets_CLR/MonitorExmpl2/CPP/monitor2.cpp#1)]
 [!code-csharp[MonitorExmpl2#1](~/samples/snippets/csharp/VS_Snippets_CLR/MonitorExmpl2/CS/monitor2.cs#1)]
 [!code-vb[MonitorExmpl2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MonitorExmpl2/VB/monitor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-327">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-327">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-328">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-328">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-329">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-329">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="d7e10-330">Resultado del intento de adquirir el bloqueo, pasado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-330">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="d7e10-331">La entrada debe ser <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-331">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-332">El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-332">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-333">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-333">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-334">Intenta adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-334">Attempts to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-335">Si es correcto, este método adquiere un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-335">If successful, this method acquires an exclusive lock on the `obj` parameter.</span></span> <span data-ttu-id="d7e10-336">Este método devuelve inmediatamente, si el bloqueo esté disponible.</span><span class="sxs-lookup"><span data-stu-id="d7e10-336">This method returns immediately, whether or not the lock is available.</span></span>  
  
 <span data-ttu-id="d7e10-337">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice.</span><span class="sxs-lookup"><span data-stu-id="d7e10-337">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="d7e10-338">Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-338">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
 <span data-ttu-id="d7e10-339">Este método es similar a <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, pero nunca se bloqueará el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="d7e10-339">This method is similar to <xref:System.Threading.Monitor.Enter%28System.Object%2CSystem.Boolean%40%29>, but it will never block the current thread.</span></span> <span data-ttu-id="d7e10-340">Si el subproceso no se puede escribir sin bloqueo, el `lockTaken` argumento está establecido en `false` cuando el método devuelve.</span><span class="sxs-lookup"><span data-stu-id="d7e10-340">If the thread cannot enter without blocking, the `lockTaken` argument is set to `false` when the method returns.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-341">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-341">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-342">Para obtener más información, vea el artículo <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-342">For more information, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="d7e10-343">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-343">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="d7e10-344">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-344">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-345">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-345">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#2)]
 [!code-vb[System.Threading.Monitor.TryEnter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#2)]  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-346">El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-346">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="d7e10-347">Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-347">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#3)]
 [!code-vb[System.Threading.Monitor.Enter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d7e10-348">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-348">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-349">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-349">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-350">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-350">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d7e10-351">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-351">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-352">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el número de segundos especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-352">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-353">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-353">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-354">Si el `millisecondsTimeout` parámetro es igual a <xref:System.Threading.Timeout.Infinite>, este método es equivalente a <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-354">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="d7e10-355">Si `millisecondsTimeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-355">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-356">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-356">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-357">Para obtener más información, consulte el <xref:System.Threading.Monitor> artículo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-357">For details, see the <xref:System.Threading.Monitor> article.</span></span>  
  
 <span data-ttu-id="d7e10-358">Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-358">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="d7e10-359">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-359">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-360">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-360">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#3)]
 [!code-vb[System.Threading.Monitor.TryEnter#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-361">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-361">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-362">
            <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-362">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-363">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-363">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static bool TryEnter (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryEnter(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryEnter (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryEnter(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.TryEnter (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-364">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-364">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="d7e10-365">
            <see cref="T:System.TimeSpan" /> que representa el período de tiempo que se va a esperar para adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-365">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="d7e10-366">Un valor de –1 milisegundo especifica una espera infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-366">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-367">Intenta adquirir un bloqueo exclusivo en el objeto especificado durante el período de tiempo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-367">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-368">Es <see langword="true" /> si el subproceso actual adquiere el bloqueo; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-368">
              <see langword="true" /> if the current thread acquires the lock; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-369">Si el valor de la `timeout` convierte a milisegundos del parámetro es igual a – 1, este método es equivalente a <xref:System.Threading.Monitor.Enter%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-369">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%2A>.</span></span> <span data-ttu-id="d7e10-370">Si el valor de `timeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-370">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-371">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-371">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-372">Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-372">For details, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="d7e10-373">Para asegurarse de que el subproceso no entrar en la sección crítica, debe examinar el valor devuelto del método y ejecutar código en la sección crítica solo si su valor devuelto es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-373">To ensure that the thread does not enter the critical section, you should examine the method's return value and  execute code in the critical section only if its return value is `true`.</span></span> <span data-ttu-id="d7e10-374">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-374">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-375">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-375">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#5)]
 [!code-vb[System.Threading.Monitor.TryEnter#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-376">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-376">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-377">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es superior a <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-377">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-378">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-378">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, int millisecondsTimeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, int32 millisecondsTimeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.Int32,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, millisecondsTimeout As Integer, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, int millisecondsTimeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * int *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, millisecondsTimeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-379">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-379">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d7e10-380">Número de milisegundos durante los que se va a esperar para adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-380">The number of milliseconds to wait for the lock.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="d7e10-381">Resultado del intento de adquirir el bloqueo, pasado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-381">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="d7e10-382">La entrada debe ser <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-382">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-383">El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-383">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-384">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-384">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-385">Intenta, durante el número especificado de milisegundos, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-385">Attempts, for the specified number of milliseconds, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-386">Si el `millisecondsTimeout` parámetro es igual a <xref:System.Threading.Timeout.Infinite>, este método es equivalente a <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-386">If the `millisecondsTimeout` parameter equals <xref:System.Threading.Timeout.Infinite>, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="d7e10-387">Si `millisecondsTimeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-387">If `millisecondsTimeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="d7e10-388">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice.</span><span class="sxs-lookup"><span data-stu-id="d7e10-388">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="d7e10-389">Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-389">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-390">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-390">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-391">Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-391">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="d7e10-392">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-392">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="d7e10-393">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-393">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-394">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-394">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#4)]
 [!code-vb[System.Threading.Monitor.TryEnter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#4)]  
  
   
  
## Examples  
 <span data-ttu-id="d7e10-395">El código siguiente muestra el patrón básico para usar el <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-395">The following code shows the basic pattern for using the <xref:System.Threading.Monitor.TryEnter%28System.Object%2CSystem.Boolean%40%29> method overload.</span></span> <span data-ttu-id="d7e10-396">Esta sobrecarga siempre establece el valor de la variable que se pasa a la `ref` parámetro (`ByRef` en Visual Basic) `lockTaken`, incluso si el método produce una excepción, por lo que el valor de la variable es un método confiable para probar si el bloqueo debe ser publicado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-396">This overload always sets the value of the variable that is passed to the `ref` parameter (`ByRef` in Visual Basic) `lockTaken`, even if the method throws an exception, so the value of the variable is a reliable way to test whether the lock has to be released.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.Enter#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.monitor.enter/cs/example.cs#4)]
 [!code-vb[System.Threading.Monitor.Enter#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.monitor.enter/vb/example.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d7e10-397">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-397">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-398">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-398">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-399">
            <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-399">
              <paramref name="millisecondsTimeout" /> is negative, and not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="TryEnter">
      <MemberSignature Language="C#" Value="public static void TryEnter (object obj, TimeSpan timeout, ref bool lockTaken);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void TryEnter(object obj, valuetype System.TimeSpan timeout, bool&amp; lockTaken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.TryEnter(System.Object,System.TimeSpan,System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub TryEnter (obj As Object, timeout As TimeSpan, ByRef lockTaken As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void TryEnter(System::Object ^ obj, TimeSpan timeout, bool % lockTaken);" />
      <MemberSignature Language="F#" Value="static member TryEnter : obj * TimeSpan *  -&gt; unit" Usage="System.Threading.Monitor.TryEnter (obj, timeout, lockTaken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="lockTaken" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-400">Objeto en el que se va a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-400">The object on which to acquire the lock.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="d7e10-401">Tiempo que se va a esperar el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-401">The amount of time to wait for the lock.</span>
          </span>
          <span data-ttu-id="d7e10-402">Un valor de –1 milisegundo especifica una espera infinita.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-402">A value of –1 millisecond specifies an infinite wait.</span>
          </span>
        </param>
        <param name="lockTaken">
          <span data-ttu-id="d7e10-403">Resultado del intento de adquirir el bloqueo, pasado por referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-403">The result of the attempt to acquire the lock, passed by reference.</span>
          </span>
          <span data-ttu-id="d7e10-404">La entrada debe ser <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-404">The input must be <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-405">El resultado es <see langword="true" /> si se adquiere el bloqueo; en caso contrario, el resultado es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-405">The output is <see langword="true" /> if the lock is acquired; otherwise, the output is <see langword="false" />.</span>
          </span>
          <span data-ttu-id="d7e10-406">El resultado se establece aunque se produzca una excepción durante el intento de adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-406">The output is set even if an exception occurs during the attempt to acquire the lock.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-407">Intenta, durante el periodo de tiempo indicado, adquirir un bloqueo exclusivo en el objeto especificado y establece de forma atómica un valor que indica si se realizó el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-407">Attempts, for the specified amount of time, to acquire an exclusive lock on the specified object, and atomically sets a value that indicates whether the lock was taken.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-408">Si el valor de la `timeout` convierte a milisegundos del parámetro es igual a – 1, este método es equivalente a <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-408">If the value of the `timeout` parameter converted to milliseconds equals –1, this method is equivalent to <xref:System.Threading.Monitor.Enter%28System.Object%29>.</span></span> <span data-ttu-id="d7e10-409">Si el valor de `timeout` es igual a 0, este método es equivalente a <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-409">If the value of `timeout` equals 0, this method is equivalent to <xref:System.Threading.Monitor.TryEnter%28System.Object%29>.</span></span>  
  
 <span data-ttu-id="d7e10-410">Si no se realizó el bloqueo porque se produjo una excepción, la variable especificada para el `lockTaken` parámetro es `false` cuando este método finalice.</span><span class="sxs-lookup"><span data-stu-id="d7e10-410">If the lock was not taken because an exception was thrown, the variable specified for the `lockTaken` parameter is `false` after this method ends.</span></span> <span data-ttu-id="d7e10-411">Esto permite que el programa determinar, en todos los casos, si es necesario para liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-411">This allows the program to determine, in all cases, whether it is necessary to release the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-412">Use <xref:System.Threading.Monitor> para bloquear objetos (es decir, tipos de referencia), no los tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="d7e10-412">Use <xref:System.Threading.Monitor> to lock objects (that is, reference types), not value types.</span></span> <span data-ttu-id="d7e10-413">Para obtener más información, consulte el <xref:System.Threading.Monitor> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-413">For more information, see the <xref:System.Threading.Monitor> class topic.</span></span>  
  
 <span data-ttu-id="d7e10-414">Para asegurarse de que el subproceso no entra en la sección crítica, debe examinar el valor de `lockTaken` y ejecutar código en la sección crítica solo si su valor es `true`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-414">To ensure that the thread does not enter the critical section, you should examine the value of `lockTaken` and  execute code in the critical section only if its value is `true`.</span></span> <span data-ttu-id="d7e10-415">El fragmento de código siguiente muestra el patrón utilizado para llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-415">The following code fragment shows the pattern used to call this method.</span></span> <span data-ttu-id="d7e10-416">Tenga en cuenta que debe llamar a <xref:System.Threading.Monitor.Exit%2A> en un `finally` bloque para asegurarse de que el subproceso que realiza la llamada libera el bloqueo en la sección crítica si se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="d7e10-416">Note that you should call <xref:System.Threading.Monitor.Exit%2A> in a `finally` block to ensure that the calling thread releases its lock on the critical section if an exception occurs.</span></span>  
  
 [!code-csharp[System.Threading.Monitor.TryEnter#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/cs/pattern1.cs#6)]
 [!code-vb[System.Threading.Monitor.TryEnter#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Monitor.TryEnter/vb/pattern1.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="d7e10-417">La entrada a <paramref name="lockTaken" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-417">The input to <paramref name="lockTaken" /> is <see langword="true" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-418">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-418">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-419">El valor de <paramref name="timeout" /> en milisegundos es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> (-1 milisegundos), o es superior a <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-419">The value of <paramref name="timeout" /> in milliseconds is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-420">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-420">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Wait">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="d7e10-421">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-421">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member Wait : obj -&gt; bool" Usage="System.Threading.Monitor.Wait obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-422">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-422">The object on which to wait.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-423">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-423">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-424">
            <see langword="true" /> si la llamada fue devuelta porque el llamador volvió a adquirir el bloqueo para el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-424">
              <see langword="true" /> if the call returned because the caller reacquired the lock for the specified object.</span>
          </span>
          <span data-ttu-id="d7e10-425">Este método no devuelve ningún resultado si el bloqueo no vuelve a adquirirse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-425">This method does not return if the lock is not reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-426">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-426">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="d7e10-427">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-427">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="d7e10-428">Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-428">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="d7e10-429">Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-429">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="d7e10-430">El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-430">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="d7e10-431">Todos los subprocesos que llaman a `Wait` permanecen en la cola de espera hasta que reciben una señal de <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>, enviada por el propietario del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-431">All threads that call `Wait` remain in the waiting queue until they receive a signal from <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>, sent by the owner of the lock.</span></span> <span data-ttu-id="d7e10-432">Si `Pulse` se envía, sólo el subproceso en el encabezado de la cola de espera se ve afectado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-432">If `Pulse` is sent, only the thread at the head of the waiting queue is affected.</span></span> <span data-ttu-id="d7e10-433">Si `PulseAll` se envía, se ven afectados todos los subprocesos que están esperando el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-433">If `PulseAll` is sent, all threads that are waiting for the object are affected.</span></span> <span data-ttu-id="d7e10-434">Cuando se recibe la señal, uno o varios subprocesos deja la cola de espera y especifique la cola de subprocesos listos.</span><span class="sxs-lookup"><span data-stu-id="d7e10-434">When the signal is received, one or more threads leave the waiting queue and enter the ready queue.</span></span> <span data-ttu-id="d7e10-435">Se permite un subproceso en la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-435">A thread in the ready queue is permitted to reacquire the lock.</span></span>  
  
 <span data-ttu-id="d7e10-436">Este método devuelve cuando el subproceso que realiza la llamada vuelve a adquirir el bloqueo en el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-436">This method returns when the calling thread reacquires the lock on the object.</span></span> <span data-ttu-id="d7e10-437">Tenga en cuenta que este método se bloquea indefinidamente si el propietario del bloqueo no llama a `Pulse` o `PulseAll`.</span><span class="sxs-lookup"><span data-stu-id="d7e10-437">Note that this method blocks indefinitely if the holder of the lock does not call `Pulse` or `PulseAll`.</span></span>  
  
 <span data-ttu-id="d7e10-438">El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-438">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="d7e10-439">Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado `Enter` en el objeto e invoca `Exit` tantas veces como sea necesario para liberar completamente el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-439">Conceptually, the `Wait` method stores the number of times the caller invoked `Enter` on the object and invokes `Exit` as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="d7e10-440">El llamador, a continuación, se bloquea mientras espera para adquirir el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-440">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="d7e10-441">Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama `Enter` tantas veces como sea necesario para restaurar el guardado `Enter` recuento para el llamador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-441">When the caller reacquires the lock, the system calls `Enter` as many times as necessary to restore the saved `Enter` count for the caller.</span></span> <span data-ttu-id="d7e10-442">Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.</span><span class="sxs-lookup"><span data-stu-id="d7e10-442">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
 <span data-ttu-id="d7e10-443">Tenga en cuenta que un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene los subprocesos que esperan para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-443">Note that a synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-444">El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-444">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-445">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-445">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-446">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-446">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-447">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-447">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="d7e10-448">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-448">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="d7e10-449">Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-449">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-450">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-450">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-451">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-451">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d7e10-452">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-452">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-453">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-453">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="d7e10-454">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-454">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-455">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-455">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="d7e10-456">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-456">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-457">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-457">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="d7e10-458">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-458">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="d7e10-459">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-459">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="d7e10-460">Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-460">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="d7e10-461">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-461">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="d7e10-462">También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</span><span class="sxs-lookup"><span data-stu-id="d7e10-462">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="d7e10-463">El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-463">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="d7e10-464">Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-464">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="d7e10-465">El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-465">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="d7e10-466">El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-466">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="d7e10-467">Sin embargo, si `millisecondsTimeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-467">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-468">Si <xref:System.Threading.Timeout.Infinite> se especifica para el `millisecondsTimeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-468">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="d7e10-469">Si `millisecondsTimeout` es igual a 0, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-469">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="d7e10-470">El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-470">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="d7e10-471">Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-471">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="d7e10-472">El llamador, a continuación, se bloquea mientras espera para adquirir el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-472">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="d7e10-473">Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-473">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="d7e10-474">Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.</span><span class="sxs-lookup"><span data-stu-id="d7e10-474">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-475">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-475">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-476">El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-476">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-477">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-477">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-478">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-478">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-479">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-479">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="d7e10-480">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-480">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="d7e10-481">Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-481">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-482">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-482">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-483">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-483">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-484">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-484">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="d7e10-485">
            <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-485">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-486">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-486">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="d7e10-487">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-487">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-488">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-488">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="d7e10-489">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-489">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-490">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-490">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="d7e10-491">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-491">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="d7e10-492">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-492">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="d7e10-493">Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-493">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="d7e10-494">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-494">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="d7e10-495">También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</span><span class="sxs-lookup"><span data-stu-id="d7e10-495">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="d7e10-496">El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-496">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="d7e10-497">Cuando un subproceso llama `Wait`, libera el bloqueo en el objeto y entra en cola de espera del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-497">When a thread calls `Wait`, it releases the lock on the object and enters the object's waiting queue.</span></span> <span data-ttu-id="d7e10-498">El siguiente subproceso en la cola de subprocesos listos del objeto (si hay alguno) adquiere el bloqueo y tiene uso exclusivo del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-498">The next thread in the object's ready queue (if there is one) acquires the lock and has exclusive use of the object.</span></span> <span data-ttu-id="d7e10-499">El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-499">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="d7e10-500">Sin embargo, si `timeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-500">However, if `timeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-501">Si un <xref:System.TimeSpan> se ha especificado que representa-1 milisegundos para la `timeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-501">If a <xref:System.TimeSpan> representing –1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="d7e10-502">Si `timeout` es 0 milisegundos, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-502">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="d7e10-503">El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-503">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="d7e10-504">Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-504">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="d7e10-505">El llamador, a continuación, se bloquea mientras espera para adquirir el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-505">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="d7e10-506">Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-506">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="d7e10-507">Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.</span><span class="sxs-lookup"><span data-stu-id="d7e10-507">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-508">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-508">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-509">El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-509">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-510">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-510">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-511">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-511">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-512">El subproceso que realiza la llamada no posee el bloqueo del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-512">The calling thread does not own the lock for the specified object.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="d7e10-513">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-513">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="d7e10-514">Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-514">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-515">El valor del parámetro <paramref name="timeout" /> en milisegundos es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (–1 milisegundo) o es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-515">The value of the <paramref name="timeout" /> parameter in milliseconds is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-516">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-516">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, int32 millisecondsTimeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, millisecondsTimeout As Integer, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, int millisecondsTimeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * int * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, millisecondsTimeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-517">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-517">The object on which to wait.</span>
          </span>
        </param>
        <param name="millisecondsTimeout">
          <span data-ttu-id="d7e10-518">Número de milisegundos que se va a estar a la espera antes de que el subproceso entre en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-518">The number of milliseconds to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="d7e10-519">
            <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-519">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-520">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-520">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="d7e10-521">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-521">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="d7e10-522">Este método también especifica si el dominio de sincronización del contexto (si se trata de un contexto sincronizado) sale antes de la espera y vuelve a adquirir el bloqueo después.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-522">This method also specifies whether the synchronization domain for the context (if in a synchronized context) is exited before the wait and reacquired afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-523">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-523">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="d7e10-524">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-524">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-525">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-525">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="d7e10-526">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-526">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="d7e10-527">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-527">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="d7e10-528">Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-528">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="d7e10-529">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-529">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="d7e10-530">También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</span><span class="sxs-lookup"><span data-stu-id="d7e10-530">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="d7e10-531">El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-531">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="d7e10-532">Cuando un subproceso llama `Wait`, libera el bloqueo y entra en la cola de espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-532">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="d7e10-533">En este momento, el siguiente subproceso en la cola de subprocesos listos (si existe) se permite tomar el control del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-533">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="d7e10-534">El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-534">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="d7e10-535">Sin embargo, si `millisecondsTimeout` transcurre antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-535">However, if `millisecondsTimeout` elapses before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-536">Si <xref:System.Threading.Timeout.Infinite> se especifica para el `millisecondsTimeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-536">If <xref:System.Threading.Timeout.Infinite> is specified for the `millisecondsTimeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="d7e10-537">Si `millisecondsTimeout` es igual a 0, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-537">If `millisecondsTimeout` equals 0, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="d7e10-538">El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-538">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="d7e10-539">Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-539">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="d7e10-540">El llamador, a continuación, se bloquea mientras espera para adquirir el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-540">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="d7e10-541">Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-541">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="d7e10-542">Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.</span><span class="sxs-lookup"><span data-stu-id="d7e10-542">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-543">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-543">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-544">El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-544">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-545">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-545">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7e10-546">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="d7e10-546">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7e10-547">El`exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.Monitor.Wait%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-547">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7e10-548">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-548">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7e10-549">Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="d7e10-549">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7e10-550">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.Monitor.Wait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-550">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="d7e10-551">Devuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.Monitor.Wait%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="d7e10-551">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7e10-552">Esto puede ser útil cuando la clase de contexto enlazado tiene el <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo aplicado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-552">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="d7e10-553">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-553">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7e10-554">Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.Monitor.Wait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="d7e10-554">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7e10-555">Cuando el <xref:System.Threading.Monitor.Wait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="d7e10-555">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-556">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-556">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-557">
            <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-557">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="d7e10-558">El subproceso que invoca a <see langword="Wait" /> se interrumpe más adelante desde el estado de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-558">The thread that invokes <see langword="Wait" /> is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="d7e10-559">Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-559">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-560">El valor del parámetro <paramref name="millisecondsTimeout" /> es negativo, y no igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-560">The value of the <paramref name="millisecondsTimeout" /> parameter is negative, and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-561">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-561">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Wait">
      <MemberSignature Language="C#" Value="public static bool Wait (object obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Wait(object obj, valuetype System.TimeSpan timeout, bool exitContext) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Monitor.Wait(System.Object,System.TimeSpan,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Wait (obj As Object, timeout As TimeSpan, exitContext As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Wait(System::Object ^ obj, TimeSpan timeout, bool exitContext);" />
      <MemberSignature Language="F#" Value="static member Wait : obj * TimeSpan * bool -&gt; bool" Usage="System.Threading.Monitor.Wait (obj, timeout, exitContext)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="exitContext" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="d7e10-562">Objeto en el que se va a esperar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-562">The object on which to wait.</span>
          </span>
        </param>
        <param name="timeout">
          <span data-ttu-id="d7e10-563">
            <see cref="T:System.TimeSpan" /> que representa la cantidad de tiempo que se va a esperar antes de que el subproceso entre en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-563">A <see cref="T:System.TimeSpan" /> representing the amount of time to wait before the thread enters the ready queue.</span>
          </span>
        </param>
        <param name="exitContext">
          <span data-ttu-id="d7e10-564">
            <see langword="true" /> para abandonar y volver a adquirir el dominio de sincronización para el contexto (en caso de encontrarse en un contexto sincronizado) antes de que transcurra la espera; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-564">
              <see langword="true" /> to exit and reacquire the synchronization domain for the context (if in a synchronized context) before the wait; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="d7e10-565">Libera el bloqueo en un objeto y bloquea el subproceso actual hasta que vuelve a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-565">Releases the lock on an object and blocks the current thread until it reacquires the lock.</span>
          </span>
          <span data-ttu-id="d7e10-566">Si transcurre el intervalo de tiempo de espera especificado, el subproceso entra en la cola de subprocesos listos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-566">If the specified time-out interval elapses, the thread enters the ready queue.</span>
          </span>
          <span data-ttu-id="d7e10-567">De modo opcional, sale del dominio de sincronización del contexto sincronizado antes de la espera y vuelve a adquirir el dominio después.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-567">Optionally exits the synchronization domain for the synchronized context before the wait and reacquires the domain afterward.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="d7e10-568">Es <see langword="true" /> si se volvió a adquirir el bloqueo antes de que transcurriera el período de tiempo especificado; es <see langword="false" /> si se volvió a adquirir el bloqueo después de que transcurriera el período de tiempo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-568">
              <see langword="true" /> if the lock was reacquired before the specified time elapsed; <see langword="false" /> if the lock was reacquired after the specified time elapsed.</span>
          </span>
          <span data-ttu-id="d7e10-569">El método no devuelve ningún resultado hasta que se vuelva a adquirir el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-569">The method does not return until the lock is reacquired.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d7e10-570">Este método no vuelve hasta que vuelve a adquirir un bloqueo exclusivo en el `obj` parámetro.</span><span class="sxs-lookup"><span data-stu-id="d7e10-570">This method does not return until it reacquires an exclusive lock on the `obj` parameter.</span></span>  
  
 <span data-ttu-id="d7e10-571">El subproceso que actualmente posee el bloqueo en el objeto especificado, invoca este método con el fin de liberar el objeto para que otro subproceso puede tener acceso a él.</span><span class="sxs-lookup"><span data-stu-id="d7e10-571">The thread that currently owns the lock on the specified object invokes this method in order to release the object so that another thread can access it.</span></span> <span data-ttu-id="d7e10-572">El autor de la llamada se bloquea mientras espera a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-572">The caller is blocked while waiting to reacquire the lock.</span></span> <span data-ttu-id="d7e10-573">Este método se llama cuando el llamador debe esperar un cambio de estado que se producirá como resultado de operaciones de otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="d7e10-573">This method is called when the caller needs to wait for a state change that will occur as a result of another thread's operations.</span></span>  
  
 <span data-ttu-id="d7e10-574">El tiempo de espera garantiza que el subproceso actual no se bloquea indefinidamente si otro subproceso libera el bloqueo sin llamar primero a la <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-574">The time-out ensures that the current thread does not block indefinitely if another thread releases the lock without first calling the <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method.</span></span> <span data-ttu-id="d7e10-575">También se mueve el subproceso a la cola de subprocesos listos, pasando por alto otros subprocesos por delante de él en la cola de espera, por lo que puede volver a adquirir el bloqueo antes.</span><span class="sxs-lookup"><span data-stu-id="d7e10-575">It also moves the thread to the ready queue, bypassing other threads ahead of it in the wait queue, so that it can reacquire the lock sooner.</span></span> <span data-ttu-id="d7e10-576">El subproceso puede probar el valor devuelto de la <xref:System.Threading.Monitor.Wait%2A> método para determinar si volvió a adquirir el bloqueo antes el tiempo de espera. El subproceso puede evaluar las condiciones que ha provocado que entre en espera, y si es necesario llamada la <xref:System.Threading.Monitor.Wait%2A> nuevo al método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-576">The thread can test the return value of the <xref:System.Threading.Monitor.Wait%2A> method to determine whether it reacquired the lock prior to the time-out. The thread can evaluate the conditions that caused it to enter the wait, and if necessary call the <xref:System.Threading.Monitor.Wait%2A> method again.</span></span>  
  
 <span data-ttu-id="d7e10-577">Cuando un subproceso llama `Wait`, libera el bloqueo y entra en la cola de espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-577">When a thread calls `Wait`, it releases the lock and enters the waiting queue.</span></span> <span data-ttu-id="d7e10-578">En este momento, el siguiente subproceso en la cola de subprocesos listos (si existe) se permite tomar el control del bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-578">At this point, the next thread in the ready queue (if there is one) is allowed to take control of the lock.</span></span> <span data-ttu-id="d7e10-579">El subproceso que invocó `Wait` permanece en la cola de espera hasta que un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.PulseAll%2A>, o es el siguiente en la cola y un subproceso que mantiene el bloqueo invoca <xref:System.Threading.Monitor.Pulse%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-579">The thread that invoked `Wait` remains in the waiting queue until either a thread that holds the lock invokes <xref:System.Threading.Monitor.PulseAll%2A>, or it is the next in the queue and a thread that holds the lock invokes <xref:System.Threading.Monitor.Pulse%2A>.</span></span> <span data-ttu-id="d7e10-580">Sin embargo, si `timeout` milisegundos que deben transcurrir antes de que otro subproceso llama a este objeto <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A> método, el subproceso original se mueve a la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-580">However, if `timeout` milliseconds elapse before another thread invokes this object's <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A> method, the original thread is moved to the ready queue in order to regain the lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-581">Si un <xref:System.TimeSpan> que representa-1 milisegundo se especifica para el `timeout` parámetro, este método se bloquea indefinidamente a menos que el propietario del bloqueo llame <xref:System.Threading.Monitor.Pulse%2A> o <xref:System.Threading.Monitor.PulseAll%2A>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-581">If a <xref:System.TimeSpan> representing -1 millisecond is specified for the `timeout` parameter, this method blocks indefinitely unless the holder of the lock calls <xref:System.Threading.Monitor.Pulse%2A> or <xref:System.Threading.Monitor.PulseAll%2A>.</span></span> <span data-ttu-id="d7e10-582">Si `timeout` es 0 milisegundos, el subproceso que llama `Wait` libera el bloqueo y, a continuación, escribe inmediatamente la cola de subprocesos listos para volver a adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="d7e10-582">If `timeout` is 0 milliseconds, the thread that calls `Wait` releases the lock and then immediately enters the ready queue in order to regain the lock.</span></span>  
  
 <span data-ttu-id="d7e10-583">El llamador ejecuta `Wait` una vez, independientemente del número de veces <xref:System.Threading.Monitor.Enter%2A> se ha invocado para el objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-583">The caller executes `Wait` once, regardless of the number of times <xref:System.Threading.Monitor.Enter%2A> has been invoked for the specified object.</span></span> <span data-ttu-id="d7e10-584">Conceptualmente, el `Wait` método almacena el número de veces que el autor de llamada invocado <xref:System.Threading.Monitor.Enter%2A> en el objeto e invoca <xref:System.Threading.Monitor.Exit%2A> tantas veces como sea necesario para liberar completamente el objeto bloqueado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-584">Conceptually, the `Wait` method stores the number of times the caller invoked <xref:System.Threading.Monitor.Enter%2A> on the object and invokes <xref:System.Threading.Monitor.Exit%2A> as many times as necessary to fully release the locked object.</span></span> <span data-ttu-id="d7e10-585">El llamador, a continuación, se bloquea mientras espera para adquirir el objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-585">The caller then blocks while waiting to reacquire the object.</span></span> <span data-ttu-id="d7e10-586">Cuando el autor de llamada vuelve a adquirir el bloqueo, el sistema llama <xref:System.Threading.Monitor.Enter%2A> tantas veces como sea necesario para restaurar el guardado <xref:System.Threading.Monitor.Enter%2A> recuento para el llamador.</span><span class="sxs-lookup"><span data-stu-id="d7e10-586">When the caller reacquires the lock, the system calls <xref:System.Threading.Monitor.Enter%2A> as many times as necessary to restore the saved <xref:System.Threading.Monitor.Enter%2A> count for the caller.</span></span> <span data-ttu-id="d7e10-587">Una llamada a `Wait` libera el bloqueo para el objeto especificado; si el llamador es el propietario de los bloqueos de otros objetos, estos bloqueos se liberan no.</span><span class="sxs-lookup"><span data-stu-id="d7e10-587">Calling `Wait` releases the lock for the specified object only; if the caller is the owner of locks on other objects, these locks are not released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d7e10-588">Un objeto sincronizado contiene varias referencias, incluida una referencia al subproceso que contiene actualmente el bloqueo, una referencia a la cola de subprocesos listos, que contiene los subprocesos que están listos para obtener el bloqueo, y una referencia a la cola de espera, que contiene el subprocesos que están esperando para recibir notificaciones de un cambio en el estado del objeto.</span><span class="sxs-lookup"><span data-stu-id="d7e10-588">A synchronized object holds several references, including a reference to the thread that currently holds the lock, a reference to the ready queue, which contains the threads that are ready to obtain the lock, and a reference to the waiting queue, which contains the threads that are waiting for notification of a change in the object's state.</span></span>  
  
 <span data-ttu-id="d7e10-589">El <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, y `Wait` métodos deben invocarse desde dentro de un bloque de código sincronizado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-589">The <xref:System.Threading.Monitor.Pulse%2A>, <xref:System.Threading.Monitor.PulseAll%2A>, and `Wait` methods must be invoked from within a synchronized block of code.</span></span>  
  
 <span data-ttu-id="d7e10-590">Los comentarios sobre la <xref:System.Threading.Monitor.Pulse%2A> método explica qué ocurre si <xref:System.Threading.Monitor.Pulse%2A> se llama cuando no hay ningún subproceso en espera.</span><span class="sxs-lookup"><span data-stu-id="d7e10-590">The remarks for the <xref:System.Threading.Monitor.Pulse%2A> method explain what happens if <xref:System.Threading.Monitor.Pulse%2A> is called when no threads are waiting.</span></span>  
  
## <a name="notes-on-exiting-the-context"></a><span data-ttu-id="d7e10-591">Notas sobre la salida del contexto</span><span class="sxs-lookup"><span data-stu-id="d7e10-591">Notes on Exiting the Context</span></span>  
 <span data-ttu-id="d7e10-592">El`exitContext` parámetro no tiene ningún efecto a menos que el <xref:System.Threading.Monitor.Wait%2A> método se llama desde dentro de un contexto administrado no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-592">The`exitContext` parameter has no effect unless the <xref:System.Threading.Monitor.Wait%2A> method is called from inside a nondefault managed context.</span></span> <span data-ttu-id="d7e10-593">Esto puede ocurrir si el subproceso está dentro de una llamada a una instancia de una clase derivada de <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="d7e10-593">This can happen if your thread is inside a call to an instance of a class derived from <xref:System.ContextBoundObject>.</span></span> <span data-ttu-id="d7e10-594">Incluso si se están ejecutando un método en una clase que no se deriva <xref:System.ContextBoundObject>, como <xref:System.String>, puede estar en un contexto no predeterminado si un <xref:System.ContextBoundObject> en la pila en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="d7e10-594">Even if you are currently executing a method on a class that is not derived from <xref:System.ContextBoundObject>, like <xref:System.String>, you can be in a nondefault context if a <xref:System.ContextBoundObject> is on your stack in the current application domain.</span></span>  
  
 <span data-ttu-id="d7e10-595">Cuando el código se ejecuta en un contexto no predeterminado, especificar `true` para `exitContext` hace que el subproceso salga del contexto administrado no predeterminado (es decir, para realizar la transición al contexto predeterminado) antes de ejecutar el <xref:System.Threading.Monitor.Wait%2A> método.</span><span class="sxs-lookup"><span data-stu-id="d7e10-595">When your code is executing in a nondefault context, specifying `true` for `exitContext` causes the thread to exit the nondefault managed context (that is, to transition to the default context) before executing the <xref:System.Threading.Monitor.Wait%2A> method.</span></span> <span data-ttu-id="d7e10-596">Devuelve al contexto original no predeterminado después de llamar a la <xref:System.Threading.Monitor.Wait%2A> método se completa.</span><span class="sxs-lookup"><span data-stu-id="d7e10-596">It returns to the original nondefault context after the call to the <xref:System.Threading.Monitor.Wait%2A> method completes.</span></span>  
  
 <span data-ttu-id="d7e10-597">Esto puede ser útil cuando la clase de contexto enlazado tiene el <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> atributo aplicado.</span><span class="sxs-lookup"><span data-stu-id="d7e10-597">This can be useful when the context-bound class has the <xref:System.Runtime.Remoting.Contexts.SynchronizationAttribute> attribute applied.</span></span> <span data-ttu-id="d7e10-598">En ese caso, todas las llamadas a miembros de la clase se sincronizan automáticamente y el dominio de sincronización es todo el cuerpo de código para la clase.</span><span class="sxs-lookup"><span data-stu-id="d7e10-598">In that case, all calls to members of the class are automatically synchronized, and the synchronization domain is the entire body of code for the class.</span></span> <span data-ttu-id="d7e10-599">Si llama código en la pila de llamadas de un miembro de la <xref:System.Threading.Monitor.Wait%2A> método y especifica `true` para `exitContext`, el subproceso sale del dominio de sincronización, lo que permite un subproceso que esté bloqueado en una llamada a cualquier miembro del objeto para continuar.</span><span class="sxs-lookup"><span data-stu-id="d7e10-599">If code in the call stack of a member calls the <xref:System.Threading.Monitor.Wait%2A> method and specifies `true` for `exitContext`, the thread exits the synchronization domain, allowing a thread that is blocked on a call to any member of the object to proceed.</span></span> <span data-ttu-id="d7e10-600">Cuando el <xref:System.Threading.Monitor.Wait%2A> método finaliza, el subproceso que realizó la llamada debe esperar para volver a escribir el dominio de sincronización.</span><span class="sxs-lookup"><span data-stu-id="d7e10-600">When the <xref:System.Threading.Monitor.Wait%2A> method returns, the thread that made the call must wait to reenter the synchronization domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="d7e10-601">El parámetro <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-601">The <paramref name="obj" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.SynchronizationLockException">
          <span data-ttu-id="d7e10-602">
            <see langword="Wait" /> no se invoca desde dentro de un bloque de código sincronizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-602">
              <see langword="Wait" /> is not invoked from within a synchronized block of code.</span>
          </span>
        </exception>
        <exception cref="T:System.Threading.ThreadInterruptedException">
          <span data-ttu-id="d7e10-603">El subproceso que invoca a Wait se interrumpe más adelante desde el estado de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-603">The thread that invokes Wait is later interrupted from the waiting state.</span>
          </span>
          <span data-ttu-id="d7e10-604">Esto ocurre cuando otro subproceso llama al método <see cref="M:System.Threading.Thread.Interrupt" /> de este subproceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-604">This happens when another thread calls this thread's <see cref="M:System.Threading.Thread.Interrupt" /> method.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="d7e10-605">El parámetro <paramref name="timeout" /> es negativo y no representa <see cref="F:System.Threading.Timeout.Infinite" /> (– 1 milisegundo), o es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-605">The <paramref name="timeout" /> parameter is negative and does not represent <see cref="F:System.Threading.Timeout.Infinite" /> (–1 millisecond), or is greater than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <altmember cref="T:System.Threading.Thread" />
        <altmember cref="T:System.Threading.Monitor" />
        <related type="Article" href="~/docs/standard/threading/index.md">
          <span data-ttu-id="d7e10-606">Subprocesamiento administrado</span>
          <span class="sxs-lookup">
            <span data-stu-id="d7e10-606">Managed Threading</span>
          </span>
        </related>
      </Docs>
    </Member>
  </Members>
</Type>