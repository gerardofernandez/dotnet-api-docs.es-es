<Type Name="ReaderWriterLock" FullName="System.Threading.ReaderWriterLock">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="eceaf936001c4e98e1bf97071c933f2a511a4a69" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37754698" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class ReaderWriterLock : System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit ReaderWriterLock extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  <TypeSignature Language="DocId" Value="T:System.Threading.ReaderWriterLock" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class ReaderWriterLock&#xA;Inherits CriticalFinalizerObject" />
  <TypeSignature Language="C++ CLI" Value="public ref class ReaderWriterLock sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject" />
  <TypeSignature Language="F#" Value="type ReaderWriterLock = class&#xA;    inherit CriticalFinalizerObject" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-1.1">System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="4c58b-101">Define un bloqueo que admite un escritor y varios lectores.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4c58b-101">Defines a lock that supports single writers and multiple readers.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="4c58b-102">[!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] tiene dos bloqueos de lector y escritor, <xref:System.Threading.ReaderWriterLockSlim> y <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-102">The [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] has two reader-writer locks, <xref:System.Threading.ReaderWriterLockSlim> and <xref:System.Threading.ReaderWriterLock>.</span></span> <span data-ttu-id="4c58b-103"><xref:System.Threading.ReaderWriterLockSlim> se recomienda para todos los nuevos desarrollos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-103"><xref:System.Threading.ReaderWriterLockSlim> is recommended for all new development.</span></span> <span data-ttu-id="4c58b-104"><xref:System.Threading.ReaderWriterLockSlim> es similar a <xref:System.Threading.ReaderWriterLock>, pero se han simplificado las reglas para la recursividad y para actualizar y degradar el estado de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-104"><xref:System.Threading.ReaderWriterLockSlim> is similar to <xref:System.Threading.ReaderWriterLock>, but it has simplified rules for recursion and for upgrading and downgrading lock state.</span></span> <span data-ttu-id="4c58b-105"><xref:System.Threading.ReaderWriterLockSlim> evita muchos casos de interbloqueo potencial.</span><span class="sxs-lookup"><span data-stu-id="4c58b-105"><xref:System.Threading.ReaderWriterLockSlim> avoids many cases of potential deadlock.</span></span> <span data-ttu-id="4c58b-106">Además, el rendimiento de <xref:System.Threading.ReaderWriterLockSlim> es significativamente mayor que <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-106">In addition, the performance of <xref:System.Threading.ReaderWriterLockSlim> is significantly better than <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 <span data-ttu-id="4c58b-107"><xref:System.Threading.ReaderWriterLock> se utiliza para sincronizar el acceso a un recurso.</span><span class="sxs-lookup"><span data-stu-id="4c58b-107"><xref:System.Threading.ReaderWriterLock> is used to synchronize access to a resource.</span></span> <span data-ttu-id="4c58b-108">En un momento dado, permite el acceso de lectura simultáneo para varios subprocesos, o bien acceso de escritura para un único subproceso.</span><span class="sxs-lookup"><span data-stu-id="4c58b-108">At any given time, it allows either concurrent read access for multiple threads, or write access for a single thread.</span></span> <span data-ttu-id="4c58b-109">En una situación donde un recurso cambia con poca frecuencia, un `ReaderWriterLock` proporciona un mejor rendimiento que un bloqueo simple de uno en uno, como <xref:System.Threading.Monitor>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-109">In a situation where a resource is changed infrequently, a `ReaderWriterLock` provides better throughput than a simple one-at-a-time lock, such as <xref:System.Threading.Monitor>.</span></span>  
  
 <span data-ttu-id="4c58b-110">`ReaderWriterLock` funciona mejor en su mayoría de los accesos es de lectura y las escrituras son poco frecuentes y de corta duración.</span><span class="sxs-lookup"><span data-stu-id="4c58b-110">`ReaderWriterLock` works best where most accesses are reads, while writes are infrequent and of short duration.</span></span> <span data-ttu-id="4c58b-111">Varios lectores alternan con escritores únicos, por lo que ni a lectores ni a escritores se bloquean durante largos períodos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-111">Multiple readers alternate with single writers, so that neither readers nor writers are blocked for long periods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-112">Que contiene los bloqueos de lector o bloqueos del sistema de escritura durante largos períodos se privar a otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-112">Holding reader locks or writer locks for long periods will starve other threads.</span></span> <span data-ttu-id="4c58b-113">Para obtener el mejor rendimiento, considere la posibilidad de reestructuración de la aplicación para minimizar la duración de las escrituras.</span><span class="sxs-lookup"><span data-stu-id="4c58b-113">For best performance, consider restructuring your application to minimize the duration of writes.</span></span>  
  
 <span data-ttu-id="4c58b-114">Un subproceso puede contener un lector de bloqueo o un bloqueo de escritor, pero no ambos al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-114">A thread can hold a reader lock or a writer lock, but not both at the same time.</span></span> <span data-ttu-id="4c58b-115">En lugar de liberar un bloqueo de lector para adquirir el bloqueo de escritor, puede usar <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> y <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-115">Instead of releasing a reader lock in order to acquire the writer lock, you can use <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> and <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A>.</span></span>  
  
 <span data-ttu-id="4c58b-116">Solicitudes de bloqueo recursivas aumentan el recuento de bloqueos en un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-116">Recursive lock requests increase the lock count on a lock.</span></span>  
  
 <span data-ttu-id="4c58b-117">Los lectores y escritores se ponen en cola por separado.</span><span class="sxs-lookup"><span data-stu-id="4c58b-117">Readers and writers are queued separately.</span></span> <span data-ttu-id="4c58b-118">Cuando un subproceso libera el bloqueo de escritor, todos los subprocesos que esperan en la cola del lector en ese momento se conceden los bloqueos de lector; Cuando todos los bloqueos de lector se han publicado, el siguiente subproceso en espera en el sistema de escritura poner en cola, si existe, se concede el bloqueo de escritor y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-118">When a thread releases the writer lock, all threads waiting in the reader queue at that instant are granted reader locks; when all of those reader locks have been released, the next thread waiting in the writer queue, if any, is granted the writer lock, and so on.</span></span> <span data-ttu-id="4c58b-119">En otras palabras, `ReaderWriterLock` alterna entre una colección de lectores y un sistema de escritura.</span><span class="sxs-lookup"><span data-stu-id="4c58b-119">In other words, `ReaderWriterLock` alternates between a collection of readers, and one writer.</span></span>  
  
 <span data-ttu-id="4c58b-120">Mientras un subproceso en la cola de sistema de escritura está esperando a que se liberen los bloqueos de lector activo, subprocesos que soliciten nuevos bloqueos de lector se acumulan en la cola del lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-120">While a thread in the writer queue is waiting for active reader locks to be released, threads requesting new reader locks accumulate in the reader queue.</span></span> <span data-ttu-id="4c58b-121">No se conceden sus solicitudes, aunque podrían compartir el acceso simultáneo con marcadores de bloqueo de lector existentes; Esto ayuda a proteger a los escritores frente a bloqueos indefinidos por los lectores.</span><span class="sxs-lookup"><span data-stu-id="4c58b-121">Their requests are not granted, even though they could share concurrent access with existing reader-lock holders; this helps protect writers against indefinite blockage by readers.</span></span>  
  
 <span data-ttu-id="4c58b-122">Mayoría de los métodos para adquirir bloqueos en un `ReaderWriterLock` acepte los valores de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="4c58b-122">Most methods for acquiring locks on a `ReaderWriterLock` accept time-out values.</span></span> <span data-ttu-id="4c58b-123">Use los tiempos de espera para evitar los interbloqueos en la aplicación.</span><span class="sxs-lookup"><span data-stu-id="4c58b-123">Use time-outs to avoid deadlocks in your application.</span></span> <span data-ttu-id="4c58b-124">Por ejemplo, un subproceso podría adquirir el bloqueo de escritura en un recurso y, a continuación, solicitar un bloqueo de lector en un segundo recurso; mientras tanto, otro subproceso podría adquirir el bloqueo de escritura en el segundo recurso y solicitar un bloqueo de lector en la primera.</span><span class="sxs-lookup"><span data-stu-id="4c58b-124">For example, a thread might acquire the writer lock on one resource and then request a reader lock on a second resource; in the meantime, another thread might acquire the writer lock on the second resource, and request a reader lock on the first.</span></span> <span data-ttu-id="4c58b-125">A menos que se usan los tiempos de espera, el interbloqueo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-125">Unless time-outs are used, the threads deadlock.</span></span>  
  
 <span data-ttu-id="4c58b-126">Si expira el intervalo de tiempo de espera y no se concedió la solicitud de bloqueo, el método devuelve el control al subproceso que realiza la llamada generando un <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-126">If the time-out interval expires and the lock request has not been granted, the method returns control to the calling thread by throwing an <xref:System.ApplicationException>.</span></span> <span data-ttu-id="4c58b-127">Un subproceso puede detectar esta excepción y determinar qué acción se debe realizar a continuación.</span><span class="sxs-lookup"><span data-stu-id="4c58b-127">A thread can catch this exception and determine what action to take next.</span></span>  
  
 <span data-ttu-id="4c58b-128">Los tiempos de espera se expresan en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-128">Time-outs are expressed in milliseconds.</span></span> <span data-ttu-id="4c58b-129">Si usa un <xref:System.TimeSpan?displayProperty=nameWithType> para especificar el tiempo de espera, el valor utilizado es el número total de milisegundos enteros representado por la <xref:System.TimeSpan>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-129">If you use a <xref:System.TimeSpan?displayProperty=nameWithType> to specify the time-out, the value used is the total number of whole milliseconds represented by the <xref:System.TimeSpan>.</span></span> <span data-ttu-id="4c58b-130">En la tabla siguiente se muestra los valores de tiempo de espera válido en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-130">The following table shows the valid time-out values in milliseconds.</span></span>  
  
|<span data-ttu-id="4c58b-131">Valor</span><span class="sxs-lookup"><span data-stu-id="4c58b-131">Value</span></span>|<span data-ttu-id="4c58b-132">Descripción</span><span class="sxs-lookup"><span data-stu-id="4c58b-132">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="4c58b-133">-1</span><span class="sxs-lookup"><span data-stu-id="4c58b-133">-1</span></span>|<span data-ttu-id="4c58b-134">El subproceso espera hasta que se adquiere el bloqueo, independientemente de cuánto se tarda.</span><span class="sxs-lookup"><span data-stu-id="4c58b-134">The thread waits until the lock is acquired, regardless of how long it takes.</span></span> <span data-ttu-id="4c58b-135">Para los métodos que especifican los tiempos de espera entero, la constante <xref:System.Threading.Timeout.Infinite> se puede usar.</span><span class="sxs-lookup"><span data-stu-id="4c58b-135">For methods that specify integer time-outs, the constant <xref:System.Threading.Timeout.Infinite> can be used.</span></span>|  
|<span data-ttu-id="4c58b-136">0</span><span class="sxs-lookup"><span data-stu-id="4c58b-136">0</span></span>|<span data-ttu-id="4c58b-137">El subproceso no esperar para adquirir el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-137">The thread does not wait to acquire the lock.</span></span> <span data-ttu-id="4c58b-138">Si no se puede adquirir el bloqueo inmediatamente, el método devuelve.</span><span class="sxs-lookup"><span data-stu-id="4c58b-138">If the lock cannot be acquired immediately, the method returns.</span></span>|  
|<span data-ttu-id="4c58b-139">>0</span><span class="sxs-lookup"><span data-stu-id="4c58b-139">>0</span></span>|<span data-ttu-id="4c58b-140">Número de milisegundos durante los que se va a esperar.</span><span class="sxs-lookup"><span data-stu-id="4c58b-140">The number of milliseconds to wait.</span></span>|  
  
 <span data-ttu-id="4c58b-141">A excepción de -1, no se permiten valores negativos del tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="4c58b-141">With the exception of -1, negative time-out values are not allowed.</span></span> <span data-ttu-id="4c58b-142">Si especifica un entero negativo distinto de -1, se usa en su lugar un valor de tiempo de espera de cero.</span><span class="sxs-lookup"><span data-stu-id="4c58b-142">If you specify a negative integer other than -1, a time-out value of zero is used instead.</span></span> <span data-ttu-id="4c58b-143">(Es decir, el método devuelve sin tener que esperar, si el bloqueo no puede adquirirse inmediatamente). Si especifica un <xref:System.TimeSpan> que representa un número negativo de milisegundos distinto de -1, <xref:System.ArgumentOutOfRangeException> se produce.</span><span class="sxs-lookup"><span data-stu-id="4c58b-143">(That is, the method returns without waiting, if the lock cannot be acquired immediately.) If you specify a <xref:System.TimeSpan> that represents a negative number of milliseconds other than -1, <xref:System.ArgumentOutOfRangeException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-144">En el ejemplo siguiente se muestra cómo usar un <xref:System.Threading.ReaderWriterLock> para proteger un recurso compartido, un número entero denominado `resource`, que se simultáneamente leer y escribir exclusivamente por varios subprocesos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-144">The following example demonstrates how to use a <xref:System.Threading.ReaderWriterLock> to protect a shared resource, an integer value named `resource`, that is read concurrently and written exclusively by multiple threads.</span></span> <span data-ttu-id="4c58b-145">Tenga en cuenta que el <xref:System.Threading.ReaderWriterLock> se declara en el nivel de clase para que sea visible para todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-145">Note that the <xref:System.Threading.ReaderWriterLock> is declared at the class level so that it is visible to all threads.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe>
      <span data-ttu-id="4c58b-146">Este tipo es seguro para la ejecución de subprocesos.</span>
      <span class="sxs-lookup">
        <span data-stu-id="4c58b-146">This type is thread safe.</span>
      </span>
    </threadsafe>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReaderWriterLock();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-147">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.ReaderWriterLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-147">Initializes a new instance of the <see cref="T:System.Threading.ReaderWriterLock" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4c58b-148">En el ejemplo de código siguiente se muestra cómo se crea una nueva instancia de la clase <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-148">The following code example demonstrates how to create a new instance of the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="4c58b-149">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-149">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireReaderLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-150">Adquiere un bloqueo de lector.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-150">Acquires a reader lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : int -&gt; unit" Usage="readerWriterLock.AcquireReaderLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="4c58b-151">Tiempo de espera en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-151">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-152">Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-152">Acquires a reader lock, using an <see cref="T:System.Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-153"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> se bloquea si un subproceso diferente tiene el bloqueo de escritor, o si al menos un subproceso está esperando el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-153"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-154">Si el subproceso actual ya tiene el bloqueo de escritor, no se adquiere ningún bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-154">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="4c58b-155">En su lugar, se incrementa el recuento de bloqueos del bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-155">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="4c58b-156">Esto evita que un subproceso de bloqueo en su propio bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-156">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="4c58b-157">El resultado es exactamente igual que llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>y una llamada adicional a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> es necesaria cuando se libera el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-157">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="4c58b-158">`AcquireReaderLock` admite solicitudes de bloqueo de lector recursivas.</span><span class="sxs-lookup"><span data-stu-id="4c58b-158">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="4c58b-159">Es decir, un subproceso puede llamar a AcquireReaderLock varias veces, lo que aumenta el recuento de bloqueos cada vez.</span><span class="sxs-lookup"><span data-stu-id="4c58b-159">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="4c58b-160">Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> una vez para cada vez que se llama `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-160">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="4c58b-161">Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-161">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="4c58b-162">Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-162">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="4c58b-163">Usar bloqueos recursivos con precaución, para evitar el bloqueo de las solicitudes de bloqueo de escritor durante largos períodos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-163">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="4c58b-164">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-164">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-165">El ejemplo de código siguiente muestra cómo adquirir y liberar un bloqueo de lector y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.</span><span class="sxs-lookup"><span data-stu-id="4c58b-165">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="4c58b-166">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-166">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-167">
            <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-167">
              <paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireReaderLock">
      <MemberSignature Language="C#" Value="public void AcquireReaderLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireReaderLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireReaderLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireReaderLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireReaderLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireReaderLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireReaderLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="4c58b-168">Un <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-168">A <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-169">Adquiere un bloqueo de lector, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-169">Acquires a reader lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-170"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> se bloquea si un subproceso diferente tiene el bloqueo de escritor, o si al menos un subproceso está esperando el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-170"><xref:System.Threading.ReaderWriterLock.AcquireReaderLock%2A> blocks if a different thread has the writer lock, or if at least one thread is waiting for the writer lock.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-171">Si el subproceso actual ya tiene el bloqueo de escritor, no se adquiere ningún bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-171">If the current thread already has the writer lock, no reader lock is acquired.</span></span> <span data-ttu-id="4c58b-172">En su lugar, se incrementa el recuento de bloqueos del bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-172">Instead, the lock count on the writer lock is incremented.</span></span> <span data-ttu-id="4c58b-173">Esto evita que un subproceso de bloqueo en su propio bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-173">This prevents a thread from blocking on its own writer lock.</span></span> <span data-ttu-id="4c58b-174">El resultado es exactamente igual que llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>y una llamada adicional a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> es necesaria cuando se libera el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-174">The result is exactly the same as calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, and an additional call to <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> is required when releasing the writer lock.</span></span>  
  
 <span data-ttu-id="4c58b-175">`AcquireReaderLock` admite solicitudes de bloqueo de lector recursivas.</span><span class="sxs-lookup"><span data-stu-id="4c58b-175">`AcquireReaderLock` supports recursive reader-lock requests.</span></span> <span data-ttu-id="4c58b-176">Es decir, un subproceso puede llamar a AcquireReaderLock varias veces, lo que aumenta el recuento de bloqueos cada vez.</span><span class="sxs-lookup"><span data-stu-id="4c58b-176">That is, a thread can call AcquireReaderLock multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="4c58b-177">Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> una vez para cada vez que se llama `AcquireReaderLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-177">You must call <xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> once for each time you call `AcquireReaderLock`.</span></span> <span data-ttu-id="4c58b-178">Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-178">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="4c58b-179">Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-179">Recursive lock requests are always granted immediately, without placing the requesting thread in the reader queue.</span></span> <span data-ttu-id="4c58b-180">Usar bloqueos recursivos con precaución, para evitar el bloqueo de las solicitudes de bloqueo de escritor durante largos períodos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-180">Use recursive locks with caution, to avoid blocking writer-lock requests for long periods.</span></span>  
  
 <span data-ttu-id="4c58b-181">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-181">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-182">
            <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-182">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4c58b-183">
            <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-183">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="AcquireWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-184">Adquiere el bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-184">Acquires the writer lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : int -&gt; unit" Usage="readerWriterLock.AcquireWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="4c58b-185">Tiempo de espera en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-185">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-186">Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.Int32" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-186">Acquires the writer lock, using an <see cref="T:System.Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-187">Este método se bloquea si otro subproceso tiene un bloqueo de lector o escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-187">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="4c58b-188">Para obtener una descripción de la forma en que el bloqueo de escritor alterna con varios bloqueos de lector simultáneo, consulte el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-188">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="4c58b-189">Un subproceso que ya tiene un bloqueo de lector puede adquirir el bloqueo de escritor en uno de dos maneras: mediante la liberación del bloqueo de lector antes de llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, o mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-189">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4c58b-190">Si un subproceso llama `AcquireWriterLock` mientras todavía tiene un bloqueo de lector, bloqueará en su propio bloqueo de lector; si se especifica un tiempo de espera infinito, el subproceso generará un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-190">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="4c58b-191">Para evitar estos interbloqueos, utilice <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar si el subproceso actual ya tiene un bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-191">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="4c58b-192">`AcquireWriterLock` admite solicitudes de bloqueo de escritor recursivas.</span><span class="sxs-lookup"><span data-stu-id="4c58b-192">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="4c58b-193">Es decir, un subproceso puede llamar a `AcquireWriterLock` varias veces, lo que aumenta el recuento de bloqueos cada vez.</span><span class="sxs-lookup"><span data-stu-id="4c58b-193">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="4c58b-194">Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> una vez para cada vez que se llama `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-194">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="4c58b-195">Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-195">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="4c58b-196">Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-196">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="4c58b-197">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-197">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-198">El ejemplo de código siguiente muestra cómo adquirir y liberar un bloqueo de escritor y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.</span><span class="sxs-lookup"><span data-stu-id="4c58b-198">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="4c58b-199">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-199">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-200">
            <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-200">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AcquireWriterLock">
      <MemberSignature Language="C#" Value="public void AcquireWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AcquireWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AcquireWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AcquireWriterLock (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AcquireWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.AcquireWriterLock : TimeSpan -&gt; unit" Usage="readerWriterLock.AcquireWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="4c58b-201">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-201">The <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-202">Adquiere el bloqueo de escritor, utilizando un valor <see cref="T:System.TimeSpan" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-202">Acquires the writer lock, using a <see cref="T:System.TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-203">Este método se bloquea si otro subproceso tiene un bloqueo de lector o escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-203">This method blocks if another thread has a reader lock or writer lock.</span></span> <span data-ttu-id="4c58b-204">Para obtener una descripción de la forma en que el bloqueo de escritor alterna con varios bloqueos de lector simultáneo, consulte el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-204">For a description of the way the writer lock alternates with multiple concurrent reader locks, see the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 <span data-ttu-id="4c58b-205">Un subproceso que ya tiene un bloqueo de lector puede adquirir el bloqueo de escritor en uno de dos maneras: mediante la liberación del bloqueo de lector antes de llamar a <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, o mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-205">A thread that already has a reader lock can acquire the writer lock in one of two ways: by releasing the reader lock before calling <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A>, or by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4c58b-206">Si un subproceso llama `AcquireWriterLock` mientras todavía tiene un bloqueo de lector, bloqueará en su propio bloqueo de lector; si se especifica un tiempo de espera infinito, el subproceso generará un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-206">If a thread calls `AcquireWriterLock` while it still has a reader lock, it will block on its own reader lock; if an infinite time-out is specified, the thread will deadlock.</span></span> <span data-ttu-id="4c58b-207">Para evitar estos interbloqueos, utilice <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> para determinar si el subproceso actual ya tiene un bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-207">To avoid such deadlocks, use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> to determine whether the current thread already has a reader lock.</span></span>  
  
 <span data-ttu-id="4c58b-208">`AcquireWriterLock` admite solicitudes de bloqueo de escritor recursivas.</span><span class="sxs-lookup"><span data-stu-id="4c58b-208">`AcquireWriterLock` supports recursive writer-lock requests.</span></span> <span data-ttu-id="4c58b-209">Es decir, un subproceso puede llamar a `AcquireWriterLock` varias veces, lo que aumenta el recuento de bloqueos cada vez.</span><span class="sxs-lookup"><span data-stu-id="4c58b-209">That is, a thread can call `AcquireWriterLock` multiple times, which increments the lock count each time.</span></span> <span data-ttu-id="4c58b-210">Debe llamar a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> una vez para cada vez que se llama `AcquireWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-210">You must call <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> once for each time you call `AcquireWriterLock`.</span></span> <span data-ttu-id="4c58b-211">Como alternativa, puede llamar a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> para reducir el recuento de bloqueos a cero inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-211">Alternatively, you can call <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> to reduce the lock count to zero immediately.</span></span>  
  
 <span data-ttu-id="4c58b-212">Solicitudes de bloqueo recursivas siempre se conceden inmediatamente, sin colocar el subproceso de solicitud en la cola del escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-212">Recursive lock requests are always granted immediately, without placing the requesting thread in the writer queue.</span></span>  
  
 <span data-ttu-id="4c58b-213">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-213">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-214">
            <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-214">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4c58b-215">
            <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-215">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="AnyWritersSince">
      <MemberSignature Language="C#" Value="public bool AnyWritersSince (int seqNum);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AnyWritersSince(int32 seqNum) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.AnyWritersSince(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function AnyWritersSince (seqNum As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AnyWritersSince(int seqNum);" />
      <MemberSignature Language="F#" Value="member this.AnyWritersSince : int -&gt; bool" Usage="readerWriterLock.AnyWritersSince seqNum" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="seqNum" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="seqNum">
          <span data-ttu-id="4c58b-216">Número de secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-216">The sequence number.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-217">Indica si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-217">Indicates whether the writer lock has been granted to any thread since the sequence number was obtained.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4c58b-218">
            <see langword="true" /> si se ha concedido el bloqueo de escritor a algún subproceso desde que se obtuvo el número de secuencia; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-218">
              <see langword="true" /> if the writer lock has been granted to any thread since the sequence number was obtained; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-219">Puede usar <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> y `AnyWritersSince` para mejorar el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="4c58b-219">You can use <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> and `AnyWritersSince` to improve application performance.</span></span> <span data-ttu-id="4c58b-220">Por ejemplo, un subproceso podría guardar en caché la información que obtiene mientras se mantiene un bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-220">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="4c58b-221">Después de liberar y volver a adquirir el bloqueo, puede usar el subproceso `AnyWritersSince` para determinar si otros subprocesos han escrito en el recurso en la versión preliminar; en caso contrario, se puede usar la información almacenada en caché.</span><span class="sxs-lookup"><span data-stu-id="4c58b-221">After releasing and later reacquiring the lock, the thread can use `AnyWritersSince` to determine whether other threads have written to the resource in the interim; if not, the cached information can be used.</span></span> <span data-ttu-id="4c58b-222">Esta técnica es útil donde resulta costoso; leer la información protegida por el bloqueo Por ejemplo, ejecutar una consulta de base de datos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-222">This technique is useful where reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="4c58b-223">El llamador debe contener un bloqueo de lector o escritor en orden para el número de secuencia ser útil.</span><span class="sxs-lookup"><span data-stu-id="4c58b-223">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-224">En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> método y el <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> por última vez, propiedad para determinar si otro subproceso adquirió el bloqueo de escritura al recurso protegido desde el subproceso actual mantiene el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-224">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method and the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="4c58b-225">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-225">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DowngradeFromWriterLock">
      <MemberSignature Language="C#" Value="public void DowngradeFromWriterLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DowngradeFromWriterLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.DowngradeFromWriterLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DowngradeFromWriterLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DowngradeFromWriterLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.DowngradeFromWriterLock :  -&gt; unit" Usage="readerWriterLock.DowngradeFromWriterLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <span data-ttu-id="4c58b-226">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-226">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-227">Recupera el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-227">Restores the lock status of the thread to what it was before <see cref="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" /> was called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-228"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> Libera el bloqueo de escritor, independientemente del recuento de bloqueos recursivos y restaura el bloqueo de lector que se incluyen en el subproceso antes de actualizar al bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-228"><xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> releases the writer lock, regardless of the recursive lock count, and restores the reader lock that was held by the thread before upgrading to the writer lock.</span></span> <span data-ttu-id="4c58b-229">Se restaura el recuento de bloqueos del bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-229">The lock count on the reader lock is restored.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-230">`DowngradeFromWriterLock` acepta un <xref:System.Threading.LockCookie> obtenido mediante una llamada a <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-230">`DowngradeFromWriterLock` accepts a <xref:System.Threading.LockCookie> obtained by calling <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span> <span data-ttu-id="4c58b-231">No use un `LockCookie` devuelto por <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-231">Do not use a `LockCookie` returned by <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span>  
  
 <span data-ttu-id="4c58b-232">Un subproceso no se bloquea al realizar una degradación de bloqueo de escritor, incluso si otros subprocesos están esperando el bloqueo de escritor, ya que todas las solicitudes de bloqueo de lector se conceden cuando se libera el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-232">A thread does not block when downgrading from the writer lock, even if other threads are waiting for the writer lock, because all reader-lock requests are granted when the writer lock is released.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-233">En el ejemplo de código siguiente se muestra cómo solicitar un bloqueo de lector, actualizar el bloqueo de lector a un bloqueo de escritor y cambiar a un bloqueo de lector de nuevo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-233">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="4c58b-234">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-234">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-235">El subproceso no dispone del bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-235">The thread does not have the writer lock.</span>
          </span>
        </exception>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4c58b-236">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-236">The address of <paramref name="lockCookie" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~ReaderWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!ReaderWriterLock ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="readerWriterLock.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-237">Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <see cref="T:System.Threading.ReaderWriterLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-237">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.ReaderWriterLock" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-238">El recolector de elementos no utilizados llame al <xref:System.Threading.ReaderWriterLock.Finalize%2A> cuando actual <xref:System.Threading.ReaderWriterLock> objeto está listo para ser finalizados.</span><span class="sxs-lookup"><span data-stu-id="4c58b-238">The garbage collector calls <xref:System.Threading.ReaderWriterLock.Finalize%2A> when the current <xref:System.Threading.ReaderWriterLock> object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsReaderLockHeld">
      <MemberSignature Language="C#" Value="public bool IsReaderLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsReaderLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsReaderLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsReaderLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsReaderLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsReaderLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-239">Obtiene un valor que indica si el subproceso actual tiene un bloqueo de lector.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-239">Gets a value indicating whether the current thread holds a reader lock.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4c58b-240">
            <see langword="true" /> si el subproceso actual tiene un bloqueo de lector; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-240">
              <see langword="true" /> if the current thread holds a reader lock; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4c58b-241">En el ejemplo de código siguiente se muestra cómo usar `IsReaderLockHeld` para evitar interbloqueos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-241">The following code example demonstrates how to use `IsReaderLockHeld` to avoid deadlocks.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsWriterLockHeld">
      <MemberSignature Language="C#" Value="public bool IsWriterLockHeld { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsWriterLockHeld" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsWriterLockHeld As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsWriterLockHeld { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsWriterLockHeld : bool" Usage="System.Threading.ReaderWriterLock.IsWriterLockHeld" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-242">Obtiene un valor que indica si el subproceso actual tiene el bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-242">Gets a value indicating whether the current thread holds the writer lock.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4c58b-243">
            <see langword="true" /> si el subproceso actual tiene el bloqueo de escritor; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-243">
              <see langword="true" /> if the current thread holds the writer lock; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="4c58b-244">El ejemplo de código siguiente muestra que cuando se intenta adquirir un bloqueo de lector en un subproceso que tiene un bloqueo de escritor, `ReaderWriterLock` no concede el bloqueo de lector, sino que incrementa el recuento de bloqueos del bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-244">The following code example demonstrates that when an attempt is made to acquire a reader lock on a thread that has a writer lock, `ReaderWriterLock` does not grant the reader lock but instead increments the lock count on the writer lock.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/CS/source.cs#1)]
 [!code-vb[System.Threading.ReaderWriterLock.IsWriterLockHeld#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock.IsWriterLockHeld/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie ReleaseLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie ReleaseLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseLock" />
      <MemberSignature Language="VB.NET" Value="Public Function ReleaseLock () As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie ReleaseLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseLock : unit -&gt; System.Threading.LockCookie" Usage="readerWriterLock.ReleaseLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-245">Libera el bloqueo, independientemente del número de veces que el subproceso haya adquirido el bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-245">Releases the lock, regardless of the number of times the thread acquired the lock.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4c58b-246">Un valor <see cref="T:System.Threading.LockCookie" /> que representa el bloqueo liberado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-246">A <see cref="T:System.Threading.LockCookie" /> value representing the released lock.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-247"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> Libera el bloqueo de lector o el bloqueo de escritor, independientemente del recuento de bloqueos recursivos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-247"><xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> releases the reader lock or writer lock, regardless of the recursive lock count.</span></span> <span data-ttu-id="4c58b-248">Para restaurar el estado del bloqueo, incluido el recuento de bloqueos, pase el <xref:System.Threading.LockCookie> a <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-248">To restore the state of the lock, including the lock count, pass the <xref:System.Threading.LockCookie> to <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-249">En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar el bloqueo, independientemente de cuántas veces ha sido adquirida por el subproceso y cómo restaurar el estado del bloqueo más adelante.</span><span class="sxs-lookup"><span data-stu-id="4c58b-249">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="4c58b-250">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-250">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReleaseReaderLock">
      <MemberSignature Language="C#" Value="public void ReleaseReaderLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseReaderLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseReaderLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseReaderLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseReaderLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseReaderLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseReaderLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-251">Reduce el recuento de bloqueos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-251">Decrements the lock count.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-252"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> disminuye el recuento de bloqueos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-252"><xref:System.Threading.ReaderWriterLock.ReleaseReaderLock%2A> decrements the lock count.</span></span> <span data-ttu-id="4c58b-253">Cuando el recuento llega a cero, se libera el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-253">When the count reaches zero, the lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-254">Si un subproceso tiene el bloqueo de escritor, la llamada a `ReleaseReaderLock` tiene el mismo efecto que llamar a <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-254">If a thread has the writer lock, calling `ReleaseReaderLock` has the same effect as calling <xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A>.</span></span> <span data-ttu-id="4c58b-255">Si un subproceso no tiene bloqueos, una llamada a `ReleaseReaderLock` produce una <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-255">If a thread has no locks, calling `ReleaseReaderLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-256">El ejemplo de código siguiente muestra cómo adquirir y liberar un bloqueo de lector y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.</span><span class="sxs-lookup"><span data-stu-id="4c58b-256">The following code example shows how to acquire and release a reader lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="4c58b-257">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-257">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#3)]
[!code-csharp[System.Threading.ReaderWriterLock#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#3)]
[!code-vb[System.Threading.ReaderWriterLock#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#3)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-258">El subproceso no tiene ningún bloqueo de lector o escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-258">The thread does not have any reader or writer locks.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ReleaseWriterLock">
      <MemberSignature Language="C#" Value="public void ReleaseWriterLock ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ReleaseWriterLock() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.ReleaseWriterLock" />
      <MemberSignature Language="VB.NET" Value="Public Sub ReleaseWriterLock ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ReleaseWriterLock();" />
      <MemberSignature Language="F#" Value="member this.ReleaseWriterLock : unit -&gt; unit" Usage="readerWriterLock.ReleaseWriterLock " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-259">Reduce el recuento de bloqueos del bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-259">Decrements the lock count on the writer lock.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-260"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> reduce el recuento de bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-260"><xref:System.Threading.ReaderWriterLock.ReleaseWriterLock%2A> decrements the writer lock count.</span></span> <span data-ttu-id="4c58b-261">Cuando el recuento llega a cero, se libera el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-261">When the count reaches zero, the writer lock is released.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="4c58b-262">Si un subproceso tiene un bloqueo de lector o no tiene bloqueos, una llamada a `ReleaseWriterLock` produce una <xref:System.ApplicationException>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-262">If a thread has a reader lock, or no locks, calling `ReleaseWriterLock` throws an <xref:System.ApplicationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-263">El ejemplo de código siguiente muestra cómo adquirir y liberar un bloqueo de escritor y cómo controlar la excepción que se produce cuando se agota el tiempo de espera de una solicitud.</span><span class="sxs-lookup"><span data-stu-id="4c58b-263">The following code example shows how to acquire and release a writer lock, and how to handle the exception thrown when a request times out.</span></span>  
  
 <span data-ttu-id="4c58b-264">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-264">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#4)]
[!code-csharp[System.Threading.ReaderWriterLock#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#4)]
[!code-vb[System.Threading.ReaderWriterLock#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#4)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-265">El subproceso no dispone del bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-265">The thread does not have the writer lock.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RestoreLock">
      <MemberSignature Language="C#" Value="public void RestoreLock (ref System.Threading.LockCookie lockCookie);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RestoreLock(valuetype System.Threading.LockCookie&amp; lockCookie) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.RestoreLock(System.Threading.LockCookie@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub RestoreLock (ByRef lockCookie As LockCookie)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RestoreLock(System::Threading::LockCookie % lockCookie);" />
      <MemberSignature Language="F#" Value="member this.RestoreLock :  -&gt; unit" Usage="readerWriterLock.RestoreLock lockCookie" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="lockCookie" Type="System.Threading.LockCookie&amp;" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="lockCookie">
          <span data-ttu-id="4c58b-266">Un <see cref="T:System.Threading.LockCookie" /> devuelto por <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-266">A <see cref="T:System.Threading.LockCookie" /> returned by <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-267">Restaura el estado de bloqueo del subproceso al estado que tenía antes de llamar a <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-267">Restores the lock status of the thread to what it was before calling <see cref="M:System.Threading.ReaderWriterLock.ReleaseLock" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-268">El estado restaurado por `RestoreLock` incluye el recuento de bloqueos recursivos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-268">The state restored by `RestoreLock` includes the recursive lock count.</span></span>  
  
 <span data-ttu-id="4c58b-269">Un subproceso se bloquea si intenta restaurar un bloqueo de lector después de que otro subproceso ha adquirido el bloqueo de escritor, o si intenta restaurar el bloqueo de escritor después de que otro subproceso ha adquirido un bloqueo de lector o escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-269">A thread blocks if it tries to restore a reader lock after another thread has acquired the writer lock, or if it tries to restore the writer lock after another thread has acquired a reader lock or writer lock.</span></span> <span data-ttu-id="4c58b-270">Dado que `RestoreLock` no acepta un tiempo de espera, procure evitar los interbloqueos posibles.</span><span class="sxs-lookup"><span data-stu-id="4c58b-270">Because `RestoreLock` does not accept a time-out, you should take care to avoid possible deadlocks.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="4c58b-271">Antes de llamar a `RestoreLock`, asegúrese de que ha liberado todos los bloqueos adquiridos desde la llamada a <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-271">Before calling `RestoreLock`, make sure you have released all locks acquired since the call to <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A>.</span></span> <span data-ttu-id="4c58b-272">Por ejemplo, un subproceso se interbloquea si adquiere un bloqueo de lector y, a continuación, intenta restaurar un bloqueo de escritor anterior.</span><span class="sxs-lookup"><span data-stu-id="4c58b-272">For example, a thread deadlocks if it acquires a reader lock, and then attempts to restore an earlier writer lock.</span></span> <span data-ttu-id="4c58b-273">Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> y <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> para detectar estos bloqueos adicionales.</span><span class="sxs-lookup"><span data-stu-id="4c58b-273">Use <xref:System.Threading.ReaderWriterLock.IsReaderLockHeld%2A> and <xref:System.Threading.ReaderWriterLock.IsWriterLockHeld%2A> to detect such additional locks.</span></span>  
  
 <span data-ttu-id="4c58b-274">No use un <xref:System.Threading.LockCookie> devuelto desde <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-274">Do not use a <xref:System.Threading.LockCookie> returned from <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-275">En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> método para liberar el bloqueo, independientemente de cuántas veces ha sido adquirida por el subproceso y cómo restaurar el estado del bloqueo más adelante.</span><span class="sxs-lookup"><span data-stu-id="4c58b-275">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.ReleaseLock%2A> method to release the lock, regardless of how many times it has been acquired by the thread, and how to restore the state of the lock later.</span></span>  
  
 <span data-ttu-id="4c58b-276">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-276">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NullReferenceException">
          <span data-ttu-id="4c58b-277">La dirección de <paramref name="lockCookie" /> es un puntero nulo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-277">The address of <paramref name="lockCookie" /> is a null pointer.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="UpgradeToWriterLock">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-278">Actualiza un bloqueo de lector al bloqueo de escritor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-278">Upgrades a reader lock to the writer lock.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (millisecondsTimeout As Integer) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : int -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="4c58b-279">Tiempo de espera en milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-279">The time-out in milliseconds.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-280">Actualiza un bloqueo de lector al bloqueo de escritor, utilizando un valor <see langword="Int32" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-280">Upgrades a reader lock to the writer lock, using an <see langword="Int32" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4c58b-281">Valor <see cref="T:System.Threading.LockCookie" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-281">A <see cref="T:System.Threading.LockCookie" /> value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-282">Cuando un subproceso llama `UpgradeToWriterLock` se libera el bloqueo de lector, independientemente del recuento de bloqueo, y el subproceso va hasta el final de la cola para el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-282">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="4c58b-283">Por lo tanto, otros subprocesos pueden escribir en el recurso antes de que el subproceso que solicitó que la actualización se concede el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-283">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4c58b-284">No se produce la excepción de tiempo de espera hasta que el subproceso que llama el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método puede volver a adquirir el bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-284">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="4c58b-285">Si no hay ningún otro subproceso esperando el bloqueo de escritor, esto ocurre inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-285">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="4c58b-286">Sin embargo, si otro subproceso se pone en cola para el bloqueo de escritor, el subproceso que llama el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método no puede volver a adquirir el bloqueo de lector hasta que todos los lectores actuales liberen sus bloqueos y un subproceso adquiera y libere el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-286">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="4c58b-287">Esto es cierto incluso si el otro subproceso que solicitó el bloqueo de escritor lo ha solicitado una vez llamado el subproceso actual el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.</span><span class="sxs-lookup"><span data-stu-id="4c58b-287">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="4c58b-288">Para restaurar el estado de bloqueo, llame a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> utilizando el <xref:System.Threading.LockCookie> devuelto por `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-288">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="4c58b-289">No use este `LockCookie` con <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-289">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="4c58b-290">Cuando un subproceso no tiene ningún bloqueo de lector, no utilice `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-290">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="4c58b-291">Utilice <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="4c58b-291">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="4c58b-292">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-292">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-293">En el ejemplo de código siguiente se muestra cómo solicitar un bloqueo de lector, actualizar el bloqueo de lector a un bloqueo de escritor y cambiar a un bloqueo de lector de nuevo.</span><span class="sxs-lookup"><span data-stu-id="4c58b-293">The following code example shows how to request a reader lock, upgrade the reader lock to a writer lock, and downgrade to a reader lock again.</span></span>  
  
 <span data-ttu-id="4c58b-294">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-294">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#5)]
[!code-csharp[System.Threading.ReaderWriterLock#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#5)]
[!code-vb[System.Threading.ReaderWriterLock#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#5)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-295">
            <paramref name="millisecondsTimeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-295">
              <paramref name="millisecondsTimeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="UpgradeToWriterLock">
      <MemberSignature Language="C#" Value="public System.Threading.LockCookie UpgradeToWriterLock (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.LockCookie UpgradeToWriterLock(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.ReaderWriterLock.UpgradeToWriterLock(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function UpgradeToWriterLock (timeout As TimeSpan) As LockCookie" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::LockCookie UpgradeToWriterLock(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.UpgradeToWriterLock : TimeSpan -&gt; System.Threading.LockCookie" Usage="readerWriterLock.UpgradeToWriterLock timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.LockCookie</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">
          <span data-ttu-id="4c58b-296">El <see langword="TimeSpan" /> que especifica el período de duración del tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-296">The <see langword="TimeSpan" /> specifying the time-out period.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="4c58b-297">Actualiza un bloqueo de lector al bloqueo de escritor utilizando un valor <see langword="TimeSpan" /> para el tiempo de espera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-297">Upgrades a reader lock to the writer lock, using a <see langword="TimeSpan" /> value for the time-out.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="4c58b-298">Valor <see cref="T:System.Threading.LockCookie" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-298">A <see cref="T:System.Threading.LockCookie" /> value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-299">Cuando un subproceso llama `UpgradeToWriterLock` se libera el bloqueo de lector, independientemente del recuento de bloqueo, y el subproceso va hasta el final de la cola para el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-299">When a thread calls `UpgradeToWriterLock` the reader lock is released, regardless of the lock count, and the thread goes to the end of the queue for the writer lock.</span></span> <span data-ttu-id="4c58b-300">Por lo tanto, otros subprocesos pueden escribir en el recurso antes de que el subproceso que solicitó que la actualización se concede el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-300">Thus, other threads might write to the resource before the thread that requested the upgrade is granted the writer lock.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="4c58b-301">No se produce la excepción de tiempo de espera hasta que el subproceso que llama el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método puede volver a adquirir el bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-301">The time-out exception is not thrown until the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method can reacquire the reader lock.</span></span> <span data-ttu-id="4c58b-302">Si no hay ningún otro subproceso esperando el bloqueo de escritor, esto ocurre inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="4c58b-302">If there are no other threads waiting for the writer lock, this happens immediately.</span></span> <span data-ttu-id="4c58b-303">Sin embargo, si otro subproceso se pone en cola para el bloqueo de escritor, el subproceso que llama el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método no puede volver a adquirir el bloqueo de lector hasta que todos los lectores actuales liberen sus bloqueos y un subproceso adquiera y libere el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-303">However, if another thread is queued for the writer lock, the thread that called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method cannot reacquire the reader lock until all current readers have released their locks, and one thread has acquired and released the writer lock.</span></span> <span data-ttu-id="4c58b-304">Esto es cierto incluso si el otro subproceso que solicitó el bloqueo de escritor lo ha solicitado una vez llamado el subproceso actual el <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> método.</span><span class="sxs-lookup"><span data-stu-id="4c58b-304">This is true even if the other thread that requested the writer lock requested it after the current thread called the <xref:System.Threading.ReaderWriterLock.UpgradeToWriterLock%2A> method.</span></span>  
  
 <span data-ttu-id="4c58b-305">Para restaurar el estado de bloqueo, llame a <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> utilizando el <xref:System.Threading.LockCookie> devuelto por `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-305">To restore the lock state, call <xref:System.Threading.ReaderWriterLock.DowngradeFromWriterLock%2A> using the <xref:System.Threading.LockCookie> returned by `UpgradeToWriterLock`.</span></span> <span data-ttu-id="4c58b-306">No use este `LockCookie` con <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-306">Do not use this `LockCookie` with <xref:System.Threading.ReaderWriterLock.RestoreLock%2A>.</span></span>  
  
 <span data-ttu-id="4c58b-307">Cuando un subproceso no tiene ningún bloqueo de lector, no utilice `UpgradeToWriterLock`.</span><span class="sxs-lookup"><span data-stu-id="4c58b-307">When a thread has no reader lock, do not use `UpgradeToWriterLock`.</span></span> <span data-ttu-id="4c58b-308">Utilice <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="4c58b-308">Use <xref:System.Threading.ReaderWriterLock.AcquireWriterLock%2A> instead.</span></span>  
  
 <span data-ttu-id="4c58b-309">Para los valores de tiempo de espera válido, vea <xref:System.Threading.ReaderWriterLock>.</span><span class="sxs-lookup"><span data-stu-id="4c58b-309">For valid time-out values, see <xref:System.Threading.ReaderWriterLock>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ApplicationException">
          <span data-ttu-id="4c58b-310">
            <paramref name="timeout" /> expira antes de que se conceda la solicitud de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-310">
              <paramref name="timeout" /> expires before the lock request is granted.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="4c58b-311">
            <paramref name="timeout" /> especifica un valor negativo que no es -1 milisegundos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-311">
              <paramref name="timeout" /> specifies a negative value other than -1 milliseconds.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="WriterSeqNum">
      <MemberSignature Language="C#" Value="public int WriterSeqNum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 WriterSeqNum" />
      <MemberSignature Language="DocId" Value="P:System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property WriterSeqNum As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int WriterSeqNum { int get(); };" />
      <MemberSignature Language="F#" Value="member this.WriterSeqNum : int" Usage="System.Threading.ReaderWriterLock.WriterSeqNum" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="4c58b-312">Obtiene el número de secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-312">Gets the current sequence number.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="4c58b-313">Número de secuencia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="4c58b-313">The current sequence number.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="4c58b-314">El número de secuencia aumenta cada vez que un subproceso adquiere el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-314">The sequence number increases whenever a thread acquires the writer lock.</span></span> <span data-ttu-id="4c58b-315">Puede guardar el número de secuencia y pasarlo a <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> en un momento posterior, si desea determinar si otros subprocesos han adquirido el bloqueo de escritor mientras tanto.</span><span class="sxs-lookup"><span data-stu-id="4c58b-315">You can save the sequence number and pass it to <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> at a later time, if you want to determine whether other threads have acquired the writer lock in the meantime.</span></span>  
  
 <span data-ttu-id="4c58b-316">Puede usar `WriterSeqNum` para mejorar el rendimiento de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="4c58b-316">You can use `WriterSeqNum` to improve application performance.</span></span> <span data-ttu-id="4c58b-317">Por ejemplo, un subproceso podría guardar en caché la información que obtiene mientras se mantiene un bloqueo de lector.</span><span class="sxs-lookup"><span data-stu-id="4c58b-317">For example, a thread might cache the information it obtains while holding a reader lock.</span></span> <span data-ttu-id="4c58b-318">Después de liberar y volver a adquirir el bloqueo, el subproceso puede determinar si otros subprocesos han escrito en el recurso mediante una llamada a `AnyWritersSince`; si no, se puede usar la información almacenada en caché.</span><span class="sxs-lookup"><span data-stu-id="4c58b-318">After releasing and later reacquiring the lock, the thread can determine whether other threads have written to the resource by calling `AnyWritersSince`; if not, the cached information can be used.</span></span> <span data-ttu-id="4c58b-319">Esta técnica es útil cuando la información protegida por el bloqueo es costosa; Por ejemplo, ejecutar una consulta de base de datos.</span><span class="sxs-lookup"><span data-stu-id="4c58b-319">This technique is useful when reading the information protected by the lock is expensive; for example, running a database query.</span></span>  
  
 <span data-ttu-id="4c58b-320">El llamador debe contener un bloqueo de lector o escritor en orden para el número de secuencia ser útil.</span><span class="sxs-lookup"><span data-stu-id="4c58b-320">The caller must be holding a reader lock or a writer lock in order for the sequence number to be useful.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="4c58b-321">En el ejemplo de código siguiente se muestra cómo utilizar el <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> propiedad y el <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> por última vez, el método para determinar si otro subproceso adquirió el bloqueo de escritura al recurso protegido desde el subproceso actual mantiene el bloqueo de escritor.</span><span class="sxs-lookup"><span data-stu-id="4c58b-321">The following code example shows how to use the <xref:System.Threading.ReaderWriterLock.WriterSeqNum%2A> property and the <xref:System.Threading.ReaderWriterLock.AnyWritersSince%2A> method to determine whether another thread acquired the writer lock on the protected resource since the current thread last held the writer lock.</span></span>  
  
 <span data-ttu-id="4c58b-322">Este código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Threading.ReaderWriterLock> clase.</span><span class="sxs-lookup"><span data-stu-id="4c58b-322">This code is part of a larger example provided for the <xref:System.Threading.ReaderWriterLock> class.</span></span>  
  
 [!code-cpp[System.Threading.ReaderWriterLock#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#2)]
 [!code-csharp[System.Threading.ReaderWriterLock#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#2)]
 [!code-vb[System.Threading.ReaderWriterLock#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#2)]  
[!code-cpp[System.Threading.ReaderWriterLock#6](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#6)]
[!code-csharp[System.Threading.ReaderWriterLock#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#6)]
[!code-vb[System.Threading.ReaderWriterLock#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#6)]  
[!code-cpp[System.Threading.ReaderWriterLock#7](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CPP/source.cpp#7)]
[!code-csharp[System.Threading.ReaderWriterLock#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/CS/source.cs#7)]
[!code-vb[System.Threading.ReaderWriterLock#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ReaderWriterLock/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>