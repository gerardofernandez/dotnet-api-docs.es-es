<Type Name="LazyInitializer" FullName="System.Threading.LazyInitializer">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d1c692878647ef3be78c25566da40339bbd95b07" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52251095" /></Metadata><TypeSignature Language="C#" Value="public static class LazyInitializer" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit LazyInitializer extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Threading.LazyInitializer" />
  <TypeSignature Language="VB.NET" Value="Public Class LazyInitializer" />
  <TypeSignature Language="C++ CLI" Value="public ref class LazyInitializer abstract sealed" />
  <TypeSignature Language="F#" Value="type LazyInitializer = class" />
  <AssemblyInfo>
    <AssemblyName>System.Threading</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="d22a7-101">Proporciona rutinas de inicialización diferida.</span><span class="sxs-lookup"><span data-stu-id="d22a7-101">Provides lazy initialization routines.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d22a7-102">Estas rutinas evitan la necesidad de asignar una instancia dedicada, inicialización diferida, en lugar de utilizar referencias para asegurarse de que se han inicializado los destinos tal como se obtiene acceso a.</span><span class="sxs-lookup"><span data-stu-id="d22a7-102">These routines avoid needing to allocate a dedicated, lazy-initialization instance, instead using references to ensure targets have been initialized as they are accessed.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d22a7-103">El ejemplo siguiente muestra cómo utilizar EnsureInitialized para inicializar un valor con un valor booleano para realizar un seguimiento de si ya ha ocurrido la inicialización de forma diferida y un objeto que se usará como el bloqueo de exclusión mutua.</span><span class="sxs-lookup"><span data-stu-id="d22a7-103">The following example demonstrates how to use EnsureInitialized to lazily initialize a value using a Boolean value to track whether initialization has already happened and an object to use as the mutual exclusion lock.</span></span>  
  
```vb  
Dim _data As ExpensiveData = Nothing  
Dim _dataInitialized As Boolean = False  
Dim _dataLock As Object = Nothing  
'    ...  
Dim name = LazyInitializer.EnsureInitialized(_data, _dataInitialized, _dataLock)  
```  
  
```csharp  
ExpensiveData _data = null;  
                     bool _dataInitialized = false;  
                     object _dataLock = new object();  
                  //  ...  
  
                    ExpensiveData dataToUse = LazyInitializer.EnsureInitialized(ref _data, ref _dataInitialized, ref _dataLock);  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d22a7-104">Los métodos de <see cref="T:System.Threading.LazyInitializer" /> son seguros para subprocesos y pueden llamarse desde varios subprocesos simultáneamente.</span><span class="sxs-lookup"><span data-stu-id="d22a7-104">The methods of <see cref="T:System.Threading.LazyInitializer" /> are thread-safe and may be called from multiple threads concurrently.</span></span></threadsafe>
    <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="d22a7-105">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="d22a7-105">Lazy Initialization</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName="EnsureInitialized&lt;T&gt;">
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d22a7-106">Inicializa un tipo de destino si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-106">Initializes a target type if it hasn't already been initialized.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d22a7-107">Tipo de referencia que se va a inicializar.</span><span class="sxs-lookup"><span data-stu-id="d22a7-107">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="d22a7-108">Referencia de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-108">A reference of type <c>T</c> to initialize if it has not already been initialized.</span></span></param>
        <summary><span data-ttu-id="d22a7-109">Inicializa un tipo de referencia de destino con su constructor predeterminado si aún no se ha inicializado el destino.</span><span class="sxs-lookup"><span data-stu-id="d22a7-109">Initializes a target reference type with the type's default constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="d22a7-110">Referencia de tipo <paramref name="T" /> que se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-110">The initialized reference of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d22a7-111">Este método solo puede usarse con tipos de referencia.</span><span class="sxs-lookup"><span data-stu-id="d22a7-111">This method may only be used on reference types.</span></span> <span data-ttu-id="d22a7-112">Para asegurar la inicialización de tipos de valor, vea otras sobrecargas de EnsureInitialized.</span><span class="sxs-lookup"><span data-stu-id="d22a7-112">To ensure initialization of value types, see other overloads of EnsureInitialized.</span></span>  
  
 <span data-ttu-id="d22a7-113">Este método puede utilizarse simultáneamente varios subprocesos para inicializar `target`.</span><span class="sxs-lookup"><span data-stu-id="d22a7-113">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="d22a7-114">En caso de que varios subprocesos obtienen acceso a este método al mismo tiempo, varias instancias de `T` mayo crearse, pero solo se almacenará en `target`.</span><span class="sxs-lookup"><span data-stu-id="d22a7-114">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target`.</span></span> <span data-ttu-id="d22a7-115">En una instancia de este tipo, este método no eliminará los objetos que no se almacenaron.</span><span class="sxs-lookup"><span data-stu-id="d22a7-115">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="d22a7-116">Si se deben eliminar estos objetos, es responsabilidad del autor de llamada para determinar si no se ha utilizado un objeto y, a continuación, eliminar el objeto de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="d22a7-116">If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="d22a7-117">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-117">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="d22a7-118">El tipo <paramref name="T" /> no contiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-118">Type <paramref name="T" /> does not have a default constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="d22a7-119">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="d22a7-119">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d22a7-120">Tipo de referencia que se va a inicializar.</span><span class="sxs-lookup"><span data-stu-id="d22a7-120">The reference type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="d22a7-121">Referencia de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-121">The reference of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="d22a7-122">Función que se llama para inicializar la referencia.</span><span class="sxs-lookup"><span data-stu-id="d22a7-122">The function that is called to initialize the reference.</span></span></param>
        <summary><span data-ttu-id="d22a7-123">Inicializa un tipo de referencia de destino utilizando la función especificada si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-123">Initializes a target reference type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="d22a7-124">Valor inicializado de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-124">The initialized value of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d22a7-125">Este método solo puede usarse con tipos de referencia, y `valueFactory` no puede devolver una referencia nula (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d22a7-125">This method may only be used on reference types, and `valueFactory` may not return a null reference (Nothing in Visual Basic).</span></span> <span data-ttu-id="d22a7-126">Para asegurar la inicialización de tipos de valor o para permitir a los tipos de referencia nula, vea otras sobrecargas de EnsureInitialized.</span><span class="sxs-lookup"><span data-stu-id="d22a7-126">To ensure initialization of value types or to allow null reference types, see other overloads of EnsureInitialized.</span></span>  
  
 <span data-ttu-id="d22a7-127">Este método puede utilizarse simultáneamente varios subprocesos para inicializar `target`.</span><span class="sxs-lookup"><span data-stu-id="d22a7-127">This method may be used concurrently by multiple threads to initialize `target`.</span></span>  
  
 <span data-ttu-id="d22a7-128">En caso de que varios subprocesos obtienen acceso a este método al mismo tiempo, varias instancias de `T` mayo crearse, pero solo se almacenará en `target`.</span><span class="sxs-lookup"><span data-stu-id="d22a7-128">In the event that multiple threads access this method concurrently, multiple instances of `T` may be created, but only one will be stored into `target`.</span></span> <span data-ttu-id="d22a7-129">En una instancia de este tipo, este método no eliminará los objetos que no se almacenaron.</span><span class="sxs-lookup"><span data-stu-id="d22a7-129">In such an occurrence, this method will not dispose of the objects that were not stored.</span></span> <span data-ttu-id="d22a7-130">Si se deben eliminar estos objetos, es responsabilidad del autor de llamada para determinar si no se ha utilizado un objeto y, a continuación, eliminar el objeto de forma adecuada.</span><span class="sxs-lookup"><span data-stu-id="d22a7-130">If such objects must be disposed, it is up to the caller to determine if an object was not used and to then dispose of the object appropriately.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="d22a7-131">El tipo <paramref name="T" /> no contiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-131">Type <paramref name="T" /> does not have a default constructor.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d22a7-132"><paramref name="valueFactory" /> devuelve un valor NULL (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="d22a7-132"><paramref name="valueFactory" /> returned null (Nothing in Visual Basic).</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="d22a7-133">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="d22a7-133">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  *  -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d22a7-134">Tipo de referencia que se va a inicializar.</span><span class="sxs-lookup"><span data-stu-id="d22a7-134">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="d22a7-135">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-135">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="d22a7-136">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</span><span class="sxs-lookup"><span data-stu-id="d22a7-136">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="d22a7-137">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-137">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="d22a7-138">Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="d22a7-138">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <summary><span data-ttu-id="d22a7-139">Inicializa un tipo de referencia de destino o tipo de valor con su constructor predeterminado si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-139">Initializes a target reference or value type with its default constructor if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="d22a7-140">Valor inicializado de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-140">The initialized value of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d22a7-141">Si `intialized` se especifica como true, se producirá ninguna inicialización adicional.</span><span class="sxs-lookup"><span data-stu-id="d22a7-141">If `intialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="d22a7-142">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-142">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="d22a7-143">El tipo <paramref name="T" /> no contiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-143">Type <paramref name="T" /> does not have a default constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="d22a7-144">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="d22a7-144">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref object syncLock, Func&lt;T&gt; valueFactory) where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;class T&gt;(!!T&amp; target, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T As Class) (ByRef target As T, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class static T EnsureInitialized(T % target, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  * Func&lt;'T (requires 'T : null)&gt; -&gt; 'T (requires 'T : null)" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T">To be added.</typeparam>
        <param name="target">To be added.</param>
        <param name="syncLock">To be added.</param>
        <param name="valueFactory">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureInitialized&lt;T&gt;">
      <MemberSignature Language="C#" Value="public static T EnsureInitialized&lt;T&gt; (ref T target, ref bool initialized, ref object syncLock, Func&lt;T&gt; valueFactory);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig !!T EnsureInitialized&lt;T&gt;(!!T&amp; target, bool&amp; initialized, object&amp; syncLock, class System.Func`1&lt;!!T&gt; valueFactory) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.LazyInitializer.EnsureInitialized``1(``0@,System.Boolean@,System.Object@,System.Func{``0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnsureInitialized(Of T) (ByRef target As T, ByRef initialized As Boolean, ByRef syncLock As Object, valueFactory As Func(Of T)) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; static T EnsureInitialized(T % target, bool % initialized, System::Object ^ % syncLock, Func&lt;T&gt; ^ valueFactory);" />
      <MemberSignature Language="F#" Value="static member EnsureInitialized :  *  *  * Func&lt;'T&gt; -&gt; 'T" Usage="System.Threading.LazyInitializer.EnsureInitialized (target, initialized, syncLock, valueFactory)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T" />
      </TypeParameters>
      <Parameters>
        <Parameter Name="target" Type="T" RefType="ref" />
        <Parameter Name="initialized" Type="System.Boolean" RefType="ref" />
        <Parameter Name="syncLock" Type="System.Object" RefType="ref" />
        <Parameter Name="valueFactory" Type="System.Func&lt;T&gt;" />
      </Parameters>
      <Docs>
        <typeparam name="T"><span data-ttu-id="d22a7-145">Tipo de referencia que se va a inicializar.</span><span class="sxs-lookup"><span data-stu-id="d22a7-145">The type of the reference to be initialized.</span></span></typeparam>
        <param name="target"><span data-ttu-id="d22a7-146">Referencia o valor de tipo <c>T</c> que se va a inicializar si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-146">A reference or value of type <c>T</c> to initialize if it hasn't already been initialized.</span></span></param>
        <param name="initialized"><span data-ttu-id="d22a7-147">Referencia a un valor booleano que determina si ya se ha inicializado el destino.</span><span class="sxs-lookup"><span data-stu-id="d22a7-147">A reference to a Boolean value that determines whether the target has already been initialized.</span></span></param>
        <param name="syncLock"><span data-ttu-id="d22a7-148">Referencia a un objeto que se usa como bloqueo mutuamente excluyente para la inicialización de <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-148">A reference to an object used as the mutually exclusive lock for initializing <paramref name="target" />.</span></span> <span data-ttu-id="d22a7-149">Si <paramref name="syncLock" /> es <see langword="null" />, se creará una instancia de un nuevo objeto.</span><span class="sxs-lookup"><span data-stu-id="d22a7-149">If <paramref name="syncLock" /> is <see langword="null" />, a new object will be instantiated.</span></span></param>
        <param name="valueFactory"><span data-ttu-id="d22a7-150">Función que se llama para inicializar la referencia o el valor.</span><span class="sxs-lookup"><span data-stu-id="d22a7-150">The function that is called to initialize the reference or value.</span></span></param>
        <summary><span data-ttu-id="d22a7-151">Inicializa un tipo de referencia de destino o tipo de valor utilizando la función especificada si aún no se ha inicializado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-151">Initializes a target reference or value type by using a specified function if it hasn't already been initialized.</span></span></summary>
        <returns><span data-ttu-id="d22a7-152">Valor inicializado de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-152">The initialized value of type <paramref name="T" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d22a7-153">Si `intialized` se especifica como true, se producirá ninguna inicialización adicional.</span><span class="sxs-lookup"><span data-stu-id="d22a7-153">If `intialized` is specified as true, then no further initialization occurs.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="d22a7-154">Faltaban los permisos para tener acceso al constructor de tipo <paramref name="T" />.</span><span class="sxs-lookup"><span data-stu-id="d22a7-154">Permissions to access the constructor of type <paramref name="T" /> were missing.</span></span></exception>
        <exception cref="T:System.MissingMemberException"><span data-ttu-id="d22a7-155">El tipo <paramref name="T" /> no contiene un constructor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="d22a7-155">Type <paramref name="T" /> does not have a default constructor.</span></span></exception>
        <related type="Article" href="~/docs/framework/performance/lazy-initialization.md"><span data-ttu-id="d22a7-156">Inicialización diferida</span><span class="sxs-lookup"><span data-stu-id="d22a7-156">Lazy Initialization</span></span></related>
      </Docs>
    </Member>
  </Members>
</Type>