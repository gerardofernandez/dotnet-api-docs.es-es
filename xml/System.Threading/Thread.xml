<Type Name="Thread" FullName="System.Threading.Thread">
  <Metadata><Meta Name="ms.openlocfilehash" Value="fd2bf7c62b10f302d95d138e19563c498a74ec5a" /><Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/20/2018" /><Meta Name="ms.locfileid" Value="52219349" /></Metadata><TypeSignature Language="C#" Value="public sealed class Thread : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Thread extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.Runtime.InteropServices._Thread" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Thread" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class Thread&#xA;Inherits CriticalFinalizerObject&#xA;Implements _Thread" />
  <TypeSignature Language="C++ CLI" Value="public ref class Thread sealed : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, System::Runtime::InteropServices::_Thread" />
  <TypeSignature Language="F#" Value="type Thread = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface _Thread" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Thread</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Thread</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Thread))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3e1bf-101">Crea y controla un subproceso, establece su prioridad y obtiene su estado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-101">Creates and controls a thread, sets its priority, and gets its status.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-102">Cuando se inicia un proceso, common language runtime crea automáticamente un subproceso único de primer plano para ejecutar código de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-102">When a process starts, the common language runtime automatically creates a single foreground thread to execute application code.</span></span> <span data-ttu-id="3e1bf-103">Junto con este subproceso principal en primer plano, un proceso puede crear uno o varios subprocesos para ejecutar una parte del código de programa asociado al proceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-103">Along with this main foreground thread, a process can create one or more threads to execute a portion of the program code associated with the process.</span></span> <span data-ttu-id="3e1bf-104">Estos subprocesos pueden ejecutar en primer plano o en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-104">These threads can execute either in the foreground or in the background.</span></span> <span data-ttu-id="3e1bf-105">Además, puede usar el <xref:System.Threading.ThreadPool> clase para ejecutar código en subprocesos de trabajo que están administrados por common language runtime.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-105">In addition, you can use the <xref:System.Threading.ThreadPool> class to execute code on worker threads that are managed by the common language runtime.</span></span>  
  
 <span data-ttu-id="3e1bf-106">En esta sección</span><span class="sxs-lookup"><span data-stu-id="3e1bf-106">In this section</span></span>  
  
 <span data-ttu-id="3e1bf-107">[Iniciar un subproceso](#Starting) </span><span class="sxs-lookup"><span data-stu-id="3e1bf-107">[Starting a thread](#Starting) </span></span>  
 <span data-ttu-id="3e1bf-108">[Recuperar objetos de subprocesos](#Retrieving) </span><span class="sxs-lookup"><span data-stu-id="3e1bf-108">[Retrieving Thread objects](#Retrieving) </span></span>  
 <span data-ttu-id="3e1bf-109">[Subprocesos de primer y segundo plano](#Foreground) </span><span class="sxs-lookup"><span data-stu-id="3e1bf-109">[Foreground and background threads](#Foreground) </span></span>  
 <span data-ttu-id="3e1bf-110">[Referencia cultural y los subprocesos](#Culture) </span><span class="sxs-lookup"><span data-stu-id="3e1bf-110">[Culture and threads](#Culture) </span></span>  
 [<span data-ttu-id="3e1bf-111">Obtener información sobre y el control de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-111">Getting information about and controlling threads</span></span>](#Properties)   
   
<a name="Starting"></a>   
## <a name="starting-a-thread"></a><span data-ttu-id="3e1bf-112">Iniciar un subproceso</span><span class="sxs-lookup"><span data-stu-id="3e1bf-112">Starting a thread</span></span>  
 <span data-ttu-id="3e1bf-113">Iniciar un subproceso proporcionando un delegado que representa el método que es el subproceso ejecutar en su constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-113">You start a thread by supplying a delegate that represents the method the thread is to execute in its class constructor.</span></span> <span data-ttu-id="3e1bf-114">A continuación, llame a la <xref:System.Threading.Thread.Start%2A> método para comenzar la ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-114">You then call the <xref:System.Threading.Thread.Start%2A> method to begin execution.</span></span>  
  
 <span data-ttu-id="3e1bf-115">El <xref:System.Threading.Thread> los constructores pueden aceptar cualquiera de los tipos de delegado de dos, dependiendo de si se puede pasar un argumento al método para ejecutarse:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-115">The <xref:System.Threading.Thread> constructors can take either of two delegate types, depending on whether you can pass an argument to the method to be executed:</span></span>  
  
-   <span data-ttu-id="3e1bf-116">Si el método no tiene ningún argumento, se pasa un <xref:System.Threading.ThreadStart> delegar en el constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-116">If the method has no arguments, you pass a <xref:System.Threading.ThreadStart> delegate to  the constructor.</span></span> <span data-ttu-id="3e1bf-117">Tiene la firma:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-117">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ThreadStart()  
    ```  
  
    ```vb  
    Public Delegate Sub ThreadStart()  
    ```  
  
     <span data-ttu-id="3e1bf-118">El ejemplo siguiente se crea e inicia un subproceso que ejecuta el `ExecuteInForeground` método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-118">The following example creates and starts a thread that executes the `ExecuteInForeground` method.</span></span> <span data-ttu-id="3e1bf-119">El método muestra información acerca de algunas propiedades de subproceso y, a continuación, ejecuta un bucle en el que se pone en pausa durante medio segundo y se muestra el número de segundos transcurrido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-119">The method displays  information about some thread properties, then executes a loop in which it pauses for half a second and displays the elapsed number of seconds.</span></span> <span data-ttu-id="3e1bf-120">Cuando el subproceso se ha ejecutado durante al menos cinco segundos, finaliza el bucle y el subproceso termina la ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-120">When the thread has executed for at least five seconds, the loop ends and the thread terminates execution.</span></span>  
  
     [!code-csharp[System.Threading.Thread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart1.cs#1)]
     [!code-vb[System.Threading.Thread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart1.vb#1)]  
  
-   <span data-ttu-id="3e1bf-121">Si el método tiene un argumento, se pasa un <xref:System.Threading.ParameterizedThreadStart> delegar en el constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-121">If the method has an argument, you pass a <xref:System.Threading.ParameterizedThreadStart> delegate to the constructor.</span></span> <span data-ttu-id="3e1bf-122">Tiene la firma:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-122">It has the signature:</span></span>  
  
    ```csharp  
    public delegate void ParameterizedThreadStart(object obj)  
    ```  
  
    ```vb  
    Public Delegate Sub ParameterizedThreadStart(obj As Object)  
    ```  
  
     <span data-ttu-id="3e1bf-123">El método ejecutado por el delegado puede, a continuación, convierta (en C#) o (en Visual Basic) el parámetro al tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-123">The method executed by the delegate can then cast (in C#) or convert (in Visual Basic) the parameter to the appropriate type.</span></span>  
  
     <span data-ttu-id="3e1bf-124">El ejemplo siguiente es idéntico al anterior, salvo que llama a la <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-124">The following example is identical to the previous one, except that it calls the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor.</span></span> <span data-ttu-id="3e1bf-125">Esta versión de la `ExecuteInForeground` método tiene un parámetro único que representa el número aproximado de milisegundos que es ejecutar el bucle.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-125">This version of the `ExecuteInForeground` method has a single parameter that represents the approximate number of milliseconds the loop is to execute.</span></span>  
  
     [!code-csharp[System.Threading.Thread#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/ThreadStart2.cs#2)]
     [!code-vb[System.Threading.Thread#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/ThreadStart2.vb#2)]  
  
 <span data-ttu-id="3e1bf-126">No es necesario conservar una referencia a un <xref:System.Threading.Thread> objeto una vez que ha iniciado el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-126">It is not necessary to retain a reference to a <xref:System.Threading.Thread> object once you have started the thread.</span></span> <span data-ttu-id="3e1bf-127">El subproceso continúa ejecutándose hasta que se complete el procedimiento de subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-127">The thread continues to execute until the thread procedure is complete.</span></span>  
  
<a name="Retrieving"></a>   
## <a name="retrieving-thread-objects"></a><span data-ttu-id="3e1bf-128">Recuperar objetos de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-128">Retrieving Thread objects</span></span>  
 <span data-ttu-id="3e1bf-129">Puede usar estático (`Shared` en Visual Basic) <xref:System.Threading.Thread.CurrentThread%2A> propiedad para recuperar una referencia al subproceso actualmente en ejecución desde el código que se está ejecutando el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-129">You can use the static (`Shared` in Visual Basic)  <xref:System.Threading.Thread.CurrentThread%2A> property to retrieve a reference to the currently executing thread from the code that the thread is executing.</span></span> <span data-ttu-id="3e1bf-130">En el ejemplo siguiente se usa el <xref:System.Threading.Thread.CurrentThread%2A> propiedad para mostrar información sobre el subproceso principal de la aplicación, otro subproceso en primer plano, un subproceso en segundo plano y un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-130">The following example uses the <xref:System.Threading.Thread.CurrentThread%2A> property to display information about the main application thread, another foreground thread, a background thread, and a thread pool thread.</span></span>  
  
 [!code-csharp[System.Threading.Thread#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/Instance1.cs#4)]
 [!code-vb[System.Threading.Thread#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/Instance1.vb#4)]  
  
<a name="Foreground"></a>   
## <a name="foreground-and-background-threads"></a><span data-ttu-id="3e1bf-131">Subprocesos de primer y segundo plano</span><span class="sxs-lookup"><span data-stu-id="3e1bf-131">Foreground and background threads</span></span>  
 <span data-ttu-id="3e1bf-132">Las instancias de la <xref:System.Threading.Thread> clase representan los subprocesos de primer plano o subprocesos en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-132">Instances of the <xref:System.Threading.Thread> class represent either foreground threads or background threads.</span></span> <span data-ttu-id="3e1bf-133">Subprocesos en segundo plano son idénticos a los subprocesos de primer plano con una excepción: un subproceso en segundo plano no mantiene un proceso que se ejecuta si se han finalizado todos los subprocesos de primer plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-133">Background threads are identical to foreground threads with one exception: a background thread does not keep a process running if all foreground threads have terminated.</span></span> <span data-ttu-id="3e1bf-134">Una vez que se han detenido todos los subprocesos de primer plano, el tiempo de ejecución detiene todos los subprocesos en segundo plano y se cierra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-134">Once all foreground threads have been stopped, the runtime stops all background threads and shuts down.</span></span>  
  
 <span data-ttu-id="3e1bf-135">De forma predeterminada, los subprocesos siguientes se ejecutan en primer plano:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-135">By default, the following threads execute in the foreground:</span></span>  
  
-   <span data-ttu-id="3e1bf-136">El subproceso principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-136">The main application thread.</span></span>  
  
-   <span data-ttu-id="3e1bf-137">Todos los subprocesos creados mediante una llamada a un <xref:System.Threading.Thread> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-137">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="3e1bf-138">Ejecuten los siguientes subprocesos en segundo plano de forma predeterminada:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-138">The following threads execute in the background by default:</span></span>  
  
-   <span data-ttu-id="3e1bf-139">El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenidas el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-139">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span>  <span data-ttu-id="3e1bf-140">Puede configurar el trabajo del subproceso de grupo y la programación de subprocesos de grupo mediante la <xref:System.Threading.ThreadPool> clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-140">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="3e1bf-141">Operaciones asincrónicas basadas en la tarea se ejecutan automáticamente en subprocesos de grupo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-141">Task-based asynchronous operations automatically execute on thread pool threads.</span></span> <span data-ttu-id="3e1bf-142">Usan operaciones asincrónicas basadas en tareas el <xref:System.Threading.Tasks.Task> y <xref:System.Threading.Tasks.Task%601> clases para implementar el [modelo asincrónico basado en tareas](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-142">Task-based asynchronous operations use the <xref:System.Threading.Tasks.Task> and <xref:System.Threading.Tasks.Task%601> classes to implement the [task-based asynchronous pattern](~/docs/standard/asynchronous-programming-patterns/task-based-asynchronous-pattern-tap.md).</span></span>  
  
-   <span data-ttu-id="3e1bf-143">Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-143">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
 <span data-ttu-id="3e1bf-144">Puede cambiar un subproceso que ejecute en segundo plano estableciendo el <xref:System.Threading.Thread.IsBackground%2A> propiedad en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-144">You can change a thread to execute in the background by setting the <xref:System.Threading.Thread.IsBackground%2A> property at any time.</span></span>  <span data-ttu-id="3e1bf-145">Subprocesos en segundo plano son útiles para cualquier operación que debe continuar mientras se está ejecutando una aplicación, pero no debe impedir que la aplicación finalice, como la supervisión de los cambios del sistema de archivos o las conexiones de socket entrante.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-145">Background threads are useful for any operation that should continue as long as an application is running but should not prevent the application from terminating, such as monitoring file system changes or incoming socket connections.</span></span>  
  
 <span data-ttu-id="3e1bf-146">El ejemplo siguiente muestra la diferencia entre los subprocesos de primer y segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-146">The following example illustrates the difference between foreground and background threads.</span></span> <span data-ttu-id="3e1bf-147">Es como el primer ejemplo de la [a partir de un subproceso](#Starting) sección, salvo que establecen el subproceso para ejecutar en segundo plano antes de iniciarlo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-147">It is like the first example in the [Starting a thread](#Starting) section, except that it sets the thread to execute in the background before starting it.</span></span> <span data-ttu-id="3e1bf-148">Como se muestra en la salida, el bucle se interrumpe antes de ejecutar durante cinco segundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-148">As the output shows, the loop is interrupted before it executes for five seconds.</span></span>  
  
 [!code-csharp[System.Threading.Thread#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread/cs/BackgroundEx1.cs#3)]
 [!code-vb[System.Threading.Thread#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread/vb/BackgroundEx1.vb#3)]  
  
<a name="Culture"></a>   
## <a name="culture-and-threads"></a><span data-ttu-id="3e1bf-149">Referencia cultural y los subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-149">Culture and threads</span></span>  
 <span data-ttu-id="3e1bf-150">Cada subproceso tiene una referencia cultural, representada por el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad y una referencia cultural de interfaz de usuario, representan por el <xref:System.Threading.Thread.CurrentUICulture%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-150">Each thread has a culture, represented by the <xref:System.Threading.Thread.CurrentCulture%2A> property, and a UI culture, represented by the <xref:System.Threading.Thread.CurrentUICulture%2A> property.</span></span>  <span data-ttu-id="3e1bf-151">La referencia cultural actual admite operaciones cultural como de análisis y formato, comparación de cadenas y ordenación y también controla el sistema de escritura y el calendario usado por un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-151">The current culture supports such culture-sensitive  operations as parsing and formatting, string comparison and sorting, and also controls the writing system and calendar used by a thread.</span></span> <span data-ttu-id="3e1bf-152">Proporciona la referencia cultural de interfaz de usuario actual para la recuperación de la referencia cultural de recursos en archivos de recursos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-152">The current UI culture provides for culture-sensitive retrieval of resources in resource files.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="3e1bf-153">El <xref:System.Threading.Thread.CurrentCulture> y <xref:System.Threading.Thread.CurrentUICulture> propiedades no funcionan bien cuando se usa con cualquier subproceso distinto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-153">The <xref:System.Threading.Thread.CurrentCulture> and <xref:System.Threading.Thread.CurrentUICulture> properties don't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="3e1bf-154">En .NET Framework, leer estas propiedades es confiable, aunque no es establecer estas propiedades para un subproceso distinto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-154">In .NET Framework, reading these properties is reliable, although setting these properties for a thread other than the current thread is not.</span></span> <span data-ttu-id="3e1bf-155">En .NET Core, un <xref:System.InvalidOperationException> se produce si un subproceso intenta leer o escribir estas propiedades en un subproceso diferente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-155">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write these properties on a different thread.</span></span>
> <span data-ttu-id="3e1bf-156">Se recomienda que use el <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> y <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propiedades para recuperar y establecer la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-156">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> properties to retrieve and set the current culture.</span></span>

 <span data-ttu-id="3e1bf-157">Cuando se crea una instancia de un nuevo subproceso, su referencia cultural y la referencia cultural de interfaz de usuario se definen por la referencia cultural actual del sistema y la referencia cultural de interfaz de usuario y no por la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde el que se crea el nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-157">When a new thread is instantiated, its culture and UI culture are defined by the current system culture and UI culture, and not by the culture and UI culture of the thread from which the new thread is created.</span></span> <span data-ttu-id="3e1bf-158">Esto significa, por ejemplo, que si la referencia cultural del sistema actual es inglés (Estados Unidos) y la referencia cultural del subproceso principal de la aplicación es francés (Francia), la referencia cultural de un nuevo subproceso creado mediante una llamada a la <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor desde el subproceso principal es el inglés (Estados Unidos) y no francés (Francia).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-158">This means, for example, that if the current system culture is English (United States) and the current culture of the primary application thread is French (France), the culture of a new thread created by calling the   <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor from the primary thread is English (United States), and not French (France).</span></span> <span data-ttu-id="3e1bf-159">Para obtener más información, consulte la sección "Referencia cultural y los subprocesos" de la <xref:System.Globalization.CultureInfo> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-159">For more information, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-160">No es el caso de los subprocesos que se ejecutan las operaciones asincrónicas para las aplicaciones que tienen como destino el [!INCLUDE[net_v46](~/includes/net-v46-md.md)] y versiones posteriores, en este caso, la referencia cultural y la referencia cultural de interfaz de usuario es parte de una forma asincrónica el contexto de las operaciones; el subproceso en el que una operación asincrónica ejecuta de forma predeterminada hereda la referencia cultural y la referencia cultural de interfaz de usuario del subproceso desde el que se inició la operación asincrónica.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-160">This is not true of threads that execute asynchronous operations for apps that target the [!INCLUDE[net_v46](~/includes/net-v46-md.md)] and later versions, In this case, the culture and UI culture is part of an asynchronous operations' context; the thread on which an asynchronous operation executes by default inherits the culture and UI culture of the thread from which the asynchronous operation was launched.</span></span> <span data-ttu-id="3e1bf-161">Para obtener más información, vea la sección "Referencia cultural y operaciones asincrónicas basadas en tareas" del tema sobre la clase <xref:System.Globalization.CultureInfo>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-161">For more information, see the "Culture and task-based asynchronous operations" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>  
  
 <span data-ttu-id="3e1bf-162">Puede realizar una de las siguientes acciones para asegurarse de que todos los subprocesos de ejecución en una aplicación comparten la misma referencia cultural y la referencia cultural de interfaz de usuario:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-162">You can do either of the following to ensure that all of the threads executing in an application share the same culture and UI culture:</span></span>  
  
-   <span data-ttu-id="3e1bf-163">Puede pasar un <xref:System.Globalization.CultureInfo> objeto que representa esa referencia cultural a la <xref:System.Threading.ParameterizedThreadStart> delegar o <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-163">You can pass a <xref:System.Globalization.CultureInfo> object that represents that culture to the <xref:System.Threading.ParameterizedThreadStart> delegate or the <xref:System.Threading.ThreadPool.QueueUserWorkItem%28System.Threading.WaitCallback%2CSystem.Object%29?displayProperty=nameWithType> method.</span></span>  
  
-   <span data-ttu-id="3e1bf-164">Para las aplicaciones que se ejecutan en el [!INCLUDE[net_v45](~/includes/net-v45-md.md)] y versiones posteriores, puede definir la referencia cultural y la referencia cultural de interfaz de usuario que se asigna a todos los subprocesos creados en un dominio de aplicación estableciendo el valor de la <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> y <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-164">For apps running on the [!INCLUDE[net_v45](~/includes/net-v45-md.md)] and later versions, you can define the culture and UI culture that is to be assigned to all threads created in an application domain by setting the value of the <xref:System.Globalization.CultureInfo.DefaultThreadCurrentCulture%2A?displayProperty=nameWithType> and <xref:System.Globalization.CultureInfo.DefaultThreadCurrentUICulture%2A?displayProperty=nameWithType> properties.</span></span> <span data-ttu-id="3e1bf-165">Tenga en cuenta que se trata de una configuración por dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-165">Note that this is a per-application domain setting.</span></span>  

 <span data-ttu-id="3e1bf-166">Para obtener más información y ejemplos, vea la sección "Referencia cultural y los subprocesos" de la <xref:System.Globalization.CultureInfo> tema de la clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-166">For more information and examples, see the "Culture and threads" section of the <xref:System.Globalization.CultureInfo> class topic.</span></span>

<a name="Properties"></a>   
## <a name="getting-information-about-and-controlling-threads"></a><span data-ttu-id="3e1bf-167">Obtener información sobre y el control de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-167">Getting information about and controlling threads</span></span>  
 <span data-ttu-id="3e1bf-168">Puede recuperar un número de valores de propiedad que proporcionan información sobre un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-168">You can retrieve a number of property values that provide information about a thread.</span></span> <span data-ttu-id="3e1bf-169">En algunos casos, también puede establecer estos valores de propiedad para controlar el funcionamiento del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-169">In some cases, you can also set these property values to control the operation of the thread.</span></span> <span data-ttu-id="3e1bf-170">Estas propiedades de subproceso incluyen:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-170">These thread properties include:</span></span>  
  
-   <span data-ttu-id="3e1bf-171">Un nombre.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-171">A name.</span></span> <span data-ttu-id="3e1bf-172"><xref:System.Threading.Thread.Name%2A> es una operación de escritura-propiedad una vez que puede usar para identificar un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-172"><xref:System.Threading.Thread.Name%2A> is a write-once property that you can use to identify a thread.</span></span>  <span data-ttu-id="3e1bf-173">Su valor predeterminado es `null`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-173">Its default value is `null`.</span></span>  
  
-   <span data-ttu-id="3e1bf-174">Un código hash, que puede recuperar mediante una llamada a la <xref:System.Threading.Thread.GetHashCode%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-174">A hash code, which you can retrieve by calling the <xref:System.Threading.Thread.GetHashCode%2A> method.</span></span> <span data-ttu-id="3e1bf-175">El código hash puede utilizarse para identificar de forma única un subproceso; durante la vigencia de su subproceso, su código hash no entra en conflicto con el valor de ningún otro subproceso, independientemente del dominio de aplicación desde el que se obtener el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-175">The hash code can be used to uniquely identify a thread; for the lifetime of your thread, its hash code will not collide with the value from any other thread, regardless of the application domain from which you obtain the value.</span></span>  
  
-   <span data-ttu-id="3e1bf-176">Un identificador de subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-176">A thread ID.</span></span> <span data-ttu-id="3e1bf-177">El valor de solo lectura <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad asignado por el tiempo de ejecución y se identifica un subproceso dentro de su proceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-177">The value of the read-only <xref:System.Threading.Thread.ManagedThreadId%2A> property is assigned by the runtime and uniquely identifies a thread within its process.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="3e1bf-178">Un [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) de sistema operativo no tiene una relación fija con un subproceso administrado, ya que un host no administrado puede controlar la relación entre subprocesos administrados y no administrados.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-178">An operating-system [ThreadId](https://msdn.microsoft.com/library/windows/desktop/ms683233.aspx) has no fixed relationship to a managed thread, because an unmanaged host can control the relationship between managed and unmanaged threads.</span></span> <span data-ttu-id="3e1bf-179">En concreto, un host sofisticado puede usar el [API de hospedaje de CLR](https://msdn.microsoft.com/library/ms404385.aspx) para programar muchos subprocesos administrados en el mismo subproceso de sistema operativo, o para mover un subproceso administrado entre los subprocesos del sistema operativo diferente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-179">Specifically, a sophisticated host can use the [CLR Hosting API](https://msdn.microsoft.com/library/ms404385.aspx) to schedule many managed threads against the same operating system thread, or to move a managed thread between different operating system threads.</span></span>  
  
-   <span data-ttu-id="3e1bf-180">El estado del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-180">The thread's current state.</span></span> <span data-ttu-id="3e1bf-181">Durante la duración de su existencia, un subproceso está siempre en uno o varios de los estados definidos por el <xref:System.Threading.ThreadState> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-181">For the duration of its existence, a thread is always in one or more of the states defined by the <xref:System.Threading.ThreadState> property.</span></span>  
  
-   <span data-ttu-id="3e1bf-182">Un nivel de prioridad de programación, que se define mediante el <xref:System.Threading.ThreadPriority> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-182">A scheduling priority level, which is defined by the <xref:System.Threading.ThreadPriority> property.</span></span> <span data-ttu-id="3e1bf-183">Aunque puede establecer este valor para solicitar la prioridad de un subproceso, no se garantiza que se respeta el sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-183">Although you can set this value to request a thread's priority, it is not guaranteed to be honored by the operating system.</span></span>  
  
-   <span data-ttu-id="3e1bf-184">Solo lectura <xref:System.Threading.Thread.IsThreadPoolThread%2A> propiedad, que indica si un subproceso es un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-184">The read-only <xref:System.Threading.Thread.IsThreadPoolThread%2A> property, which indicates whether a thread is  a thread pool thread.</span></span>  
  
-   <span data-ttu-id="3e1bf-185">Propiedad <xref:System.Threading.Thread.IsBackground%2A></span><span class="sxs-lookup"><span data-stu-id="3e1bf-185">The <xref:System.Threading.Thread.IsBackground%2A> property.</span></span> <span data-ttu-id="3e1bf-186">Para obtener más información, consulte el [subprocesos de primer plano y fondo](#Foreground) sección.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-186">For more information, see the [Foreground and background threads](#Foreground) section.</span></span>  
  
## Examples  
 <span data-ttu-id="3e1bf-187">El ejemplo siguiente muestra la funcionalidad de subprocesamiento simple.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-187">The following example demonstrates simple threading functionality.</span></span>  
  
 [!code-cpp[Classic Thread Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Thread Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Thread Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Thread Example/CS/source.cs#1)]
 [!code-vb[Classic Thread Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Thread Example/VB/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-188">Este código genera una salida similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-188">This code produces output similar to the following:</span></span>  
  
```  
[VB, C++, C#]  
Main thread: Start a second thread.  
Main thread: Do some work.  
ThreadProc: 0  
Main thread: Do some work.  
ThreadProc: 1  
Main thread: Do some work.  
ThreadProc: 2  
Main thread: Do some work.  
ThreadProc: 3  
Main thread: Call Join(), to wait until ThreadProc ends.  
ThreadProc: 4  
ThreadProc: 5  
ThreadProc: 6  
ThreadProc: 7  
ThreadProc: 8  
ThreadProc: 9  
Main thread: ThreadProc.Join has returned.  Press Enter to end program.  
```  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="3e1bf-189">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-189">This type is thread safe.</span></span></threadsafe>
    <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-190">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-190">Threads and Threading</span></span></related>
    <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="3e1bf-191">Utilizar subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-191">Using Threads and Threading</span></span></related>
    <related type="ExternalDocumentation" href="https://referencesource.microsoft.com/#mscorlib/system/threading/thread.cs#3980e012bae82e96"><span data-ttu-id="3e1bf-192">Origen de referencia para la clase de subproceso</span><span class="sxs-lookup"><span data-stu-id="3e1bf-192">Reference Source for the Thread Class</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-193">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-193">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="3e1bf-194">Delegado que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-194">A delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="3e1bf-195">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />, especificando un delegado que permite pasar un objeto al subproceso cuando este último se inicia.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-195">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-196">Un subproceso no comienza a ejecutarse cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-196">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="3e1bf-197">Para programar el subproceso de ejecución, llame a la <xref:System.Threading.Thread.Start%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-197">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span> <span data-ttu-id="3e1bf-198">Para pasar un objeto de datos para el subproceso, use el <xref:System.Threading.Thread.Start%28System.Object%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-198">To pass a data object to the thread, use the <xref:System.Threading.Thread.Start%28System.Object%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-199">Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.ThreadStart> constructor al crear un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-199">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="3e1bf-200">Use la `AddressOf` operador al pasar el método, por ejemplo `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-200">Use the `AddressOf` operator when passing your method, for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="3e1bf-201">Visual Basic llama automáticamente el <xref:System.Threading.ThreadStart> constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-201">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-202">El ejemplo siguiente muestra la sintaxis para crear y usar un <xref:System.Threading.ParameterizedThreadStart> delegado con un método estático y un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-202">The following example shows the syntax for creating and using a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-203">El valor de <paramref name="start" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-203"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="3e1bf-204">Crear subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-204">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart -&gt; System.Threading.Thread" Usage="new System.Threading.Thread start" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="3e1bf-205">Delegado <see cref="T:System.Threading.ThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-205">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <summary><span data-ttu-id="3e1bf-206">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-206">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-207">Un subproceso no comienza a ejecutarse cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-207">A thread does not begin executing when it is created.</span></span> <span data-ttu-id="3e1bf-208">Para programar el subproceso de ejecución, llame a la <xref:System.Threading.Thread.Start%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-208">To schedule the thread for execution, call the <xref:System.Threading.Thread.Start%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-209">Los usuarios de Visual Basic pueden omitir el <xref:System.Threading.ThreadStart> constructor al crear un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-209">Visual Basic users can omit the <xref:System.Threading.ThreadStart> constructor when creating a thread.</span></span> <span data-ttu-id="3e1bf-210">Use la `AddressOf` al pasar por ejemplo el método de operador `Dim t As New Thread(AddressOf ThreadProc)`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-210">Use the `AddressOf` operator when passing your method for example `Dim t As New Thread(AddressOf ThreadProc)`.</span></span> <span data-ttu-id="3e1bf-211">Visual Basic llama automáticamente el <xref:System.Threading.ThreadStart> constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-211">Visual Basic automatically calls the <xref:System.Threading.ThreadStart> constructor.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-212">El ejemplo de código siguiente muestra cómo crear un subproceso que ejecuta un método estático.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-212">The following code example shows how to create a thread that executes a static method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor/VB/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-213">El ejemplo de código siguiente muestra cómo crear un subproceso que ejecuta un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-213">The following code example shows how to create a thread that executes an instance method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ctor2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ctor2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ctor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ctor2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-214">El parámetro <paramref name="start" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-214">The <paramref name="start" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadStart" />
        <altmember cref="Overload:System.Threading.Thread.Start" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="3e1bf-215">Crear subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-215">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ParameterizedThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ParameterizedThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ParameterizedThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ParameterizedThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ParameterizedThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ParameterizedThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ParameterizedThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="3e1bf-216">Delegado <see cref="T:System.Threading.ParameterizedThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-216">A <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="3e1bf-217">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-217">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="3e1bf-218">Importante   En el caso de código de confianza parcial, se pasa por alto <paramref name="maxStackSize" /> si es mayor que el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-218">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="3e1bf-219">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-219">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="3e1bf-220">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" /> y, para ello, especifica un delegado que permite pasar un objeto al subproceso cuando este último se inicia; además, especifica el tamaño de pila máximo para el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-220">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying a delegate that allows an object to be passed to the thread when the thread is started and specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-221">Evite utilizar esta sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-221">Avoid using this constructor overload.</span></span> <span data-ttu-id="3e1bf-222">El tamaño de pila predeterminado utilizado por el <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-222">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ParameterizedThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="3e1bf-223">Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como una recursividad infinita.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-223">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-224">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sólo de plena confianza puede establecer código `maxStackSize` en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-224">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="3e1bf-225">Si se especifica un valor mayor para `maxStackSize` cuando se ejecuta el código con confianza parcial, `maxStackSize` se omite y se utiliza el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-225">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="3e1bf-226">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-226">No exception is thrown.</span></span> <span data-ttu-id="3e1bf-227">Puede establecer el código en cualquier nivel de confianza `maxStackSize` en un valor que es menor que el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-227">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-228">Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila de gran tamaño, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-228">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="3e1bf-229">De no hacerlo a menos que se controla por completo el código que se ejecuta en el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-229">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="3e1bf-230">Si `maxStackSize` es menor que el tamaño de pila mínimo, se utiliza el tamaño mínimo de la pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-230">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="3e1bf-231">Si `maxStackSize` no es un múltiplo del tamaño de página, se redondea al múltiplo más grande del tamaño de página siguiente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-231">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="3e1bf-232">Por ejemplo, si utiliza la versión 2.0 de .NET Framework en Windows Vista, 256KB (262 144 bytes) es el tamaño de pila mínimo y el tamaño de página es de 64KB (65.536 bytes).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-232">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-233">En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, `maxStackSize` se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-233">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="3e1bf-234">Si especifica un tamaño de pila muy pequeño, es posible que deba deshabilitar el sondeo de desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-234">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="3e1bf-235">Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-235">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="3e1bf-236">Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-236">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-237">El valor de <paramref name="start" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-237"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-238"><paramref name="maxStackSize" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-238"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Thread (System.Threading.ThreadStart start, int maxStackSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Threading.ThreadStart start, int32 maxStackSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.#ctor(System.Threading.ThreadStart,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (start As ThreadStart, maxStackSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Thread(System::Threading::ThreadStart ^ start, int maxStackSize);" />
      <MemberSignature Language="F#" Value="new System.Threading.Thread : System.Threading.ThreadStart * int -&gt; System.Threading.Thread" Usage="new System.Threading.Thread (start, maxStackSize)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="start" Type="System.Threading.ThreadStart" />
        <Parameter Name="maxStackSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="3e1bf-239">Delegado <see cref="T:System.Threading.ThreadStart" /> que representa los métodos que deben invocarse cuando empieza a ejecutarse este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-239">A <see cref="T:System.Threading.ThreadStart" /> delegate that represents the methods to be invoked when this thread begins executing.</span></span></param>
        <param name="maxStackSize"><span data-ttu-id="3e1bf-240">Tamaño de pila máximo, en bytes, que va a usar el subproceso, o 0 para usar el tamaño de pila máximo predeterminado especificado en el encabezado del ejecutable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-240">The maximum stack size, in bytes, to be used by the thread, or 0 to use the default maximum stack size specified in the header for the executable.</span></span>  
  
<span data-ttu-id="3e1bf-241">Importante   En el caso de código de confianza parcial, se pasa por alto <paramref name="maxStackSize" /> si es mayor que el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-241">Important   For partially trusted code, <paramref name="maxStackSize" /> is ignored if it is greater than the default stack size.</span></span> <span data-ttu-id="3e1bf-242">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-242">No exception is thrown.</span></span></param>
        <summary><span data-ttu-id="3e1bf-243">Inicializa una nueva instancia de la clase <see cref="T:System.Threading.Thread" />, especificando el tamaño de pila máximo para el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-243">Initializes a new instance of the <see cref="T:System.Threading.Thread" /> class, specifying the maximum stack size for the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-244">Evite utilizar esta sobrecarga del constructor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-244">Avoid using this constructor overload.</span></span> <span data-ttu-id="3e1bf-245">El tamaño de pila predeterminado utilizado por el <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> sobrecarga del constructor es el tamaño de pila recomendado para los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-245">The default stack size used by the <xref:System.Threading.Thread.%23ctor%28System.Threading.ThreadStart%29> constructor overload is the recommended stack size for threads.</span></span> <span data-ttu-id="3e1bf-246">Si un subproceso tiene problemas de memoria, la causa más probable es un error de programación, como una recursividad infinita.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-246">If a thread has memory problems, the most likely cause is programming error, such as infinite recursion.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-247">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], sólo de plena confianza puede establecer código `maxStackSize` en un valor que es mayor que el tamaño de pila predeterminado (1 megabyte).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-247">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], only fully trusted code can set `maxStackSize` to a value that is greater than the default stack size (1 megabyte).</span></span> <span data-ttu-id="3e1bf-248">Si se especifica un valor mayor para `maxStackSize` cuando se ejecuta el código con confianza parcial, `maxStackSize` se omite y se utiliza el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-248">If a larger value is specified for `maxStackSize` when code is running with partial trust, `maxStackSize` is ignored and the default stack size is used.</span></span> <span data-ttu-id="3e1bf-249">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-249">No exception is thrown.</span></span> <span data-ttu-id="3e1bf-250">Puede establecer el código en cualquier nivel de confianza `maxStackSize` en un valor que es menor que el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-250">Code at any trust level can set `maxStackSize` to a value that is less than the default stack size.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-251">Si está desarrollando una biblioteca de plena confianza que se usará en el código de confianza parcial, y necesita iniciar un subproceso que requiere una pila de gran tamaño, debe imponer plena confianza antes de crear el subproceso o se utilizará el tamaño de pila predeterminado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-251">If you are developing a fully trusted library that will be used by partially trusted code, and you need to start a thread that requires a large stack, you must assert full trust before creating the thread, or the default stack size will be used.</span></span> <span data-ttu-id="3e1bf-252">De no hacerlo a menos que se controla por completo el código que se ejecuta en el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-252">Do not do this unless you fully control the code that runs on the thread.</span></span>  
  
 <span data-ttu-id="3e1bf-253">Si `maxStackSize` es menor que el tamaño de pila mínimo, se utiliza el tamaño mínimo de la pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-253">If `maxStackSize` is less than the minimum stack size, the minimum stack size is used.</span></span> <span data-ttu-id="3e1bf-254">Si `maxStackSize` no es un múltiplo del tamaño de página, se redondea al múltiplo más grande del tamaño de página siguiente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-254">If `maxStackSize` is not a multiple of the page size, it is rounded to the next larger multiple of the page size.</span></span> <span data-ttu-id="3e1bf-255">Por ejemplo, si utiliza la versión 2.0 de .NET Framework en Windows Vista, 256KB (262 144 bytes) es el tamaño de pila mínimo y el tamaño de página es de 64KB (65.536 bytes).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-255">For example, if you are using the .NET Framework version 2.0 on Windows Vista, 256KB (262,144 bytes) is the minimum stack size, and the page size is 64KB (65,536 bytes).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-256">En las versiones de Microsoft Windows anteriores a Windows XP y Windows Server 2003, `maxStackSize` se omite, y se utiliza el tamaño de pila especificado en el encabezado del ejecutable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-256">On versions of Microsoft Windows prior to Windows XP and Windows Server 2003, `maxStackSize` is ignored, and the stack size specified in the executable header is used.</span></span>  
  
 <span data-ttu-id="3e1bf-257">Si especifica un tamaño de pila muy pequeño, es posible que deba deshabilitar el sondeo de desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-257">If you specify a very small stack size, you might need to disable stack-overflow probing.</span></span> <span data-ttu-id="3e1bf-258">Cuando la pila está muy limitada, el propio sondeo puede provocar un desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-258">When the stack is severely constrained, the probing can itself cause a stack overflow.</span></span> <span data-ttu-id="3e1bf-259">Para deshabilitar el sondeo de desbordamiento de pila, agregue lo siguiente al archivo de configuración de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-259">To disable stack overflow probing, add the following to your application configuration file.</span></span>  
  
```xml  
<configuration>  
  <runtime>  
    <disableStackOverflowProbing enabled="true"/>  
  </runtime>  
</configuration>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-260">El valor de <paramref name="start" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-260"><paramref name="start" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-261"><paramref name="maxStackSize" /> es menor que cero.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-261"><paramref name="maxStackSize" /> is less than zero.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Abort">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-262">Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-262">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="3e1bf-263">Normalmente, una llamada a este método finaliza el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-263">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
> <span data-ttu-id="3e1bf-264">El `Thread.Abort` método debe usarse con precaución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-264">The `Thread.Abort` method should be used with caution.</span></span> <span data-ttu-id="3e1bf-265">Especialmente cuando se llama para anular un subproceso distinto del subproceso actual, no sabe qué código se ejecuta o no se pudo ejecutar cuando el <xref:System.Threading.ThreadAbortException> se produce, ni puede ser determinado del estado de la aplicación o cualquier estado de aplicación y usuario que es responsable de conservar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-265">Particularly when you call it to abort a thread other than the current thread, you do not know what code has executed or failed to execute when the <xref:System.Threading.ThreadAbortException> is thrown, nor can you be certain of the state of your application or any application and user state that it is responsible for preserving.</span></span> <span data-ttu-id="3e1bf-266">Por ejemplo, al llamar a `Thread.Abort` puede impedir que los constructores estáticos se ejecute o evitar la liberación de recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-266">For example, calling `Thread.Abort` may prevent static constructors from executing or prevent the release of unmanaged resources.</span></span> 
>
> <span data-ttu-id="3e1bf-267">Tenga en cuenta que el `Thread.Abort` método no se admite en .NET Core.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-267">Note that the `Thread.Abort` method is not supported on .NET Core.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort();" />
      <MemberSignature Language="F#" Value="member this.Abort : unit -&gt; unit" Usage="thread.Abort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-268">Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-268">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread.</span></span> <span data-ttu-id="3e1bf-269">Normalmente, una llamada a este método finaliza el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-269">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-270">Cuando este método se invoca en un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException> en el subproceso para anularla.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-270">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="3e1bf-271">`ThreadAbortException` es una excepción especial que se puede detectar el código de aplicación, pero se vuelve a producir al final de la `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-271">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="3e1bf-272">`ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-272">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="3e1bf-273">Sin ejecutar `finally` bloques se ejecutan antes de que se anula el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-273">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-274">Cuando un subproceso llama `Abort` en sí mismo, el efecto es similar a producir una excepción; la <xref:System.Threading.ThreadAbortException> sucede inmediatamente, y el resultado es predecible.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-274">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="3e1bf-275">Sin embargo, si un subproceso llama a `Abort` en otro subproceso, se interrumpe el código que se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-275">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="3e1bf-276">También es probable que se pudo anular un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-276">There is also a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="3e1bf-277">En raras ocasiones, esto podría impedir que las instancias de esa clase que se crean en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-277">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="3e1bf-278">En las versiones 1.0 y 1.1 de .NET Framework, es probable que se ha podido anular el subproceso mientras un `finally` bloque se está ejecutando, en cuyo caso el `finally` bloque se ha anulado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-278">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="3e1bf-279">El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-279">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="3e1bf-280">Esta situación puede producirse si un subproceso realiza una cantidad ilimitada de operaciones en el `finally` bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la anulación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-280">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="3e1bf-281">Para esperar hasta que se anula un subproceso, puede llamar a la <xref:System.Threading.Thread.Join%2A> método en el subproceso después de llamar a la <xref:System.Threading.Thread.Abort%2A> método, pero no hay ninguna garantía de la espera finalizará.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-281">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-282">El subproceso que llama <xref:System.Threading.Thread.Abort%2A> podrían bloquear si el subproceso que se va a anular está en una región protegida de código, como un `catch` bloque, `finally` bloque o región de ejecución restringida.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-282">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="3e1bf-283">Si el subproceso que llama <xref:System.Threading.Thread.Abort%2A> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-283">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="3e1bf-284">Si `Abort` se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <xref:System.Threading.Thread.Start%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-284">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="3e1bf-285">Si `Abort` se llama en un subproceso que está bloqueado o inactivo, el subproceso se interrumpe y, a continuación, se anula.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-285">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="3e1bf-286">Si `Abort` se llama en un subproceso que se ha suspendido, un <xref:System.Threading.ThreadStateException> se produce en el subproceso que llamó a <xref:System.Threading.Thread.Abort%2A>, y <xref:System.Threading.ThreadState.AbortRequested> se agrega a la <xref:System.Threading.Thread.ThreadState%2A> propiedad del subproceso que se va a anular.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-286">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="3e1bf-287">Un <xref:System.Threading.ThreadAbortException> no se produce en el subproceso suspendido hasta que <xref:System.Threading.Thread.Resume%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-287">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="3e1bf-288">Si `Abort` se llama en un subproceso administrado mientras se ejecuta el código no administrado, un `ThreadAbortException` no se produce hasta que el subproceso vuelve al código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-288">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="3e1bf-289">Si dos llamadas a `Abort` proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada para ejecutar el `Abort`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-289">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="3e1bf-290">Sin embargo, una aplicación no puede detectar esta situación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-290">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="3e1bf-291">Después de `Abort` se invoca en un subproceso, el estado del subproceso incluye <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-291">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="3e1bf-292">Después de que el subproceso ha terminado debido a una llamada correcta a `Abort`, se cambia el estado del subproceso a <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-292">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="3e1bf-293">Con los permisos suficientes, un subproceso que es el destino de una `Abort` puede cancelar la anulación utilizando el `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-293">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="3e1bf-294">Para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método, consulte el `ThreadAbortException` clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-294">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-295">Solo .NET Core: este miembro no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-295">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-296">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-296">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-297">Actualmente se suspende el subproceso que se está anulando.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-297">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-298">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-298">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-299">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-299">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-300">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-300">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="3e1bf-301">Uso de subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-301">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="3e1bf-302">Destrucción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-302">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Abort">
      <MemberSignature Language="C#" Value="public void Abort (object stateInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Abort(object stateInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Abort(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Abort (stateInfo As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Abort(System::Object ^ stateInfo);" />
      <MemberSignature Language="F#" Value="member this.Abort : obj -&gt; unit" Usage="thread.Abort stateInfo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stateInfo" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="stateInfo"><span data-ttu-id="3e1bf-303">Objeto que contiene información específica de la aplicación como, por ejemplo, su estado, y que el subproceso anulado puede utilizar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-303">An object that contains application-specific information, such as state, which can be used by the thread being aborted.</span></span></param>
        <summary><span data-ttu-id="3e1bf-304">Produce una excepción <see cref="T:System.Threading.ThreadAbortException" /> en el subproceso en el que se invoca, para iniciar el proceso de finalización del subproceso, proporcionando al mismo tiempo información sobre excepciones relativa a la terminación del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-304">Raises a <see cref="T:System.Threading.ThreadAbortException" /> in the thread on which it is invoked, to begin the process of terminating the thread while also providing exception information about the thread termination.</span></span> <span data-ttu-id="3e1bf-305">Normalmente, una llamada a este método finaliza el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-305">Calling this method usually terminates the thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-306">Cuando este método se invoca en un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException> en el subproceso para anularla.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-306">When this method is invoked on a thread, the system throws a <xref:System.Threading.ThreadAbortException> in the thread to abort it.</span></span> <span data-ttu-id="3e1bf-307">`ThreadAbortException` es una excepción especial que se puede detectar el código de aplicación, pero se vuelve a producir al final de la `catch` bloquear a menos que <xref:System.Threading.Thread.ResetAbort%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-307">`ThreadAbortException` is a special exception that can be caught by application code, but is re-thrown at the end of the `catch` block unless <xref:System.Threading.Thread.ResetAbort%2A> is called.</span></span> <span data-ttu-id="3e1bf-308">`ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-308">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span> <span data-ttu-id="3e1bf-309">Sin ejecutar `finally` bloques se ejecutan antes de que se anula el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-309">Unexecuted `finally` blocks are executed before the thread is aborted.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-310">Cuando un subproceso llama `Abort` en sí mismo, el efecto es similar a producir una excepción; la <xref:System.Threading.ThreadAbortException> sucede inmediatamente, y el resultado es predecible.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-310">When a thread calls `Abort` on itself, the effect is similar to throwing an exception; the <xref:System.Threading.ThreadAbortException> happens immediately, and the result is predictable.</span></span> <span data-ttu-id="3e1bf-311">Sin embargo, si un subproceso llama a `Abort` en otro subproceso, se interrumpe el código que se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-311">However, if one thread calls `Abort` on another thread, the abort interrupts whatever code is running.</span></span> <span data-ttu-id="3e1bf-312">Es probable que se pudo anular un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-312">There is a chance that a static constructor could be aborted.</span></span> <span data-ttu-id="3e1bf-313">En raras ocasiones, esto podría impedir que las instancias de esa clase que se crean en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-313">In rare cases, this might prevent instances of that class from being created in that application domain.</span></span> <span data-ttu-id="3e1bf-314">En las versiones 1.0 y 1.1 de .NET Framework, es probable que se ha podido anular el subproceso mientras un `finally` bloque se está ejecutando, en cuyo caso el `finally` bloque se ha anulado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-314">In the .NET Framework versions 1.0 and 1.1, there is a chance the thread could abort while a `finally` block is running, in which case the `finally` block is aborted.</span></span>  
  
 <span data-ttu-id="3e1bf-315">El subproceso no se garantiza para anular la operación inmediatamente, o en absoluto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-315">The thread is not guaranteed to abort immediately, or at all.</span></span> <span data-ttu-id="3e1bf-316">Esta situación puede producirse si un subproceso realiza una cantidad ilimitada de operaciones en el `finally` bloques que se llaman como parte del procedimiento de anulación, indefinidamente, por tanto, la anulación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-316">This situation can occur if a thread does an unbounded amount of computation in the `finally` blocks that are called as part of the abort procedure, thereby indefinitely delaying the abort.</span></span> <span data-ttu-id="3e1bf-317">Para esperar hasta que se anula un subproceso, puede llamar a la <xref:System.Threading.Thread.Join%2A> método en el subproceso después de llamar a la <xref:System.Threading.Thread.Abort%2A> método, pero no hay ninguna garantía de que la espera finalizará.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-317">To wait until a thread has aborted, you can call the <xref:System.Threading.Thread.Join%2A> method on the thread after calling the <xref:System.Threading.Thread.Abort%2A> method, but there is no guarantee that the wait will end.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-318">El subproceso que llama <xref:System.Threading.Thread.Abort%2A> podrían bloquear si el subproceso que se va a anular está en una región protegida de código, como un `catch` bloque, `finally` bloque o región de ejecución restringida.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-318">The thread that calls <xref:System.Threading.Thread.Abort%2A> might block if the thread that is being aborted is in a protected region of code, such as a `catch` block, `finally` block, or constrained execution region.</span></span> <span data-ttu-id="3e1bf-319">Si el subproceso que llama <xref:System.Threading.Thread.Abort%2A> mantiene un bloqueo que el subproceso anulado requiere, puede producirse un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-319">If the thread that calls <xref:System.Threading.Thread.Abort%2A> holds a lock that the aborted thread requires, a deadlock can occur.</span></span>  
  
 <span data-ttu-id="3e1bf-320">Si `Abort` se llama en un subproceso que no se ha iniciado, el subproceso anulará cuando <xref:System.Threading.Thread.Start%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-320">If `Abort` is called on a thread that has not been started, the thread will abort when <xref:System.Threading.Thread.Start%2A> is called.</span></span> <span data-ttu-id="3e1bf-321">Si `Abort` se llama en un subproceso que está bloqueado o inactivo, el subproceso se interrumpe y, a continuación, se anula.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-321">If `Abort` is called on a thread that is blocked or is sleeping, the thread is interrupted and then aborted.</span></span>  
  
 <span data-ttu-id="3e1bf-322">Si `Abort` se llama en un subproceso que se ha suspendido, un <xref:System.Threading.ThreadStateException> se produce en el subproceso que llamó a <xref:System.Threading.Thread.Abort%2A>, y <xref:System.Threading.ThreadState.AbortRequested> se agrega a la <xref:System.Threading.Thread.ThreadState%2A> propiedad del subproceso que se va a anular.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-322">If `Abort` is called on a thread that has been suspended, a <xref:System.Threading.ThreadStateException> is thrown in the thread that called <xref:System.Threading.Thread.Abort%2A>, and <xref:System.Threading.ThreadState.AbortRequested> is added to the <xref:System.Threading.Thread.ThreadState%2A> property of the thread being aborted.</span></span> <span data-ttu-id="3e1bf-323">Un <xref:System.Threading.ThreadAbortException> no se produce en el subproceso suspendido hasta que <xref:System.Threading.Thread.Resume%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-323">A <xref:System.Threading.ThreadAbortException> is not thrown in the suspended thread until <xref:System.Threading.Thread.Resume%2A> is called.</span></span>  
  
 <span data-ttu-id="3e1bf-324">Si `Abort` se llama en un subproceso administrado mientras se ejecuta el código no administrado, un `ThreadAbortException` no se produce hasta que el subproceso vuelve al código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-324">If `Abort` is called on a managed thread while it is executing unmanaged code, a `ThreadAbortException` is not thrown until the thread returns to managed code.</span></span>  
  
 <span data-ttu-id="3e1bf-325">Si dos llamadas a `Abort` proceder al mismo tiempo, es posible que una llamada establecer la información de estado y la otra llamada para ejecutar el `Abort`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-325">If two calls to `Abort` come at the same time, it is possible for one call to set the state information and the other call to execute the `Abort`.</span></span> <span data-ttu-id="3e1bf-326">Sin embargo, una aplicación no puede detectar esta situación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-326">However, an application cannot detect this situation.</span></span>  
  
 <span data-ttu-id="3e1bf-327">Después de `Abort` se invoca en un subproceso, el estado del subproceso incluye <xref:System.Threading.ThreadState.AbortRequested>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-327">After `Abort` is invoked on a thread, the state of the thread includes <xref:System.Threading.ThreadState.AbortRequested>.</span></span> <span data-ttu-id="3e1bf-328">Después de que el subproceso ha terminado debido a una llamada correcta a `Abort`, se cambia el estado del subproceso a <xref:System.Threading.ThreadState.Stopped>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-328">After the thread has terminated as a result of a successful call to `Abort`, the state of the thread is changed to <xref:System.Threading.ThreadState.Stopped>.</span></span> <span data-ttu-id="3e1bf-329">Con los permisos suficientes, un subproceso que es el destino de una `Abort` puede cancelar la anulación utilizando el `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-329">With sufficient permissions, a thread that is the target of an `Abort` can cancel the abort using the `ResetAbort` method.</span></span> <span data-ttu-id="3e1bf-330">Para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método, consulte el `ThreadAbortException` clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-330">For an example that demonstrates calling the `ResetAbort` method, see the `ThreadAbortException` class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-331">El ejemplo de código siguiente muestra cómo pasar información a un subproceso que se va a anular.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-331">The following code example shows how to pass information to a thread that is being aborted.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Abort2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Abort2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Abort2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Abort2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-332">Solo .NET Core: este miembro no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-332">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-333">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-333">The caller does not have the required permission.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-334">Actualmente se suspende el subproceso que se está anulando.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-334">The thread that is being aborted is currently suspended.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-335">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-335">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-336">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-336">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadAbortException" />
        <altmember cref="F:System.Threading.ThreadState.Aborted" />
        <altmember cref="F:System.Threading.ThreadState.AbortRequested" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-337">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-337">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/using-threads-and-threading.md"><span data-ttu-id="3e1bf-338">Uso de subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-338">Using threads and threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="3e1bf-339">Destrucción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-339">Destroying threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateDataSlot ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateDataSlot() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateDataSlot" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateDataSlot () As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateDataSlot();" />
      <MemberSignature Language="F#" Value="static member AllocateDataSlot : unit -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateDataSlot " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-340">Asigna una ranura de datos sin nombre en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-340">Allocates an unnamed data slot on all the threads.</span></span> <span data-ttu-id="3e1bf-341">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-341">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-342">Ranura de datos con nombre asignada en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-342">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-343">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-343">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-344">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-344">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-345">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-345">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-346">Se asigna a la ranura en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-346">The slot is allocated on all threads.</span></span>  
  
 <span data-ttu-id="3e1bf-347">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-347">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-348">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-348">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-349">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-349">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="3e1bf-350">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-350">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-351">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-351">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-352">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-352">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-353">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-353">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-354">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-354">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-355">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-355">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-356">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-356">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-357">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-357">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-358">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-358">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-359">El ejemplo de código siguiente muestra cómo usar una ranura de datos para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-359">The following code example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-360">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-360">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-361">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-361">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="AllocateNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot AllocateNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot AllocateNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.AllocateNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function AllocateNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ AllocateNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member AllocateNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.AllocateNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3e1bf-362">Nombre de la ranura de datos que se va a asignar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-362">The name of the data slot to be allocated.</span></span></param>
        <summary><span data-ttu-id="3e1bf-363">Asigna una ranura de datos con nombre en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-363">Allocates a named data slot on all threads.</span></span> <span data-ttu-id="3e1bf-364">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-364">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-365">Ranura de datos con nombre asignada en todos los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-365">The allocated named data slot on all threads.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-366">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-366">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-367">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-367">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-368">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-368">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-369">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-369">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-370">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-370">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-371">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-371">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="3e1bf-372">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-372">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-373">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-373">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="3e1bf-374">No es necesario utilizar el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método para asignar una ranura de datos con nombre, porque el <xref:System.Threading.Thread.GetNamedDataSlot%2A> método asigna la ranura si ya no se ha asignado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-374">It is not necessary to use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method to allocate a named data slot, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-375">Si el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> se usa el método, debe llamarse en el subproceso principal al inicio del programa, ya que produce una excepción si ya se ha asignado una ranura con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-375">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup, because it throws an exception if a slot with the specified name has already been allocated.</span></span> <span data-ttu-id="3e1bf-376">No hay ninguna manera para comprobar si ya se ha asignado una ranura.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-376">There is no way to test whether a slot has already been allocated.</span></span>  
  
 <span data-ttu-id="3e1bf-377">Las ranuras asignadas con este método se deben liberar con <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-377">Slots allocated with this method must be freed with <xref:System.Threading.Thread.FreeNamedDataSlot%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-378">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-378">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-379">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-379">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-380">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-380">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-381">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-381">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-382">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-382">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-383">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-383">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-384">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-384">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-385">El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-385">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-386">El código de ejemplo no utiliza la <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> método, porque el <xref:System.Threading.Thread.GetNamedDataSlot%2A> método asigna la ranura si ya no se ha asignado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-386">The example code does not use the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method, because the <xref:System.Threading.Thread.GetNamedDataSlot%2A> method allocates the slot if it has not already been allocated.</span></span> <span data-ttu-id="3e1bf-387">Si el <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> se usa el método, se debe llamar en el subproceso principal al inicio del programa.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-387">If the <xref:System.Threading.Thread.AllocateNamedDataSlot%2A> method is used, it should be called in the main thread at program startup.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-388">Ya existe una ranura para datos con el nombre especificado</span><span class="sxs-lookup"><span data-stu-id="3e1bf-388">A named data slot with the specified name already exists.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-389">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-389">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-390">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-390">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState ApartmentState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ApartmentState ApartmentState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Property ApartmentState As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ApartmentState ApartmentState { System::Threading::ApartmentState get(); void set(System::Threading::ApartmentState value); };" />
      <MemberSignature Language="F#" Value="member this.ApartmentState : System.Threading.ApartmentState with get, set" Usage="System.Threading.Thread.ApartmentState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Deprecated in favor of GetApartmentState, SetApartmentState and TrySetApartmentState.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("The ApartmentState property has been deprecated.  Use GetApartmentState, SetApartmentState or TrySetApartmentState instead.", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-391">Obtiene o establece el estado de apartamento de este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-391">Gets or sets the apartment state of this thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-392">Uno de los valores de <see cref="T:System.Threading.ApartmentState" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-392">One of the <see cref="T:System.Threading.ApartmentState" /> values.</span></span> <span data-ttu-id="3e1bf-393">El valor inicial es <see langword="Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-393">The initial value is <see langword="Unknown" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-394">**El <xref:System.Threading.Thread.ApartmentState%2A> propiedad está obsoleta.**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-394">**The <xref:System.Threading.Thread.ApartmentState%2A> property is obsolete.**</span></span>  <span data-ttu-id="3e1bf-395">Las alternativas no obsoleto son el <xref:System.Threading.Thread.GetApartmentState%2A> método para recuperar el estado del apartamento y <xref:System.Threading.Thread.SetApartmentState%2A> método para establecer el estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-395">The non-obsolete alternatives are the <xref:System.Threading.Thread.GetApartmentState%2A> method to retrieve the apartment state and the   <xref:System.Threading.Thread.SetApartmentState%2A> method to set the apartment state.</span></span>  
  
 <span data-ttu-id="3e1bf-396">En las versiones de .NET Framework 1.0 y 1.1, el `ApartmentState` propiedad marca un subproceso para indicar que se ejecutará en un apartamento multiproceso o uniproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-396">In the .NET Framework versions 1.0 and 1.1, the `ApartmentState` property marks a thread to indicate that it will execute in a single-threaded or multithreaded apartment.</span></span> <span data-ttu-id="3e1bf-397">Esta propiedad puede establecerse cuando el subproceso está en el `Unstarted` o `Running` subprocesos estado; sin embargo, puede establecerse solo una vez por subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-397">This property can be set when the thread is in the `Unstarted` or `Running` thread state; however, it can be set only once for a thread.</span></span> <span data-ttu-id="3e1bf-398">Si no se estableció la propiedad, devuelve `Unknown`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-398">If the property has not been set, it returns `Unknown`.</span></span>  
  
 <span data-ttu-id="3e1bf-399">Intentar utilizar el <xref:System.Threading.Thread.ApartmentState%2A> se omite la propiedad para establecer el estado de apartamento de un subproceso cuyo estado de apartamento ya se ha establecido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-399">An attempt to use the <xref:System.Threading.Thread.ApartmentState%2A> property to set the apartment state of a thread whose apartment state has already been set is ignored.</span></span> <span data-ttu-id="3e1bf-400">Sin embargo, el <xref:System.Threading.Thread.SetApartmentState%2A> método produce una <xref:System.InvalidOperationException> en este caso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-400">However, the <xref:System.Threading.Thread.SetApartmentState%2A> method throws a <xref:System.InvalidOperationException> in this case.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-401">En la versión 2.0 de .NET Framework, los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-401">In the .NET Framework version 2.0, new threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="3e1bf-402">El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-402">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="3e1bf-403">Ya no se puede establecer el subproceso principal de la aplicación en <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> estableciendo el <xref:System.Threading.ApartmentState?displayProperty=nameWithType> propiedad en la primera línea de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-403">You can no longer set the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> by setting the <xref:System.Threading.ApartmentState?displayProperty=nameWithType> property on the first line of code.</span></span> <span data-ttu-id="3e1bf-404">Use el <xref:System.STAThreadAttribute> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-404">Use the <xref:System.STAThreadAttribute> instead.</span></span>  
  
 <span data-ttu-id="3e1bf-405">En la versión 2.0 de .NET Framework, puede especificar el COM de subprocesamiento de modelo para una aplicación de C++ mediante el [/CLRTHREADATTRIBUTE (Establecer atributo de subproceso de CLR)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) opción del vinculador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-405">In the .NET Framework version 2.0, you can specify the COM threading model for a C++ application using the [/CLRTHREADATTRIBUTE (Set CLR Thread Attribute)](https://msdn.microsoft.com/library/4907e9ef-5031-446c-aecf-0a0b32fae1e8) linker option.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-406">En el ejemplo de código siguiente se muestra cómo establecer el estado de apartamento de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-406">The following code example demonstrates how to set the apartment state of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.ApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.ApartmentState/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-407">Se realiza un intento de establecer esta propiedad en un estado que no es un estado de contenedor válido (un estado distinto de contenedor uniproceso (<see langword="STA" />) o contenedor multiproceso (<see langword="MTA" />)).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-407">An attempt is made to set this property to a state that is not a valid apartment state (a state other than single-threaded apartment (<see langword="STA" />) or multithreaded apartment (<see langword="MTA" />)).</span></span></exception>
        <altmember cref="T:System.Threading.ThreadState" />
        <altmember cref="M:System.Threading.Thread.GetApartmentState" />
        <altmember cref="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      </Docs>
    </Member>
    <Member MemberName="BeginCriticalRegion">
      <MemberSignature Language="C#" Value="public static void BeginCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member BeginCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.BeginCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-408">Notifica a un host que la ejecución está a punto de entrar en una región del código donde los efectos de una anulación del subproceso o de una excepción no controlada podrían constituir un riesgo para otras tareas del dominio de aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-408">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception might jeopardize other tasks in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-409">Hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en regiones críticas y no críticas del código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-409">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="3e1bf-410">Una región crítica es aquella en la que los efectos de una anulación de subproceso o una excepción no controlada pueden no limitarse a la tarea actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-410">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="3e1bf-411">Por el contrario, una anulación o un error en una región no crítica del código afecta a solo la tarea que se produce el error.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-411">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="3e1bf-412">Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-412">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="3e1bf-413">Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <xref:System.AppDomain>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-413">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="3e1bf-414">Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-414">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="3e1bf-415">Cuando se produce un error en una región crítica, el host puede optar por descargar toda la <xref:System.AppDomain> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-415">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="3e1bf-416">Para informar al host que el código está entrando en una región crítica, llame a <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-416">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="3e1bf-417">Llamar a <xref:System.Threading.Thread.EndCriticalRegion%2A> cuando se devuelve a una región no crítica del código de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-417">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="3e1bf-418">Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-418">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-419">En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir un bloque de código en regiones críticas y no críticas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-419">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.EndCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="BeginThreadAffinity">
      <MemberSignature Language="C#" Value="public static void BeginThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void BeginThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.BeginThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub BeginThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void BeginThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member BeginThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.BeginThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-420">Notifica a un host que el código administrado está a punto de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-420">Notifies a host that managed code is about to execute instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-421">Algunos hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-421">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="3e1bf-422">Un host que proporciona su propia administración de subprocesos puede mover una tarea en ejecución de un subproceso de sistema operativo físico a otro en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-422">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="3e1bf-423">Mayoría de las tareas no se ven afectada por este cambio.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-423">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="3e1bf-424">Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-424">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="3e1bf-425">Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-425">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="3e1bf-426">Por ejemplo, si la aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir el bloqueo, y <xref:System.Threading.Thread.EndThreadAffinity%2A> después de liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-426">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="3e1bf-427">Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-427">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-428">En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> y <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-428">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-429">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-429">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-430">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-430">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-431">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-431">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.EndThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="CurrentContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Remoting.Contexts.Context CurrentContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Remoting.Contexts.Context CurrentContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContext As Context" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Remoting::Contexts::Context ^ CurrentContext { System::Runtime::Remoting::Contexts::Context ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContext : System.Runtime.Remoting.Contexts.Context" Usage="System.Threading.Thread.CurrentContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.Contexts.Context</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-432">Obtiene el contexto actual donde se está ejecutando el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-432">Gets the current context in which the thread is executing.</span></span></summary>
        <value><span data-ttu-id="3e1bf-433"><see cref="T:System.Runtime.Remoting.Contexts.Context" /> que representa el contexto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-433">A <see cref="T:System.Runtime.Remoting.Contexts.Context" /> representing the current thread context.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-434">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-434">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-435">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-435">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-436">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-436">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentCulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentCulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentCulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentCulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentCulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentCulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentCulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentCulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-437">Obtiene o establece la referencia cultural del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-437">Gets or sets the culture for the current thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-438">Objeto que representa la referencia cultural del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-438">An object that represents the culture for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-439">La <xref:System.Globalization.CultureInfo> objeto devuelto por esta propiedad, junto con sus objetos asociados, determinar el formato predeterminado para las fechas, horas, números, valores de moneda, el criterio de ordenación de texto, las mayúsculas y minúsculas de las convenciones y comparaciones de cadenas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-439">The <xref:System.Globalization.CultureInfo> object that is returned by this property, together with its associated objects, determine the default format for dates, times, numbers, currency values, the sorting order of text, casing conventions, and string comparisons.</span></span> <span data-ttu-id="3e1bf-440">Consulte la <xref:System.Globalization.CultureInfo> clase para obtener información sobre los nombres de referencia cultural y los identificadores, las diferencias entre culturas invariables, neutras y específicas, y la información de referencia cultural de manera que afecta a dominios de aplicación y subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-440">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="3e1bf-441">Consulte la <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> propiedad para obtener información sobre cómo se determina la referencia cultural predeterminada de un subproceso y cómo los usuarios establecer información de referencia cultural para sus equipos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-441">See the <xref:System.Globalization.CultureInfo.CurrentCulture%2A?displayProperty=nameWithType> property to learn how a thread's default culture is determined, and how users set culture information for their computers.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="3e1bf-442">El <xref:System.Threading.Thread.CurrentCulture> propiedad no funciona de forma confiable cuando se usa con cualquier subproceso distinto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-442">The <xref:System.Threading.Thread.CurrentCulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="3e1bf-443">En .NET Framework, la propiedad de lectura es confiable, aunque si se establece para un subproceso distinto del subproceso actual no es.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-443">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="3e1bf-444">En .NET Core, un <xref:System.InvalidOperationException> se produce si un subproceso intenta leer o escribir el <xref:System.Threading.Thread.CurrentCulture> propiedad en un subproceso diferente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-444">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentCulture> property on a different thread.</span></span>
> <span data-ttu-id="3e1bf-445">Se recomienda que use el <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> propiedad para recuperar y establecer la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-445">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentCulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="3e1bf-446">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], puede establecer el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad a una referencia cultural neutra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-446">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], you can set the <xref:System.Threading.Thread.CurrentCulture%2A> property to a neutral culture.</span></span> <span data-ttu-id="3e1bf-447">Esto es porque el comportamiento de la <xref:System.Globalization.CultureInfo> clase ha cambiado: cuando representa una referencia cultural neutra, sus valores de propiedad (en concreto, el <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, y <xref:System.Globalization.CultureInfo.TextInfo%2A> propiedades) ahora refleja la referencia cultural específica que está asociada con la referencia cultural neutra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-447">This is because the behavior of the <xref:System.Globalization.CultureInfo> class has changed: When it represents a neutral culture, its property values (in particular, the <xref:System.Globalization.CultureInfo.Calendar%2A>, <xref:System.Globalization.CultureInfo.CompareInfo%2A>, <xref:System.Globalization.CultureInfo.DateTimeFormat%2A>, <xref:System.Globalization.CultureInfo.NumberFormat%2A>, and <xref:System.Globalization.CultureInfo.TextInfo%2A> properties) now reflect the specific culture that is associated with the neutral culture.</span></span> <span data-ttu-id="3e1bf-448">En versiones anteriores de .NET Framework, el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad produjo una <xref:System.NotSupportedException> excepción cuando se le asignó una referencia cultural neutra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-448">In earlier versions of the .NET Framework, the <xref:System.Threading.Thread.CurrentCulture%2A> property threw a <xref:System.NotSupportedException> exception when a neutral culture was assigned.</span></span>  
  
## Examples  
 <span data-ttu-id="3e1bf-449">El ejemplo siguiente muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de una aplicación de Windows Forms para mostrar en la referencia cultural que se establece en el Panel de Control.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-449">The following example shows the threading statement that allows the user interface of a Windows Forms application to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="3e1bf-450">Se necesita código adicional.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-450">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-451">La propiedad se establece en <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-451">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-452">Solo .NET Core: no se admite la lectura o escritura de la referencia cultural de un subproceso desde otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-452">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-453">Para establecer la propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-453">for setting the property.</span></span> <span data-ttu-id="3e1bf-454">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="3e1bf-454">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentPrincipal">
      <MemberSignature Language="C#" Value="public static System.Security.Principal.IPrincipal CurrentPrincipal { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Security.Principal.IPrincipal CurrentPrincipal" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentPrincipal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property CurrentPrincipal As IPrincipal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Security::Principal::IPrincipal ^ CurrentPrincipal { System::Security::Principal::IPrincipal ^ get(); void set(System::Security::Principal::IPrincipal ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentPrincipal : System.Security.Principal.IPrincipal with get, set" Usage="System.Threading.Thread.CurrentPrincipal" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Principal.IPrincipal</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-455">Obtiene o establece la entidad de seguridad actual del subproceso (de la seguridad basada en roles).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-455">Gets or sets the thread's current principal (for role-based security).</span></span></summary>
        <value><span data-ttu-id="3e1bf-456">Valor de <see cref="T:System.Security.Principal.IPrincipal" /> que representa el contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-456">An <see cref="T:System.Security.Principal.IPrincipal" /> value representing the security context.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e1bf-457">El ejemplo de código siguiente muestra cómo establecer y recuperar la entidad de seguridad de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-457">The following code example shows how to set and retrieve the principal of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.CurrentPrincipal/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-458">El autor de llamada no tiene el permiso necesario para establecer la entidad de seguridad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-458">The caller does not have the permission required to set the principal.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-459">para manipular el objeto principal.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-459">to manipulate the principal object.</span></span> <span data-ttu-id="3e1bf-460">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-460">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CurrentThread">
      <MemberSignature Language="C#" Value="public static System.Threading.Thread CurrentThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Threading.Thread CurrentThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentThread As Thread" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Threading::Thread ^ CurrentThread { System::Threading::Thread ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentThread : System.Threading.Thread" Usage="System.Threading.Thread.CurrentThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.Thread</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-461">Obtiene el subproceso actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-461">Gets the currently running thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-462"><see cref="T:System.Threading.Thread" /> que representa el subproceso actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-462">A <see cref="T:System.Threading.Thread" /> that is the representation of the currently running thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e1bf-463">El ejemplo siguiente crea una tarea que a su vez crea 20 tareas secundarias.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-463">The following example creates a task that in turn creates 20 child tasks.</span></span> <span data-ttu-id="3e1bf-464">La aplicación, como también cada tarea, llama a la `ShowThreadInformation` método, que usa el <xref:System.Threading.Thread.CurrentThread%2A> propiedad para mostrar información sobre el subproceso en el que se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-464">The application itself, as well as each task, calls the `ShowThreadInformation` method, which uses the <xref:System.Threading.Thread.CurrentThread%2A> property  to display information about the thread on which it is running.</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.currentthread/cs/currentthread2.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.currentthread/vb/currentthread2.vb#1)]  
  
 <span data-ttu-id="3e1bf-465">Cada tarea secundaria genera números aleatorios de 1 millón de entre 1 y 1 millón y devuelve su Media.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-465">Each child task generates 1 million random numbers between 1 and 1 million and returns their mean.</span></span> <span data-ttu-id="3e1bf-466">Las llamadas de la tarea primaria la <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> método para asegurarse de que se han completado las tareas secundarias antes de mostrar la media devuelta por cada tarea y calcular la media de medios.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-466">The parent task calls the <xref:System.Threading.Tasks.Task.WaitAll%2A?displayProperty=nameWithType> method to ensure that the child tasks have completed before displaying the mean returned by each task and calculating the mean of means.</span></span>  
  
 <span data-ttu-id="3e1bf-467">Tenga en cuenta que mientras la aplicación se ejecuta en un subproceso en primer plano, cada tarea se ejecuta en un subproceso ThreadPool.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-467">Note that while the application runs on a foreground thread, each task runs on a thread pool thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentUICulture">
      <MemberSignature Language="C#" Value="public System.Globalization.CultureInfo CurrentUICulture { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Globalization.CultureInfo CurrentUICulture" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.CurrentUICulture" />
      <MemberSignature Language="VB.NET" Value="Public Property CurrentUICulture As CultureInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Globalization::CultureInfo ^ CurrentUICulture { System::Globalization::CultureInfo ^ get(); void set(System::Globalization::CultureInfo ^ value); };" />
      <MemberSignature Language="F#" Value="member this.CurrentUICulture : System.Globalization.CultureInfo with get, set" Usage="System.Threading.Thread.CurrentUICulture" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Globalization.CultureInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-468">Obtiene o establece la referencia cultural actual utilizada por el administrador de recursos para buscar recursos específicos de la referencia cultural en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-468">Gets or sets the current culture used by the Resource Manager to look up culture-specific resources at run time.</span></span></summary>
        <value><span data-ttu-id="3e1bf-469">Objeto que representa la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-469">An object that represents the current culture.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-470">La referencia cultural de interfaz de usuario especifica los recursos de una aplicación debe admitir la entrada de usuario y la salida y de forma predeterminada es igual que la referencia cultural del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-470">The UI culture specifies the resources an application needs to support user input and output, and by default is the same as the operating system culture.</span></span> <span data-ttu-id="3e1bf-471">Consulte la <xref:System.Globalization.CultureInfo> clase para obtener información sobre los nombres de referencia cultural y los identificadores, las diferencias entre culturas invariables, neutras y específicas, y la información de referencia cultural de manera que afecta a dominios de aplicación y subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-471">See the <xref:System.Globalization.CultureInfo> class to learn about culture names and identifiers, the differences between invariant, neutral, and specific cultures, and the way culture information affects threads and application domains.</span></span> <span data-ttu-id="3e1bf-472">Consulte la <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> propiedad para obtener información sobre cómo se determina la referencia cultural de interfaz de usuario de predeterminada de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-472">See the <xref:System.Globalization.CultureInfo.CurrentUICulture%2A?displayProperty=nameWithType> property to learn how a thread's default UI culture is determined.</span></span>  

> [!IMPORTANT]
> <span data-ttu-id="3e1bf-473">El <xref:System.Threading.Thread.CurrentUICulture> propiedad no funciona de forma confiable cuando se usa con cualquier subproceso distinto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-473">The <xref:System.Threading.Thread.CurrentUICulture> property doesn't work reliably when used with any thread other than the current thread.</span></span> <span data-ttu-id="3e1bf-474">En .NET Framework, la propiedad de lectura es confiable, aunque si se establece para un subproceso distinto del subproceso actual no es.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-474">In .NET Framework, reading the property is reliable, although setting it for a thread other than the current thread is not.</span></span> <span data-ttu-id="3e1bf-475">En .NET Core, un <xref:System.InvalidOperationException> se produce si un subproceso intenta leer o escribir el <xref:System.Threading.Thread.CurrentUICulture> propiedad en un subproceso diferente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-475">On .NET Core, an <xref:System.InvalidOperationException> is thrown if a thread attempts to read or write the <xref:System.Threading.Thread.CurrentUICulture> property on a different thread.</span></span>
> <span data-ttu-id="3e1bf-476">Se recomienda que use el <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> propiedad para recuperar y establecer la referencia cultural actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-476">We recommend that you use the <xref:System.Globalization.CultureInfo.CurrentUICulture?displayProperty=nameWithType> property to retrieve and set the current culture.</span></span>

 <span data-ttu-id="3e1bf-477">El <xref:System.Globalization.CultureInfo> devuelto por esta propiedad puede ser una referencia cultural neutra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-477">The <xref:System.Globalization.CultureInfo> returned by this property can be a neutral culture.</span></span> <span data-ttu-id="3e1bf-478">No deben usarse con métodos de formato, como las referencias culturales neutras <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, y <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-478">Neutral cultures should not be used with formatting methods such as <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>, <xref:System.DateTime.ToString%28System.String%2CSystem.IFormatProvider%29?displayProperty=nameWithType>, and <xref:System.Convert.ToString%28System.Char%2CSystem.IFormatProvider%29?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-479">Utilice la <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método para obtener una referencia cultural específica, o use el <xref:System.Threading.Thread.CurrentCulture%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-479">Use the <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method to get a specific culture, or use the <xref:System.Threading.Thread.CurrentCulture%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-480">El <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> método inicie una excepción <xref:System.ArgumentException> para las referencias culturales neutras "zh-Hant" ("zh-CHT") y "zh-Hans" ("zh-CHS").</span><span class="sxs-lookup"><span data-stu-id="3e1bf-480">The <xref:System.Globalization.CultureInfo.CreateSpecificCulture%2A?displayProperty=nameWithType> method throws <xref:System.ArgumentException> for the neutral cultures "zh-Hant" ("zh-CHT") and "zh-Hans" ("zh-CHS").</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-481">El ejemplo siguiente determina si el idioma de la referencia cultural de interfaz de usuario del subproceso actual es francés.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-481">The following example determines whether the language of the current thread's UI culture is French.</span></span> <span data-ttu-id="3e1bf-482">Si no es así, Establece la referencia cultural de interfaz de usuario del subproceso actual para inglés (Estados Unidos).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-482">If it is not, it sets the UI culture of the current thread to English (United States).</span></span>  
  
 [!code-csharp[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/cs/CurrentUICulture1.cs#1)]
 [!code-vb[System.Threading.Thread.CurrentUICulture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.Thread.CurrentUICulture/vb/CurrentUICulture1.vb#1)]  
  
 <span data-ttu-id="3e1bf-483">El ejemplo de código siguiente muestra la instrucción de subprocesamiento que permite a la interfaz de usuario de un Windows Forms para mostrar en la referencia cultural que se establece en el Panel de Control.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-483">The following code example shows the threading statement that allows the user interface of a Windows Forms to display in the culture that is set in Control Panel.</span></span> <span data-ttu-id="3e1bf-484">Se necesita código adicional.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-484">Additional code is needed.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Culture#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Culture#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Culture/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Culture#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Culture/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="3e1bf-485">La propiedad se establece en <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-485">The property is set to <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-486">La propiedad se establece en un nombre de referencia cultural que no se puede usar para buscar un archivo de recursos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-486">The property is set to a culture name that cannot be used to locate a resource file.</span></span> <span data-ttu-id="3e1bf-487">Los nombres de archivo de recursos deben incluir solo letras, números, guiones o caracteres de subrayado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-487">Resource filenames must include only letters, numbers, hyphens or underscores.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-488">Solo .NET Core: no se admite la lectura o escritura de la referencia cultural de un subproceso desde otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-488">.NET Core only: Reading or writing the culture of a thread from another thread is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisableComObjectEagerCleanup">
      <MemberSignature Language="C#" Value="public void DisableComObjectEagerCleanup ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DisableComObjectEagerCleanup() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.DisableComObjectEagerCleanup" />
      <MemberSignature Language="VB.NET" Value="Public Sub DisableComObjectEagerCleanup ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DisableComObjectEagerCleanup();" />
      <MemberSignature Language="F#" Value="member this.DisableComObjectEagerCleanup : unit -&gt; unit" Usage="thread.DisableComObjectEagerCleanup " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-489">Desactiva la limpieza automática de contenedores RCW (Runtime Callable Wrappers) para el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-489">Turns off automatic cleanup of runtime callable wrappers (RCW) for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-490">De forma predeterminada, common language runtime (CLR) limpia los contenedores RCW de automáticamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-490">By default, the common language runtime (CLR) cleans up runtime callable wrappers automatically.</span></span> <span data-ttu-id="3e1bf-491">El CLR bombea los mensajes durante la limpieza, lo que podría producir problemas de reentrada de algunas aplicaciones que cumplen los criterios siguientes inusuales:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-491">The CLR pumps messages during the cleanup, which might cause reentrancy problems for a few applications that meet the following unusual criteria:</span></span>  
  
-   <span data-ttu-id="3e1bf-492">La aplicación realiza su propia distribución de mensajes.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-492">The application does its own message pumping.</span></span>  
  
-   <span data-ttu-id="3e1bf-493">La aplicación debe controlar con precisión cuando se produce la distribución de mensajes.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-493">The application needs to control precisely when message pumping occurs.</span></span>  
  
 <span data-ttu-id="3e1bf-494">Pueden usar estas aplicaciones las <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> método para evitar que el CLR de realizar una recuperación automática del tiempo de ejecución de contenedores RCW.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-494">Such applications can use the <xref:System.Threading.Thread.DisableComObjectEagerCleanup%2A> method to prevent the CLR from doing automatic reclamation of runtime callable wrappers.</span></span>  
  
 <span data-ttu-id="3e1bf-495">Cuando este método se ha llamado en un subproceso, la limpieza automática no se puede volver a habilitar para ese subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-495">When this method has been called on a thread, automatic cleanup cannot be re-enabled for that thread.</span></span> <span data-ttu-id="3e1bf-496">Cuando la aplicación está lista para limpiar los contenedores RCW, utilice el <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> método para indicar al runtime para limpiar todos los contenedores RCW en el contexto actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-496">When your application is ready to clean up runtime callable wrappers, use the <xref:System.Runtime.InteropServices.Marshal.CleanupUnusedObjectsInCurrentContext%2A?displayProperty=nameWithType> method to instruct the runtime to clean up all runtime callable wrappers in the current context.</span></span> <span data-ttu-id="3e1bf-497">Suministro de mensajes tiene lugar mientras se ejecuta el método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-497">Message pumping occurs while the method executes.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-498">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-498">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-499">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-499">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="EndCriticalRegion">
      <MemberSignature Language="C#" Value="public static void EndCriticalRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndCriticalRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndCriticalRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndCriticalRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndCriticalRegion();" />
      <MemberSignature Language="F#" Value="static member EndCriticalRegion : unit -&gt; unit" Usage="System.Threading.Thread.EndCriticalRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-500">Notifica a un host que la ejecución está a punto de entrar en una región de código donde los efectos de una anulación del subproceso o de una excepción no controlada se limitan a la tarea actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-500">Notifies a host that execution is about to enter a region of code in which the effects of a thread abort or unhandled exception are limited to the current task.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-501">Hosts de common language runtime (CLR), como Microsoft SQL Server 2005, pueden establecer directivas diferentes para los errores en regiones críticas y no críticas del código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-501">Hosts of the common language runtime (CLR), such as Microsoft SQL Server 2005, can establish different policies for failures in critical and non-critical regions of code.</span></span> <span data-ttu-id="3e1bf-502">Una región crítica es aquella en la que los efectos de una anulación de subproceso o una excepción no controlada pueden no limitarse a la tarea actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-502">A critical region is one in which the effects of a thread abort or an unhandled exception might not be limited to the current task.</span></span> <span data-ttu-id="3e1bf-503">Por el contrario, una anulación o un error en una región no crítica del código afecta a solo la tarea que se produce el error.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-503">By contrast, an abort or failure in a non-critical region of code affects only the task in which the error occurs.</span></span>  
  
 <span data-ttu-id="3e1bf-504">Por ejemplo, considere la posibilidad de una tarea que intenta asignar memoria mientras se mantiene un bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-504">For example, consider a task that attempts to allocate memory while holding a lock.</span></span> <span data-ttu-id="3e1bf-505">Si se produce un error en la asignación de memoria, la anulación de la tarea actual no es suficiente para garantizar la estabilidad de la <xref:System.AppDomain>, porque puede haber otras tareas en el dominio esperando el mismo bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-505">If the memory allocation fails, aborting the current task is not sufficient to ensure stability of the <xref:System.AppDomain>, because there can be other tasks in the domain waiting for the same lock.</span></span> <span data-ttu-id="3e1bf-506">Si se termina la tarea actual, otras tareas podrían sufrir un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-506">If the current task is terminated, other tasks could be deadlocked.</span></span>  
  
 <span data-ttu-id="3e1bf-507">Cuando se produce un error en una región crítica, el host puede optar por descargar toda la <xref:System.AppDomain> en lugar de correr el riesgo de continuar la ejecución en un estado potencialmente inestable.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-507">When a failure occurs in a critical region, the host might decide to unload the entire <xref:System.AppDomain> rather than take the risk of continuing execution in a potentially unstable state.</span></span> <span data-ttu-id="3e1bf-508">Para informar al host que el código está entrando en una región crítica, llame a <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-508">To inform the host that your code is entering a critical region, call <xref:System.Threading.Thread.BeginCriticalRegion%2A>.</span></span> <span data-ttu-id="3e1bf-509">Llamar a <xref:System.Threading.Thread.EndCriticalRegion%2A> cuando se devuelve a una región no crítica del código de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-509">Call <xref:System.Threading.Thread.EndCriticalRegion%2A> when execution returns to a non-critical region of code.</span></span>  
  
 <span data-ttu-id="3e1bf-510">Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-510">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-511">En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginCriticalRegion%2A> y <xref:System.Threading.Thread.EndCriticalRegion%2A> métodos para dividir un bloque de código en regiones críticas y no críticas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-511">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginCriticalRegion%2A> and <xref:System.Threading.Thread.EndCriticalRegion%2A> methods to divide a block of code into critical and non-critical regions.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginCriticalRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginCriticalRegion/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.BeginCriticalRegion" />
      </Docs>
    </Member>
    <Member MemberName="EndThreadAffinity">
      <MemberSignature Language="C#" Value="public static void EndThreadAffinity ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndThreadAffinity() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.EndThreadAffinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndThreadAffinity ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndThreadAffinity();" />
      <MemberSignature Language="F#" Value="static member EndThreadAffinity : unit -&gt; unit" Usage="System.Threading.Thread.EndThreadAffinity " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-512">Notifica a un host que el código administrado ha terminado de ejecutar instrucciones que dependen de la identidad del subproceso del sistema operativo físico actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-512">Notifies a host that managed code has finished executing instructions that depend on the identity of the current physical operating system thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-513">Algunos hosts de common language runtime, como Microsoft SQL Server 2005, proporcionan su propia administración de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-513">Some hosts of the common language runtime, such as Microsoft SQL Server 2005, provide their own thread management.</span></span> <span data-ttu-id="3e1bf-514">Un host que proporciona su propia administración de subprocesos puede mover una tarea en ejecución de un subproceso de sistema operativo físico a otro en cualquier momento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-514">A host that provides its own thread management can move an executing task from one physical operating system thread to another at any time.</span></span> <span data-ttu-id="3e1bf-515">Mayoría de las tareas no se ven afectada por este cambio.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-515">Most tasks are not affected by this switching.</span></span> <span data-ttu-id="3e1bf-516">Sin embargo, algunas tareas tienen afinidad de subprocesos, es decir, que dependen de la identidad de un subproceso físico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-516">However, some tasks have thread affinity - that is, they depend on the identity of a physical operating system thread.</span></span> <span data-ttu-id="3e1bf-517">Estas tareas deben informar al host cuando ejecuta código que no se debe cambiar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-517">These tasks must inform the host when they execute code that should not be switched.</span></span>  
  
 <span data-ttu-id="3e1bf-518">Por ejemplo, si la aplicación llama una API del sistema para adquirir un sistema operativo de bloqueo que tiene afinidad de subprocesos, como CRITICAL_SECTION de Win32, se debe llamar a <xref:System.Threading.Thread.BeginThreadAffinity%2A> antes de adquirir el bloqueo, y <xref:System.Threading.Thread.EndThreadAffinity%2A> después de liberar el bloqueo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-518">For example, if your application calls a system API to acquire an operating system lock that has thread affinity, such as a Win32 CRITICAL_SECTION, you must call <xref:System.Threading.Thread.BeginThreadAffinity%2A> before acquiring the lock, and <xref:System.Threading.Thread.EndThreadAffinity%2A> after releasing the lock.</span></span>  
  
 <span data-ttu-id="3e1bf-519">Con este método en el código que se ejecuta en SQL Server 2005 requiere que el código que se ejecutará en el nivel más alto de protección de host.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-519">Using this method in code that runs under SQL Server 2005 requires the code to be run at the highest host protection level.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-520">En el ejemplo siguiente se muestra el uso de la <xref:System.Threading.Thread.BeginThreadAffinity%2A> y <xref:System.Threading.Thread.EndThreadAffinity%2A> métodos para notificar a un host que un bloque de código depende de la identidad de un subproceso físico del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-520">The following example demonstrates the use of the <xref:System.Threading.Thread.BeginThreadAffinity%2A> and <xref:System.Threading.Thread.EndThreadAffinity%2A> methods to notify a host that a block of code depends on the identity of a physical operating system thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.BeginThreadAffinity#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.BeginThreadAffinity/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-521">El llamador no dispone del permiso requerido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-521">The caller does not have the required permission.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-522">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-522">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-523">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-523">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Threading.Thread.BeginThreadAffinity" />
      </Docs>
    </Member>
    <Member MemberName="ExecutionContext">
      <MemberSignature Language="C#" Value="public System.Threading.ExecutionContext ExecutionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.ExecutionContext ExecutionContext" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ExecutionContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ExecutionContext As ExecutionContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ExecutionContext ^ ExecutionContext { System::Threading::ExecutionContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ExecutionContext : System.Threading.ExecutionContext" Usage="System.Threading.Thread.ExecutionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ExecutionContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-524">Obtiene un objeto <see cref="T:System.Threading.ExecutionContext" /> que contiene información sobre los distintos contextos del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-524">Gets an <see cref="T:System.Threading.ExecutionContext" /> object that contains information about the various contexts of the current thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-525">Objeto <see cref="T:System.Threading.ExecutionContext" /> que consolida la información de contexto del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-525">An <see cref="T:System.Threading.ExecutionContext" /> object that consolidates context information for the current thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-526">La <xref:System.Threading.ExecutionContext> clase proporciona un único contenedor para toda la información relevante para un subproceso lógico de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-526">The <xref:System.Threading.ExecutionContext> class provides a single container for all information relevant to a logical thread of execution.</span></span> <span data-ttu-id="3e1bf-527">Esto incluye el contexto de seguridad, contexto de llamada, el contexto de sincronización, el contexto de localización y contexto de transacción.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-527">This includes security context, call context, synchronization context, localization context, and transaction context.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Thread ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Thread ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="thread.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-528">Se asegura de que los recursos se liberan y que se llevan a cabo otras operaciones de limpieza cuando el recolector de elementos no utilizados recupere el objeto <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-528">Ensures that resources are freed and other cleanup operations are performed when the garbage collector reclaims the <see cref="T:System.Threading.Thread" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-529">El recolector de elementos no utilizados llame al <xref:System.Threading.Thread.Finalize%2A> cuando el objeto actual está preparado para finalizarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-529">The garbage collector calls <xref:System.Threading.Thread.Finalize%2A> when the current object is ready to be finalized.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FreeNamedDataSlot">
      <MemberSignature Language="C#" Value="public static void FreeNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void FreeNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.FreeNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub FreeNamedDataSlot (name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void FreeNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member FreeNamedDataSlot : string -&gt; unit" Usage="System.Threading.Thread.FreeNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3e1bf-530">Nombre de la ranura de datos que se va a liberar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-530">The name of the data slot to be freed.</span></span></param>
        <summary><span data-ttu-id="3e1bf-531">Elimina la asociación entre un nombre y una ranura en todos los subprocesos del proceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-531">Eliminates the association between a name and a slot, for all threads in the process.</span></span> <span data-ttu-id="3e1bf-532">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-532">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-533">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-533">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-534">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-534">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-535">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-535">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-536">Después de cualquier subproceso llama a `FreeNamedDataSlot`, ningún otro subproceso que llama a <xref:System.Threading.Thread.GetNamedDataSlot%2A> con el mismo nombre que se asignará una nueva ranura asociada con el nombre.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-536">After any thread calls `FreeNamedDataSlot`, any other thread that calls <xref:System.Threading.Thread.GetNamedDataSlot%2A> with the same name will allocate a new slot associated with the name.</span></span> <span data-ttu-id="3e1bf-537">Las llamadas subsiguientes a `GetNamedDataSlot` cualquier subproceso devolverá el nuevo espacio.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-537">Subsequent calls to `GetNamedDataSlot` by any thread will return the new slot.</span></span> <span data-ttu-id="3e1bf-538">Sin embargo, cualquier subproceso que aún tiene un <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> devuelto por una llamada anterior a `GetNamedDataSlot` puede seguir usando la ranura anterior.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-538">However, any thread that still has a <xref:System.LocalDataStoreSlot?displayProperty=nameWithType> returned by an earlier call to `GetNamedDataSlot` can continue to use the old slot.</span></span>  
  
 <span data-ttu-id="3e1bf-539">Se libera una ranura que se ha asociado con el nombre solo cuando cada `LocalDataStoreSlot` que obtuvo antes de llamar a `FreeNamedDataSlot` se ha liberado y recolección.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-539">A slot that has been associated with a name is released only when every `LocalDataStoreSlot` that was obtained prior to the call to `FreeNamedDataSlot` has been released and garbage-collected.</span></span>  
  
 <span data-ttu-id="3e1bf-540">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-540">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-541">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-541">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-542">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-542">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="3e1bf-543">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-543">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-544">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-544">No other thread (not even a child thread) can get that data.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-545">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-545">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-546">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-546">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-547">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-547">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-548">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-548">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-549">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-549">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-550">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-550">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-551">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-551">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-552">El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-552">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-553">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-553">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-554">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-554">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetApartmentState">
      <MemberSignature Language="C#" Value="public System.Threading.ApartmentState GetApartmentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Threading.ApartmentState GetApartmentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetApartmentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetApartmentState () As ApartmentState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::ApartmentState GetApartmentState();" />
      <MemberSignature Language="F#" Value="member this.GetApartmentState : unit -&gt; System.Threading.ApartmentState" Usage="thread.GetApartmentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ApartmentState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-555">Devuelve un valor <see cref="T:System.Threading.ApartmentState" /> que indica el estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-555">Returns an <see cref="T:System.Threading.ApartmentState" /> value indicating the apartment state.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-556">Uno de los valores de <see cref="T:System.Threading.ApartmentState" /> que indica el estado del apartamento del subproceso administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-556">One of the <see cref="T:System.Threading.ApartmentState" /> values indicating the apartment state of the managed thread.</span></span> <span data-ttu-id="3e1bf-557">El valor predeterminado es <see cref="F:System.Threading.ApartmentState.Unknown" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-557">The default is <see cref="F:System.Threading.ApartmentState.Unknown" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-558">Este método, junto con el <xref:System.Threading.Thread.SetApartmentState%2A> método y el <xref:System.Threading.Thread.TrySetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-558">This method, along with the <xref:System.Threading.Thread.SetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-559">En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-559">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="3e1bf-560">El ejemplo de código crea un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-560">The code example creates a thread.</span></span> <span data-ttu-id="3e1bf-561">Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-561">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-562">El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-562">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="3e1bf-563">Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-563">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="3e1bf-564">Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-564">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="3e1bf-565">Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-565">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCompressedStack">
      <MemberSignature Language="C#" Value="public System.Threading.CompressedStack GetCompressedStack ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.CompressedStack GetCompressedStack() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCompressedStack" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCompressedStack () As CompressedStack" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::CompressedStack ^ GetCompressedStack();" />
      <MemberSignature Language="F#" Value="member this.GetCompressedStack : unit -&gt; System.Threading.CompressedStack" Usage="thread.GetCompressedStack " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.GetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.CompressedStack</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-566">Devuelve un objeto <see cref="T:System.Threading.CompressedStack" /> que se puede utilizar para capturar la pila correspondiente al subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-566">Returns a <see cref="T:System.Threading.CompressedStack" /> object that can be used to capture the stack for the current thread.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-567">Ninguno.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-567">None.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-568">Este método ya no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-568">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-569">En todos los casos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-569">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-570">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-570">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-571">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-571">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProcessorId">
      <MemberSignature Language="C#" Value="public static int GetCurrentProcessorId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentProcessorId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetCurrentProcessorId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentProcessorId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentProcessorId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentProcessorId : unit -&gt; int" Usage="System.Threading.Thread.GetCurrentProcessorId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public static object GetData (LocalDataStoreSlot slot);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object GetData(class System.LocalDataStoreSlot slot) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetData (slot As LocalDataStoreSlot) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ GetData(LocalDataStoreSlot ^ slot);" />
      <MemberSignature Language="F#" Value="static member GetData : LocalDataStoreSlot -&gt; obj" Usage="System.Threading.Thread.GetData slot" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="3e1bf-572">La <see cref="T:System.LocalDataStoreSlot" /> de donde se va a obtener el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-572">The <see cref="T:System.LocalDataStoreSlot" /> from which to get the value.</span></span></param>
        <summary><span data-ttu-id="3e1bf-573">Recupera el valor de la ranura especificada en el subproceso actual, dentro del dominio actual del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-573">Retrieves the value from the specified slot on the current thread, within the current thread's current domain.</span></span> <span data-ttu-id="3e1bf-574">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-574">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-575">El valor recuperado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-575">The retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-576">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-576">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-577">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-577">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-578">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-578">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-579">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-579">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-580">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-580">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-581">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-581">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="3e1bf-582">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-582">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-583">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-583">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-584"><xref:System.Threading.Thread.GetData%2A> es un `Shared` método que se aplica siempre que el subproceso actualmente en ejecución, incluso si se le llama mediante una variable que hace referencia a otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-584"><xref:System.Threading.Thread.GetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="3e1bf-585">Para evitar confusiones, utilice el nombre de clase al llamar a `Shared` métodos: `Dim test As Object = Thread.GetData(testSlot)`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-585">To avoid confusion, use the class name when calling `Shared` methods: `Dim test As Object = Thread.GetData(testSlot)`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-586">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-586">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-587">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-587">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-588">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-588">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-589">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-589">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-590">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-590">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-591">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-591">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-592">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-592">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-593">El ejemplo siguiente muestra cómo usar una ranura de datos para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-593">The following example demonstrates how to use a data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-594">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-594">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-595">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-595">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetDomain">
      <MemberSignature Language="C#" Value="public static AppDomain GetDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain GetDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomain () As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ GetDomain();" />
      <MemberSignature Language="F#" Value="static member GetDomain : unit -&gt; AppDomain" Usage="System.Threading.Thread.GetDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-596">Devuelve el dominio en el que se está ejecutando el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-596">Returns the current domain in which the current thread is running.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-597">Un <see cref="T:System.AppDomain" /> que representa el dominio de la aplicación actual del subproceso en ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-597">An <see cref="T:System.AppDomain" /> representing the current application domain of the running thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e1bf-598">El ejemplo de código siguiente muestra cómo recuperar el nombre e identificador de la `AppDomain` en que se está ejecutando el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-598">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetDomainID">
      <MemberSignature Language="C#" Value="public static int GetDomainID ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetDomainID() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetDomainID" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetDomainID () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetDomainID();" />
      <MemberSignature Language="F#" Value="static member GetDomainID : unit -&gt; int" Usage="System.Threading.Thread.GetDomainID " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-599">Devuelve un identificador único del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-599">Returns a unique application domain identifier.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-600">Entero de 32 bits con signo que identifica de forma unívoca el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-600">A 32-bit signed integer uniquely identifying the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="3e1bf-601">El ejemplo de código siguiente muestra cómo recuperar el nombre e identificador de la `AppDomain` en que se está ejecutando el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-601">The following code example shows how to retrieve the name and ID of the `AppDomain` in which the thread is running.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Domain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Domain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Domain/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Domain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Domain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="thread.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-602">Devuelve un código hash para el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-602">Returns a hash code for the current thread.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-603">Valor de código hash entero.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-603">An integer hash code value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-604">El código hash no se garantiza que sea único.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-604">The hash code is not guaranteed to be unique.</span></span> <span data-ttu-id="3e1bf-605">Use el <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad si necesita un identificador único para un subproceso administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-605">Use the <xref:System.Threading.Thread.ManagedThreadId%2A> property if you need a unique identifier for a managed thread.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetNamedDataSlot">
      <MemberSignature Language="C#" Value="public static LocalDataStoreSlot GetNamedDataSlot (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.LocalDataStoreSlot GetNamedDataSlot(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.GetNamedDataSlot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetNamedDataSlot (name As String) As LocalDataStoreSlot" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static LocalDataStoreSlot ^ GetNamedDataSlot(System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member GetNamedDataSlot : string -&gt; LocalDataStoreSlot" Usage="System.Threading.Thread.GetNamedDataSlot name" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.LocalDataStoreSlot</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="3e1bf-606">Nombre de la ranura de datos local.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-606">The name of the local data slot.</span></span></param>
        <summary><span data-ttu-id="3e1bf-607">Busca una ranura de datos con nombre.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-607">Looks up a named data slot.</span></span> <span data-ttu-id="3e1bf-608">Para mejorar el rendimiento, en su lugar use campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-608">For better performance, use fields that are marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-609">Una <see cref="T:System.LocalDataStoreSlot" /> asignada para este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-609">A <see cref="T:System.LocalDataStoreSlot" /> allocated for this thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-610">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-610">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-611">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-611">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-612">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-612">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-613">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-613">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-614">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-614">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-615">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para su reutilización después de que expire el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-615">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread expires.</span></span> <span data-ttu-id="3e1bf-616">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-616">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-617">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-617">No other thread (not even a child thread) can get that data.</span></span>  
  
 <span data-ttu-id="3e1bf-618">Si la ranura con nombre no existe, se asigna un nuevo espacio.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-618">If the named slot does not exist, a new slot is allocated.</span></span> <span data-ttu-id="3e1bf-619">Las ranuras de datos con nombre son públicas y se pueden manipular cualquier usuario.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-619">Named data slots are public and can be manipulated by anyone.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-620">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-620">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-621">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-621">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-622">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-622">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-623">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-623">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-624">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-624">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-625">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-625">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-626">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-626">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-627">El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-627">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-628">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-628">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-629">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-629">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Interrupt">
      <MemberSignature Language="C#" Value="public void Interrupt ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Interrupt() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Interrupt" />
      <MemberSignature Language="VB.NET" Value="Public Sub Interrupt ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Interrupt();" />
      <MemberSignature Language="F#" Value="member this.Interrupt : unit -&gt; unit" Usage="thread.Interrupt " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-630">Interrumpe un subproceso que se encuentra en estado de subproceso <see langword="WaitSleepJoin" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-630">Interrupts a thread that is in the <see langword="WaitSleepJoin" /> thread state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-631">Si este subproceso no está actualmente bloqueada en espera, suspensión o estado de unión, se interrumpirá cuando comienza a continuación bloquear.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-631">If this thread is not currently blocked in a wait, sleep, or join state, it will be interrupted when it next begins to block.</span></span>  
  
 <span data-ttu-id="3e1bf-632"><xref:System.Threading.ThreadInterruptedException> se produce en el subproceso interrumpido, pero no hasta que el subproceso se bloquea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-632"><xref:System.Threading.ThreadInterruptedException> is thrown in the interrupted thread, but not until the thread blocks.</span></span> <span data-ttu-id="3e1bf-633">Si el subproceso nunca se bloquea, nunca se produce la excepción y, por tanto, el subproceso podría finalizar sin ser interrumpido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-633">If the thread never blocks, the exception is never thrown, and thus the thread might complete without ever being interrupted.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-634">En el ejemplo de código siguiente se muestra el comportamiento de un subproceso en ejecución cuando se interrumpe y posteriormente se bloquea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-634">The following code example shows the behavior of a running thread when it is interrupted and subsequently gets blocked.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Interrupt#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Interrupt#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Interrupt#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Interrupt/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-635">El autor de la llamada no dispone del <see cref="T:System.Security.Permissions.SecurityPermission" /> adecuado</span><span class="sxs-lookup"><span data-stu-id="3e1bf-635">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-636">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-636">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-637">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-637">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <altmember cref="T:System.Threading.ThreadState" />
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="3e1bf-638">Pausa e interrupción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-638">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-639">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-639">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsAlive">
      <MemberSignature Language="C#" Value="public bool IsAlive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAlive" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsAlive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAlive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAlive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAlive : bool" Usage="System.Threading.Thread.IsAlive" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-640">Obtiene un valor que indica el estado de ejecución del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-640">Gets a value indicating the execution status of the current thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-641"><see langword="true" /> si el subproceso se ha iniciado y no ha terminado con normalidad o se ha anulado; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-641"><see langword="true" /> if this thread has been started and has not terminated normally or aborted; otherwise, <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsBackground">
      <MemberSignature Language="C#" Value="public bool IsBackground { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBackground" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsBackground" />
      <MemberSignature Language="VB.NET" Value="Public Property IsBackground As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBackground { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.IsBackground : bool with get, set" Usage="System.Threading.Thread.IsBackground" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-642">Obtiene o establece un valor que indica si un subproceso es o no un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-642">Gets or sets a value indicating whether or not a thread is a background thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-643"><see langword="true" /> si el subproceso es un subproceso en segundo plano o va a convertirse en un subproceso en segundo plano; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-643"><see langword="true" /> if this thread is or is to become a background thread; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-644">Un subproceso es un subproceso en segundo plano o en un subproceso en primer plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-644">A thread is either a background thread or a foreground thread.</span></span> <span data-ttu-id="3e1bf-645">Subprocesos en segundo plano son idénticos a los subprocesos de primer plano, salvo que los subprocesos en segundo plano no impiden que un proceso de terminación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-645">Background threads are identical to foreground threads, except that background threads do not prevent a process from terminating.</span></span> <span data-ttu-id="3e1bf-646">Una vez que han finalizado todos los subprocesos de primer plano que pertenecen a un proceso, common language runtime finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-646">Once all foreground threads belonging to a process have terminated, the common language runtime ends the process.</span></span> <span data-ttu-id="3e1bf-647">Los subprocesos en segundo plano restantes se detienen y no se completan.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-647">Any remaining background threads are stopped and do not complete.</span></span>  
  
 <span data-ttu-id="3e1bf-648">De forma predeterminada, los subprocesos siguientes se ejecutan en primer plano (es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedad devuelve `false`):</span><span class="sxs-lookup"><span data-stu-id="3e1bf-648">By default, the following threads execute in the foreground (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `false`):</span></span>  
  
-   <span data-ttu-id="3e1bf-649">El subproceso principal (o subproceso de aplicación principal).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-649">The primary thread (or main application thread).</span></span>  
  
-   <span data-ttu-id="3e1bf-650">Todos los subprocesos creados mediante una llamada a un <xref:System.Threading.Thread> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-650">All threads created by calling a <xref:System.Threading.Thread> class constructor.</span></span>  
  
 <span data-ttu-id="3e1bf-651">De forma predeterminada, los subprocesos siguientes se ejecutan en segundo plano (es decir, sus <xref:System.Threading.Thread.IsBackground%2A> propiedad devuelve `true`):</span><span class="sxs-lookup"><span data-stu-id="3e1bf-651">By default, the following threads execute in the background  (that is, their <xref:System.Threading.Thread.IsBackground%2A> property returns `true`):</span></span>  
  
-   <span data-ttu-id="3e1bf-652">El subproceso del grupo de subprocesos, que son un grupo de subprocesos de trabajo mantenidas el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-652">Thread pool threads, which are a pool of worker threads maintained by the runtime.</span></span> <span data-ttu-id="3e1bf-653">Puede configurar el trabajo del subproceso de grupo y la programación de subprocesos de grupo mediante la <xref:System.Threading.ThreadPool> clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-653">You can configure the thread pool and schedule work on thread pool threads by using the <xref:System.Threading.ThreadPool> class.</span></span>  
  
    > [!NOTE]
    >  <span data-ttu-id="3e1bf-654">Operaciones asincrónicas basadas en la tarea se ejecutan automáticamente en subprocesos de grupo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-654">Task-based asynchronous operations automatically execute on thread pool threads.</span></span>  
  
-   <span data-ttu-id="3e1bf-655">Todos los subprocesos que entran en el entorno de ejecución administrado desde código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-655">All threads that enter the managed execution environment from unmanaged code.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-656">El ejemplo siguiente compara el comportamiento de los subprocesos de primer y segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-656">The following example contrasts the behavior of foreground and background threads.</span></span> <span data-ttu-id="3e1bf-657">Crea un subproceso en primer plano y un subproceso en segundo plano.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-657">It creates a foreground thread and a background thread.</span></span> <span data-ttu-id="3e1bf-658">El subproceso en primer plano mantiene el proceso que se ejecuta hasta que finalice su `for` un bucle y termina.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-658">The foreground thread keeps the process running until completes its `for` loop and terminates.</span></span> <span data-ttu-id="3e1bf-659">Sin embargo, como se muestra el resultado del ejemplo, porque el subproceso en primer plano ha terminado de ejecutarse, el proceso finaliza antes de que el subproceso en segundo plano ha finalizado su ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-659">However, as the output from the example shows, because the foreground thread has finished execution, the process is terminated before the background thread has completed execution.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsBackground#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsBackground#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsBackground#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsBackground/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-660">El proceso está inactivo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-660">The thread is dead.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/foreground-and-background-threads.md"><span data-ttu-id="3e1bf-661">Subprocesos de primer y segundo plano</span><span class="sxs-lookup"><span data-stu-id="3e1bf-661">Foreground and Background Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsThreadPoolThread">
      <MemberSignature Language="C#" Value="public bool IsThreadPoolThread { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsThreadPoolThread" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.IsThreadPoolThread" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsThreadPoolThread As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsThreadPoolThread { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsThreadPoolThread : bool" Usage="System.Threading.Thread.IsThreadPoolThread" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-662">Obtiene un valor que indica si un subproceso pertenece al grupo de subprocesos administrados o no.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-662">Gets a value indicating whether or not a thread belongs to the managed thread pool.</span></span></summary>
        <value><span data-ttu-id="3e1bf-663"><see langword="true" /> si el subproceso pertenece al grupo de subprocesos administrados; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-663"><see langword="true" /> if this thread belongs to the managed thread pool; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-664">Para obtener más información, consulte [el grupo de subprocesos administrados](~/docs/standard/threading/the-managed-thread-pool.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-664">For more information see [The managed thread pool](~/docs/standard/threading/the-managed-thread-pool.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-665">El ejemplo de código siguiente muestra cómo determinar si es un subproceso del grupo de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-665">The following code example shows how to determine whether a thread is from the thread pool.</span></span>  
  
 [!code-cpp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.IsThreadPoolThread#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.IsThreadPoolThread/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Threading.ThreadPool" />
        <related type="Article" href="~/docs/standard/threading/the-managed-thread-pool.md"><span data-ttu-id="3e1bf-666">Grupo de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-666">The Managed Thread Pool</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Join">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-667">Bloquea el subproceso de llamada hasta que finaliza el subproceso representado por esta instancia.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-667">Blocks the calling thread until the thread represented by this instance terminates.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public void Join ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Join() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join" />
      <MemberSignature Language="VB.NET" Value="Public Sub Join ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Join();" />
      <MemberSignature Language="F#" Value="member this.Join : unit -&gt; unit" Usage="thread.Join " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-668">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza, pero continúa bombeando <see langword="SendMessage" /> y COM estándar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-668">Blocks the calling thread until the thread represented by this instance terminates, while continuing to perform standard COM and <see langword="SendMessage" /> pumping.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-669"><xref:System.Threading.Thread.Join%2A> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-669"><xref:System.Threading.Thread.Join%2A> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed.</span></span> <span data-ttu-id="3e1bf-670">Utilice este método para asegurarse de que un subproceso ha finalizado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-670">Use this method to ensure that a thread has been terminated.</span></span> <span data-ttu-id="3e1bf-671">El llamador se bloquee indefinidamente si el subproceso no termina.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-671">The caller will block indefinitely if the thread does not terminate.</span></span> <span data-ttu-id="3e1bf-672">En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` al bloque hasta `Thread2` se ha completado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-672">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block until `Thread2` has completed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1a.cs#1)]
 [!code-vb[System.Threading.Thread.Join#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1a.vb#1)]  
  
 <span data-ttu-id="3e1bf-673">Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-673">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
> [!WARNING]
>  <span data-ttu-id="3e1bf-674">Nunca debe llamar a la <xref:System.Threading.Thread.Join%2A> método de la <xref:System.Threading.Thread> objeto que representa el subproceso actual del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-674">You should never call the <xref:System.Threading.Thread.Join%2A> method of the <xref:System.Threading.Thread> object that represents the current thread from the current thread.</span></span> <span data-ttu-id="3e1bf-675">Esto hace que la aplicación deje de responder porque el subproceso actual espera a sí mismo indefinidamente,</span><span class="sxs-lookup"><span data-stu-id="3e1bf-675">This causes your app to hang because the current thread waits upon itself indefinitely,</span></span>  
  
 <span data-ttu-id="3e1bf-676">Este método cambia el estado del subproceso que realiza la llamada debe incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-676">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-677">No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-677">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-678">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-678">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadInterruptedException"><span data-ttu-id="3e1bf-679">El subproceso se interrumpe mientras espera.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-679">The thread is interrupted while waiting.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-680">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-680">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (millisecondsTimeout As Integer) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="member this.Join : int -&gt; bool" Usage="thread.Join millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="3e1bf-681">Número de milisegundos durante los que se va a esperar a que el subproceso finalice.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-681">The number of milliseconds to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="3e1bf-682">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-682">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-683"><see langword="true" /> si el subproceso ha terminado; <see langword="false" /> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <paramref name="millisecondsTimeout" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-683"><see langword="true" /> if the thread has terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="millisecondsTimeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-684"><xref:System.Threading.Thread.Join%28System.Int32%29> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-684"><xref:System.Threading.Thread.Join%28System.Int32%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="3e1bf-685">En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` para bloquear hasta que `Thread2` se ha completado o hayan transcurrido 2 segundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-685">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1b.cs#2)]
 [!code-vb[System.Threading.Thread.Join#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1b.vb#2)]  
  
 <span data-ttu-id="3e1bf-686">Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> se especifica para el `millisecondsTimeout` parámetro, este método se comporta igual que el <xref:System.Threading.Thread.Join> sobrecarga del método, excepto para el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-686">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for the `millisecondsTimeout` parameter, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="3e1bf-687">Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-687">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="3e1bf-688">Este método cambia el estado del subproceso que realiza la llamada debe incluir <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-688">This method changes the state of the calling thread to include <xref:System.Threading.ThreadState.WaitSleepJoin?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-689">No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-689">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-690">El valor de <paramref name="millisecondsTimeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-690">The value of <paramref name="millisecondsTimeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-691">No se ha iniciado el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-691">The thread has not been started.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-692">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-692">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Join">
      <MemberSignature Language="C#" Value="public bool Join (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Join(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Join(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function Join (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Join(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.Join : TimeSpan -&gt; bool" Usage="thread.Join timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3e1bf-693">Un <see cref="T:System.TimeSpan" /> establecido en el período de tiempo durante el que se esperará a que espere el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-693">A <see cref="T:System.TimeSpan" /> set to the amount of time to wait for the thread to terminate.</span></span></param>
        <summary><span data-ttu-id="3e1bf-694">Bloquea el subproceso de llamada hasta que el subproceso representado por esta instancia finaliza o transcurre el tiempo especificado, pero continúa bombeando SendMessage y COM estándar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-694">Blocks the calling thread until the thread represented by this instance terminates or the specified time elapses, while continuing to perform standard COM and SendMessage pumping.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-695"><see langword="true" /> si el subproceso ha terminado; <see langword="false" /> si el subproceso no ha terminado una vez transcurrido el período de tiempo especificado por el parámetro <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-695"><see langword="true" /> if the thread terminated; <see langword="false" /> if the thread has not terminated after the amount of time specified by the <paramref name="timeout" /> parameter has elapsed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> es un método de sincronización que bloquea el subproceso que realiza la llamada (es decir, el subproceso que llama al método) hasta que el subproceso de cualquier cuyo <xref:System.Threading.Thread.Join%2A> se llama al método se ha completado o ha transcurrido el intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-696"><xref:System.Threading.Thread.Join%28System.TimeSpan%29> is a synchronization method that blocks the calling thread (that is, the thread that calls the method) until either the thread whose <xref:System.Threading.Thread.Join%2A> method is called has completed or the time-out interval has elapsed.</span></span> <span data-ttu-id="3e1bf-697">En el ejemplo siguiente, la `Thread1` subproceso llama a la <xref:System.Threading.Thread.Join> método `Thread2`, lo que hace que `Thread1` para bloquear hasta que `Thread2` se ha completado o hayan transcurrido 2 segundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-697">In the following example, the `Thread1` thread calls the <xref:System.Threading.Thread.Join> method of `Thread2`, which causes `Thread1` to block either until `Thread2` has completed or 2 seconds have elapsed.</span></span>  
  
 [!code-csharp[System.Threading.Thread.Join#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.join/cs/join1c.cs#3)]
 [!code-vb[System.Threading.Thread.Join#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.join/vb/join1c.vb#3)]  
  
 <span data-ttu-id="3e1bf-698">Si <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> se especifica para `timeout`, este método se comporta igual que el <xref:System.Threading.Thread.Join> sobrecarga del método, excepto para el valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-698">If <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> is specified for `timeout`, this method behaves identically to the <xref:System.Threading.Thread.Join> method overload, except for the return value.</span></span>  
  
 <span data-ttu-id="3e1bf-699">Si el subproceso ya ha terminado cuando <xref:System.Threading.Thread.Join%2A> se llama, el método vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-699">If the thread has already terminated when <xref:System.Threading.Thread.Join%2A> is called, the method returns immediately.</span></span>  
  
 <span data-ttu-id="3e1bf-700">Este método cambia el estado del subproceso actual para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-700">This method changes the state of the current thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span> <span data-ttu-id="3e1bf-701">No se puede invocar `Join` en un subproceso que está en el <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> estado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-701">You cannot invoke `Join` on a thread that is in the <xref:System.Threading.ThreadState.Unstarted?displayProperty=nameWithType> state.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-702">En el ejemplo de código siguiente se muestra cómo usar un `TimeSpan` valor con el `Join` método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-702">The following code example demonstrates how to use a `TimeSpan` value with the `Join` method.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Timespan#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Timespan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Timespan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Timespan/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-703">El valor de <paramref name="timeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos, o es superior a <see cref="F:System.Int32.MaxValue" /> milisegundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-703">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-704">El autor de la llamada ha intentado combinar un subproceso que se encuentra en el estado <see cref="F:System.Threading.ThreadState.Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-704">The caller attempted to join a thread that is in the <see cref="F:System.Threading.ThreadState.Unstarted" /> state.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-705">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-705">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ManagedThreadId">
      <MemberSignature Language="C#" Value="public int ManagedThreadId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ManagedThreadId" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ManagedThreadId" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ManagedThreadId As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ManagedThreadId { int get(); };" />
      <MemberSignature Language="F#" Value="member this.ManagedThreadId : int" Usage="System.Threading.Thread.ManagedThreadId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-706">Obtiene un identificador único para el actual subproceso administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-706">Gets a unique identifier for the current managed thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-707">Entero que representa un identificador único para este subproceso administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-707">An integer that represents a unique identifier for this managed thread.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-708">Un subproceso <xref:System.Threading.Thread.ManagedThreadId%2A> valor de propiedad sirve para identificar de forma exclusiva ese subproceso dentro de su proceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-708">A thread's <xref:System.Threading.Thread.ManagedThreadId%2A> property value serves to uniquely identify that thread within its process.</span></span>  
  
 <span data-ttu-id="3e1bf-709">El valor de la <xref:System.Threading.Thread.ManagedThreadId%2A> propiedad no varía con el tiempo, incluso si el código no administrado que hospeda common language runtime implementa el subproceso como una fibra.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-709">The value of the <xref:System.Threading.Thread.ManagedThreadId%2A> property does not vary over time, even if unmanaged code that hosts the common language runtime implements the thread as a fiber.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MemoryBarrier">
      <MemberSignature Language="C#" Value="public static void MemoryBarrier ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void MemoryBarrier() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.MemoryBarrier" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub MemoryBarrier ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void MemoryBarrier();" />
      <MemberSignature Language="F#" Value="static member MemoryBarrier : unit -&gt; unit" Usage="System.Threading.Thread.MemoryBarrier " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-710">Sincroniza el acceso a la memoria de la siguiente forma: el procesador que ejecuta el subproceso actual no puede reordenar las instrucciones de forma que los accesos a la memoria anteriores a la llamada a <see cref="M:System.Threading.Thread.MemoryBarrier" /> se ejecuten después de los accesos a memoria que siguen a la llamada a <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-710">Synchronizes memory access as follows: The processor executing the current thread cannot reorder instructions in such a way that memory accesses prior to the call to <see cref="M:System.Threading.Thread.MemoryBarrier" /> execute after memory accesses that follow the call to <see cref="M:System.Threading.Thread.MemoryBarrier" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-711"><xref:System.Threading.Thread.MemoryBarrier%2A> solo es necesario en sistemas multiprocesador con ordenación (por ejemplo, un sistema que utilice varios procesadores Intel Itanium) de memoria débil.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-711"><xref:System.Threading.Thread.MemoryBarrier%2A> is required only on multiprocessor systems with weak memory ordering (for example, a system employing multiple Intel Itanium processors).</span></span>  
  
 <span data-ttu-id="3e1bf-712">Para la mayoría de los casos, C# `lock` instrucción, Visual Basic `SyncLock` instrucción, o la <xref:System.Threading.Monitor> clase proporcionan formas sencillas para sincronizar los datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-712">For most purposes, the C# `lock` statement, the Visual Basic `SyncLock` statement, or the <xref:System.Threading.Monitor> class provide easier ways to synchronize data.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Name : string with get, set" Usage="System.Threading.Thread.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-713">Obtiene o establece el nombre del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-713">Gets or sets the name of the thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-714">Cadena que contiene el nombre del subproceso o <see langword="null" /> si no se ha establecido ningún nombre.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-714">A string containing the name of the thread, or <see langword="null" /> if no name was set.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-715">Esta propiedad es de escritura: una vez.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-715">This property is write-once.</span></span> <span data-ttu-id="3e1bf-716">Dado que el valor predeterminado de un subproceso <xref:System.Threading.Thread.Name%2A> propiedad es `null`, puede determinar si un nombre ya se han explícitamente asignado al subproceso comparándola con `null`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-716">Because the default value of a thread's <xref:System.Threading.Thread.Name%2A> property is `null`, you can determine whether a name has already been explicitly assigned to the thread by comparing it with `null`.</span></span>  
  
 <span data-ttu-id="3e1bf-717">La cadena asignada a la <xref:System.Threading.Thread.Name%2A> propiedad puede incluir cualquier carácter Unicode.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-717">The string assigned to the <xref:System.Threading.Thread.Name%2A> property can include any Unicode character.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-718">El ejemplo siguiente muestra cómo denominar un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-718">The following example shows how to name a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.Name#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.Name#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.Name/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.Name#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.Name/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-719">Se solicitó una operación Set, pero ya se ha establecido la propiedad <see langword="Name" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-719">A set operation was requested, but the <see langword="Name" /> property has already been set.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Priority">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadPriority Priority { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadPriority Priority" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.Priority" />
      <MemberSignature Language="VB.NET" Value="Public Property Priority As ThreadPriority" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadPriority Priority { System::Threading::ThreadPriority get(); void set(System::Threading::ThreadPriority value); };" />
      <MemberSignature Language="F#" Value="member this.Priority : System.Threading.ThreadPriority with get, set" Usage="System.Threading.Thread.Priority" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>set: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadPriority</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-720">Obtiene o establece un valor que indica la prioridad de programación de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-720">Gets or sets a value indicating the scheduling priority of a thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-721">Uno de los valores de <see cref="T:System.Threading.ThreadPriority" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-721">One of the <see cref="T:System.Threading.ThreadPriority" /> values.</span></span> <span data-ttu-id="3e1bf-722">El valor predeterminado es <see cref="F:System.Threading.ThreadPriority.Normal" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-722">The default value is <see cref="F:System.Threading.ThreadPriority.Normal" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-723">Un subproceso se puede asignar cualquiera de la siguiente prioridad <xref:System.Threading.ThreadPriority> valores:</span><span class="sxs-lookup"><span data-stu-id="3e1bf-723">A thread can be assigned any one of the following priority <xref:System.Threading.ThreadPriority> values:</span></span>  
  
-   `Highest`  
  
-   `AboveNormal`  
  
-   `Normal`  
  
-   `BelowNormal`  
  
-   `Lowest`  
  
 <span data-ttu-id="3e1bf-724">Sistemas operativos no tienen que respeta la prioridad de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-724">Operating systems are not required to honor the priority of a thread.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-725">El ejemplo siguiente muestra el resultado de cambiar la prioridad de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-725">The following example shows the result of changing the priority of a thread.</span></span> <span data-ttu-id="3e1bf-726">Se crean tres subprocesos, se establece la prioridad de un subproceso en <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, y la prioridad de segundo se establece en <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-726">Three threads are created, the priority of one thread is set to <xref:System.Threading.ThreadPriority.BelowNormal?displayProperty=nameWithType>, and the priority of a second is set to <xref:System.Threading.ThreadPriority.AboveNormal?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-727">Cada subproceso incrementa una variable en un `while` bucle y se ejecuta durante un tiempo establecido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-727">Each thread increments a variable in a `while` loop and runs for a set time.</span></span>  
  
 [!code-csharp[System.Threading.ThreadPriority#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Threading.ThreadPriority/cs/Example1.cs#1)]
 [!code-vb[System.Threading.ThreadPriority#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Threading.ThreadPriority/vb/Example1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-728">El subproceso ha alcanzado un estado final, como <see cref="F:System.Threading.ThreadState.Aborted" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-728">The thread has reached a final state, such as <see cref="F:System.Threading.ThreadState.Aborted" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-729">El valor especificado para un operación set no es un valor <see cref="T:System.Threading.ThreadPriority" /> válido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-729">The value specified for a set operation is not a valid <see cref="T:System.Threading.ThreadPriority" /> value.</span></span></exception>
        <altmember cref="T:System.Threading.ThreadPriority" />
        <related type="Article" href="~/docs/standard/threading/scheduling-threads.md"><span data-ttu-id="3e1bf-730">Programación de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-730">Scheduling threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ResetAbort">
      <MemberSignature Language="C#" Value="public static void ResetAbort ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ResetAbort() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.ResetAbort" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ResetAbort ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ResetAbort();" />
      <MemberSignature Language="F#" Value="static member ResetAbort : unit -&gt; unit" Usage="System.Threading.Thread.ResetAbort " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-731">Cancela un método <see cref="M:System.Threading.Thread.Abort(System.Object)" /> solicitado para el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-731">Cancels an <see cref="M:System.Threading.Thread.Abort(System.Object)" /> requested for the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-732">Este método solo se puede llamar mediante código con los permisos adecuados.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-732">This method can only be called by code with the proper permissions.</span></span>  
  
 <span data-ttu-id="3e1bf-733">Cuando se realiza una llamada a `Abort` para terminar un subproceso, el sistema produce una <xref:System.Threading.ThreadAbortException>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-733">When a call is made to `Abort` to terminate a thread, the system throws a <xref:System.Threading.ThreadAbortException>.</span></span> <span data-ttu-id="3e1bf-734">`ThreadAbortException` es una excepción especial que puede detectar el código de la aplicación, pero se vuelve a producir al final del bloque catch a menos que `ResetAbort` se llama.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-734">`ThreadAbortException` is a special exception that can be caught by application code, but is rethrown at the end of the catch block unless `ResetAbort` is called.</span></span> <span data-ttu-id="3e1bf-735">`ResetAbort` cancela la solicitud de anulación y evita la `ThreadAbortException` de finalización del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-735">`ResetAbort` cancels the request to abort, and prevents the `ThreadAbortException` from terminating the thread.</span></span>  
  
 <span data-ttu-id="3e1bf-736">Consulte <xref:System.Threading.ThreadAbortException> para obtener un ejemplo que muestra cómo llamar a la `ResetAbort` método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-736">See <xref:System.Threading.ThreadAbortException> for an example that demonstrates calling the `ResetAbort` method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-737">Solo .NET Core: este miembro no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-737">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-738"><see langword="Abort" /> no se invocó en el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-738"><see langword="Abort" /> was not invoked on the current thread.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-739">El autor de la llamada no tiene el permiso de seguridad necesario para el subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-739">The caller does not have the required security permission for the current thread.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-740">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-740">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-741">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-741">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/destroying-threads.md"><span data-ttu-id="3e1bf-742">Destrucción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-742">Destroying threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-743">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-743">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="thread.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Resume has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-744">Reanuda un subproceso que se ha suspendido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-744">Resumes a thread that has been suspended.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!CAUTION]
>  <span data-ttu-id="3e1bf-745">No utilice el <xref:System.Threading.Thread.Suspend%2A> y <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar las actividades de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-745">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="3e1bf-746">No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se suspende.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-746">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="3e1bf-747">Si se suspende un subproceso mientras mantiene bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <xref:System.AppDomain> podría bloquearse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-747">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="3e1bf-748">Si se suspende un subproceso mientras se esté ejecutando un constructor de clase, otros subprocesos en la <xref:System.AppDomain> que intentan usar que se bloquean la clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-748">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="3e1bf-749">Pueden producirse interbloqueos muy fácilmente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-749">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-750">Solo .NET Core: este miembro no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-750">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-751">El subproceso no se ha iniciado, está inactivo o no está en estado suspendido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-751">The thread has not been started, is dead, or is not in the suspended state.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-752">El autor de la llamada no dispone del <see cref="T:System.Security.Permissions.SecurityPermission" /> adecuado</span><span class="sxs-lookup"><span data-stu-id="3e1bf-752">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-753">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-753">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-754">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span><span class="sxs-lookup"><span data-stu-id="3e1bf-754">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" /></span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="3e1bf-755">Pausa e interrupción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-755">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-756">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-756">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetApartmentState">
      <MemberSignature Language="C#" Value="public void SetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetApartmentState (state As ApartmentState)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.SetApartmentState : System.Threading.ApartmentState -&gt; unit" Usage="thread.SetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="3e1bf-757">Nuevo estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-757">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="3e1bf-758">Establece el estado del apartamento de un subproceso antes de iniciarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-758">Sets the apartment state of a thread before it is started.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-759">Los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-759">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="3e1bf-760">Estado del apartamento se debe establecer antes de que se inicia un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-760">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-761">El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-761">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="3e1bf-762">La única forma de establecer el estado del apartamento del subproceso principal de la aplicación para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste en aplicar el <xref:System.STAThreadAttribute> atributo al método de punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-762">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="3e1bf-763">El <xref:System.Threading.Thread.SetApartmentState%2A> método, junto con el <xref:System.Threading.Thread.GetApartmentState%2A> método y el <xref:System.Threading.Thread.TrySetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-763">The <xref:System.Threading.Thread.SetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.TrySetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-764">En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-764">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="3e1bf-765">El ejemplo de código crea un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-765">The code example creates a thread.</span></span> <span data-ttu-id="3e1bf-766">Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-766">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-767">El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-767">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="3e1bf-768">Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-768">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="3e1bf-769">Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-769">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="3e1bf-770">Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-770">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-771">Solo .NET Core: este miembro no se admite en las plataformas macOS y Linux.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-771">.NET Core only: This member is not supported on the macOS and Linux platforms.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-772"><paramref name="state" /> no es un estado del apartamento válido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-772"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-773">Ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-773">The thread has already been started.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-774">El estado de apartamento ya se inicializó.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-774">The apartment state has already been initialized.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetCompressedStack">
      <MemberSignature Language="C#" Value="public void SetCompressedStack (System.Threading.CompressedStack stack);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetCompressedStack(class System.Threading.CompressedStack stack) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetCompressedStack(System.Threading.CompressedStack)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCompressedStack (stack As CompressedStack)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetCompressedStack(System::Threading::CompressedStack ^ stack);" />
      <MemberSignature Language="F#" Value="member this.SetCompressedStack : System.Threading.CompressedStack -&gt; unit" Usage="thread.SetCompressedStack stack" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.SetCompressedStack is no longer supported. Please use the System.Threading.CompressedStack class")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stack" Type="System.Threading.CompressedStack" />
      </Parameters>
      <Docs>
        <param name="stack"><span data-ttu-id="3e1bf-775">Objeto <see cref="T:System.Threading.CompressedStack" /> que va a aplicarse al subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-775">The <see cref="T:System.Threading.CompressedStack" /> object to be applied to the current thread.</span></span></param>
        <summary><span data-ttu-id="3e1bf-776">Aplica un objeto <see cref="T:System.Threading.CompressedStack" /> capturado al subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-776">Applies a captured <see cref="T:System.Threading.CompressedStack" /> to the current thread.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-777">Este método ya no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-777">This method is no longer supported.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-778">En todos los casos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-778">In all cases.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3e1bf-779">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-779">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="3e1bf-780">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-780">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public static void SetData (LocalDataStoreSlot slot, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetData(class System.LocalDataStoreSlot slot, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SetData(System.LocalDataStoreSlot,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetData (slot As LocalDataStoreSlot, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetData(LocalDataStoreSlot ^ slot, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="static member SetData : LocalDataStoreSlot * obj -&gt; unit" Usage="System.Threading.Thread.SetData (slot, data)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="slot" Type="System.LocalDataStoreSlot" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="slot"><span data-ttu-id="3e1bf-781">La <see cref="T:System.LocalDataStoreSlot" /> donde se va a establecer el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-781">The <see cref="T:System.LocalDataStoreSlot" /> in which to set the value.</span></span></param>
        <param name="data"><span data-ttu-id="3e1bf-782">Valor que se va a establecer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-782">The value to be set.</span></span></param>
        <summary><span data-ttu-id="3e1bf-783">Establece los datos de la ranura especificada en el subproceso actualmente en ejecución, para el dominio actual de dicho subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-783">Sets the data in the specified slot on the currently running thread, for that thread's current domain.</span></span> <span data-ttu-id="3e1bf-784">Para obtener un mejor rendimiento, utilice en su lugar los campos marcados con el atributo <see cref="T:System.ThreadStaticAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-784">For better performance, use fields marked with the <see cref="T:System.ThreadStaticAttribute" /> attribute instead.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-785">.NET Framework proporciona dos mecanismos para el uso de almacenamiento local de subprocesos (TLS): campos estáticos relacionados con subprocesos (es decir, los campos marcados con el <xref:System.ThreadStaticAttribute> atributo) y las ranuras de datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-785">The .NET Framework provides two mechanisms for using thread local storage (TLS): thread-relative static fields (that is, fields that are marked with the <xref:System.ThreadStaticAttribute> attribute) and data slots.</span></span> <span data-ttu-id="3e1bf-786">Campos estáticos relacionados con subprocesos proporcionan un rendimiento mucho mejor que las ranuras de datos y habilitar la comprobación de tipos en tiempo de compilación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-786">Thread-relative static fields provide much better performance than data slots, and enable compile-time type checking.</span></span> <span data-ttu-id="3e1bf-787">Para obtener más información sobre el uso de TLS, consulte [almacenamiento Local de subprocesos: campos estáticos relacionados con subprocesos y ranuras de datos](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-787">For more information about using TLS, see [Thread Local Storage: Thread-Relative Static Fields and Data Slots](~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md).</span></span>  
  
 <span data-ttu-id="3e1bf-788">Subprocesos utilizan un mecanismo de memoria de almacenamiento local para almacenar datos específicos del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-788">Threads use a local store memory mechanism to store thread-specific data.</span></span> <span data-ttu-id="3e1bf-789">Common language runtime asigna una matriz de almacenamiento de datos de varias ranuras para cada proceso cuando se crea.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-789">The common language runtime allocates a multi-slot data store array to each process when it is created.</span></span> <span data-ttu-id="3e1bf-790">El subproceso puede asignar una ranura de datos del almacén de datos, almacenar y recuperar datos de un valor en la ranura y liberar la ranura para volver a usarse una vez finalizado el procedimiento de subproceso y el <xref:System.Threading.Thread> objeto se ha recuperado por la recolección.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-790">The thread can allocate a data slot in the data store, store and retrieve a data value in the slot, and free the slot for reuse after the thread procedure ends and the <xref:System.Threading.Thread> object has been reclaimed by garbage collection.</span></span> <span data-ttu-id="3e1bf-791">Las ranuras de datos son únicas para cada subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-791">Data slots are unique per thread.</span></span> <span data-ttu-id="3e1bf-792">Ningún otro subproceso (ni siquiera un subproceso secundario) puede obtener esos datos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-792">No other thread (not even a child thread) can get that data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-793"><xref:System.Threading.Thread.SetData%2A> es un `Shared` método que se aplica siempre que el subproceso actualmente en ejecución, incluso si se le llama mediante una variable que hace referencia a otro subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-793"><xref:System.Threading.Thread.SetData%2A> is a `Shared` method that always applies to the currently executing thread, even if you call it using a variable that refers to another thread.</span></span> <span data-ttu-id="3e1bf-794">Para evitar confusiones, utilice el nombre de clase al llamar a `Shared` métodos: `Thread.SetData(testSlot, "test data")`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-794">To avoid confusion, use the class name when calling `Shared` methods: `Thread.SetData(testSlot, "test data")`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-795">Esta sección contiene dos ejemplos de código.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-795">This section contains two code examples.</span></span> <span data-ttu-id="3e1bf-796">El primer ejemplo muestra cómo usar un campo que está marcado con el <xref:System.ThreadStaticAttribute> atributo para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-796">The first example shows how to use a field that is marked with the <xref:System.ThreadStaticAttribute> attribute to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-797">El segundo ejemplo muestra cómo usar una ranura de datos para hacer lo mismo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-797">The second example shows how to use a data slot to do the same thing.</span></span>  
  
 <span data-ttu-id="3e1bf-798">**Primer ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-798">**First Example**</span></span>  
  
 <span data-ttu-id="3e1bf-799">En el ejemplo siguiente se muestra cómo usar un campo que está marcado con <xref:System.ThreadStaticAttribute> para almacenar información específica de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-799">The following example shows how to use a field that is marked with <xref:System.ThreadStaticAttribute> to hold thread-specific information.</span></span> <span data-ttu-id="3e1bf-800">Esta técnica proporciona mejor rendimiento que la técnica que se muestra en el segundo ejemplo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-800">This technique provides better performance than the technique that is shown in the second example.</span></span>  
  
 [!code-cpp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.DoNotUseDataSlots#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.DoNotUseDataSlots/vb/source.vb#1)]  
  
 <span data-ttu-id="3e1bf-801">**Segundo ejemplo**</span><span class="sxs-lookup"><span data-stu-id="3e1bf-801">**Second Example**</span></span>  
  
 <span data-ttu-id="3e1bf-802">El ejemplo siguiente muestra cómo usar una ranura de datos con nombre para almacenar información específica del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-802">The following example demonstrates how to use a named data slot to store thread-specific information.</span></span>  
  
 [!code-cpp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/CS/source.cs#1)]
 [!code-vb[System.Threading.Thread.NamedDataSlot#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.Thread.NamedDataSlot/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Threading.Thread.GetData(System.LocalDataStoreSlot)" />
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-803">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-803">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/thread-local-storage-thread-relative-static-fields-and-data-slots.md"><span data-ttu-id="3e1bf-804">Almacenamiento local para los subprocesos: Campos estáticos relacionados con subprocesos y ranuras de datos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-804">Thread Local Storage: Thread-Relative Static Fields and Data Slots</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Sleep">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-805">Suspende el subproceso actual durante la cantidad de tiempo especificada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-805">Suspends the current thread for the specified amount of time.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (millisecondsTimeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : int -&gt; unit" Usage="System.Threading.Thread.Sleep millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout"><span data-ttu-id="3e1bf-806">Número de milisegundos durante los que el subproceso está suspendido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-806">The number of milliseconds for which the thread is suspended.</span></span> <span data-ttu-id="3e1bf-807">Si el valor del argumento <paramref name="millisecondsTimeout" /> es cero, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que está listo para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-807">If the value of the <paramref name="millisecondsTimeout" /> argument is zero, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="3e1bf-808">Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-808">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="3e1bf-809">Suspende el subproceso actual durante el número de milisegundos especificado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-809">Suspends the current thread for the specified number of milliseconds.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-810">El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-810">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="3e1bf-811">Este método cambia el estado del subproceso para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-811">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="3e1bf-812">Puede especificar <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> para el `millisecondsTimeout` parámetro para suspender el subproceso indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-812">You can specify <xref:System.Threading.Timeout.Infinite?displayProperty=nameWithType> for the `millisecondsTimeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="3e1bf-813">Sin embargo, se recomienda utilizar otros <xref:System.Threading?displayProperty=nameWithType> clases como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> en su lugar para sincronizar subprocesos o administrar los recursos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-813">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="3e1bf-814">Los ciclos de reloj del sistema a un ritmo específico denomina la resolución del reloj.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-814">The system clock ticks at a specific rate called the clock resolution.</span></span> <span data-ttu-id="3e1bf-815">El tiempo de espera real podría no ser exactamente el tiempo de espera, ya que el tiempo de espera especificado se ajustará para que coincida con los ciclos de reloj.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-815">The actual timeout might not be exactly the specified timeout, because the specified timeout will be adjusted to coincide with clock ticks.</span></span> <span data-ttu-id="3e1bf-816">Para obtener más información sobre la resolución del reloj y el tiempo de espera, vea el [suspensión función](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) tema.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-816">For more information on clock resolution and the waiting time, see the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) topic.</span></span> <span data-ttu-id="3e1bf-817">Este método llama a la [suspensión función](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) desde las API del sistema de Windows.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-817">This method calls the [Sleep function](https://msdn.microsoft.com/library/windows/desktop/ms686298.aspx) from the Windows system APIs.</span></span>  
  
 <span data-ttu-id="3e1bf-818">Este método no realiza suministro de SendMessage y COM estándar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-818">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-819">Si se debe al modo de suspensión en un subproceso que tiene <xref:System.STAThreadAttribute>, pero desea bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <xref:System.Threading.Thread.Join%2A> método que especifica un intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-819">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-820">En el ejemplo siguiente se usa el <xref:System.Threading.Thread.Sleep%2A> método para bloquear el subproceso principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-820">The following example uses the <xref:System.Threading.Thread.Sleep%2A> method to block the application's main thread.</span></span>  
  
 [!code-cpp[Thread.Sleep#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep/cs/example.cs#1)]
 [!code-vb[Thread.Sleep#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-821">El valor de tiempo de espera es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-821">The time-out value is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Sleep">
      <MemberSignature Language="C#" Value="public static void Sleep (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Sleep(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Sleep(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Sleep (timeout As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Sleep(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="static member Sleep : TimeSpan -&gt; unit" Usage="System.Threading.Thread.Sleep timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="3e1bf-822">Cantidad de tiempo durante la que el subproceso está suspendido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-822">The amount of time for which the thread is suspended.</span></span> <span data-ttu-id="3e1bf-823">Si el valor del argumento <paramref name="millisecondsTimeout" /> es <see cref="F:System.TimeSpan.Zero" />, el subproceso cede el resto de su porción de tiempo a cualquier subproceso de idéntica prioridad que está listo para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-823">If the value of the <paramref name="millisecondsTimeout" /> argument is <see cref="F:System.TimeSpan.Zero" />, the thread relinquishes the remainder of its time slice to any thread of equal priority that is ready to run.</span></span> <span data-ttu-id="3e1bf-824">Si no hay ningún otro subproceso de igual prioridad que está listo para ejecutarse, no se suspende la ejecución del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-824">If there are no other threads of equal priority that are ready to run, execution of the current thread is not suspended.</span></span></param>
        <summary><span data-ttu-id="3e1bf-825">Suspende el subproceso actual durante la cantidad de tiempo especificada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-825">Suspends the current thread for the specified amount of time.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-826">El subproceso no se programará para su ejecución por el sistema operativo durante el tiempo especificado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-826">The thread will not be scheduled for execution by the operating system for the amount of time specified.</span></span> <span data-ttu-id="3e1bf-827">Este método cambia el estado del subproceso para incluir <xref:System.Threading.ThreadState.WaitSleepJoin>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-827">This method changes the state of the thread to include <xref:System.Threading.ThreadState.WaitSleepJoin>.</span></span>  
  
 <span data-ttu-id="3e1bf-828">Puede especificar <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> para el `timeout` parámetro para suspender el subproceso indefinidamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-828">You can specify <xref:System.Threading.Timeout.InfiniteTimeSpan?displayProperty=nameWithType> for the `timeout` parameter to suspend the thread indefinitely.</span></span> <span data-ttu-id="3e1bf-829">Sin embargo, se recomienda utilizar otros <xref:System.Threading?displayProperty=nameWithType> clases como <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, o <xref:System.Threading.Semaphore> en su lugar para sincronizar subprocesos o administrar los recursos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-829">However, we recommend that you use other <xref:System.Threading?displayProperty=nameWithType> classes such as <xref:System.Threading.Mutex>, <xref:System.Threading.Monitor>, <xref:System.Threading.EventWaitHandle>, or <xref:System.Threading.Semaphore> instead to sychronize threads or manage resources.</span></span>  
  
 <span data-ttu-id="3e1bf-830">Esta sobrecarga de <xref:System.Threading.Thread.Sleep%2A> utiliza el número total de milisegundos enteros en `timeout`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-830">This overload of <xref:System.Threading.Thread.Sleep%2A> uses the total number of whole milliseconds in `timeout`.</span></span> <span data-ttu-id="3e1bf-831">Se descartan las fracciones de milisegundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-831">Fractional milliseconds are discarded.</span></span>  
  
 <span data-ttu-id="3e1bf-832">Este método no realiza suministro de SendMessage y COM estándar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-832">This method does not perform standard COM and SendMessage pumping.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-833">Si se debe al modo de suspensión en un subproceso que tiene <xref:System.STAThreadAttribute>, pero desea bombeando SendMessage y COM estándar, puede usar una de las sobrecargas de los <xref:System.Threading.Thread.Join%2A> método que especifica un intervalo de tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-833">If you need to sleep on a thread that has <xref:System.STAThreadAttribute>, but you want to perform standard COM and SendMessage pumping, consider using one of the overloads of the <xref:System.Threading.Thread.Join%2A> method that specifies a timeout interval.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-834">En el ejemplo siguiente se usa el <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> sobrecarga del método para bloquear el subproceso principal de la aplicación cinco veces, durante dos segundos cada vez.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-834">The following example uses the <xref:System.Threading.Thread.Sleep%28System.TimeSpan%29> method overload to block the application's main thread five times, for two seconds each time.</span></span>  
  
 [!code-cpp[Thread.Sleep_TimeSpan#1](~/samples/snippets/cpp/VS_Snippets_CLR/thread.sleep_timespan/cpp/example.cpp#1)]
 [!code-csharp[Thread.Sleep_TimeSpan#1](~/samples/snippets/csharp/VS_Snippets_CLR/thread.sleep_timespan/cs/example.cs#1)]
 [!code-vb[Thread.Sleep_TimeSpan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/thread.sleep_timespan/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="3e1bf-835">El valor de <paramref name="timeout" /> es negativo y no es igual a <see cref="F:System.Threading.Timeout.Infinite" /> en milisegundos, o es superior a <see cref="F:System.Int32.MaxValue" /> milisegundos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-835">The value of <paramref name="timeout" /> is negative and is not equal to <see cref="F:System.Threading.Timeout.Infinite" /> in milliseconds, or is greater than <see cref="F:System.Int32.MaxValue" /> milliseconds.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SpinWait">
      <MemberSignature Language="C#" Value="public static void SpinWait (int iterations);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SpinWait(int32 iterations) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.SpinWait(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SpinWait (iterations As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SpinWait(int iterations);" />
      <MemberSignature Language="F#" Value="static member SpinWait : int -&gt; unit" Usage="System.Threading.Thread.SpinWait iterations" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iterations" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="iterations"><span data-ttu-id="3e1bf-836">Entero de 32 bits con signo que define la cantidad de tiempo de espera de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-836">A 32-bit signed integer that defines how long a thread is to wait.</span></span></param>
        <summary><span data-ttu-id="3e1bf-837">Hace que un subproceso espere el número de veces definido por el parámetro <paramref name="iterations" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-837">Causes a thread to wait the number of times defined by the <paramref name="iterations" /> parameter.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-838">El <xref:System.Threading.Thread.SpinWait%2A> método es útil para implementar bloqueos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-838">The <xref:System.Threading.Thread.SpinWait%2A> method is useful for implementing locks.</span></span> <span data-ttu-id="3e1bf-839">Las clases de .NET Framework, como <xref:System.Threading.Monitor> y <xref:System.Threading.ReaderWriterLock>, use este método internamente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-839">Classes in the .NET Framework, such as <xref:System.Threading.Monitor> and <xref:System.Threading.ReaderWriterLock>, use this method internally.</span></span> <span data-ttu-id="3e1bf-840"><xref:System.Threading.Thread.SpinWait%2A> Básicamente, coloca el procesador en un bucle ajustado muy, con el recuento del bucle especificado por el `iterations` parámetro.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-840"><xref:System.Threading.Thread.SpinWait%2A> essentially puts the processor into a very tight loop, with the loop count specified by the `iterations` parameter.</span></span> <span data-ttu-id="3e1bf-841">El tiempo de espera, por tanto, depende de la velocidad del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-841">The duration of the wait therefore depends on the speed of the processor.</span></span>  
  
 <span data-ttu-id="3e1bf-842">Compare esto con el <xref:System.Threading.Thread.Sleep%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-842">Contrast this with the <xref:System.Threading.Thread.Sleep%2A> method.</span></span> <span data-ttu-id="3e1bf-843">Un subproceso que llama a <xref:System.Threading.Thread.Sleep%2A> genera el resto de su porción de tiempo de procesador actual, incluso si el intervalo especificado es cero.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-843">A thread that calls <xref:System.Threading.Thread.Sleep%2A> yields the rest of its current slice of processor time, even if the specified interval is zero.</span></span> <span data-ttu-id="3e1bf-844">Especificar un intervalo distinto de cero para <xref:System.Threading.Thread.Sleep%2A> quita el subproceso de examen por el programador del subproceso hasta que haya transcurrido el intervalo de tiempo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-844">Specifying a non-zero interval for <xref:System.Threading.Thread.Sleep%2A> removes the thread from consideration by the thread scheduler until the time interval has elapsed.</span></span>  
  
 <span data-ttu-id="3e1bf-845"><xref:System.Threading.Thread.SpinWait%2A> no es generalmente útil para las aplicaciones comunes.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-845"><xref:System.Threading.Thread.SpinWait%2A> is not generally useful for ordinary applications.</span></span> <span data-ttu-id="3e1bf-846">En la mayoría de los casos, debe usar las clases de sincronización proporcionadas por .NET Framework; Por ejemplo, llamar a <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> o una instrucción que ajusta <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` en C# o `SyncLock` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-846">In most cases, you should use the synchronization classes provided by the .NET Framework; for example, call <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> or a statement that wraps <xref:System.Threading.Monitor.Enter%2A?displayProperty=nameWithType> (`lock` in C# or `SyncLock` in Visual Basic).</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3e1bf-847">En el caso excepcional donde resulta ventajoso para evitar un cambio de contexto, por ejemplo, cuando se sabe que un cambio de estado es inminente, realice una llamada a la <xref:System.Threading.Thread.SpinWait%2A> método en el bucle.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-847">In the rare case where it is advantageous to avoid a context switch, such as when you know that a state change is imminent, make a call to the <xref:System.Threading.Thread.SpinWait%2A> method in your loop.</span></span> <span data-ttu-id="3e1bf-848">El código <xref:System.Threading.Thread.SpinWait%2A> ejecuta está diseñado para evitar problemas que pueden producirse en equipos con varios procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-848">The code <xref:System.Threading.Thread.SpinWait%2A> executes is designed to prevent problems that can occur on computers with multiple processors.</span></span> <span data-ttu-id="3e1bf-849">Por ejemplo, en equipos con varios procesadores de Intel que emplean la tecnología Hyper-Threading, <xref:System.Threading.Thread.SpinWait%2A> evita la inanición del procesador en determinadas situaciones.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-849">For example, on computers with multiple Intel processors employing Hyper-Threading technology, <xref:System.Threading.Thread.SpinWait%2A> prevents processor starvation in certain situations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-850">Hace que se programe un subproceso para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-850">Causes a thread to be scheduled for execution.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="thread.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-851">Hace que el sistema operativo cambie el estado de la instancia actual a <see cref="F:System.Threading.ThreadState.Running" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-851">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-852">Una vez que un subproceso está en el <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, el sistema operativo puede programarlo para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-852">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="3e1bf-853">El subproceso empieza a ejecutarse en la primera línea del método representado por la <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegado proporcionado al constructor del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-853">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="3e1bf-854">Tenga en cuenta que la llamada a <xref:System.Threading.Thread.Start%2A> no bloquea el subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-854">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-855">Si esta sobrecarga se utiliza con un subproceso creado mediante una <xref:System.Threading.ParameterizedThreadStart> delegar, `null` se pasa al método ejecutado por el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-855">If this overload is used with a thread created using a <xref:System.Threading.ParameterizedThreadStart> delegate, `null` is passed to the method executed by the thread.</span></span>  
  
 <span data-ttu-id="3e1bf-856">Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a `Start`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-856">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-857">El ejemplo siguiente se crea e inicia un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-857">The following example creates and starts a thread.</span></span>  
  
 [!code-cpp[ThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR/ThreadStart/CPP/threadstart.cpp#1)]
 [!code-csharp[ThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR/ThreadStart/CS/threadstart.cs#1)]
 [!code-vb[ThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ThreadStart/VB/threadstart.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-858">Ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-858">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3e1bf-859">No hay memoria suficiente disponible para iniciar este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-859">There is not enough memory available to start this thread.</span></span></exception>
        <related type="Article" href="~/docs/standard/threading/threads-and-threading.md"><span data-ttu-id="3e1bf-860">Subprocesos y subprocesamiento</span><span class="sxs-lookup"><span data-stu-id="3e1bf-860">Threads and Threading</span></span></related>
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="3e1bf-861">Crear subprocesos y analizar los datos en el inicio</span><span class="sxs-lookup"><span data-stu-id="3e1bf-861">Creating Threads and Passing Data at Start Time</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (object parameter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(object parameter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Start(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (parameter As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(System::Object ^ parameter);" />
      <MemberSignature Language="F#" Value="member this.Start : obj -&gt; unit" Usage="thread.Start parameter" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="parameter" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="parameter"><span data-ttu-id="3e1bf-862">Objeto que contiene datos para que los use el método ejecutado por el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-862">An object that contains data to be used by the method the thread executes.</span></span></param>
        <summary><span data-ttu-id="3e1bf-863">Hace que el sistema operativo cambie el estado de la instancia actual a <see cref="F:System.Threading.ThreadState.Running" />; también puede proporcionar un objeto que contiene datos para que los use el método ejecutado por el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-863">Causes the operating system to change the state of the current instance to <see cref="F:System.Threading.ThreadState.Running" />, and optionally supplies an object containing data to be used by the method the thread executes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-864">Una vez que un subproceso está en el <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> de estado, el sistema operativo puede programarlo para su ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-864">Once a thread is in the <xref:System.Threading.ThreadState.Running?displayProperty=nameWithType> state, the operating system can schedule it for execution.</span></span> <span data-ttu-id="3e1bf-865">El subproceso empieza a ejecutarse en la primera línea del método representado por la <xref:System.Threading.ThreadStart> o <xref:System.Threading.ParameterizedThreadStart> delegado proporcionado al constructor del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-865">The thread begins executing at the first line of the method represented by the <xref:System.Threading.ThreadStart> or <xref:System.Threading.ParameterizedThreadStart> delegate supplied to the thread constructor.</span></span> <span data-ttu-id="3e1bf-866">Tenga en cuenta que la llamada a <xref:System.Threading.Thread.Start%2A> no bloquea el subproceso que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-866">Note that the call to <xref:System.Threading.Thread.Start%2A> does not block the calling thread.</span></span>  
  
 <span data-ttu-id="3e1bf-867">Una vez que finaliza el subproceso, no se puede reiniciar con otra llamada a `Start`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-867">Once the thread terminates, it cannot be restarted with another call to `Start`.</span></span>  
  
 <span data-ttu-id="3e1bf-868">Esta sobrecarga y la <xref:System.Threading.ParameterizedThreadStart> delegado facilitan la tarea pasar datos a un procedimiento de subproceso, pero la técnica no es segura porque se puede pasar cualquier objeto a esta sobrecarga.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-868">This overload and the <xref:System.Threading.ParameterizedThreadStart> delegate make it easy to pass data to a thread procedure, but the technique is not type safe because any object can be passed to this overload.</span></span> <span data-ttu-id="3e1bf-869">Es una manera más sólida para pasar datos a un procedimiento de subproceso poner el procedimiento de subproceso y los campos de datos en un objeto de trabajo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-869">A more robust way to pass data to a thread procedure is to put both the thread procedure and the data fields into a worker object.</span></span> <span data-ttu-id="3e1bf-870">Para obtener más información, consulte [crear subprocesos y pasar datos en tiempo de inicio](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-870">For more information, see [Creating Threads and Passing Data at Start Time](~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-871">En el ejemplo siguiente se crea un <xref:System.Threading.ParameterizedThreadStart> delegado con un método estático y un método de instancia.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-871">The following example creates a <xref:System.Threading.ParameterizedThreadStart> delegate with a static method and an instance method.</span></span>  
  
 [!code-cpp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CPP/source.cpp#1)]
 [!code-csharp[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/CS/source.cs#1)]
 [!code-vb[System.Threading.ParameterizedThreadStart#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Threading.ParameterizedThreadStart/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-872">Ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-872">The thread has already been started.</span></span></exception>
        <exception cref="T:System.OutOfMemoryException"><span data-ttu-id="3e1bf-873">No hay memoria suficiente iniciar este subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-873">There is not enough memory available to start this thread.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="3e1bf-874">Este subproceso se creó mediante un delegado <see cref="T:System.Threading.ThreadStart" /> en lugar de un delegado <see cref="T:System.Threading.ParameterizedThreadStart" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-874">This thread was created using a <see cref="T:System.Threading.ThreadStart" /> delegate instead of a <see cref="T:System.Threading.ParameterizedThreadStart" /> delegate.</span></span></exception>
        <altmember cref="T:System.Threading.ParameterizedThreadStart" />
        <altmember cref="T:System.AppDomain" />
        <related type="Article" href="~/docs/standard/threading/creating-threads-and-passing-data-at-start-time.md"><span data-ttu-id="3e1bf-875">Crear subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-875">Creating Threads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Suspend">
      <MemberSignature Language="C#" Value="public void Suspend ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Suspend() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Suspend" />
      <MemberSignature Language="VB.NET" Value="Public Sub Suspend ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Suspend();" />
      <MemberSignature Language="F#" Value="member this.Suspend : unit -&gt; unit" Usage="thread.Suspend " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("Thread.Suspend has been deprecated.  Please use other classes in System.Threading, such as Monitor, Mutex, Event, and Semaphore, to synchronize Threads or protect resources.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-876">Suspende el subproceso o, si este ya se ha suspendido, no tiene efecto alguno.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-876">Either suspends the thread, or if the thread is already suspended, has no effect.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-877">Si el subproceso ya está suspendido, este método tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-877">If the thread is already suspended, this method has no effect.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3e1bf-878">No utilice el <xref:System.Threading.Thread.Suspend%2A> y <xref:System.Threading.Thread.Resume%2A> métodos para sincronizar las actividades de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-878">Do not use the <xref:System.Threading.Thread.Suspend%2A> and <xref:System.Threading.Thread.Resume%2A> methods to synchronize the activities of threads.</span></span> <span data-ttu-id="3e1bf-879">No tener ninguna manera de saber qué código un subproceso se ejecuta cuando se suspende.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-879">You have no way of knowing what code a thread is executing when you suspend it.</span></span> <span data-ttu-id="3e1bf-880">Si se suspende un subproceso mientras mantiene bloqueos durante una evaluación de permisos de seguridad, otros subprocesos en la <xref:System.AppDomain> podría bloquearse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-880">If you suspend a thread while it holds locks during a security permission evaluation, other threads in the <xref:System.AppDomain> might be blocked.</span></span> <span data-ttu-id="3e1bf-881">Si se suspende un subproceso mientras se esté ejecutando un constructor de clase, otros subprocesos en la <xref:System.AppDomain> que intentan usar que se bloquean la clase.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-881">If you suspend a thread while it is executing a class constructor, other threads in the <xref:System.AppDomain> that attempt to use that class are blocked.</span></span> <span data-ttu-id="3e1bf-882">Pueden producirse interbloqueos muy fácilmente.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-882">Deadlocks can occur very easily.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException"><span data-ttu-id="3e1bf-883">Solo .NET Core: este miembro no se admite.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-883">.NET Core only: This member is not supported.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-884">No se ha iniciado el subproceso o está inactivo</span><span class="sxs-lookup"><span data-stu-id="3e1bf-884">The thread has not been started or is dead.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="3e1bf-885">El autor de la llamada no dispone del <see cref="T:System.Security.Permissions.SecurityPermission" /> adecuado</span><span class="sxs-lookup"><span data-stu-id="3e1bf-885">The caller does not have the appropriate <see cref="T:System.Security.Permissions.SecurityPermission" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3e1bf-886">para las operaciones avanzadas en subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-886">for advanced operations on threads.</span></span> <span data-ttu-id="3e1bf-887">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-887">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlThread" />.</span></span></permission>
        <related type="Article" href="~/docs/standard/threading/pausing-and-resuming-threads.md"><span data-ttu-id="3e1bf-888">Pausa e interrupción de subprocesos</span><span class="sxs-lookup"><span data-stu-id="3e1bf-888">Pausing and interrupting threads</span></span></related>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-889">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-889">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Thread.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Thread.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Thread::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="3e1bf-890">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-890">Reserved for future use.</span></span> <span data-ttu-id="3e1bf-891">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-891">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="3e1bf-892">Matriz que se pasa con los nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-892">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="3e1bf-893">Número de nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-893">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="3e1bf-894">Contexto de configuración regional en el que se van a interpretar los nombres.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-894">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="3e1bf-895">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-895">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="3e1bf-896">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-896">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-897">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-897">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3e1bf-898">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-898">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3e1bf-899">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-899">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Thread.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="3e1bf-900">Información de tipos que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-900">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="3e1bf-901">Identificador de la configuración regional de la información de tipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-901">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="3e1bf-902">Recibe un puntero al objeto de información de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-902">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="3e1bf-903">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-903">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-904">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-904">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3e1bf-905">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-905">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3e1bf-906">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-906">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Thread.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Thread.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Thread::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="3e1bf-907">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-907">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="3e1bf-908">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-908">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-909">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-909">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3e1bf-910">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-910">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3e1bf-911">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-911">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Thread.Invoke">
      <MemberSignature Language="C#" Value="void _Thread.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Thread.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.System#Runtime#InteropServices#_Thread#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Thread.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Thread.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Thread::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Thread.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="3e1bf-912">Identifica el miembro.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-912">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="3e1bf-913">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-913">Reserved for future use.</span></span> <span data-ttu-id="3e1bf-914">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-914">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="3e1bf-915">Contexto de la configuración regional en que se interpretan los argumentos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-915">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="3e1bf-916">Marcas que describen el contexto de la llamada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-916">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="3e1bf-917">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-917">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="3e1bf-918">Puntero a la ubicación donde se va a almacenar el resultado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-918">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="3e1bf-919">Puntero a una estructura que contiene información de excepciones.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-919">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="3e1bf-920">Índice del primer argumento que tiene un error.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-920">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="3e1bf-921">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-921">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-922">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-922">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="3e1bf-923">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-923">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="3e1bf-924">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-924">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ThreadState">
      <MemberSignature Language="C#" Value="public System.Threading.ThreadState ThreadState { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Threading.ThreadState ThreadState" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Thread.ThreadState" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ThreadState As ThreadState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::ThreadState ThreadState { System::Threading::ThreadState get(); };" />
      <MemberSignature Language="F#" Value="member this.ThreadState : System.Threading.ThreadState" Usage="System.Threading.Thread.ThreadState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Threading.ThreadState</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3e1bf-925">Obtiene un valor que contiene los estados del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-925">Gets a value containing the states of the current thread.</span></span></summary>
        <value><span data-ttu-id="3e1bf-926">Uno de los valores de <see cref="T:System.Threading.ThreadState" /> que indica el estado del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-926">One of the <see cref="T:System.Threading.ThreadState" /> values indicating the state of the current thread.</span></span> <span data-ttu-id="3e1bf-927">El valor inicial es <see langword="Unstarted" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-927">The initial value is <see langword="Unstarted" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-928">El <xref:System.Threading.Thread.ThreadState%2A> propiedad proporciona información más específica que la <xref:System.Threading.Thread.IsAlive%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-928">The <xref:System.Threading.Thread.ThreadState%2A> property provides more specific information than the <xref:System.Threading.Thread.IsAlive%2A> property.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="3e1bf-929">Estado de los subprocesos solo es de interés en escenarios de depuración.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-929">Thread state is only of interest in debugging scenarios.</span></span> <span data-ttu-id="3e1bf-930">El código nunca debe usar el estado de los subprocesos para sincronizar las actividades de los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-930">Your code should never use thread state to synchronize the activities of threads.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-931">En el ejemplo de código siguiente se muestra cómo tener acceso el `ThreadState` de un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-931">The following code example demonstrates accessing the `ThreadState` of a thread.</span></span>  
  
 [!code-cpp[System.Threading.Thread.ThreadState#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cpp/source.cpp#1)]
 [!code-csharp[System.Threading.Thread.ThreadState#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.threading.thread.threadstate/cs/source.cs#1)]
 [!code-vb[System.Threading.Thread.ThreadState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.threading.thread.threadstate/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/threading/managed-thread-states.md"><span data-ttu-id="3e1bf-932">Estados de subprocesos administrados</span><span class="sxs-lookup"><span data-stu-id="3e1bf-932">Managed Thread States</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="TrySetApartmentState">
      <MemberSignature Language="C#" Value="public bool TrySetApartmentState (System.Threading.ApartmentState state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TrySetApartmentState(valuetype System.Threading.ApartmentState state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.TrySetApartmentState(System.Threading.ApartmentState)" />
      <MemberSignature Language="VB.NET" Value="Public Function TrySetApartmentState (state As ApartmentState) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TrySetApartmentState(System::Threading::ApartmentState state);" />
      <MemberSignature Language="F#" Value="member this.TrySetApartmentState : System.Threading.ApartmentState -&gt; bool" Usage="thread.TrySetApartmentState state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Threading.ApartmentState" />
      </Parameters>
      <Docs>
        <param name="state"><span data-ttu-id="3e1bf-933">Nuevo estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-933">The new apartment state.</span></span></param>
        <summary><span data-ttu-id="3e1bf-934">Establece el estado del apartamento de un subproceso antes de iniciarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-934">Sets the apartment state of a thread before it is started.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-935"><see langword="true" /> si se ha establecido el estado del apartamento; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-935"><see langword="true" /> if the apartment state is set; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-936">Los subprocesos nuevos se inicializan como <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> si no se ha establecido su estado de apartamento antes de que se inicien.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-936">New threads are initialized as <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> if their apartment state has not been set before they are started.</span></span> <span data-ttu-id="3e1bf-937">Estado del apartamento se debe establecer antes de que se inicia un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-937">Apartment state must be set before a thread is started.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-938">El subproceso principal de la aplicación se inicializa en <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> de forma predeterminada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-938">The main application thread is initialized to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> by default.</span></span> <span data-ttu-id="3e1bf-939">La única forma de establecer el estado del apartamento del subproceso principal de la aplicación para <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> consiste en aplicar el <xref:System.STAThreadAttribute> atributo al método de punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-939">The only way to set the apartment state of the main application thread to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType> is to apply the <xref:System.STAThreadAttribute> attribute to the entry point method.</span></span>  
  
 <span data-ttu-id="3e1bf-940">El <xref:System.Threading.Thread.TrySetApartmentState%2A> método, junto con el <xref:System.Threading.Thread.GetApartmentState%2A> método y el <xref:System.Threading.Thread.SetApartmentState%2A> método, reemplaza el <xref:System.Threading.Thread.ApartmentState%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-940">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method, along with the <xref:System.Threading.Thread.GetApartmentState%2A> method and the <xref:System.Threading.Thread.SetApartmentState%2A> method, replaces the <xref:System.Threading.Thread.ApartmentState%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3e1bf-941">En el ejemplo de código siguiente se muestra el <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, y <xref:System.Threading.Thread.TrySetApartmentState%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-941">The following code example demonstrates the <xref:System.Threading.Thread.GetApartmentState%2A>, <xref:System.Threading.Thread.SetApartmentState%2A>, and <xref:System.Threading.Thread.TrySetApartmentState%2A> methods.</span></span> <span data-ttu-id="3e1bf-942">El ejemplo de código crea un subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-942">The code example creates a thread.</span></span> <span data-ttu-id="3e1bf-943">Antes de inicia el subproceso, <xref:System.Threading.Thread.GetApartmentState%2A> muestra inicial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> estado y <xref:System.Threading.Thread.SetApartmentState%2A> cambia el estado a <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-943">Before the thread is started, <xref:System.Threading.Thread.GetApartmentState%2A> displays the initial <xref:System.Threading.ApartmentState.Unknown?displayProperty=nameWithType> state and <xref:System.Threading.Thread.SetApartmentState%2A> changes the state to <xref:System.Threading.ApartmentState.STA?displayProperty=nameWithType>.</span></span> <span data-ttu-id="3e1bf-944">El <xref:System.Threading.Thread.TrySetApartmentState%2A> , a continuación, devuelve el método `false` al intentar cambiar el estado a <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> porque ya está establecido el estado del apartamento.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-944">The <xref:System.Threading.Thread.TrySetApartmentState%2A> method then returns `false` when attempting to change the state to <xref:System.Threading.ApartmentState.MTA?displayProperty=nameWithType> because the apartment state is already set.</span></span> <span data-ttu-id="3e1bf-945">Si hubiera intentado la misma operación <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> habría iniciado.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-945">If the same operation had been attempted with <xref:System.Threading.Thread.SetApartmentState%2A>, <xref:System.InvalidOperationException> would have been thrown.</span></span>  
  
 <span data-ttu-id="3e1bf-946">Una vez iniciado el subproceso, el <xref:System.Threading.Thread.TrySetApartmentState%2A> método se utiliza de nuevo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-946">After the thread is started, the <xref:System.Threading.Thread.TrySetApartmentState%2A> method is used again.</span></span> <span data-ttu-id="3e1bf-947">Esta vez, se produce <xref:System.Threading.ThreadStateException> porque ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-947">This time it throws <xref:System.Threading.ThreadStateException> because the thread has already been started.</span></span>  
  
 [!code-cpp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/cpp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cpp/source.cpp#1)]
 [!code-csharp[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/csharp/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/cs/source.cs#1)]
 [!code-vb[Thread.GetSetTrySetApartmentState#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Thread.GetSetTrySetApartmentState/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="3e1bf-948"><paramref name="state" /> no es un estado del apartamento válido.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-948"><paramref name="state" /> is not a valid apartment state.</span></span></exception>
        <exception cref="T:System.Threading.ThreadStateException"><span data-ttu-id="3e1bf-949">Ya se inició el subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-949">The thread has already been started.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileRead">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-950">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-950">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-951">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-951">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static byte VolatileRead (ref byte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int8 VolatileRead(unsigned int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Byte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Byte) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Byte VolatileRead(System::Byte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; byte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-952">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-952">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-953">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-953">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-954">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-954">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-955">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-955">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-956"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-956"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-957">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-957">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-958">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-958">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-959">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-959">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-960">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-960">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-961">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-961">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-962">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-962">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-963">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-963">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-964">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-964">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static double VolatileRead (ref double address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 VolatileRead(float64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Double@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double VolatileRead(double % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; double" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-965">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-965">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-966">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-966">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-967">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-967">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-968">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-968">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-969"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-969"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-970">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-970">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-971">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-971">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-972">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-972">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-973">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-973">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-974">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-974">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-975">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-975">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-976">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-976">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-977">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-977">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static short VolatileRead (ref short address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int16 VolatileRead(int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Short) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static short VolatileRead(short % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-978">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-978">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-979">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-979">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-980">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-980">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-981">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-981">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-982"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-982"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-983">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-983">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-984">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-984">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-985">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-985">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-986">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-986">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-987">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-987">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-988">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-988">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-989">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-989">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-990">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-990">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static int VolatileRead (ref int address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 VolatileRead(int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int VolatileRead(int % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-991">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-991">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-992">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-992">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-993">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-993">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-994">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-994">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-995"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-995"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-996">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-996">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-997">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-997">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-998">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-998">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-999">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-999">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1000">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1000">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1001">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1001">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1002">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1002">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1003">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1003">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static long VolatileRead (ref long address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 VolatileRead(int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Int64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Long) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long VolatileRead(long % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; int64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1004">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1004">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1005">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1005">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1006">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1006">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1007">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1007">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1008"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1008"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1009">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1009">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1010">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1010">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1011">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1011">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1012">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1012">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1013">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1013">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1014">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1014">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1015">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1015">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1016">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1016">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static IntPtr VolatileRead (ref IntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int VolatileRead(native int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.IntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As IntPtr) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr VolatileRead(IntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; nativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1017">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1017">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1018">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1018">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1019">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1019">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1020">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1020">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1021"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1021"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1022">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1022">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1023">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1023">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1024">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1024">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1025">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1025">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1026">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1026">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1027">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1027">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1028">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1028">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1029">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1029">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static object VolatileRead (ref object address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig object VolatileRead(object&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Object@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Object) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Object ^ VolatileRead(System::Object ^ % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; obj" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1030">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1030">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1031">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1031">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1032">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1032">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1033">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1033">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1034"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1034"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1035">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1035">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1036">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1036">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1037">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1037">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1038">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1038">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1039">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1039">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1040">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1040">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1041">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1041">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1042">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1042">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static sbyte VolatileRead (ref sbyte address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int8 VolatileRead(int8&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.SByte@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As SByte) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::SByte VolatileRead(System::SByte % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; sbyte" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1043">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1043">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1044">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1044">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1045">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1045">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1046">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1046">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1047"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1047"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1048">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1048">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1049">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1049">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1050">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1050">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1051">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1051">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1052">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1052">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1053">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1053">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1054">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1054">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1055">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1055">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static float VolatileRead (ref float address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float32 VolatileRead(float32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.Single@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As Single) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static float VolatileRead(float % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; single" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1056">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1056">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1057">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1057">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1058">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1058">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1059">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1059">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1060"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1060"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1061">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1061">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1062">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1062">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1063">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1063">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1064">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1064">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1065">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1065">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1066">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1066">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1067">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1067">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1068">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1068">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ushort VolatileRead (ref ushort address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int16 VolatileRead(unsigned int16&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt16@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UShort) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt16 VolatileRead(System::UInt16 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint16" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1069">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1069">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1070">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1070">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1071">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1071">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1072">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1072">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1073"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1073"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1074">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1074">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1075">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1075">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1076">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1076">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1077">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1077">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1078">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1078">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1079">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1079">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1080">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1080">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1081">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1081">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static uint VolatileRead (ref uint address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int32 VolatileRead(unsigned int32&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt32 VolatileRead(System::UInt32 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint32" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1082">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1082">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1083">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1083">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1084">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1084">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1085">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1085">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1086"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1086"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1087">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1087">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1088">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1088">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1089">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1089">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1090">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1090">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1091">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1091">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1092">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1092">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1093">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1093">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1094">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1094">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static ulong VolatileRead (ref ulong address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig unsigned int64 VolatileRead(unsigned int64&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UInt64@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As ULong) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::UInt64 VolatileRead(System::UInt64 % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; uint64" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1095">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1095">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1096">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1096">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1097">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1097">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1098">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1098">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1099"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1099"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1100">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1100">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1101">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1101">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1102">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1102">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1103">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1103">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1104">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1104">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1105">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1105">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1106">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1106">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1107">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1107">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileRead">
      <MemberSignature Language="C#" Value="public static UIntPtr VolatileRead (ref UIntPtr address);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native unsigned int VolatileRead(native unsigned int&amp; address) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileRead(System.UIntPtr@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function VolatileRead (ByRef address As UIntPtr) As UIntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static UIntPtr VolatileRead(UIntPtr % address);" />
      <MemberSignature Language="F#" Value="static member VolatileRead :  -&gt; unativeint" Usage="System.Threading.Thread.VolatileRead address" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UIntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1108">Campo que se va a leer.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1108">The field to be read.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1109">Lee el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1109">Reads the value of a field.</span></span> <span data-ttu-id="3e1bf-1110">El valor es el último que haya escrito cualquier procesador de un equipo, independientemente del número de procesadores y del estado de la caché del procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1110">The value is the latest written by any processor in a computer, regardless of the number of processors or the state of processor cache.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1111">Último valor que ha escrito en el campo un procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1111">The latest value written to the field by any processor.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1112"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1112"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1113">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1113">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1114">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileRead%2A> Obtiene el último valor escrito cualquier procesador a una ubicación de memoria.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1114">On a multiprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> obtains the very latest value written to a memory location by any processor.</span></span> <span data-ttu-id="3e1bf-1115">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1115">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1116">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1116">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1117">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1117">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1118">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1118">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1119">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1119">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1120">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1120">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="VolatileWrite">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3e1bf-1121">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1121">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref byte address, byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int8&amp; address, unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Byte@,System.Byte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Byte, value As Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Byte % address, System::Byte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * byte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Byte" RefType="ref" />
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1122">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1122">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1123">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1123">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1124">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1124">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1125"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1125"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1126">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1126">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1127">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1127">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1128">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1128">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1129">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1129">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1130">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1130">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1131">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1131">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1132">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1132">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1133">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1133">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref double address, double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float64&amp; address, float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Double@,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Double, value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(double % address, double value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * double -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Double" RefType="ref" />
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1134">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1134">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1135">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1135">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1136">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1136">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1137"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1137"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1138">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1138">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1139">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1139">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1140">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1140">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1141">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1141">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1142">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1142">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1143">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1143">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1144">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1144">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1145">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1145">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref short address, short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int16&amp; address, int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int16@,System.Int16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Short, value As Short)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(short % address, short value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int16" RefType="ref" />
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1146">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1146">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1147">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1147">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1148">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1148">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1149"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1149"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1150">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1150">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1151">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1151">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1152">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1152">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1153">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1153">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1154">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1154">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1155">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1155">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1156">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1156">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1157">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1157">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref int address, int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int32&amp; address, int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int32@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Integer, value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(int % address, int value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int32" RefType="ref" />
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1158">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1158">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1159">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1159">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1160">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1160">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1161"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1161"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1162">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1162">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1163">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1163">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1164">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1164">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1165">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1165">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1166">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1166">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1167">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1167">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1168">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1168">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1169">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1169">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref long address, long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int64&amp; address, int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Int64@,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Long, value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(long % address, long value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * int64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Int64" RefType="ref" />
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1170">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1170">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1171">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1171">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1172">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1172">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1173"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1173"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1174">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1174">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1175">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1175">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1176">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1176">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1177">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1177">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1178">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1178">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1179">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1179">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1180">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1180">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1181">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1181">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref IntPtr address, IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native int&amp; address, native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.IntPtr@,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As IntPtr, value As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(IntPtr % address, IntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * nativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.IntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1182">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1182">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1183">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1183">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1184">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1184">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1185"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1185"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1186">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1186">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1187">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1187">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1188">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1188">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1189">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1189">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1190">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1190">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1191">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1191">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1192">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1192">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1193">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1193">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref object address, object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(object&amp; address, object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Object@,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Object, value As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::Object ^ % address, System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * obj -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Object" RefType="ref" />
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1194">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1194">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1195">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1195">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1196">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1196">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1197"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1197"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1198">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1198">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1199">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1199">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1200">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1200">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1201">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1201">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1202">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1202">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1203">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1203">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1204">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1204">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1205">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1205">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref sbyte address, sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(int8&amp; address, int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.SByte@,System.SByte)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As SByte, value As SByte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::SByte % address, System::SByte value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * sbyte -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.SByte" RefType="ref" />
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1206">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1206">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1207">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1207">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1208">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1208">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1209"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1209"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1210">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1210">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1211">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1211">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1212">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1212">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1213">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1213">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1214">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1214">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1215">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1215">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1216">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1216">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1217">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1217">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref float address, float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(float32&amp; address, float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.Single@,System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As Single, value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(float % address, float value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * single -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Single" RefType="ref" />
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1218">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1218">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1219">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1219">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1220">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1220">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1221"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1221"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1222">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1222">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1223">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1223">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1224">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1224">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1225">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1225">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1226">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1226">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1227">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1227">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1228">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1228">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1229">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1229">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ushort address, ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int16&amp; address, unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt16@,System.UInt16)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UShort, value As UShort)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt16 % address, System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint16 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt16" RefType="ref" />
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1230">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1230">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1231">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1231">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1232">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1232">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1233"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1233"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1234">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1234">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1235">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1235">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1236">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1236">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1237">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1237">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1238">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1238">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1239">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1239">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1240">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1240">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1241">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1241">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref uint address, uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int32&amp; address, unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt32@,System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UInteger, value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt32 % address, System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint32 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt32" RefType="ref" />
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1242">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1242">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1243">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1243">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1244">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1244">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1245"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1245"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1246">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1246">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1247">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1247">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1248">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1248">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1249">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1249">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1250">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1250">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1251">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1251">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1252">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1252">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1253">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1253">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref ulong address, ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(unsigned int64&amp; address, unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UInt64@,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As ULong, value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(System::UInt64 % address, System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * uint64 -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UInt64" RefType="ref" />
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1254">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1254">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1255">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1255">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1256">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1256">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1257"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1257"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1258">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1258">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1259">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1259">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1260">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1260">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1261">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1261">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1262">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1262">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1263">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1263">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1264">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1264">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1265">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1265">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="VolatileWrite">
      <MemberSignature Language="C#" Value="public static void VolatileWrite (ref UIntPtr address, UIntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void VolatileWrite(native unsigned int&amp; address, native unsigned int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.VolatileWrite(System.UIntPtr@,System.UIntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub VolatileWrite (ByRef address As UIntPtr, value As UIntPtr)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void VolatileWrite(UIntPtr % address, UIntPtr value);" />
      <MemberSignature Language="F#" Value="static member VolatileWrite :  * unativeint -&gt; unit" Usage="System.Threading.Thread.VolatileWrite (address, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.UIntPtr" RefType="ref" />
        <Parameter Name="value" Type="System.UIntPtr" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="3e1bf-1266">Campo en el que se escribirá el valor.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1266">The field to which the value is to be written.</span></span></param>
        <param name="value"><span data-ttu-id="3e1bf-1267">Valor que se va a escribir.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1267">The value to be written.</span></span></param>
        <summary><span data-ttu-id="3e1bf-1268">Escribe inmediatamente un valor en un campo, de manera que el valor sea visible para todos los procesadores del equipo.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1268">Writes a value to a field immediately, so that the value is visible to all processors in the computer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1269"><xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> son los casos especiales de sincronización.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1269"><xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> are for special cases of synchronization.</span></span> <span data-ttu-id="3e1bf-1270">En circunstancias normales, C# `lock` instrucción, Visual Basic `SyncLock` instrucción y el <xref:System.Threading.Monitor> clase proporcionan alternativas más sencillas.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1270">Under normal circumstances, the C# `lock` statement, the Visual Basic `SyncLock` statement, and the <xref:System.Threading.Monitor> class provide easier alternatives.</span></span>  
  
 <span data-ttu-id="3e1bf-1271">En un sistema multiprocesador, <xref:System.Threading.Thread.VolatileWrite%2A> garantiza que un valor que se escriben en una ubicación de memoria es inmediatamente visible para todos los procesadores.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1271">On a multiprocessor system, <xref:System.Threading.Thread.VolatileWrite%2A> ensures that a value written to a memory location is immediately visible to all processors.</span></span> <span data-ttu-id="3e1bf-1272">Esto podría requerir vaciar las memorias caché de procesador.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1272">This might require flushing processor caches.</span></span>  
  
 <span data-ttu-id="3e1bf-1273">Incluso en un sistema monoprocesador, <xref:System.Threading.Thread.VolatileRead%2A> y <xref:System.Threading.Thread.VolatileWrite%2A> Asegúrese de que un valor es leer o escriben en la memoria y no se almacenan en caché (por ejemplo, en un registro del procesador).</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1273">Even on a uniprocessor system, <xref:System.Threading.Thread.VolatileRead%2A> and <xref:System.Threading.Thread.VolatileWrite%2A> ensure that a value is read or written to memory, and not cached (for example, in a processor register).</span></span> <span data-ttu-id="3e1bf-1274">Por lo tanto, puede usar para sincronizar el acceso a un campo que se puede actualizar por otro subproceso o el hardware.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1274">Thus, you can use them to synchronize access to a field that can be updated by another thread, or by hardware.</span></span>  
  
 <span data-ttu-id="3e1bf-1275">Llamar a este método sólo afecta a una sola memoria access.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1275">Calling this method affects only a single memory access.</span></span> <span data-ttu-id="3e1bf-1276">Para proporcionar una sincronización efectiva para un campo, debe usar todo el acceso al campo <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1276">To provide effective synchronization for a field, all access to the field must use <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3e1bf-1277">En C#, utilizando el `volatile` modificador en un campo garantiza que todo el acceso a ese campo utilice <xref:System.Threading.Thread.VolatileRead%2A> o <xref:System.Threading.Thread.VolatileWrite%2A>.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1277">In C#, using the `volatile` modifier on a field guarantees that all access to that field uses <xref:System.Threading.Thread.VolatileRead%2A> or <xref:System.Threading.Thread.VolatileWrite%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Yield">
      <MemberSignature Language="C#" Value="public static bool Yield ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool Yield() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Thread.Yield" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Yield () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool Yield();" />
      <MemberSignature Language="F#" Value="static member Yield : unit -&gt; bool" Usage="System.Threading.Thread.Yield " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Thread</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3e1bf-1278">Hace que el subproceso que realiza la llamada ceda la ejecución a otro subproceso que está listo para ejecutarse en el procesador actual.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1278">Causes the calling thread to yield execution to another thread that is ready to run on the current processor.</span></span> <span data-ttu-id="3e1bf-1279">El sistema operativo selecciona el subproceso al que se va a ceder la ejecución.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1279">The operating system selects the thread to yield to.</span></span></summary>
        <returns><span data-ttu-id="3e1bf-1280">Es <see langword="true" /> si el sistema operativo cambió la ejecución a otro subproceso; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1280"><see langword="true" /> if the operating system switched execution to another thread; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3e1bf-1281">Si este método se realiza correctamente, se cede el resto del intervalo de tiempo actual del subproceso.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1281">If this method succeeds, the rest of the thread's current time slice is yielded.</span></span> <span data-ttu-id="3e1bf-1282">El sistema operativo programa el subproceso de llamada para otro intervalo de tiempo, según su prioridad y el estado de otros subprocesos que están disponibles para ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1282">The operating system schedules the calling thread for another time slice, according to its priority and the status of other threads that are available to run.</span></span>  
  
 <span data-ttu-id="3e1bf-1283">La retención se limita al procesador que se está ejecutando el subproceso de llamada.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1283">Yielding is limited to the processor that is executing the calling thread.</span></span> <span data-ttu-id="3e1bf-1284">El sistema operativo no se cambiará la ejecución a otro procesador, incluso si dicho procesador está inactivo o se está ejecutando un subproceso de menor prioridad.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1284">The operating system will not switch execution to another processor, even if that processor is idle or is running a thread of lower priority.</span></span> <span data-ttu-id="3e1bf-1285">Si no hay ningún otro subproceso que esté listo para ejecutarse en el procesador actual, el sistema operativo no produce la ejecución y que devuelve este método `false`.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1285">If there are no other threads that are ready to execute on the current processor, the operating system does not yield execution, and this method returns `false`.</span></span>  
  
 <span data-ttu-id="3e1bf-1286">Este método es equivalente a usar invocación de plataforma para llamar a Win32 nativo `SwitchToThread` función.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1286">This method is equivalent to using platform invoke to call the native Win32 `SwitchToThread` function.</span></span> <span data-ttu-id="3e1bf-1287">Debe llamar a la <xref:System.Threading.Thread.Yield%2A> invocación de método en lugar de usar la plataforma, ya que omite cualquier comportamiento de subprocesamiento personalizado el host ha solicitado la invocación de plataforma.</span><span class="sxs-lookup"><span data-stu-id="3e1bf-1287">You should call the <xref:System.Threading.Thread.Yield%2A> method instead of using platform invoke, because platform invoke bypasses any custom threading behavior the host has requested.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>