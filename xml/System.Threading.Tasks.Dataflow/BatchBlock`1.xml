<Type Name="BatchBlock&lt;T&gt;" FullName="System.Threading.Tasks.Dataflow.BatchBlock&lt;T&gt;">
  <TypeSignature Language="C#" Value="public sealed class BatchBlock&lt;T&gt; : System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;, System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi sealed beforefieldinit BatchBlock`1&lt;T&gt; extends System.Object implements class System.Threading.Tasks.Dataflow.IDataflowBlock, class System.Threading.Tasks.Dataflow.IPropagatorBlock`2&lt;!T, !T[]&gt;, class System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T[]&gt;, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class BatchBlock(Of T)&#xA;Implements IPropagatorBlock(Of T, T()), IReceivableSourceBlock(Of T()), ISourceBlock(Of T()), ITargetBlock(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class BatchBlock sealed : System::Threading::Tasks::Dataflow::IPropagatorBlock&lt;T, cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::IReceivableSourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;, System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
    <AssemblyVersion>4.6.0.0</AssemblyVersion>
    <AssemblyVersion>4.6.1.0</AssemblyVersion>
    <AssemblyVersion>4.6.2.0</AssemblyVersion>
    <AssemblyVersion>4.6.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IPropagatorBlock&lt;T,T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.IReceivableSourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T"><span data-ttu-id="ce19c-101">Especifica el tipo de datos guardados en lotes.</span><span class="sxs-lookup"><span data-stu-id="ce19c-101">Specifies the type of data put into batches.</span></span></typeparam>
    <summary><span data-ttu-id="ce19c-102">Proporciona un bloque de flujo de datos que procesa por lotes las entradas en las matrices.</span><span class="sxs-lookup"><span data-stu-id="ce19c-102">Provides a dataflow block that batches inputs into arrays.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
[!INCLUDE [tpl-install-instructions](~/includes/tpl-install-instructions.md)]
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="ce19c-103">Número de elementos que se van a agrupar en un lote.</span><span class="sxs-lookup"><span data-stu-id="ce19c-103">The number of items to group into a batch.</span></span></param>
        <summary><span data-ttu-id="ce19c-104">Inicializa una nueva instancia de <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado.</span><span class="sxs-lookup"><span data-stu-id="ce19c-104">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> with the specified batch size.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ce19c-105"><paramref name="batchSize" /> debe ser positivo.</span><span class="sxs-lookup"><span data-stu-id="ce19c-105">The <paramref name="batchSize" /> must be positive.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BatchBlock (int batchSize, System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 batchSize, class System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions dataflowBlockOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.#ctor(System.Int32,System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (batchSize As Integer, dataflowBlockOptions As GroupingDataflowBlockOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BatchBlock(int batchSize, System::Threading::Tasks::Dataflow::GroupingDataflowBlockOptions ^ dataflowBlockOptions);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="batchSize" Type="System.Int32" />
        <Parameter Name="dataflowBlockOptions" Type="System.Threading.Tasks.Dataflow.GroupingDataflowBlockOptions" />
      </Parameters>
      <Docs>
        <param name="batchSize"><span data-ttu-id="ce19c-106">Número de elementos que se van a agrupar en un lote.</span><span class="sxs-lookup"><span data-stu-id="ce19c-106">The number of items to group into a batch.</span></span></param>
        <param name="dataflowBlockOptions"><span data-ttu-id="ce19c-107">Las opciones con las que se va a configurar este <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-107">The options with which to configure this <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span></span></param>
        <summary><span data-ttu-id="ce19c-108">Inicializa una nueva <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> con el tamaño de lote especificado, la opción de rechazo y las opciones de bloque.</span><span class="sxs-lookup"><span data-stu-id="ce19c-108">Initializes a new <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> with the specified batch size, declining option, and block options.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="ce19c-109"><paramref name="batchSize" /> debe ser positivo.</span><span class="sxs-lookup"><span data-stu-id="ce19c-109">The <paramref name="batchSize" /> must be positive.</span></span>  
  
 <span data-ttu-id="ce19c-110">O bien</span><span class="sxs-lookup"><span data-stu-id="ce19c-110">-or-</span></span>  
  
 <span data-ttu-id="ce19c-111"><paramref name="batchSize" /> debe ser menor que el valor de la opción <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> si se ha establecido un valor no predeterminado.</span><span class="sxs-lookup"><span data-stu-id="ce19c-111">The <paramref name="batchSize" /> must be smaller than the value of the <see cref="P:System.Threading.Tasks.Dataflow.DataflowBlockOptions.BoundedCapacity" /> option if a non-default value has been set.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ce19c-112">El valor de <paramref name="dataflowBlockOptions" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-112">The <paramref name="dataflowBlockOptions" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce19c-113">Obtiene el tamaño de los lotes generados por <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-113">Gets the size of the batches generated by this  <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" />.</span></span></summary>
        <value><span data-ttu-id="ce19c-114">Tamaño del lote.</span><span class="sxs-lookup"><span data-stu-id="ce19c-114">The batch size.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-115">Si el número de elementos proporcionados para el bloque no es divisible por el tamaño del lote proporcionado al constructor del bloque, lote final del bloque puede contener menor que el número solicitado de elementos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-115">If the number of items provided to the block is not evenly divisible by the batch size provided to the block's constructor, the block's final batch may contain fewer than the requested number of items.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Complete">
      <MemberSignature Language="C#" Value="public void Complete ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Complete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.Complete" />
      <MemberSignature Language="VB.NET" Value="Public Sub Complete ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Complete();" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Complete</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce19c-116">Señala a <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> que no debe aceptar ni mostrar más mensajes ni usar más mensajes pospuestos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-116">Signals to the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> that it should not accept nor produce any more messages nor consume any more postponed messages.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-117">Después de <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> ha sido llamado en un bloque de flujo de datos, se completará dicho bloque y su <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> tarea pasará un estado final ha procesado todos los datos disponibles anteriormente.</span><span class="sxs-lookup"><span data-stu-id="ce19c-117">After <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task will enter a final state after it has processed all previously available data.</span></span> <span data-ttu-id="ce19c-118"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> Will no bloque esperar la finalización se produzca, pero en su lugar, se iniciará la solicitud; para esperar la finalización se produzca, el <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> puede utilizarse la tarea.</span><span class="sxs-lookup"><span data-stu-id="ce19c-118"><xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Complete%2A> will not block waiting for completion to occur, but rather will initiate the request; to wait for completion to occur, the <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task may be used.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Completion">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task Completion { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Threading.Tasks.Task Completion" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.Completion" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Completion As Task" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Threading::Tasks::Task ^ Completion { System::Threading::Tasks::Task ^ get(); };" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Threading.Tasks.Dataflow.IDataflowBlock.Completion</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce19c-119">Obtiene un objeto <see cref="T:System.Threading.Tasks.Task" /> que representa la operación asincrónica y la finalización del bloque de flujo de datos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-119">Gets a <see cref="T:System.Threading.Tasks.Task" /> that represents the asynchronous operation and completion of the dataflow block.</span></span></summary>
        <value><span data-ttu-id="ce19c-120">Tarea.</span><span class="sxs-lookup"><span data-stu-id="ce19c-120">The task.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-121">Un bloque de flujo de datos se considera completada cuando no está procesando actualmente un mensaje y cuando se garantiza que no se procesará más mensajes.</span><span class="sxs-lookup"><span data-stu-id="ce19c-121">A dataflow block is considered completed when it is not currently processing a message and when it has guaranteed that it will not process any more messages.</span></span> <span data-ttu-id="ce19c-122">El valor devuelto <xref:System.Threading.Tasks.Task> le transición a un estado completado cuando se haya completado el bloque asociado.</span><span class="sxs-lookup"><span data-stu-id="ce19c-122">The returned <xref:System.Threading.Tasks.Task> will transition to a completed state when the associated block has completed.</span></span> <span data-ttu-id="ce19c-123">Realizará la transición a la <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.RanToCompletion> semántica definido por el estado cuando el bloque termine de procesarse correctamente según el bloque de flujo de datos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-123">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.RanToCompletion> state when the block completes its processing successfully according to the dataflow block’s defined semantics.</span></span> <span data-ttu-id="ce19c-124">Realizará la transición a la <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Faulted> cuando el bloque de flujo de datos ha completado el procesamiento antes de tiempo debido a una excepción no controlada y realizará la transición a la <xref:System.Threading.Tasks.TaskStatus> <xref:System.Threading.Tasks.TaskStatus.Canceled> estado cuando el bloque de flujo de datos finaliza el procesamiento antes de tiempo debido a la recepción de una solicitud de cancelación.</span><span class="sxs-lookup"><span data-stu-id="ce19c-124">It will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Faulted> state when the dataflow block has completed processing prematurely due to an unhandled exception, and it will transition to the <xref:System.Threading.Tasks.TaskStatus><xref:System.Threading.Tasks.TaskStatus.Canceled> state when the dataflow block has completed processing prematurely due to receiving a cancellation request.</span></span> <span data-ttu-id="ce19c-125">Si la tarea se completa con el <xref:System.Threading.Tasks.TaskStatus.Faulted> estado, su `Exception` propiedad devolverá una <xref:System.AggregateException> que contiene una o más excepciones que ha causado el bloqueo de un error.</span><span class="sxs-lookup"><span data-stu-id="ce19c-125">If the task completes in the <xref:System.Threading.Tasks.TaskStatus.Faulted> state, its `Exception` property will return an <xref:System.AggregateException> containing the one or more exceptions that caused the block to fail.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LinkTo">
      <MemberSignature Language="C#" Value="public IDisposable LinkTo (System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.IDisposable LinkTo(class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, class System.Threading.Tasks.Dataflow.DataflowLinkOptions linkOptions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Threading.Tasks.Dataflow.DataflowLinkOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function LinkTo (target As ITargetBlock(Of T()), linkOptions As DataflowLinkOptions) As IDisposable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual IDisposable ^ LinkTo(System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, System::Threading::Tasks::Dataflow::DataflowLinkOptions ^ linkOptions);" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.LinkTo(System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Threading.Tasks.Dataflow.DataflowLinkOptions)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IDisposable</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="linkOptions" Type="System.Threading.Tasks.Dataflow.DataflowLinkOptions" />
      </Parameters>
      <Docs>
        <param name="target"><span data-ttu-id="ce19c-126"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> con el que conectar este origen.</span><span class="sxs-lookup"><span data-stu-id="ce19c-126">The  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to which to connect this source.</span></span></param>
        <param name="linkOptions"><span data-ttu-id="ce19c-127">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> que configura el vínculo.</span><span class="sxs-lookup"><span data-stu-id="ce19c-127">A <see cref="T:System.Threading.Tasks.Dataflow.DataflowLinkOptions" /> instance that configures the link.</span></span></param>
        <summary><span data-ttu-id="ce19c-128">Vincula el <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> al <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="ce19c-128">Links the  <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> to the specified  <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> .</span></span></summary>
        <returns><span data-ttu-id="ce19c-129">IDisposable que, al llamar a Dispose, desvinculará el origen del destino.</span><span class="sxs-lookup"><span data-stu-id="ce19c-129">An IDisposable that, upon calling Dispose, will unlink the source from the target.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="ce19c-130"><paramref name="target" /> es NULL (Nothing en Visual Basic) o <paramref name="linkOptions" /> es NULL (Nothing en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="ce19c-130"><paramref name="target" /> is null (Nothing in Visual Basic) or  <paramref name="linkOptions" /> is null (Nothing in Visual Basic).</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OutputCount">
      <MemberSignature Language="C#" Value="public int OutputCount { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 OutputCount" />
      <MemberSignature Language="DocId" Value="P:System.Threading.Tasks.Dataflow.BatchBlock`1.OutputCount" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property OutputCount As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int OutputCount { int get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="ce19c-131">Obtiene el número de elementos de salida disponibles que se pueden recibir de este bloque.</span><span class="sxs-lookup"><span data-stu-id="ce19c-131">Gets the number of output items available to be received from this block.</span></span></summary>
        <value><span data-ttu-id="ce19c-132">Número de elementos de salida.</span><span class="sxs-lookup"><span data-stu-id="ce19c-132">The number of output items.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.IDataflowBlock.Fault">
      <MemberSignature Language="C#" Value="void IDataflowBlock.Fault (Exception exception);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(class System.Exception exception) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#IDataflowBlock#Fault(System.Exception)" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(Exception ^ exception) = System::Threading::Tasks::Dataflow::IDataflowBlock::Fault;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault(System.Exception)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="exception" Type="System.Exception" />
      </Parameters>
      <Docs>
        <param name="exception"><span data-ttu-id="ce19c-133"><see cref="T:System.Exception" /> que causó el error.</span><span class="sxs-lookup"><span data-stu-id="ce19c-133">The <see cref="T:System.Exception" /> that caused the faulting.</span></span></param>
        <summary><span data-ttu-id="ce19c-134">Hace que <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> se complete en un estado <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-134">Causes the <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> to complete in a  <see cref="F:System.Threading.Tasks.TaskStatus.Faulted" /> state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-135">Después de <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> ha sido llamado en un bloque de flujo de datos, se completará dicho bloque y su <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> tarea pasará a un estado final.</span><span class="sxs-lookup"><span data-stu-id="ce19c-135">After <xref:System.Threading.Tasks.Dataflow.IDataflowBlock.Fault%2A> has been called on a dataflow block, that block will complete, and its <xref:System.Threading.Tasks.Dataflow.BatchBlock%601.Completion%2A> task will enter a final state.</span></span> <span data-ttu-id="ce19c-136">Un error en un bloque, como con cancelar un bloque, hace que los mensajes almacenados en búfer (mensajes de entrada sin procesar así como mensajes de salida unoffered) se perderán.</span><span class="sxs-lookup"><span data-stu-id="ce19c-136">Faulting a block, as with canceling a block, causes buffered messages (unprocessed input messages as well as unoffered output messages) to be lost.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ce19c-137">El valor de <paramref name="exception" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-137">The <paramref name="exception" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage">
      <MemberSignature Language="C#" Value="T[] ISourceBlock&lt;T[]&gt;.ConsumeMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target, out bool messageConsumed);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance !T[] System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target, [out] bool&amp; messageConsumed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]},System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Function ConsumeMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T()), ByRef messageConsumed As Boolean) As T() Implements ISourceBlock(Of T()).ConsumeMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual cli::array &lt;T&gt; ^ System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ConsumeMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target, [Runtime::InteropServices::Out] bool % messageConsumed) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ConsumeMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
        <Parameter Name="messageConsumed" Type="System.Boolean&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="ce19c-138"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está usando.</span><span class="sxs-lookup"><span data-stu-id="ce19c-138">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message being consumed.</span></span></param>
        <param name="target"><span data-ttu-id="ce19c-139"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que consume el mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-139">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> consuming the message.</span></span></param>
        <param name="messageConsumed">
          <span data-ttu-id="ce19c-140"><see langword="true" /> si se ha consumido correctamente el mensaje; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-140"><see langword="true" /> if the message was successfully consumed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="ce19c-141">Lo llama una <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para aceptar y consumir una <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-141">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to accept and consume a <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> previously offered by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> .</span></span></summary>
        <returns><span data-ttu-id="ce19c-142">Valor del mensaje consumido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-142">The value of the consumed message.</span></span> <span data-ttu-id="ce19c-143">Esto puede corresponder a una instancia diferente de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que se ha reservado y pasado previamente como <paramref name="messageHeader" /> a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-143">This may correspond to a different <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instance than was previously reserved and passed as the <paramref name="messageHeader" /> to <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" />.</span></span> <span data-ttu-id="ce19c-144">La interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> de consumo debe usar el valor devuelto en lugar del valor pasado como messageValue mediante <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-144">The consuming <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> must use the returned value instead of the value passed as messageValue through <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />.</span></span>  
  
 <span data-ttu-id="ce19c-145">Si el mensaje solicitado no está disponible, el valor devuelto será <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-145">If the message requested is not available, the return value will be <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-146">Solo [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 > instancias vinculadas a este [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 > instancia puede utilizar [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A >, y solo debe usarse para consumir [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > instancias proporcionado anteriormente por este origen al destino.</span><span class="sxs-lookup"><span data-stu-id="ce19c-146">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> , and it must only be used to consume [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously offered by this source to the target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce19c-147"><paramref name="messageHeader" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-147">The  <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ce19c-148">El valor de <paramref name="target" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-148">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation">
      <MemberSignature Language="C#" Value="void ISourceBlock&lt;T[]&gt;.ReleaseReservation (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Sub ReleaseReservation (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) Implements ISourceBlock(Of T()).ReleaseReservation" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReleaseReservation(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReleaseReservation;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReleaseReservation(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="ce19c-149"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje reservado que se va a liberar.</span><span class="sxs-lookup"><span data-stu-id="ce19c-149">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the reserved message being released.</span></span></param>
        <param name="target"><span data-ttu-id="ce19c-150"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que libera el mensaje que reservó previamente.</span><span class="sxs-lookup"><span data-stu-id="ce19c-150">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> releasing the message it previously reserved.</span></span></param>
        <summary><span data-ttu-id="ce19c-151">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para liberar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> reservada previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-151">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to release a previously reserved <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-152">Solo [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 > instancias vinculadas a este [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 > instancia puede utilizar `ReleaseReservation`, y solo debe usarse para liberar [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > instancias previamente y correctamente reservados por el destino.</span><span class="sxs-lookup"><span data-stu-id="ce19c-152">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use `ReleaseReservation`, and it must only be used to release [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously and successfully reserved by the target.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce19c-153"><paramref name="messageHeader" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-153">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ce19c-154">El valor de <paramref name="target" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-154">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="ce19c-155"><paramref name="target" /> no tiene el mensaje reservado.</span><span class="sxs-lookup"><span data-stu-id="ce19c-155">The <paramref name="target" /> did not have the message reserved.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage">
      <MemberSignature Language="C#" Value="bool ISourceBlock&lt;T[]&gt;.ReserveMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt; target);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, class System.Threading.Tasks.Dataflow.ITargetBlock`1&lt;!T[]&gt; target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ISourceBlock&lt;T[]&gt;#ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0[]})" />
      <MemberSignature Language="VB.NET" Value="Function ReserveMessage (messageHeader As DataflowMessageHeader, target As ITargetBlock(Of T())) As Boolean Implements ISourceBlock(Of T()).ReserveMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Threading.Tasks.Dataflow.ISourceBlock&lt;T[]&gt;.ReserveMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, System::Threading::Tasks::Dataflow::ITargetBlock&lt;cli::array &lt;T&gt; ^&gt; ^ target) = System::Threading::Tasks::Dataflow::ISourceBlock&lt;cli::array &lt;T&gt; ^&gt;::ReserveMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ReserveMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0})</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="target" Type="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T[]&gt;" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="ce19c-156"><see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> del mensaje que se está reservando.</span><span class="sxs-lookup"><span data-stu-id="ce19c-156">The <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> of the message being reserved.</span></span></param>
        <param name="target"><span data-ttu-id="ce19c-157"><see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> que reserva el mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-157">The <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> reserving the message.</span></span></param>
        <summary><span data-ttu-id="ce19c-158">Lo llama una interfaz <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> vinculada para reservar una estructura <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> ofrecida previamente por esta interfaz <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-158">Called by a linked <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" /> to reserve a previously offered <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> by this <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" />.</span></span></summary>
        <returns>
          <span data-ttu-id="ce19c-159"><see langword="true" /> si se ha procesado correctamente el mensaje; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-159"><see langword="true" /> if the message was successfully reserved; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-160">Solo [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 > instancias vinculadas a este [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601 > instancia puede utilizar [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A >, y solo debe usarse para reservar [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader > instancias proporcionado anteriormente por este origen al destino.</span><span class="sxs-lookup"><span data-stu-id="ce19c-160">Only [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> instances linked to this [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601> instance may use [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A>, and it must only be used to reserve [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.DataflowMessageHeader> instances previously offered by this source to the target.</span></span>  
  
 <span data-ttu-id="ce19c-161">Si `true` se devuelve, el [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601 > posteriormente debe llamar a [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A > o [ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A > para este mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-161">If `true` is returned, the  [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ITargetBlock%601> must subsequently call either  [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ConsumeMessage%2A> or [ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReleaseReservation%2A> for this message.</span></span> <span data-ttu-id="ce19c-162">Si no lo hace puede producir en el origen de su incapacidad para propagar los mensajes adicionales a este u otros destinos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-162">Failure to do so may result in the source being unable to propagate any further messages to this or other targets.</span></span>  
  
 <span data-ttu-id="ce19c-163">[ISourceBlock (T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A > no deben llamar mientras el destino mantiene los bloqueos internos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-163">[ISourceBlock(T\<xref:System.Threading.Tasks.Dataflow.ISourceBlock%601.ReserveMessage%2A> must not be called while the target is holding any internal locks.</span></span> <span data-ttu-id="ce19c-164">Si lo hace, infringirán la jerarquía de bloqueos necesaria para evitar los interbloqueos en una red de flujo de datos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-164">Doing so will violate the lock hierarchy necessary to avoid deadlocks in a dataflow network.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce19c-165"><paramref name="messageHeader" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-165">The <paramref name="messageHeader" /> is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="ce19c-166">El valor de <paramref name="target" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-166">The <paramref name="target" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage">
      <MemberSignature Language="C#" Value="System.Threading.Tasks.Dataflow.DataflowMessageStatus ITargetBlock&lt;T&gt;.OfferMessage (System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, T messageValue, System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt; source, bool consumeToAccept);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance valuetype System.Threading.Tasks.Dataflow.DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(valuetype System.Threading.Tasks.Dataflow.DataflowMessageHeader messageHeader, !T messageValue, class System.Threading.Tasks.Dataflow.ISourceBlock`1&lt;!T&gt; source, bool consumeToAccept) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.System#Threading#Tasks#Dataflow#ITargetBlock&lt;T&gt;#OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Function OfferMessage (messageHeader As DataflowMessageHeader, messageValue As T, source As ISourceBlock(Of T), consumeToAccept As Boolean) As DataflowMessageStatus Implements ITargetBlock(Of T).OfferMessage" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Threading::Tasks::Dataflow::DataflowMessageStatus System.Threading.Tasks.Dataflow.ITargetBlock&lt;T&gt;.OfferMessage(System::Threading::Tasks::Dataflow::DataflowMessageHeader messageHeader, T messageValue, System::Threading::Tasks::Dataflow::ISourceBlock&lt;T&gt; ^ source, bool consumeToAccept) = System::Threading::Tasks::Dataflow::ITargetBlock&lt;T&gt;::OfferMessage;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Dataflow.DataflowMessageStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="messageHeader" Type="System.Threading.Tasks.Dataflow.DataflowMessageHeader" />
        <Parameter Name="messageValue" Type="T" />
        <Parameter Name="source" Type="System.Threading.Tasks.Dataflow.ISourceBlock&lt;T&gt;" />
        <Parameter Name="consumeToAccept" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="messageHeader"><span data-ttu-id="ce19c-167">Instancia de <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> que representa el encabezado del mensaje que se va a ofrecer.</span><span class="sxs-lookup"><span data-stu-id="ce19c-167">A <see cref="T:System.Threading.Tasks.Dataflow.DataflowMessageHeader" /> instance that represents the header of the message being offered.</span></span></param>
        <param name="messageValue"><span data-ttu-id="ce19c-168">Valor del mensaje que se va a ofrecer.</span><span class="sxs-lookup"><span data-stu-id="ce19c-168">The value of the message being offered.</span></span></param>
        <param name="source"><span data-ttu-id="ce19c-169"><see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> que ofrece el mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-169">The <see cref="T:System.Threading.Tasks.Dataflow.ISourceBlock`1" /> offering the message.</span></span> <span data-ttu-id="ce19c-170">Puede ser null.</span><span class="sxs-lookup"><span data-stu-id="ce19c-170">This may be null.</span></span></param>
        <param name="consumeToAccept"><span data-ttu-id="ce19c-171">Establézcalo en <see langword="true" /> para indicar al destino para llamar a <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> sincrónicamente durante la llamada a <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, antes de devolver <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, para usar el mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-171">Set to <see langword="true" /> to instruct the target to call <see cref="M:System.Threading.Tasks.Dataflow.ISourceBlock`1.ConsumeMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,System.Threading.Tasks.Dataflow.ITargetBlock{`0},System.Boolean@)" /> synchronously during the call to <see cref="M:System.Threading.Tasks.Dataflow.ITargetBlock`1.OfferMessage(System.Threading.Tasks.Dataflow.DataflowMessageHeader,`0,System.Threading.Tasks.Dataflow.ISourceBlock{`0},System.Boolean)" />, prior to returning <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" />, in order to consume the message.</span></span></param>
        <summary><span data-ttu-id="ce19c-172">Ofrece un mensaje a <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, dando al destino la oportunidad de usar o de posponer el mensaje.</span><span class="sxs-lookup"><span data-stu-id="ce19c-172">Offers a message to the <see cref="T:System.Threading.Tasks.Dataflow.ITargetBlock`1" />, giving the target the opportunity to consume or postpone the message.</span></span></summary>
        <returns><span data-ttu-id="ce19c-173">Estado del mensaje ofrecido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-173">The status of the offered message.</span></span> <span data-ttu-id="ce19c-174">Si el destino aceptó el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> y el origen ya no debe usar más el mensaje ofrecido, ya que ahora es propiedad del destino.</span><span class="sxs-lookup"><span data-stu-id="ce19c-174">If the message was accepted by the target, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Accepted" /> is returned, and the source should no longer use the offered message, because it is now owned by the target.</span></span> <span data-ttu-id="ce19c-175">Si el destino pospuso el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> como notificación de que el destino puede intentar más adelante consumir o reservar el mensaje; mientras tanto, el origen todavía posee el mensaje y puede ofrecerlo a otros bloques.</span><span class="sxs-lookup"><span data-stu-id="ce19c-175">If the message was postponed by the target, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Postponed" /> is returned as a notification that the target may later attempt to consume or reserve the message; in the meantime, the source still owns the message and may offer it to other blocks.</span></span>  
  
 <span data-ttu-id="ce19c-176">Si el destino habría pospuesto de otra forma el mensaje, pero <paramref name="source" /> era <see langword="null" />, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="ce19c-176">If the target would have otherwise postponed message, but <paramref name="source" /> was <see langword="null" />, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> is instead returned.</span></span>  
  
 <span data-ttu-id="ce19c-177">Si el destino intentó aceptar el mensaje pero no pudo hacerlo porque el origen entrega el mensaje a otro destino o lo descarta simplemente, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-177">If the target tried to accept the message but missed it due to the source delivering the message to another target or simply discarding it, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.NotAvailable" /> is returned.</span></span>  
  
 <span data-ttu-id="ce19c-178">Si el destino eligió no aceptar el mensaje, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-178">If the target chose not to accept the message, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.Declined" /> is returned.</span></span> <span data-ttu-id="ce19c-179">Si el destino eligió no aceptar el mensaje y nunca aceptará otro mensaje de este origen, se devuelve <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-179">If the target chose not to accept the message and will never accept another message from this source, <see cref="F:System.Threading.Tasks.Dataflow.DataflowMessageStatus.DecliningPermanently" /> is returned.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="ce19c-180"><paramref name="messageHeader" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="ce19c-180">The  <paramref name="messageHeader" /> is not valid.</span></span>  
  
 <span data-ttu-id="ce19c-181">O bien, <paramref name="consumeToAccept" /> solo puede ser true si se le proporciona un valor <paramref name="source" /> distinto de NULL.</span><span class="sxs-lookup"><span data-stu-id="ce19c-181">-or- <paramref name="consumeToAccept" /> may only be true if provided with a non-null <paramref name="source" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce19c-182">Devuelve una cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-182">Returns a string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></summary>
        <returns><span data-ttu-id="ce19c-183">Cadena que representa el nombre con formato de esta instancia de <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-183">A string that represents the formatted name of this  <see cref="T:System.Threading.Tasks.Dataflow.IDataflowBlock" /> instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-184">Se hereda de <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ce19c-184">Inherited from <xref:System.Object>.</span></span> <span data-ttu-id="ce19c-185">Usa el <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> opción.</span><span class="sxs-lookup"><span data-stu-id="ce19c-185">Uses the  <xref:System.Threading.Tasks.Dataflow.DataflowBlockOptions.NameFormat%2A> option.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TriggerBatch">
      <MemberSignature Language="C#" Value="public void TriggerBatch ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TriggerBatch() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TriggerBatch" />
      <MemberSignature Language="VB.NET" Value="Public Sub TriggerBatch ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TriggerBatch();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="ce19c-186">Desencadena <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> para iniciar una operación de procesamiento por lotes incluso si el número de elementos actualmente en cola o pospuestos es menor que <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-186">Triggers the <see cref="T:System.Threading.Tasks.Dataflow.BatchBlock`1" /> to initiate a batching operation even if the number of currently queued or postponed items is less than the <see cref="P:System.Threading.Tasks.Dataflow.BatchBlock`1.BatchSize" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-187">En modo expansivo, se generará un lote de elementos en cola aunque menos existan que el tamaño del lote.</span><span class="sxs-lookup"><span data-stu-id="ce19c-187">In greedy mode, a batch will be generated from queued items even if fewer exist than the batch size.</span></span>  
  
 <span data-ttu-id="ce19c-188">En el modo no expansivo, un lote se genera asincrónicamente desde elementos pospuestos aunque pueden utilizarse menos elementos que especifican el tamaño del lote.</span><span class="sxs-lookup"><span data-stu-id="ce19c-188">In non-greedy mode, a batch will be generated asynchronously from postponed items even if fewer items than specified by the batch size can be consumed.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceive">
      <MemberSignature Language="C#" Value="public bool TryReceive (Predicate&lt;T[]&gt; filter, out T[] item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceive(class System.Predicate`1&lt;!T[]&gt; filter, [out] !T[]&amp; item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceive(System.Predicate{`0[]},`0[]@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceive (filter As Predicate(Of T()), ByRef item As T()) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceive(Predicate&lt;cli::array &lt;T&gt; ^&gt; ^ filter, [Runtime::InteropServices::Out] cli::array &lt;T&gt; ^ % item);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Predicate&lt;T[]&gt;" />
        <Parameter Name="item" Type="T[]&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="ce19c-189">Predicado que un valor debe pasar correctamente para que se reciba.</span><span class="sxs-lookup"><span data-stu-id="ce19c-189">The predicate a value must successfully pass in order for it to be received.</span></span>  <span data-ttu-id="ce19c-190"><c>filter</c> puede ser <see langword="null" />, en cuyo caso se pasarán todos los elementos.</span><span class="sxs-lookup"><span data-stu-id="ce19c-190"><c>filter</c> may be <see langword="null" />, in which case all items will pass.</span></span></param>
        <param name="item"><span data-ttu-id="ce19c-191">Elemento recibido del origen.</span><span class="sxs-lookup"><span data-stu-id="ce19c-191">The item received from the source.</span></span></param>
        <summary><span data-ttu-id="ce19c-192">Intentos de recibir sincrónicamente un elemento de salida disponible de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-192">Attempts to synchronously receive an available output item from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns>
          <span data-ttu-id="ce19c-193">Es <see langword="true" /> si se pudo recibir un elemento; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-193"><see langword="true" /> if an item could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-194">Este método no bloquear la espera para el origen proporcionar un elemento.</span><span class="sxs-lookup"><span data-stu-id="ce19c-194">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="ce19c-195">Devolverá después de comprobar si un elemento, si no estaba disponible un elemento.</span><span class="sxs-lookup"><span data-stu-id="ce19c-195">It will return after checking for an element, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryReceiveAll">
      <MemberSignature Language="C#" Value="public bool TryReceiveAll (out System.Collections.Generic.IList&lt;T[]&gt; items);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryReceiveAll([out] class System.Collections.Generic.IList`1&lt;!T[]&gt;&amp; items) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Threading.Tasks.Dataflow.BatchBlock`1.TryReceiveAll(System.Collections.Generic.IList{`0[]}@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryReceiveAll (ByRef items As IList(Of T())) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool TryReceiveAll([Runtime::InteropServices::Out] System::Collections::Generic::IList&lt;cli::array &lt;T&gt; ^&gt; ^ % items);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Threading.Tasks.Dataflow</AssemblyName>
        <AssemblyVersion>4.6.0.0</AssemblyVersion>
        <AssemblyVersion>4.6.1.0</AssemblyVersion>
        <AssemblyVersion>4.6.2.0</AssemblyVersion>
        <AssemblyVersion>4.6.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="items" Type="System.Collections.Generic.IList&lt;T[]&gt;&amp;" RefType="out" />
      </Parameters>
      <Docs>
        <param name="items"><span data-ttu-id="ce19c-196">Elementos recibidos del origen.</span><span class="sxs-lookup"><span data-stu-id="ce19c-196">The items received from the source.</span></span></param>
        <summary><span data-ttu-id="ce19c-197">Intentos de recibir sincrónicamente todos los elementos disponibles de <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-197">Attempts to synchronously receive all available items from the <see cref="T:System.Threading.Tasks.Dataflow.IReceivableSourceBlock`1" />.</span></span></summary>
        <returns>
          <span data-ttu-id="ce19c-198">Es <see langword="true" /> si se podían recibir uno o más elementos; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="ce19c-198"><see langword="true" /> if one or more items could be received; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="ce19c-199">Este método no bloquear la espera para el origen proporcionar un elemento.</span><span class="sxs-lookup"><span data-stu-id="ce19c-199">This method does not block waiting for the source to provide an item.</span></span>  
  
 <span data-ttu-id="ce19c-200">Devolverá después de comprobar los elementos, si no estaba disponible un elemento.</span><span class="sxs-lookup"><span data-stu-id="ce19c-200">It will return after checking for elements, whether or not an element was available.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>