<Type Name="CodeAccessPermission" FullName="System.Security.CodeAccessPermission">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="8e7af9d8cbb4fd2f1ff40caec1c241fe521efb7a" />
    <Meta Name="ms.sourcegitcommit" Value="c0c07dbd19cd7017243f9ac36915755f79bc8da6" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/27/2018" />
    <Meta Name="ms.locfileid" Value="52365067" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class CodeAccessPermission : System.Security.IPermission, System.Security.IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit CodeAccessPermission extends System.Object implements class System.Security.IPermission, class System.Security.ISecurityEncodable, class System.Security.IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.CodeAccessPermission" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeAccessPermission&#xA;Implements IPermission, IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeAccessPermission abstract : System::Security::IPermission, System::Security::IStackWalk" />
  <TypeSignature Language="F#" Value="type CodeAccessPermission = class&#xA;    interface IPermission&#xA;    interface ISecurityEncodable&#xA;    interface IStackWalk" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Security.IPermission</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.ISecurityEncodable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IStackWalk</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="f6a7f-101">Define la estructura subyacente de todos los permisos de acceso del código.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f6a7f-101">Defines the underlying structure of all code access permissions.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-102">Permisos de acceso de código utiliza un recorrido de pila para asegurarse de que todos los llamadores del código tienen un permiso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-102">Code access permissions use a stack walk to ensure that all callers of the code have been granted a permission.</span></span> <span data-ttu-id="f6a7f-103">Si es un objeto de permiso `null`, se administra igual que un objeto de permiso con el estado <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-103">If a permission object is `null`, it is handled the same as a permission object with the state <xref:System.Security.Permissions.PermissionState.None?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="f6a7f-104">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-104">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="f6a7f-105">Los herederos de la <xref:System.Security.CodeAccessPermission> clase se debe conceder plena confianza para que funcione correctamente como permisos que extienden la infraestructura de seguridad.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-105">Inheritors of the <xref:System.Security.CodeAccessPermission> class must be granted full trust to function correctly as permissions extending the security infrastructure.</span></span> <span data-ttu-id="f6a7f-106">Para determinar que los herederos sean de plena confianza, <xref:System.Security.CodeAccessPermission> problemas una <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> para <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence>  =  `true` y <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy>  =  `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-106">To determine that the inheritors are fully trusted, <xref:System.Security.CodeAccessPermission> issues an <xref:System.Security.Permissions.SecurityAction.InheritanceDemand> for <xref:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence> = `true` and <xref:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy> = `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-107">En el ejemplo de código siguiente se muestra un permiso que se deriva el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-107">The following code example shows a permission derived from the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#1)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#1)]
 [!code-vb[System.Security.Permissions.NameIdPermission#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand">
      <span data-ttu-id="f6a7f-108">para los herederos para proporcionar evidencia y ver y modificar la directiva.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f6a7f-108">for the ability of inheritors to provide evidence and view and modify policy.</span>
      </span>
      <span data-ttu-id="f6a7f-109">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="f6a7f-109">Associated enumerations: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />, <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPolicy" />.</span>
      </span>
    </permission>
    <block subset="none" type="overrides">
      <para>
        <span data-ttu-id="f6a7f-110">Al heredar de <see cref="T:System.Security.CodeAccessPermission" />, también debe implementar la <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interfaz.</span>
        <span class="sxs-lookup">
          <span data-stu-id="f6a7f-110">When you inherit from <see cref="T:System.Security.CodeAccessPermission" />, you must also implement the <see cref="T:System.Security.Permissions.IUnrestrictedPermission" /> interface.</span>
        </span>
        <span data-ttu-id="f6a7f-111">La siguiente <see cref="T:System.Security.CodeAccessPermission" /> deben invalidarse los miembros: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, y <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="f6a7f-111">The following <see cref="T:System.Security.CodeAccessPermission" /> members must be overridden: <see cref="M:System.Security.CodeAccessPermission.Copy" />, <see cref="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />, <see cref="M:System.Security.CodeAccessPermission.ToXml" />, <see cref="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />, and <see cref="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />.</span>
        </span>
        <span data-ttu-id="f6a7f-112">También debe definir un constructor que toma un <see cref="T:System.Security.Permissions.PermissionState" /> como su único parámetro.</span>
        <span class="sxs-lookup">
          <span data-stu-id="f6a7f-112">You must also define a constructor that takes a <see cref="T:System.Security.Permissions.PermissionState" /> as its only parameter.</span>
        </span>
        <span data-ttu-id="f6a7f-113">Se debe aplicar el <see cref="T:System.SerializableAttribute" /> atributo a una clase que hereda de <see cref="T:System.Security.CodeAccessPermission" />.</span>
        <span class="sxs-lookup">
          <span data-stu-id="f6a7f-113">You must apply the <see cref="T:System.SerializableAttribute" /> attribute to a class that inherits from <see cref="T:System.Security.CodeAccessPermission" />.</span>
        </span>
      </para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeAccessPermission ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeAccessPermission();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-114">Inicializa una nueva instancia de la clase <see cref="T:System.Security.CodeAccessPermission" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-114">Initializes a new instance of the <see cref="T:System.Security.CodeAccessPermission" /> class.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-115">Se llama a este constructor para inicializar el estado en el tipo cada vez que se crea una instancia de la clase derivada.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-115">This constructor is called to initialize state in the type whenever an instance of the derived class is created.</span></span> <span data-ttu-id="f6a7f-116">Aunque puede llamar explícitamente a este constructor en la declaración del constructor del constructor de clase derivada, esto normalmente no es necesario; la mayoría de los compiladores generará automáticamente la llamada para usted.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-116">Although you can explicitly call this constructor in the constructor declaration of the derived class constructor, this is not usually necessary; most compilers will automatically generate the call for you.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit&#xA;override this.Assert : unit -&gt; unit" Usage="codeAccessPermission.Assert " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-117">Declara que el código de llamada puede tener acceso al recurso protegido por una demanda de permiso a través del código que llama a este método, incluso si los autores de la llamada situados en una posición más alta de la pila no tienen permiso para tener acceso al recurso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-117">Declares that the calling code can access the resource protected by a permission demand through the code that calls this method, even if callers higher in the stack have not been granted permission to access the resource.</span>
          </span>
          <span data-ttu-id="f6a7f-118">El uso de <see cref="M:System.Security.CodeAccessPermission.Assert" /> puede crear problemas de seguridad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-118">Using <see cref="M:System.Security.CodeAccessPermission.Assert" /> can create security issues.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-119">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-119">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="f6a7f-120">Una llamada a <xref:System.Security.CodeAccessPermission.Assert%2A> evita que un recorrido de pila que se originan inferior en la pila de llamadas de continuar la pila de llamadas por encima del código que llama a este método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-120">Calling <xref:System.Security.CodeAccessPermission.Assert%2A> prevents a stack walk originating lower in the call stack from proceeding up the call stack beyond the code that calls this method.</span></span> <span data-ttu-id="f6a7f-121">Por lo tanto, incluso si los llamadores situados en la pila de llamadas no tiene los permisos necesarios para tener acceso a un recurso, todavía podrán tener acceso a través del código que llama a este método en el permiso necesario.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-121">Therefore, even if callers higher on the call stack do not have the requisite permissions to access a resource, they can still access it through the code that calls this method on the necessary permission.</span></span> <span data-ttu-id="f6a7f-122">Una aserción es efectiva únicamente si el código que llama <xref:System.Security.CodeAccessPermission.Assert%2A> pasa la comprobación de seguridad para el permiso que está la aserción.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-122">An assertion is effective only if the code that calls <xref:System.Security.CodeAccessPermission.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="f6a7f-123">La llamada a <xref:System.Security.CodeAccessPermission.Assert%2A> es efectivo hasta que el código de llamada vuelve al llamador.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-123">The call to <xref:System.Security.CodeAccessPermission.Assert%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f6a7f-124">Solo un <xref:System.Security.CodeAccessPermission.Assert%2A> pueden estar activas en un marco.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-124">Only one <xref:System.Security.CodeAccessPermission.Assert%2A> can be active on a frame.</span></span> <span data-ttu-id="f6a7f-125">Un intento de llamar a <xref:System.Security.CodeAccessPermission.Assert%2A> cuando se activa <xref:System.Security.CodeAccessPermission.Assert%2A> existe en el marco da como resultado un <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-125">An attempt to call <xref:System.Security.CodeAccessPermission.Assert%2A> when an active <xref:System.Security.CodeAccessPermission.Assert%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f6a7f-126">Llame a <xref:System.Security.CodeAccessPermission.RevertAssert%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> para quitar un activo <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-126">Call <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span>  
  
 <span data-ttu-id="f6a7f-127"><xref:System.Security.CodeAccessPermission.Assert%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-127"><xref:System.Security.CodeAccessPermission.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="f6a7f-128">Sin embargo, si llama código más abajo en la pila de llamadas <xref:System.Security.CodeAccessPermission.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-128">However, if code lower on the call stack calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f6a7f-129">Esto sucede porque el código que llamó <xref:System.Security.CodeAccessPermission.Assert%2A> no dispone del permiso, aunque intentó <xref:System.Security.CodeAccessPermission.Assert%2A> lo.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-129">This happens because the code that called <xref:System.Security.CodeAccessPermission.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.CodeAccessPermission.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="f6a7f-130">Dado que una llamada a <xref:System.Security.CodeAccessPermission.Assert%2A> quita el requisito de que todo el código en la cadena de llamada debe tener el permiso para acceder al recurso especificado, puede abrir problemas de seguridad si utiliza incorrectamente o incorrectamente.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-130">Because calling <xref:System.Security.CodeAccessPermission.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security issues if used incorrectly or inappropriately.</span></span> <span data-ttu-id="f6a7f-131">Por lo tanto, debe usarse con mucha precaución.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-131">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f6a7f-132">El código de llamada no tiene <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-132">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span>
          </span>
          <span data-ttu-id="f6a7f-133">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-133">-or-</span>
          </span>
          <span data-ttu-id="f6a7f-134">Ya hay una <see cref="M:System.Security.CodeAccessPermission.Assert" /> activa para el marco actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-134">There is already an active <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="f6a7f-135">Para poder llamar a <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-135">for the ability to call <see cref="M:System.Security.CodeAccessPermission.Assert" />.</span>
          </span>
          <span data-ttu-id="f6a7f-136">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-136">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" /></span>
          </span>
        </permission>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-137">No se puede invalidar este método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-137">You cannot override this method.</span>
            </span>
          </para>
        </block>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md">
          <span data-ttu-id="f6a7f-138">Utilizar el método Assert</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-138">Using the Assert Method</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Copy" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Copy () As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Copy();" />
      <MemberSignature Language="F#" Value="abstract member Copy : unit -&gt; System.Security.IPermission" Usage="codeAccessPermission.Copy " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Copy</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-139">Cuando se implementa mediante una clase derivada, crea y devuelve una copia idéntica del objeto de permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-139">When implemented by a derived class, creates and returns an identical copy of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-140">Copia del objeto de permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-140">A copy of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-141">Una copia de un objeto de permiso representa el mismo acceso a los recursos que el objeto de permiso original.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-141">A copy of a permission object represents the same access to resources as the original permission object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-142">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.Copy%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-142">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Copy%2A> method.</span></span> <span data-ttu-id="f6a7f-143">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-143">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#2)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#2)]
 [!code-vb[System.Security.Permissions.NameIdPermission#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-144">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-144">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit&#xA;override this.Demand : unit -&gt; unit" Usage="codeAccessPermission.Demand " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-145">Fuerza a un <see cref="T:System.Security.SecurityException" /> en tiempo de ejecución si todos los autores de llamada situados en la parte superior de la pila de llamadas no disponen del permiso especificado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-145">Forces a <see cref="T:System.Security.SecurityException" /> at run time if all callers higher in the call stack have not been granted the permission specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-146">Este método se usa normalmente por las bibliotecas seguras para asegurarse de que los llamadores tienen permiso para acceder a un recurso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-146">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="f6a7f-147">Por ejemplo, llama una clase de archivo en una biblioteca de clases seguras <xref:System.Security.CodeAccessPermission.Demand%2A> para necesarios <xref:System.Security.Permissions.FileIOPermission> antes de realizar una operación de archivo solicitada por el llamador.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-147">For example, a file class in a secure class library calls <xref:System.Security.CodeAccessPermission.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="f6a7f-148">Los permisos del código que llama a este método no se examinan; la comprobación comienza desde el llamador inmediato de ese código y continúa hasta la pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-148">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="f6a7f-149">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-149">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span> <span data-ttu-id="f6a7f-150"><xref:System.Security.CodeAccessPermission.Demand%2A> se realiza correctamente sólo si no hay ningún <xref:System.Security.SecurityException> se genera.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-150"><xref:System.Security.CodeAccessPermission.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f6a7f-151">Un autor de llamada situado más arriba en la pila de llamadas no tiene el permiso especificado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-151">A caller higher in the call stack does not have the permission specified by the current instance.</span>
          </span>
          <span data-ttu-id="f6a7f-152">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-152">-or-</span>
          </span>
          <span data-ttu-id="f6a7f-153">Un autor de llamada situado más arriba en la pila de llamadas ha llamado a <see cref="M:System.Security.CodeAccessPermission.Deny" /> en el objeto de permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-153">A caller higher in the call stack has called <see cref="M:System.Security.CodeAccessPermission.Deny" /> on the current permission object.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-154">No se puede invalidar este método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-154">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit&#xA;override this.Deny : unit -&gt; unit" Usage="codeAccessPermission.Deny " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-155">Impide que los autores de la llamada situados en la posición más alta de la pila de llamadas usen el código que llama a este método para tener acceso al recurso especificado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-155">Prevents callers higher in the call stack from using the code that calls this method to access the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6a7f-156">El <xref:System.Security.CodeAccessPermission.Deny%2A> método debe usarse solo para proteger los recursos frente al acceso accidental por código de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-156">The <xref:System.Security.CodeAccessPermission.Deny%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="f6a7f-157">No debe usarse para proteger los recursos de uso indebido intencionado por código de confianza.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-157">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="f6a7f-158">Por ejemplo, si método `A` problemas una <xref:System.Security.CodeAccessPermission.Deny%2A> para un permiso y, a continuación, las llamadas a método `B`, método `B` abiertamente puede invalidar el <xref:System.Security.CodeAccessPermission.Deny%2A> emitiendo un <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-158">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.Deny%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.Deny%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f6a7f-159">El método llamado es siempre más arriba en la pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-159">The called method is always higher in the stack.</span></span> <span data-ttu-id="f6a7f-160">Por lo tanto, si método `B` intenta tener acceso a un recurso protegido, el sistema de seguridad comienza a comprobar los permisos con ella porque método `B` es el llamador inmediato y, a continuación, los recorridos de abajo en la pila para confirmar que no hay ningún <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> más abajo en la pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-160">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="f6a7f-161">Método `B`, que está intentando tener acceso al recurso, puede detener el recorrido de pila inmediatamente mediante el <xref:System.Security.CodeAccessPermission.Assert%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-161">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="f6a7f-162">En ese caso, el <xref:System.Security.CodeAccessPermission.Deny%2A> colocado en la pila por método `A` (el método de llamada) nunca se ha detectado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-162">In that case, the <xref:System.Security.CodeAccessPermission.Deny%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="f6a7f-163">Este método evita que los llamadores situados en la pila de llamadas de acceso al recurso protegido a través del código que llama a este método, incluso si los llamadores tienen permiso para acceder a él.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-163">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="f6a7f-164">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-164">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="f6a7f-165"><xref:System.Security.CodeAccessPermission.Deny%2A> puede limitar la responsabilidad del programador o ayudar a evitar problemas de seguridad accidental porque ayuda a evitar que el método que llama a <xref:System.Security.CodeAccessPermission.Deny%2A> desde que se usa para tener acceso al recurso protegido por el permiso denegado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-165"><xref:System.Security.CodeAccessPermission.Deny%2A> can limit the liability of the programmer or help prevent accidental security issues because it helps prevent the method that calls <xref:System.Security.CodeAccessPermission.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="f6a7f-166">Si llama un método <xref:System.Security.CodeAccessPermission.Deny%2A> en un permiso y si un <xref:System.Security.CodeAccessPermission.Demand%2A> para ese permiso se invoque un llamante más abajo en la pila de llamadas, dicha comprobación de seguridad se producirá un error cuando se alcanza el <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-166">If a method calls <xref:System.Security.CodeAccessPermission.Deny%2A> on a permission, and if a <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span>  
  
 <span data-ttu-id="f6a7f-167">La llamada a <xref:System.Security.CodeAccessPermission.Deny%2A> es efectivo hasta que el código de llamada vuelve al llamador.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-167">The call to <xref:System.Security.CodeAccessPermission.Deny%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f6a7f-168">Solo un <xref:System.Security.CodeAccessPermission.Deny%2A> pueden estar activas en un marco.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-168">Only one <xref:System.Security.CodeAccessPermission.Deny%2A> can be active on a frame.</span></span> <span data-ttu-id="f6a7f-169">Un intento de llamar a <xref:System.Security.CodeAccessPermission.Deny%2A> cuando se activa <xref:System.Security.CodeAccessPermission.Deny%2A> existe en el marco da como resultado un <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-169">An attempt to call <xref:System.Security.CodeAccessPermission.Deny%2A> when an active <xref:System.Security.CodeAccessPermission.Deny%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f6a7f-170">Llame a <xref:System.Security.CodeAccessPermission.RevertDeny%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> para quitar un activo <xref:System.Security.CodeAccessPermission.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-170">Call <xref:System.Security.CodeAccessPermission.RevertDeny%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.Deny%2A>.</span></span> <span data-ttu-id="f6a7f-171"><xref:System.Security.CodeAccessPermission.Deny%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-171"><xref:System.Security.CodeAccessPermission.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f6a7f-172">Ya hay una <see cref="M:System.Security.CodeAccessPermission.Deny" /> activa para el marco actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-172">There is already an active <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-173">No se puede invalidar este método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-173">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="codeAccessPermission.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="f6a7f-174">Objeto <see cref="T:System.Security.CodeAccessPermission" /> que se va a comparar con el objeto <see cref="T:System.Security.CodeAccessPermission" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-174">The <see cref="T:System.Security.CodeAccessPermission" /> object to compare with the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f6a7f-175">Determina si el objeto <see cref="T:System.Security.CodeAccessPermission" /> especificado es igual al objeto <see cref="T:System.Security.CodeAccessPermission" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-175">Determines whether the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-176">Es <see langword="true" /> si el objeto <see cref="T:System.Security.CodeAccessPermission" /> especificado es igual al objeto <see cref="T:System.Security.CodeAccessPermission" /> actual; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-176">
              <see langword="true" /> if the specified <see cref="T:System.Security.CodeAccessPermission" /> object is equal to the current <see cref="T:System.Security.CodeAccessPermission" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-177">Para obtener más información, vea <xref:System.Object.Equals%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-177">For more information, see <xref:System.Object.Equals%2A>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FromXml">
      <MemberSignature Language="C#" Value="public abstract void FromXml (System.Security.SecurityElement elem);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void FromXml(class System.Security.SecurityElement elem) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.FromXml(System.Security.SecurityElement)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub FromXml (elem As SecurityElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void FromXml(System::Security::SecurityElement ^ elem);" />
      <MemberSignature Language="F#" Value="abstract member FromXml : System.Security.SecurityElement -&gt; unit" Usage="codeAccessPermission.FromXml elem" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.FromXml(System.Security.SecurityElement)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="elem" Type="System.Security.SecurityElement" />
      </Parameters>
      <Docs>
        <param name="elem">
          <span data-ttu-id="f6a7f-178">Codificación XML que se usará para reconstruir el objeto de seguridad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-178">The XML encoding to use to reconstruct the security object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f6a7f-179">Cuando se invalida en una clase derivada, reconstruye un objeto de seguridad con un estado especificado a partir de codificación XML.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-179">When overridden in a derived class, reconstructs a security object with a specified state from an XML encoding.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-180">El código personalizado que extiende los objetos de seguridad debe implementar la <xref:System.Security.CodeAccessPermission.ToXml%2A> y <xref:System.Security.CodeAccessPermission.FromXml%2A> métodos para que los objetos puedan codificarse con seguridad.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-180">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-181">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.FromXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-181">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.FromXml%2A> method.</span></span> <span data-ttu-id="f6a7f-182">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-182">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#10)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#10)]
 [!code-vb[System.Security.Permissions.NameIdPermission#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="f6a7f-183">El parámetro <paramref name="elem" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-183">The <paramref name="elem" /> parameter is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f6a7f-184">El parámetro <paramref name="elem" /> no contiene la codificación XML de una instancia del mismo tipo que la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-184">The <paramref name="elem" /> parameter does not contain the XML encoding for an instance of the same type as the current instance.</span>
          </span>
          <span data-ttu-id="f6a7f-185">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-185">-or-</span>
          </span>
          <span data-ttu-id="f6a7f-186">No se admite el número de la versión del parámetro <paramref name="elem" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-186">The version number of the <paramref name="elem" /> parameter is not supported.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-187">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-187">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="codeAccessPermission.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-188">Obtiene un código hash para el objeto <see cref="T:System.Security.CodeAccessPermission" /> que es adecuado para su uso en algoritmos hash y estructuras de datos como una tabla hash.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-188">Gets a hash code for the <see cref="T:System.Security.CodeAccessPermission" /> object that is suitable for use in hashing algorithms and data structures such as a hash table.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-189">Código hash para el objeto <see cref="T:System.Security.CodeAccessPermission" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-189">A hash code for the current <see cref="T:System.Security.CodeAccessPermission" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-190">El código hash para dos instancias del mismo permiso podría ser diferente, por lo tanto, un código hash no debe usarse para comparar dos <xref:System.Security.CodeAccessPermission> objetos.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-190">The hash code for two instances of the same permission might be different, hence a hash code should not be used to compare two <xref:System.Security.CodeAccessPermission> objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public abstract System.Security.IPermission Intersect (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Intersect(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Intersect(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Intersect (target As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::IPermission ^ Intersect(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Intersect target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Intersect(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f6a7f-191">Permiso para formar intersección con el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-191">A permission to intersect with the current permission.</span>
          </span>
          <span data-ttu-id="f6a7f-192">Debe ser del mismo tipo que el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-192">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f6a7f-193">Cuando se implementa mediante una clase derivada, crea y devuelve un permiso que es la intersección del permiso actual y el permiso especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-193">When implemented by a derived class, creates and returns a permission that is the intersection of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-194">Nuevo permiso que representa la intersección del permiso actual y del permiso especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-194">A new permission that represents the intersection of the current permission and the specified permission.</span>
          </span>
          <span data-ttu-id="f6a7f-195">Este nuevo permiso es <see langword="null" /> si la intersección está vacía.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-195">This new permission is <see langword="null" /> if the intersection is empty.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-196">La intersección de dos permisos es un permiso que describe el conjunto de operaciones descritas en ambos.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-196">The intersection of two permissions is a permission that describes the set of operations they both describe in common.</span></span> <span data-ttu-id="f6a7f-197">Sólo una petición que pase ambos permisos originales pasará la intersección.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-197">Only a demand that passes both original permissions will pass the intersection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-198">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.Intersect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-198">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Intersect%2A> method.</span></span> <span data-ttu-id="f6a7f-199">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-199">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#5)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#5)]
 [!code-vb[System.Security.Permissions.NameIdPermission#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f6a7f-200">El parámetro <paramref name="target" /> no es <see langword="null" /> y no es una instancia de la misma clase que el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-200">The <paramref name="target" /> parameter is not <see langword="null" /> and is not an instance of the same class as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-201">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-201">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public abstract bool IsSubsetOf (System.Security.IPermission target);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Security.IPermission target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.IsSubsetOf(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function IsSubsetOf (target As IPermission) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract bool IsSubsetOf(System::Security::IPermission ^ target);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : System.Security.IPermission -&gt; bool" Usage="codeAccessPermission.IsSubsetOf target" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.IsSubsetOf(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="target">
          <span data-ttu-id="f6a7f-202">Permiso que se va a probar para la relación de subconjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-202">A permission that is to be tested for the subset relationship.</span>
          </span>
          <span data-ttu-id="f6a7f-203">Este permiso debe ser del mismo tipo que el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-203">This permission must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f6a7f-204">Cuando se implementa mediante una clase derivada, determina si el permiso actual es un subconjunto del permiso especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-204">When implemented by a derived class, determines whether the current permission is a subset of the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-205">
            <see langword="true" /> si el permiso actual es un subconjunto del permiso especificado; si no, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-205">
              <see langword="true" /> if the current permission is a subset of the specified permission; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-206">El permiso actual es un subconjunto del permiso especificado si el permiso actual especifica un conjunto de operaciones que está incluido completamente por el permiso especificado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-206">The current permission is a subset of the specified permission if the current permission specifies a set of operations that is wholly contained by the specified permission.</span></span> <span data-ttu-id="f6a7f-207">Por ejemplo, un permiso que representa el acceso a C:\example.txt es un subconjunto de un permiso que representa el acceso a C:\\.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-207">For example, a permission that represents access to C:\example.txt is a subset of a permission that represents access to C:\\.</span></span> <span data-ttu-id="f6a7f-208">Si este método devuelve `true`, el permiso actual no representa ningún más acceso al recurso protegido que tiene el permiso especificado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-208">If this method returns `true`, the current permission represents no more access to the protected resource than does the specified permission.</span></span>  
  
 <span data-ttu-id="f6a7f-209">Las siguientes instrucciones tienen que ser `true` para todas las invalidaciones de la <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-209">The following statements are required to be `true` for all overrides of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="f6a7f-210">*X*, *Y*, y *Z* representan objetos de permiso de acceso del código personalizado que no son referencias nulas, *U* representa un permiso de acceso de código sin restricciones y *N* representa un permiso vacío con un <xref:System.Security.Permissions.PermissionState> de <xref:System.Security.Permissions.PermissionState.None>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-210">*X*, *Y*, and *Z* represent custom code access permission objects that are not null references, *U* represents an unrestricted code access permission, and *N* represents an empty permission with a <xref:System.Security.Permissions.PermissionState> of <xref:System.Security.Permissions.PermissionState.None>.</span></span>  
  
-   <span data-ttu-id="f6a7f-211">*X*. IsSubsetOf (*X*) devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-211">*X*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f6a7f-212">*X*. IsSubsetOf (*Y*) devuelve el mismo valor que *Y*. IsSubsetOf (*X*) únicamente si *X* y *Y* representan el mismo conjunto de permisos.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-212">*X*.IsSubsetOf(*Y*) returns the same value as *Y*.IsSubsetOf(*X*) if and only if *X* and *Y* represent the same set of permissions.</span></span>  
  
-   <span data-ttu-id="f6a7f-213">Si *X*. IsSubsetOf (*Y*) y *Y*. IsSubsetOf (*Z*) ambos devuelven `true`, *X*. IsSubsetOf (*Z*) devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-213">If *X*.IsSubsetOf(*Y*) and *Y*.IsSubsetOf(*Z*) both return `true`, *X*.IsSubsetOf(*Z*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f6a7f-214">*X*. IsSubsetOf (*U*) devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-214">*X*.IsSubsetOf(*U*) returns `true`.</span></span>  
  
-   <span data-ttu-id="f6a7f-215">*X*. IsSubsetOf (*N*) devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-215">*X*.IsSubsetOf(*N*) returns `false`.</span></span>  
  
-   <span data-ttu-id="f6a7f-216">*N*. IsSubsetOf (*X*) devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-216">*N*.IsSubsetOf(*X*) returns `true`.</span></span>  
  
 <span data-ttu-id="f6a7f-217">Si *X* y *Y* representan objetos de permiso de acceso del código personalizado que son referencias nulas, *X*. IsSubsetOf (*Y*) devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-217">If *X* and *Y* represent custom code access permission objects that are null references, *X*.IsSubsetOf(*Y*) returns `true`.</span></span> <span data-ttu-id="f6a7f-218">Si *Z* también es null, la operación de establecimiento de compuesto *X*. Union (*Y*). IsSubsetOf (*Z*) también devuelve `true` porque la unión de dos permisos nulos es un permiso nulo.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-218">If *Z* is also null, the compound set operation *X*.Union(*Y*).IsSubsetOf(*Z*) also returns `true` because the union of two null permissions is a null permission.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-219">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-219">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.IsSubsetOf%2A> method.</span></span> <span data-ttu-id="f6a7f-220">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-220">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#4)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#4)]
 [!code-vb[System.Security.Permissions.NameIdPermission#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="f6a7f-221">El parámetro <paramref name="target" /> no es <see langword="null" /> y no es del mismo tipo que el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-221">The <paramref name="target" /> parameter is not <see langword="null" /> and is not of the same type as the current permission.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-222">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-222">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit&#xA;override this.PermitOnly : unit -&gt; unit" Usage="codeAccessPermission.PermitOnly " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-223">Impide que los llamadores situados más arriba en la pila de llamadas usen el código que llama a este método para tener acceso a todos los recursos excepto al recurso especificado por la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-223">Prevents callers higher in the call stack from using the code that calls this method to access all resources except for the resource specified by the current instance.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="f6a7f-224">El <xref:System.Security.CodeAccessPermission.PermitOnly%2A> método debe usarse solo para proteger los recursos frente al acceso accidental por código de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-224">The <xref:System.Security.CodeAccessPermission.PermitOnly%2A> method should be used only to protect resources from accidental access by fully trusted code.</span></span> <span data-ttu-id="f6a7f-225">No debe usarse para proteger los recursos de uso indebido intencionado por código de confianza.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-225">It should not be used to protect resources from intentional misuse by untrusted code.</span></span> <span data-ttu-id="f6a7f-226">Por ejemplo, si método `A` problemas una <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para un permiso y, a continuación, las llamadas a método `B`, método `B` abiertamente puede invalidar el <xref:System.Security.CodeAccessPermission.PermitOnly%2A> emitiendo un <xref:System.Security.CodeAccessPermission.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-226">For example, if method `A` issues a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for a permission and then calls method `B`, method `B` can overtly override the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> by issuing an <xref:System.Security.CodeAccessPermission.Assert%2A>.</span></span> <span data-ttu-id="f6a7f-227">El método llamado es siempre más arriba en la pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-227">The called method is always higher in the stack.</span></span> <span data-ttu-id="f6a7f-228">Por lo tanto, si método `B` intenta tener acceso a un recurso protegido, el sistema de seguridad comienza a comprobar los permisos con ella porque método `B` es el llamador inmediato y, a continuación, los recorridos de abajo en la pila para confirmar que no hay ningún <xref:System.Security.CodeAccessPermission.Deny%2A> o <xref:System.Security.CodeAccessPermission.PermitOnly%2A> más abajo en la pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-228">Therefore, if method `B` tries to access a protected resource, the security system begins checking for permissions with it because method `B` is the immediate caller, and then walks down the stack to confirm that there is no <xref:System.Security.CodeAccessPermission.Deny%2A> or <xref:System.Security.CodeAccessPermission.PermitOnly%2A> lower in the stack.</span></span> <span data-ttu-id="f6a7f-229">Método `B`, que está intentando tener acceso al recurso, puede detener el recorrido de pila inmediatamente mediante el <xref:System.Security.CodeAccessPermission.Assert%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-229">Method `B`, which is trying to access the resource, can stop the stack walk immediately by using the <xref:System.Security.CodeAccessPermission.Assert%2A> method.</span></span> <span data-ttu-id="f6a7f-230">En ese caso, el <xref:System.Security.CodeAccessPermission.PermitOnly%2A> colocado en la pila por método `A` (el método de llamada) nunca se ha detectado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-230">In that case, the <xref:System.Security.CodeAccessPermission.PermitOnly%2A> placed on the stack by method `A` (the calling method) is never discovered.</span></span>  
  
 <span data-ttu-id="f6a7f-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> es similar a <xref:System.Security.CodeAccessPermission.Deny%2A>, ya que ambos provocan recorridos de pila producirá un error cuando se realizarían correctamente en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-231"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is similar to <xref:System.Security.CodeAccessPermission.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="f6a7f-232">La diferencia es que <xref:System.Security.CodeAccessPermission.Deny%2A> especifica los permisos que hará que el recorrido de pila producirá un error, pero <xref:System.Security.CodeAccessPermission.PermitOnly%2A> especifica los permisos que no producen un error en el recorrido de pila.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-232">The difference is that <xref:System.Security.CodeAccessPermission.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.CodeAccessPermission.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span>  
  
 <span data-ttu-id="f6a7f-233">Llame a este método para asegurarse de que el código puede utilizarse para tener acceso solo a los recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-233">Call this method to ensure that your code can be used to access only the specified resources.</span></span> <span data-ttu-id="f6a7f-234">La llamada a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> es efectivo hasta que el código de llamada vuelve al llamador.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-234">The call to <xref:System.Security.CodeAccessPermission.PermitOnly%2A> is effective until the calling code returns to its caller.</span></span> <span data-ttu-id="f6a7f-235">Solo un <xref:System.Security.CodeAccessPermission.PermitOnly%2A> pueden estar activas en un marco.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-235">Only one <xref:System.Security.CodeAccessPermission.PermitOnly%2A> can be active on a frame.</span></span> <span data-ttu-id="f6a7f-236">Un intento de llamar a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> cuando se activa <xref:System.Security.CodeAccessPermission.PermitOnly%2A> existe en el marco da como resultado un <xref:System.Security.SecurityException>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-236">An attempt to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A> when an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A> exists on the frame results in a <xref:System.Security.SecurityException>.</span></span> <span data-ttu-id="f6a7f-237">Llame a <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> para quitar un activo <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-237">Call <xref:System.Security.CodeAccessPermission.RevertPermitOnly%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> to remove an active <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span>  
  
 <span data-ttu-id="f6a7f-238"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-238"><xref:System.Security.CodeAccessPermission.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="f6a7f-239">Sin embargo, si el código situado más abajo en la llamada de la pila más adelante llamadas <xref:System.Security.CodeAccessPermission.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-239">However, if code lower on the call stack later calls <xref:System.Security.CodeAccessPermission.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.CodeAccessPermission.PermitOnly%2A>.</span></span> <span data-ttu-id="f6a7f-240">Esto es porque el código que llamó <xref:System.Security.CodeAccessPermission.PermitOnly%2A> no dispone del permiso, aunque haya llamado a <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-240">This is because the code that called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="f6a7f-241">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-241">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException">
          <span data-ttu-id="f6a7f-242">Ya hay una <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> activa para el marco actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-242">There is already an active <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-243">No se puede invalidar este método.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-243">You cannot override this method.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="RevertAll">
      <MemberSignature Language="C#" Value="public static void RevertAll ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAll() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAll" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAll ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAll();" />
      <MemberSignature Language="F#" Value="static member RevertAll : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAll " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-244">Provoca que se eliminen todos los reemplazos anteriores del marco actual y que ya no estén en vigor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-244">Causes all previous overrides for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-245">Si no hay ninguna invalidación (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, o <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) para el marco actual, un <xref:System.ExecutionEngineException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-245">If there are no overrides (<xref:System.Security.CodeAccessPermission.Assert%2A>, <xref:System.Security.CodeAccessPermission.Deny%2A>, or <xref:System.Security.CodeAccessPermission.PermitOnly%2A>) for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f6a7f-246">No hay ningún <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" /> o <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior para el marco actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-246">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" />, <see cref="M:System.Security.CodeAccessPermission.Deny" />, or <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertAssert">
      <MemberSignature Language="C#" Value="public static void RevertAssert ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertAssert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertAssert" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertAssert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertAssert();" />
      <MemberSignature Language="F#" Value="static member RevertAssert : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertAssert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-247">Provoca que se elimine y deje de tener efecto cualquier <see cref="M:System.Security.CodeAccessPermission.Assert" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-247">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-248">Si no hay ningún <xref:System.Security.CodeAccessPermission.Assert%2A> para el marco actual, un <xref:System.ExecutionEngineException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-248">If there is no <xref:System.Security.CodeAccessPermission.Assert%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f6a7f-249">No hay ningún <see cref="M:System.Security.CodeAccessPermission.Assert" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-249">There is no previous <see cref="M:System.Security.CodeAccessPermission.Assert" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertDeny">
      <MemberSignature Language="C#" Value="public static void RevertDeny ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertDeny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertDeny" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertDeny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertDeny();" />
      <MemberSignature Language="F#" Value="static member RevertDeny : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertDeny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;dotnet-plat-ext-2.1;netcore-2.2">
          <AttributeName>System.Obsolete</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Deny is obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-250">Provoca que se elimine y deje de tener efecto cualquier <see cref="M:System.Security.CodeAccessPermission.Deny" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-250">Causes any previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-251">Si no hay ningún <xref:System.Security.CodeAccessPermission.Deny%2A> para el marco actual, un <xref:System.ExecutionEngineException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-251">If there is no <xref:System.Security.CodeAccessPermission.Deny%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f6a7f-252">No hay ningún <see cref="M:System.Security.CodeAccessPermission.Deny" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-252">There is no previous <see cref="M:System.Security.CodeAccessPermission.Deny" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="RevertPermitOnly">
      <MemberSignature Language="C#" Value="public static void RevertPermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RevertPermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.RevertPermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RevertPermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RevertPermitOnly();" />
      <MemberSignature Language="F#" Value="static member RevertPermitOnly : unit -&gt; unit" Usage="System.Security.CodeAccessPermission.RevertPermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8">
          <AttributeName>System.Diagnostics.Conditional("FEATURE_MONO_CAS")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-253">Provoca que se elimine y deje de tener efecto cualquier <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-253">Causes any previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame to be removed and no longer in effect.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-254">Si no hay ningún <xref:System.Security.CodeAccessPermission.PermitOnly%2A> para el marco actual, un <xref:System.ExecutionEngineException> se produce.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-254">If there is no <xref:System.Security.CodeAccessPermission.PermitOnly%2A> for the current frame, an <xref:System.ExecutionEngineException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="f6a7f-255">No hay ningún <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> anterior para el fotograma actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-255">There is no previous <see cref="M:System.Security.CodeAccessPermission.PermitOnly" /> for the current frame.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IPermission.Demand">
      <MemberSignature Language="C#" Value="void IPermission.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IPermission.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IPermission#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IPermission.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IPermission.Demand() = System::Security::IPermission::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Assert">
      <MemberSignature Language="C#" Value="void IStackWalk.Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Assert" />
      <MemberSignature Language="VB.NET" Value="Sub Assert () Implements IStackWalk.Assert" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Assert() = System::Security::IStackWalk::Assert;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Assert</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Demand">
      <MemberSignature Language="C#" Value="void IStackWalk.Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Demand" />
      <MemberSignature Language="VB.NET" Value="Sub Demand () Implements IStackWalk.Demand" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Demand() = System::Security::IStackWalk::Demand;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Demand</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.Deny">
      <MemberSignature Language="C#" Value="void IStackWalk.Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#Deny" />
      <MemberSignature Language="VB.NET" Value="Sub Deny () Implements IStackWalk.Deny" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.Deny() = System::Security::IStackWalk::Deny;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.Deny</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Security.IStackWalk.PermitOnly">
      <MemberSignature Language="C#" Value="void IStackWalk.PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Security.IStackWalk.PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.System#Security#IStackWalk#PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Sub PermitOnly () Implements IStackWalk.PermitOnly" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Security.IStackWalk.PermitOnly() = System::Security::IStackWalk::PermitOnly;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IStackWalk.PermitOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="codeAccessPermission.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-256">Crea y devuelve una representación de cadena del objeto de permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-256">Creates and returns a string representation of the current permission object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-257">Representación de cadena del objeto de permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-257">A string representation of the current permission object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-258">Este método es útil para depurar cuando se necesita el permiso se muestran como una cadena.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-258">This method is useful in debugging when you need to display the permission as a string.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToXml">
      <MemberSignature Language="C#" Value="public abstract System.Security.SecurityElement ToXml ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.SecurityElement ToXml() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.ToXml" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function ToXml () As SecurityElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Security::SecurityElement ^ ToXml();" />
      <MemberSignature Language="F#" Value="abstract member ToXml : unit -&gt; System.Security.SecurityElement" Usage="codeAccessPermission.ToXml " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.ISecurityEncodable.ToXml</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.SecurityElement</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="f6a7f-259">Cuando se invalida en una clase derivada, crea una codificación XML del objeto de seguridad y su estado actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-259">When overridden in a derived class, creates an XML encoding of the security object and its current state.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-260">Codificación XML del objeto de seguridad, incluida cualquier información de estado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-260">An XML encoding of the security object, including any state information.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-261">El código personalizado que extiende los objetos de seguridad debe implementar la <xref:System.Security.CodeAccessPermission.ToXml%2A> y <xref:System.Security.CodeAccessPermission.FromXml%2A> métodos para que los objetos puedan codificarse con seguridad.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-261">Custom code that extends security objects needs to implement the <xref:System.Security.CodeAccessPermission.ToXml%2A> and <xref:System.Security.CodeAccessPermission.FromXml%2A> methods to make the objects security-encodable.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-262">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.ToXml%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-262">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.ToXml%2A> method.</span></span> <span data-ttu-id="f6a7f-263">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-263">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#11)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#11)]
 [!code-vb[System.Security.Permissions.NameIdPermission#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#11)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-264">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-264">You must override this method in a derived class.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public virtual System.Security.IPermission Union (System.Security.IPermission other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Security.IPermission Union(class System.Security.IPermission other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.CodeAccessPermission.Union(System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Union (other As IPermission) As IPermission" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Security::IPermission ^ Union(System::Security::IPermission ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : System.Security.IPermission -&gt; System.Security.IPermission&#xA;override this.Union : System.Security.IPermission -&gt; System.Security.IPermission" Usage="codeAccessPermission.Union other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Security.IPermission.Union(System.Security.IPermission)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.IPermission</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="f6a7f-265">Permiso para combinar con el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-265">A permission to combine with the current permission.</span>
          </span>
          <span data-ttu-id="f6a7f-266">Debe ser del mismo tipo que el permiso actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-266">It must be of the same type as the current permission.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="f6a7f-267">Cuando se invalida en una clase derivada, crea un permiso que es la unión del permiso actual y el permiso especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-267">When overridden in a derived class, creates a permission that is the union of the current permission and the specified permission.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="f6a7f-268">Nuevo permiso que representa la unión del permiso actual y el especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-268">A new permission that represents the union of the current permission and the specified permission.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="f6a7f-269">El resultado de una llamada a <xref:System.Security.CodeAccessPermission.Union%2A> es un permiso que representa todas las operaciones representadas por el permiso actual y el permiso especificado.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-269">The result of a call to <xref:System.Security.CodeAccessPermission.Union%2A> is a permission that represents all the operations represented by both the current permission and the specified permission.</span></span> <span data-ttu-id="f6a7f-270">Cualquier solicitud que pase alguno de estos permisos pasa su unión.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-270">Any demand that passes either permission passes their union.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="f6a7f-271">En el ejemplo de código siguiente se muestra una invalidación de la <xref:System.Security.CodeAccessPermission.Union%2A> método.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-271">The following code example shows an override of the <xref:System.Security.CodeAccessPermission.Union%2A> method.</span></span> <span data-ttu-id="f6a7f-272">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Security.CodeAccessPermission> clase.</span><span class="sxs-lookup"><span data-stu-id="f6a7f-272">This code example is part of a larger example provided for the <xref:System.Security.CodeAccessPermission> class.</span></span>  
  
 [!code-cpp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CPP/nameidpermission.cpp#12)]
 [!code-csharp[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/CS/nameidpermission.cs#12)]
 [!code-vb[System.Security.Permissions.NameIdPermission#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Security.Permissions.NameIdPermission/VB/nameidpermission.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="f6a7f-273">El parámetro <paramref name="other" /> no es un objeto <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-273">The <paramref name="other" /> parameter is not <see langword="null" />.</span>
          </span>
          <span data-ttu-id="f6a7f-274">Este método solo se admite en este nivel cuando se pasa <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="f6a7f-274">This method is only supported at this level when passed <see langword="null" />.</span>
          </span>
        </exception>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="f6a7f-275">Debe invalidar este método en una clase derivada.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-275">You must override this method in a derived class.</span>
            </span>
            <span data-ttu-id="f6a7f-276">Debe devolver una copia del permiso si el valor de la <paramref name="other" /> parámetro es <see langword="null" />.</span>
            <span class="sxs-lookup">
              <span data-stu-id="f6a7f-276">You should return a copy of the permission if the value of the <paramref name="other" /> parameter is <see langword="null" />.</span>
            </span>
          </para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>