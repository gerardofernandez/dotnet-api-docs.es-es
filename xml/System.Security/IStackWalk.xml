<Type Name="IStackWalk" FullName="System.Security.IStackWalk">
  <Metadata><Meta Name="ms.openlocfilehash" Value="ffff6974a1ebf871cd84ed3f0b180c1e73b50d37" /><Meta Name="ms.sourcegitcommit" Value="8e213bb5e6801f6e29861ba72664978ad00e34fa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="02/18/2019" /><Meta Name="ms.locfileid" Value="56402374" /></Metadata><TypeSignature Language="C#" Value="public interface IStackWalk" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IStackWalk" />
  <TypeSignature Language="DocId" Value="T:System.Security.IStackWalk" />
  <TypeSignature Language="VB.NET" Value="Public Interface IStackWalk" />
  <TypeSignature Language="C++ CLI" Value="public interface class IStackWalk" />
  <TypeSignature Language="F#" Value="type IStackWalk = interface" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="aa167-101">Administra el recorrido de pila que determina si todos los llamadores de la pila de llamadas disponen de los permisos necesarios para obtener acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="aa167-101">Manages the stack walk that determines whether all callers in the call stack have the required permissions to access a protected resource.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa167-102">Código de confianza parcial siempre presenta un riesgo de seguridad.</span><span class="sxs-lookup"><span data-stu-id="aa167-102">Partially trusted code always presents a security risk.</span></span> <span data-ttu-id="aa167-103">A veces se puede manipular para llevar a cabo acciones en nombre de código malintencionado que no tiene permiso para acceder a un recurso.</span><span class="sxs-lookup"><span data-stu-id="aa167-103">It can sometimes be manipulated to perform actions on behalf of malicious code that does not have permission to access a resource.</span></span> <span data-ttu-id="aa167-104">De este modo, el código malintencionado puede obtener mayor seguridad de acceso que debe permitirse.</span><span class="sxs-lookup"><span data-stu-id="aa167-104">In this way, malicious code can achieve higher security access than it should be allowed.</span></span>  
  
 <span data-ttu-id="aa167-105">Common language runtime ayuda a proteger el código administrado mediante la ejecución de un recorrido de pila en todas las llamadas a estos ataques.</span><span class="sxs-lookup"><span data-stu-id="aa167-105">The common language runtime helps protect managed code from these attacks by running a stack walk on all calls.</span></span> <span data-ttu-id="aa167-106">El recorrido de pila requiere que todo el código de la pila de llamadas tiene permiso para tener acceso a un recurso protegido.</span><span class="sxs-lookup"><span data-stu-id="aa167-106">The stack walk requires that all code in the call stack has permission to access a protected resource.</span></span> <span data-ttu-id="aa167-107">Dado que el código intenta realizar el ataque siempre estará en alguna parte en la pila de llamadas, no podrá superar sus propios permisos de seguridad.</span><span class="sxs-lookup"><span data-stu-id="aa167-107">Because the code attempting the attack will always be somewhere in the call stack, it will be unable to exceed its own security permissions.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Assert">
      <MemberSignature Language="C#" Value="public void Assert ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Assert() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Assert" />
      <MemberSignature Language="VB.NET" Value="Public Sub Assert ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Assert();" />
      <MemberSignature Language="F#" Value="abstract member Assert : unit -&gt; unit" Usage="iStackWalk.Assert " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aa167-108">Afirma que el código de llamada puede tener acceso al recurso identificado por el objeto de permiso actual, incluso si los autores de la llamada situados en una posición más alta de la pila no tienen permiso para tener acceso al recurso.</span><span class="sxs-lookup"><span data-stu-id="aa167-108">Asserts that the calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa167-109">Una llamada a <xref:System.Security.IStackWalk.Assert%2A> se detiene la comprobación del permiso en los llamadores situados en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="aa167-109">Calling <xref:System.Security.IStackWalk.Assert%2A> stops the permission check on callers higher in the call stack.</span></span> <span data-ttu-id="aa167-110">Por lo tanto, incluso si estos llamadores no tienen los permisos necesarios, todavía pueden acceder los recursos.</span><span class="sxs-lookup"><span data-stu-id="aa167-110">Therefore, even if these callers do not have the requisite permissions, they can still access resources.</span></span> <span data-ttu-id="aa167-111">Una aserción es efectiva únicamente si el código que llama <xref:System.Security.IStackWalk.Assert%2A> pasa la comprobación de seguridad para el permiso que está la aserción.</span><span class="sxs-lookup"><span data-stu-id="aa167-111">An assertion is effective only if the code that calls <xref:System.Security.IStackWalk.Assert%2A> passes the security check for the permission that it is asserting.</span></span>  
  
 <span data-ttu-id="aa167-112">Una llamada a <xref:System.Security.IStackWalk.Assert%2A> es efectivo hasta que el código de llamada vuelve a su llamador o hasta que una llamada subsiguiente a <xref:System.Security.IStackWalk.Assert%2A> representa la aserción anterior ineficaces.</span><span class="sxs-lookup"><span data-stu-id="aa167-112">A call to <xref:System.Security.IStackWalk.Assert%2A> is effective until the calling code returns to its caller or until a subsequent call to <xref:System.Security.IStackWalk.Assert%2A> renders the previous assertion ineffective.</span></span> <span data-ttu-id="aa167-113">Además, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> o <xref:System.Security.CodeAccessPermission.RevertAll%2A> quita una pendiente <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa167-113">Also, <xref:System.Security.CodeAccessPermission.RevertAssert%2A> or <xref:System.Security.CodeAccessPermission.RevertAll%2A> removes a pending <xref:System.Security.IStackWalk.Assert%2A>.</span></span>  
  
 <span data-ttu-id="aa167-114"><xref:System.Security.IStackWalk.Assert%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="aa167-114"><xref:System.Security.IStackWalk.Assert%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="aa167-115">Sin embargo, si llama código más abajo en la pila de llamadas <xref:System.Security.IStackWalk.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.IStackWalk.Assert%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa167-115">However, if code lower on the call stack calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.Assert%2A>.</span></span> <span data-ttu-id="aa167-116">Esto sucede porque el código que llamó <xref:System.Security.IStackWalk.Assert%2A> no dispone del permiso, aunque intentó <xref:System.Security.IStackWalk.Assert%2A> lo.</span><span class="sxs-lookup"><span data-stu-id="aa167-116">This happens because the code that called <xref:System.Security.IStackWalk.Assert%2A> has not been granted the permission, even though it tried to <xref:System.Security.IStackWalk.Assert%2A> it.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="aa167-117">Dado que una llamada a <xref:System.Security.IStackWalk.Assert%2A> quita el requisito de que todo el código en la cadena de llamada debe tener el permiso para acceder al recurso especificado, lo cual puede provocar vulnerabilidades de seguridad si utiliza incorrectamente o incorrectamente.</span><span class="sxs-lookup"><span data-stu-id="aa167-117">Because calling <xref:System.Security.IStackWalk.Assert%2A> removes the requirement that all code in the call chain must be granted permission to access the specified resource, it can open up security vulnerabilities if used incorrectly or inappropriately.</span></span> <span data-ttu-id="aa167-118">Por lo tanto, debe usarse con mucha precaución.</span><span class="sxs-lookup"><span data-stu-id="aa167-118">Therefore, it should be used with great caution.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aa167-119">El código de llamada no tiene <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span><span class="sxs-lookup"><span data-stu-id="aa167-119">The calling code does not have <see cref="F:System.Security.Permissions.SecurityPermissionFlag.Assertion" />.</span></span></exception>
        <related type="Article" href="~/docs/framework/misc/using-the-assert-method.md"><span data-ttu-id="aa167-120">Utilizar el método Assert</span><span class="sxs-lookup"><span data-stu-id="aa167-120">Using the Assert Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Demand">
      <MemberSignature Language="C#" Value="public void Demand ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Demand() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Demand" />
      <MemberSignature Language="VB.NET" Value="Public Sub Demand ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Demand();" />
      <MemberSignature Language="F#" Value="abstract member Demand : unit -&gt; unit" Usage="iStackWalk.Demand " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aa167-121">Determina en tiempo de ejecución si todos los llamadores en la pila de llamadas disponen del permiso especificado por el objeto de permiso actual.</span><span class="sxs-lookup"><span data-stu-id="aa167-121">Determines at run time whether all callers in the call stack have been granted the permission specified by the current permission object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa167-122">Este método se usa normalmente por las bibliotecas seguras para asegurarse de que los llamadores tienen permiso para acceder a un recurso.</span><span class="sxs-lookup"><span data-stu-id="aa167-122">This method is typically used by secure libraries to ensure that callers have permission to access a resource.</span></span> <span data-ttu-id="aa167-123">Por ejemplo, llama una clase de archivo en una biblioteca de clases seguras <xref:System.Security.IStackWalk.Demand%2A> para necesarios <xref:System.Security.Permissions.FileIOPermission> antes de realizar una operación de archivo solicitada por el llamador.</span><span class="sxs-lookup"><span data-stu-id="aa167-123">For example, a file class in a secure class library calls <xref:System.Security.IStackWalk.Demand%2A> for the necessary <xref:System.Security.Permissions.FileIOPermission> before performing a file operation requested by the caller.</span></span>  
  
 <span data-ttu-id="aa167-124">Los permisos del código que llama a este método no se examinan; la comprobación comienza desde el llamador inmediato de ese código y continúa hasta la pila.</span><span class="sxs-lookup"><span data-stu-id="aa167-124">The permissions of the code that calls this method are not examined; the check begins from the immediate caller of that code and proceeds up the stack.</span></span> <span data-ttu-id="aa167-125"><xref:System.Security.IStackWalk.Demand%2A> se realiza correctamente sólo si no hay ningún <xref:System.Security.SecurityException> se genera.</span><span class="sxs-lookup"><span data-stu-id="aa167-125"><xref:System.Security.IStackWalk.Demand%2A> succeeds only if no <xref:System.Security.SecurityException> is raised.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="aa167-126">Un llamador que esté situado más arriba en la pila de llamadas no tiene el permiso especificado por el objeto de permiso actual.</span><span class="sxs-lookup"><span data-stu-id="aa167-126">A caller higher in the call stack does not have the permission specified by the current permission object.</span></span>  
  
<span data-ttu-id="aa167-127">O bien</span><span class="sxs-lookup"><span data-stu-id="aa167-127">-or-</span></span> 
<span data-ttu-id="aa167-128">Un llamador de la pila de llamadas ha llamado a <see cref="M:System.Security.IStackWalk.Deny" /> en el objeto de permiso actual.</span><span class="sxs-lookup"><span data-stu-id="aa167-128">A caller in the call stack has called <see cref="M:System.Security.IStackWalk.Deny" /> on the current permission object.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Deny">
      <MemberSignature Language="C#" Value="public void Deny ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Deny() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.Deny" />
      <MemberSignature Language="VB.NET" Value="Public Sub Deny ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Deny();" />
      <MemberSignature Language="F#" Value="abstract member Deny : unit -&gt; unit" Usage="iStackWalk.Deny " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aa167-129">Hace que devuelva error cada método <see cref="M:System.Security.IStackWalk.Demand" /> del objeto actual que pase a través del código de llamada.</span><span class="sxs-lookup"><span data-stu-id="aa167-129">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for the current object that passes through the calling code to fail.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa167-130">Este método evita que los llamadores situados en la pila de llamadas de acceso al recurso protegido a través del código que llama a este método, incluso si los llamadores tienen permiso para acceder a él.</span><span class="sxs-lookup"><span data-stu-id="aa167-130">This method prevents callers higher in the call stack from accessing the protected resource through the code that calls this method, even if those callers have been granted permission to access it.</span></span> <span data-ttu-id="aa167-131">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="aa167-131">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 <span data-ttu-id="aa167-132"><xref:System.Security.IStackWalk.Deny%2A> puede limitar la responsabilidad del programador o ayudar a evitar vulnerabilidades de seguridad accidental, ya que ayuda a evitar que el método que llama a <xref:System.Security.IStackWalk.Deny%2A> desde que se usa para tener acceso al recurso protegido por el permiso denegado.</span><span class="sxs-lookup"><span data-stu-id="aa167-132"><xref:System.Security.IStackWalk.Deny%2A> can limit the liability of the programmer or help prevent accidental security vulnerabilities because it helps prevent the method that calls <xref:System.Security.IStackWalk.Deny%2A> from being used to access the resource protected by the denied permission.</span></span> <span data-ttu-id="aa167-133">Si llama un método <xref:System.Security.IStackWalk.Deny%2A> en un permiso y si un <xref:System.Security.IStackWalk.Demand%2A> para ese permiso se invoque un llamante más abajo en la pila de llamadas, dicha comprobación de seguridad se producirá un error cuando se alcanza el <xref:System.Security.IStackWalk.Deny%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa167-133">If a method calls <xref:System.Security.IStackWalk.Deny%2A> on a permission, and if a <xref:System.Security.IStackWalk.Demand%2A> for that permission is invoked by a caller lower in the call stack, that security check will fail when it reaches the <xref:System.Security.IStackWalk.Deny%2A>.</span></span>  
  
 <span data-ttu-id="aa167-134"><xref:System.Security.IStackWalk.Deny%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="aa167-134"><xref:System.Security.IStackWalk.Deny%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="aa167-135">No se puede invalidar este método.</span><span class="sxs-lookup"><span data-stu-id="aa167-135">You cannot override this method.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="PermitOnly">
      <MemberSignature Language="C#" Value="public void PermitOnly ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void PermitOnly() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.IStackWalk.PermitOnly" />
      <MemberSignature Language="VB.NET" Value="Public Sub PermitOnly ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void PermitOnly();" />
      <MemberSignature Language="F#" Value="abstract member PermitOnly : unit -&gt; unit" Usage="iStackWalk.PermitOnly " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="aa167-136">Hace que devuelva error cada método <see cref="M:System.Security.IStackWalk.Demand" /> de todos los objetos excepto del objeto actual que pase a través del código de llamada, incluso si el código situado más arriba en la pila de llamadas dispone de permiso para obtener acceso a otros recursos.</span><span class="sxs-lookup"><span data-stu-id="aa167-136">Causes every <see cref="M:System.Security.IStackWalk.Demand" /> for all objects except the current one that passes through the calling code to fail, even if code higher in the call stack has been granted permission to access other resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="aa167-137"><xref:System.Security.IStackWalk.PermitOnly%2A> es similar a <xref:System.Security.IStackWalk.Deny%2A>, ya que ambos provocan recorridos de pila producirá un error cuando se realizarían correctamente en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="aa167-137"><xref:System.Security.IStackWalk.PermitOnly%2A> is similar to <xref:System.Security.IStackWalk.Deny%2A>, in that both cause stack walks to fail when they would otherwise succeed.</span></span> <span data-ttu-id="aa167-138">La diferencia es que <xref:System.Security.IStackWalk.Deny%2A> especifica los permisos que hará que el recorrido de pila producirá un error, pero <xref:System.Security.IStackWalk.PermitOnly%2A> especifica los permisos que no producen un error en el recorrido de pila.</span><span class="sxs-lookup"><span data-stu-id="aa167-138">The difference is that <xref:System.Security.IStackWalk.Deny%2A> specifies permissions that will cause the stack walk to fail, but <xref:System.Security.IStackWalk.PermitOnly%2A> specifies the only permissions that do not cause the stack walk to fail.</span></span> <span data-ttu-id="aa167-139">Llame a este método para asegurarse de que el código puede utilizarse para tener acceso solo a los recursos especificados.</span><span class="sxs-lookup"><span data-stu-id="aa167-139">Call this method to ensure that your code can be used to access only the specified resources.</span></span>  
  
 <span data-ttu-id="aa167-140"><xref:System.Security.IStackWalk.PermitOnly%2A> se omite para un permiso no concedido, ya que no se realizará correctamente una demanda para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="aa167-140"><xref:System.Security.IStackWalk.PermitOnly%2A> is ignored for a permission not granted because a demand for that permission will not succeed.</span></span> <span data-ttu-id="aa167-141">Sin embargo, si el código situado más abajo en la llamada de la pila más adelante llamadas <xref:System.Security.IStackWalk.Demand%2A> para ese permiso, un <xref:System.Security.SecurityException> se produce cuando el recorrido de pila alcanza el código que intentó llamar a <xref:System.Security.IStackWalk.PermitOnly%2A>.</span><span class="sxs-lookup"><span data-stu-id="aa167-141">However, if code lower on the call stack later calls <xref:System.Security.IStackWalk.Demand%2A> for that permission, a <xref:System.Security.SecurityException> is thrown when the stack walk reaches the code that tried to call <xref:System.Security.IStackWalk.PermitOnly%2A>.</span></span> <span data-ttu-id="aa167-142">Esto es porque el código que llamó <xref:System.Security.IStackWalk.PermitOnly%2A> no dispone del permiso, aunque haya llamado a <xref:System.Security.IStackWalk.PermitOnly%2A> para ese permiso.</span><span class="sxs-lookup"><span data-stu-id="aa167-142">This is because the code that called <xref:System.Security.IStackWalk.PermitOnly%2A> has not been granted the permission, even though it called <xref:System.Security.IStackWalk.PermitOnly%2A> for that permission.</span></span> <span data-ttu-id="aa167-143">La pila de llamadas suele representarse de forma decreciente, por lo que más arriba en la pila de llamadas de métodos llamar a métodos inferior en la pila de llamadas.</span><span class="sxs-lookup"><span data-stu-id="aa167-143">The call stack is typically represented as growing down, so that methods higher in the call stack call methods lower in the call stack.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>