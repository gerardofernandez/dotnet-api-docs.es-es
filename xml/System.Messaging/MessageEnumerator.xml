<Type Name="MessageEnumerator" FullName="System.Messaging.MessageEnumerator">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dfbd83b435486357a91721f19b050fdc1e7aa258" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52611166" /></Metadata><TypeSignature Language="C#" Value="public class MessageEnumerator : MarshalByRefObject, IDisposable, System.Collections.IEnumerator" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MessageEnumerator extends System.MarshalByRefObject implements class System.Collections.IEnumerator, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Messaging.MessageEnumerator" />
  <TypeSignature Language="VB.NET" Value="Public Class MessageEnumerator&#xA;Inherits MarshalByRefObject&#xA;Implements IDisposable, IEnumerator" />
  <TypeSignature Language="C++ CLI" Value="public ref class MessageEnumerator : MarshalByRefObject, IDisposable, System::Collections::IEnumerator" />
  <TypeSignature Language="F#" Value="type MessageEnumerator = class&#xA;    inherit MarshalByRefObject&#xA;    interface IEnumerator&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Messaging</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerator</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="61a41-101">Ofrece un cursor de solo avance para enumerar los mensajes de una cola de mensajes.</span><span class="sxs-lookup"><span data-stu-id="61a41-101">Provides a forward-only cursor to enumerate through messages in a message queue.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-102">Use <xref:System.Messaging.MessageEnumerator> para la interacción dinámica con los mensajes en una cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-102">Use <xref:System.Messaging.MessageEnumerator> for dynamic interaction with messages in a queue.</span></span> <span data-ttu-id="61a41-103">Métodos disponibles a través de la <xref:System.Messaging.MessageQueue> clase puede devolver un <xref:System.Messaging.MessageEnumerator> señalando a una lista dinámica de los mensajes en la cola o una matriz que contiene una copia en un momento dado (una instantánea) de la cola en el momento en el método especificado se llamó.</span><span class="sxs-lookup"><span data-stu-id="61a41-103">Methods available through the <xref:System.Messaging.MessageQueue> class can return either a <xref:System.Messaging.MessageEnumerator> pointing to a dynamic list of messages in the queue, or an array that contains a copy at a given instant - a snapshot - of the queue at the time the specified method was called.</span></span>  
  
 <span data-ttu-id="61a41-104">A diferencia de una instantánea estática, un enumerador permite modificar la colección.</span><span class="sxs-lookup"><span data-stu-id="61a41-104">Unlike a static snapshot, an enumerator allows you to modify the collection.</span></span> <span data-ttu-id="61a41-105">Mediante un <xref:System.Messaging.MessageEnumerator>, puede quitar los mensajes de la cola y el cambio se refleja inmediatamente en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-105">Using a <xref:System.Messaging.MessageEnumerator>, you can remove messages from the queue, and the change is immediately reflected in the queue.</span></span>  
  
 <span data-ttu-id="61a41-106">Un enumerador no elimina los mensajes de la cola cuando consulta la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-106">An enumerator does not remove the messages from the queue when it queries the queue.</span></span> <span data-ttu-id="61a41-107">Devuelve información sobre el mensaje en la posición actual del cursor, pero deja el mensaje en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-107">It returns information about the message at the current cursor position, but it leaves the message in the queue.</span></span>  
  
 <span data-ttu-id="61a41-108">Un <xref:System.Messaging.MessageEnumerator> es un cursor, inicializado en el encabezado de una lista dinámica.</span><span class="sxs-lookup"><span data-stu-id="61a41-108">A <xref:System.Messaging.MessageEnumerator> is a cursor, initialized to the head of a dynamic list.</span></span> <span data-ttu-id="61a41-109">El orden de lista es el mismo que el orden de los mensajes en la cola, según la prioridad del mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-109">The list order is the same as the order of the messages in the queue, according to message priority.</span></span> <span data-ttu-id="61a41-110">Puede mover el cursor hasta el primer mensaje en la cola mediante una llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-110">You can move the cursor to the first message in the queue by calling <xref:System.Messaging.MessageEnumerator.MoveNext%2A>.</span></span> <span data-ttu-id="61a41-111">Una vez inicializado el enumerador, puede usar <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para avanzar paso a paso a través de los mensajes restantes.</span><span class="sxs-lookup"><span data-stu-id="61a41-111">After the enumerator has been initialized, you can use <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to step forward through the remaining messages.</span></span> <span data-ttu-id="61a41-112">Puede especificar si se debe esperar un mensaje esté disponible pasando un tiempo de espera en el <xref:System.Messaging.MessageEnumerator.MoveNext%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-112">You can specify whether to wait for a message to become available by passing a timeout into the <xref:System.Messaging.MessageEnumerator.MoveNext%2A> method.</span></span>  
  
 <span data-ttu-id="61a41-113">Dado que el enumerador es dinámico, el enumerador puede tener acceso a un mensaje que se anexa más allá de la posición del cursor actual (por ejemplo, debido a la prioridad baja).</span><span class="sxs-lookup"><span data-stu-id="61a41-113">Because the enumerator is dynamic, a message that is appended beyond the cursor's current position (for example, due to low priority), can be accessed by the enumerator.</span></span> <span data-ttu-id="61a41-114">Un mensaje que se inserta antes de que no se puede tener acceso a la posición del cursor actual.</span><span class="sxs-lookup"><span data-stu-id="61a41-114">A message that is inserted before the cursor's current position cannot be accessed.</span></span> <span data-ttu-id="61a41-115">No es posible ir hacia atrás con un <xref:System.Messaging.MessageEnumerator>.</span><span class="sxs-lookup"><span data-stu-id="61a41-115">It is not possible to step backward with a <xref:System.Messaging.MessageEnumerator>.</span></span> <span data-ttu-id="61a41-116">Un cursor permite el movimiento de solo avance.</span><span class="sxs-lookup"><span data-stu-id="61a41-116">A cursor allows forward-only movement.</span></span> <span data-ttu-id="61a41-117">El <xref:System.Messaging.MessageEnumerator.Reset%2A> método le permite colocar el cursor al principio de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-117">The <xref:System.Messaging.MessageEnumerator.Reset%2A> method enables you to place the cursor back at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="61a41-118">Las instancias de <xref:System.Messaging.MessageEnumerator> para una cola determinada trabajar de forma independiente.</span><span class="sxs-lookup"><span data-stu-id="61a41-118">Instances of <xref:System.Messaging.MessageEnumerator> for a given queue work independently.</span></span> <span data-ttu-id="61a41-119">Puede crear dos <xref:System.Messaging.MessageEnumerator> instancias que se aplican a la misma cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-119">You can create two <xref:System.Messaging.MessageEnumerator> instances that apply to the same queue.</span></span> <span data-ttu-id="61a41-120">Los cambios que otro <xref:System.Messaging.MessageEnumerator> facilita a los mensajes en la cola se reflejarán inmediatamente en un segundo enumerador si el segundo enumerador se coloca antes de la primera.</span><span class="sxs-lookup"><span data-stu-id="61a41-120">The changes that one <xref:System.Messaging.MessageEnumerator> makes to the messages in the queue will be reflected immediately in a second enumerator if the second enumerator is positioned before the first.</span></span> <span data-ttu-id="61a41-121">Sin embargo, si dos enumeradores tienen la misma posición y uno de ellos quita el mensaje en esa posición, se produce una excepción si el otro enumerador intenta obtener el valor de la <xref:System.Messaging.MessageEnumerator.Current%2A> propiedad en el mensaje eliminado ahora.</span><span class="sxs-lookup"><span data-stu-id="61a41-121">However, if two enumerators have the same position and one of them removes the message at that position, an exception is thrown if the other enumerator attempts to get the value of the <xref:System.Messaging.MessageEnumerator.Current%2A> property on the now-deleted message.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="61a41-122">Si crea una instancia de <xref:System.Messaging.MessageQueue> con <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> establecido en `true`, ninguna otra aplicación puede modificar los mensajes del enumerador mientras tenga la conexión a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-122">If you create an instance of <xref:System.Messaging.MessageQueue> with <xref:System.Messaging.MessageQueue.DenySharedReceive%2A?displayProperty=nameWithType> set to `true`, no other application can modify the messages in your enumerator while you have the connection to the queue.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="61a41-123">En el ejemplo siguiente se obtiene una lista dinámica de los mensajes en una cola y cuenta todos los mensajes con el <xref:System.Messaging.Message.Priority%2A> propiedad establecida en <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="61a41-123">The following example gets a dynamic list of messages in a queue and counts all messages with the <xref:System.Messaging.Message.Priority%2A> property set to <xref:System.Messaging.MessagePriority.Lowest?displayProperty=nameWithType>.</span></span>  
  
 [!code-cpp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/cpp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CPP/mqgetmessageenumerator.cpp#1)]
 [!code-csharp[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/csharp/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/CS/mqgetmessageenumerator.cs#1)]
 [!code-vb[MessageQueue.GetMessageEnumerator#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/MessageQueue.GetMessageEnumerator/VB/mqgetmessageenumerator.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Messaging.Message" />
    <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator2" />
  </Docs>
  <Members>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="messageEnumerator.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-124">Libera los recursos asociados al enumerador.</span><span class="sxs-lookup"><span data-stu-id="61a41-124">Frees the resources associated with the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-125">El sistema operativo retiene un identificador abierto en la cola durante la vigencia del cursor.</span><span class="sxs-lookup"><span data-stu-id="61a41-125">The operating system retains an open handle to the queue during the lifetime of the cursor.</span></span> <span data-ttu-id="61a41-126">Cuando haya terminado de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar los recursos asociados con el identificador.</span><span class="sxs-lookup"><span data-stu-id="61a41-126">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release the resources associated with the handle.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
      </Docs>
    </Member>
    <Member MemberName="Current">
      <MemberSignature Language="C#" Value="public System.Messaging.Message Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Messaging.Message Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.Current" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Current As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Messaging::Message ^ Current { System::Messaging::Message ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Current : System.Messaging.Message" Usage="System.Messaging.MessageEnumerator.Current" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61a41-127">Obtiene el <see cref="T:System.Messaging.Message" /> actual al que apunta este enumerador.</span><span class="sxs-lookup"><span data-stu-id="61a41-127">Gets the current <see cref="T:System.Messaging.Message" /> that this enumerator points to.</span></span></summary>
        <value><span data-ttu-id="61a41-128">Mensaje actual.</span><span class="sxs-lookup"><span data-stu-id="61a41-128">The current message.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-129">Cuando se crea el enumerador, apunta al principio de la cola, en una ubicación delante del primer mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-129">When the enumerator is created, it points to the head of the queue, at a location before the first message.</span></span> <span data-ttu-id="61a41-130">En este caso, <xref:System.Messaging.MessageEnumerator.Current%2A> no es válido y se iniciará una excepción si se tiene acceso a.</span><span class="sxs-lookup"><span data-stu-id="61a41-130">In this case, <xref:System.Messaging.MessageEnumerator.Current%2A> is not valid and will throw an exception if it is accessed.</span></span> <span data-ttu-id="61a41-131">Debe llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> para colocar el cursor en el primer mensaje de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-131">You must call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> to position the cursor at the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="61a41-132">Llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> antes de la primera llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-132">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> before the first call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" />.</span></span> <span data-ttu-id="61a41-133">El cursor se encuentra ubicado delante del primer elemento de la enumeración del mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-133">The cursor is located before the first element of the message enumeration.</span></span>  
  
<span data-ttu-id="61a41-134">O bien</span><span class="sxs-lookup"><span data-stu-id="61a41-134">-or-</span></span> 
<span data-ttu-id="61a41-135">Llamó a <see cref="P:System.Messaging.MessageEnumerator.Current" /> después de que una llamada a <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> devolviera <see langword="false" /> (lo que indicaba que el cursor está situado después del último elemento de la enumeración del mensaje).</span><span class="sxs-lookup"><span data-stu-id="61a41-135">You called <see cref="P:System.Messaging.MessageEnumerator.Current" /> after a call to <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> had returned <see langword="false" /> (indicating the cursor is located after the last element of the message enumeration.)</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-136">El mensaje al que está apuntando actualmente el enumerador ya no existe.</span><span class="sxs-lookup"><span data-stu-id="61a41-136">The message the enumerator is currently pointing to no longer exists.</span></span> <span data-ttu-id="61a41-137">Puede que se hayan eliminado.</span><span class="sxs-lookup"><span data-stu-id="61a41-137">It might have been deleted.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="M:System.Messaging.MessageQueue.GetMessageEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="CursorHandle">
      <MemberSignature Language="C#" Value="public IntPtr CursorHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int CursorHandle" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CursorHandle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr CursorHandle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.CursorHandle : nativeint" Usage="System.Messaging.MessageEnumerator.CursorHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61a41-138">Obtiene el indicador de cursor de Message Queuing nativo que se utiliza para explorar los mensajes de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-138">Gets the native Message Queuing cursor handle used to browse messages in the queue.</span></span></summary>
        <value><span data-ttu-id="61a41-139">Indicador de cursor nativo.</span><span class="sxs-lookup"><span data-stu-id="61a41-139">The native cursor handle.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-140">Esta propiedad contiene el identificador nativo de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="61a41-140">This property contains the native handle to the enumeration.</span></span> <span data-ttu-id="61a41-141">Cuando haya terminado de trabajar con el enumerador, llame a <xref:System.Messaging.MessageEnumerator.Close%2A> para liberar este recurso.</span><span class="sxs-lookup"><span data-stu-id="61a41-141">When you have finished working with the enumerator, call <xref:System.Messaging.MessageEnumerator.Close%2A> to release this resource.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-142">El indicador no existe.</span><span class="sxs-lookup"><span data-stu-id="61a41-142">The handle does not exist.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="61a41-143">Libera los recursos que usa <see cref="T:System.Messaging.MessageEnumerator" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-143">Releases the resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="messageEnumerator.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-144">Libera todos los recursos que usa <see cref="T:System.Messaging.MessageEnumerator" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-144">Releases all resources used by the <see cref="T:System.Messaging.MessageEnumerator" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-145">Una llamada a <xref:System.Messaging.MessageEnumerator.Dispose%2A> permite a los recursos utilizados por el <xref:System.Messaging.MessageEnumerator> que reasignarse para otros fines.</span><span class="sxs-lookup"><span data-stu-id="61a41-145">Calling <xref:System.Messaging.MessageEnumerator.Dispose%2A> allows the resources used by the <xref:System.Messaging.MessageEnumerator> to be reallocated for other purposes.</span></span> <span data-ttu-id="61a41-146">Para obtener más información acerca de <xref:System.Messaging.MessageEnumerator.Dispose%2A>, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="61a41-146">For more information about <xref:System.Messaging.MessageEnumerator.Dispose%2A>, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="61a41-147">Limpiar recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="61a41-147">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="messageEnumerator.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="61a41-148">Es <see langword="true" /> para liberar tanto recursos administrados como no administrados; es <see langword="false" /> para liberar únicamente recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="61a41-148"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to release only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="61a41-149">Libera los recursos no administrados que usa <see cref="T:System.Messaging.MessageEnumerator" /> y, de forma opcional, libera los recursos administrados.</span><span class="sxs-lookup"><span data-stu-id="61a41-149">Releases the unmanaged resources used by the <see cref="T:System.Messaging.MessageEnumerator" /> and optionally releases the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-150">Este método se llama por el público <xref:System.Messaging.MessageEnumerator.Dispose%2A> método y el <xref:System.Object.Finalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-150">This method is called by the public <xref:System.Messaging.MessageEnumerator.Dispose%2A> method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="61a41-151">`Dispose()` invoca el protegido `Dispose(Boolean)` método con el `disposing` parámetro establecido en `true`.</span><span class="sxs-lookup"><span data-stu-id="61a41-151">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="61a41-152"><xref:System.Object.Finalize%2A> invoca `Dispose` con `disposing` establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="61a41-152"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="61a41-153">Cuando el parámetro `disposing` es `true`, este método libera todos los recursos retenidos por los objetos administrados a los que el control <xref:System.Messaging.MessageEnumerator> hace referencia.</span><span class="sxs-lookup"><span data-stu-id="61a41-153">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Messaging.MessageEnumerator> references.</span></span> <span data-ttu-id="61a41-154">Este método invoca al método `Dispose()` de cada uno de los objetos a los que se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="61a41-154">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="61a41-155">
            <see langword="Dispose" /> puede recibir varias llamadas de otros objetos.</span><span class="sxs-lookup"><span data-stu-id="61a41-155">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="61a41-156">Al invalidar <see langword="Dispose(Boolean)" />, tenga cuidado de no hacer referencia a objetos que se hayan eliminado en una llamada anterior a <see langword="Dispose" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-156">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="61a41-157">Para obtener más información sobre cómo implementar <see langword="Dispose" />, consulte [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).</span><span class="sxs-lookup"><span data-stu-id="61a41-157">For more information about how to implement <see langword="Dispose" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="61a41-158">Para obtener más información acerca de <see langword="Dispose" /> y <see langword="Finalize" />, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="61a41-158">For more information about <see langword="Dispose" /> and <see langword="Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
        <related type="Article" href="~/docs/standard/garbage-collection/implementing-dispose.md"><span data-ttu-id="61a41-159">Implementar un método Dispose</span><span class="sxs-lookup"><span data-stu-id="61a41-159">Implementing a Dispose method</span></span></related>
        <related type="Article" href="~/docs/standard/garbage-collection/unmanaged.md"><span data-ttu-id="61a41-160">Limpiar recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="61a41-160">Cleaning Up Unmanaged Resources</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~MessageEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!MessageEnumerator ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="messageEnumerator.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-161">Libera los recursos mantenidos por el enumerador.</span><span class="sxs-lookup"><span data-stu-id="61a41-161">Releases the resources held by the enumerator.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="61a41-162">Este método invalida <xref:System.Object.Finalize>.</span><span class="sxs-lookup"><span data-stu-id="61a41-162">This method overrides <xref:System.Object.Finalize>.</span></span> <span data-ttu-id="61a41-163">Código de la aplicación no debe llamar a este método; método Finalize de un objeto se invoca automáticamente durante la recolección de elementos no utilizados, a menos que se ha deshabilitado la finalización por el recolector de elementos no utilizados mediante una llamada a la <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-163">Application code should not call this method; an object's Finalize method is automatically invoked during garbage collection, unless finalization by the garbage collector has been disabled by a call to the <xref:System.GC.SuppressFinalize%2A?displayProperty=nameWithType> method.</span></span>

<span data-ttu-id="61a41-164">Para obtener más información, consulte [métodos de finalización y destructores](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md), y [reemplazar el método Finalize](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="61a41-164">For more information, see [Finalize Methods and Destructors](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/0s71x931(v=vs.100)), [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md), and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <MemberGroup MemberName="MoveNext">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="61a41-165">Desplaza el enumerador al siguiente mensaje de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-165">Advances the enumerator to the next message in the queue.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool MoveNext() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool MoveNext();" />
      <MemberSignature Language="F#" Value="abstract member MoveNext : unit -&gt; bool&#xA;override this.MoveNext : unit -&gt; bool" Usage="messageEnumerator.MoveNext " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.MoveNext</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-166">Desplaza el enumerador al siguiente mensaje de la cola si hay alguno disponible.</span><span class="sxs-lookup"><span data-stu-id="61a41-166">Advances the enumerator to the next message in the queue, if one is currently available.</span></span></summary>
        <returns><span data-ttu-id="61a41-167"><see langword="true" /> si el enumerador avanzó con éxito hasta el siguiente mensaje; <see langword="false" /> si el enumerador alcanzó el final de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-167"><see langword="true" /> if the enumerator was succesfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-168">Esta sobrecarga vuelve inmediatamente si no hay ningún mensaje en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-168">This overload returns immediately if there is no message in the queue.</span></span> <span data-ttu-id="61a41-169">Hay otra sobrecarga que espera un determinado <xref:System.TimeSpan> para que llegue un mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-169">There is another overload that waits a specified <xref:System.TimeSpan> for a message to arrive.</span></span>  
  
 <span data-ttu-id="61a41-170">Si un mensaje no está disponible actualmente porque la cola está vacía o porque se ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> devuelve `false` al método de llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-170">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> returns `false` to the calling method.</span></span>  
  
 <span data-ttu-id="61a41-171">Tras su creación, un enumerador conceptualmente se coloca delante del primer mensaje de la cola y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> pone el primer mensaje de la cola a la vista.</span><span class="sxs-lookup"><span data-stu-id="61a41-171">Upon creation, an enumerator is conceptually positioned before the first message of the queue, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the queue into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-172">Se ha producido una excepción específica para Message Queuing.</span><span class="sxs-lookup"><span data-stu-id="61a41-172">An exception specific to Message Queuing was thrown.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <Member MemberName="MoveNext">
      <MemberSignature Language="C#" Value="public bool MoveNext (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool MoveNext(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.MoveNext(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function MoveNext (timeout As TimeSpan) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool MoveNext(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.MoveNext : TimeSpan -&gt; bool" Usage="messageEnumerator.MoveNext timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="61a41-173"><see cref="T:System.TimeSpan" /> que se va a esperar hasta que un mensaje se encuentre disponible si el enumerador se coloca al final de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-173">The <see cref="T:System.TimeSpan" /> to wait for a message to be available if the enumerator is positioned at the end of the queue.</span></span></param>
        <summary><span data-ttu-id="61a41-174">Desplaza el enumerador al siguiente mensaje de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-174">Advances the enumerator to the next message in the queue.</span></span> <span data-ttu-id="61a41-175">Si el enumerador se coloca al final de la cola, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> espera hasta que haya un mensaje disponible o expire el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="61a41-175">If the enumerator is positioned at the end of the queue, <see cref="M:System.Messaging.MessageEnumerator.MoveNext" /> waits until a message is available or the given timeout expires.</span></span></summary>
        <returns><span data-ttu-id="61a41-176"><see langword="true" /> si el enumerador avanzó satisfactoriamente hasta el siguiente mensaje; <see langword="false" /> si el enumerador llegó al final de la cola y un mensaje no pasa a estar disponible en el plazo de tiempo especificado por el parámetro <paramref name="timeout" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-176"><see langword="true" /> if the enumerator successfully advanced to the next message; <see langword="false" /> if the enumerator has reached the end of the queue and a message does not become available within the time specified by the <paramref name="timeout" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-177">Espera a que esta sobrecarga si no hay ningún mensaje en la cola o si el cursor ha llegado al final de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-177">This overload waits if there is no message in the queue or if the cursor has reached the end of the queue.</span></span> <span data-ttu-id="61a41-178">Si un mensaje no está disponible actualmente porque la cola está vacía o porque se ha movido más allá del último elemento de la colección, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> espera el tiempo de espera especificado.</span><span class="sxs-lookup"><span data-stu-id="61a41-178">If a message is not currently available because the queue is empty or because you have moved beyond the last element in the collection, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> waits the specified timeout.</span></span>  
  
 <span data-ttu-id="61a41-179">Si el cursor ya está al final de la cola, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> sólo devuelve `true` si el nuevo mensaje llega en el intervalo de tiempo especificado, tiene una prioridad menor que todos los mensajes actualmente en la cola y se coloca al final de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-179">If the cursor is already at the end of the queue, <xref:System.Messaging.MessageEnumerator.MoveNext%2A> only returns `true` if the new message arrives within the specified time interval, has lower priority than all messages currently in the queue and is placed at the end of the queue.</span></span> <span data-ttu-id="61a41-180">Una sobrecarga sin parámetros devuelve inmediatamente si no hay más mensajes están en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-180">An overload with no parameter returns immediately if no further messages are in the queue.</span></span>  
  
 <span data-ttu-id="61a41-181">Tras su creación, un enumerador conceptualmente se coloca delante del primer mensaje de la enumeración y la primera llamada a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> aporta el primer mensaje de la enumeración en la vista.</span><span class="sxs-lookup"><span data-stu-id="61a41-181">Upon creation, an enumerator is conceptually positioned before the first message of the enumeration, and the first call to <xref:System.Messaging.MessageEnumerator.MoveNext%2A> brings the first message of the enumeration into view.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="61a41-182">El valor especificado para el parámetro de tiempo de espera no es válido.</span><span class="sxs-lookup"><span data-stu-id="61a41-182">The value specified for the timeout parameter is invalid.</span></span> <span data-ttu-id="61a41-183">Podría representar un número negativo.</span><span class="sxs-lookup"><span data-stu-id="61a41-183">It might represent a negative number.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-184">Se ha producido una excepción específica para Message Queuing.</span><span class="sxs-lookup"><span data-stu-id="61a41-184">An exception specific to Message Queuing was thrown.</span></span>  
  
<span data-ttu-id="61a41-185">O bien</span><span class="sxs-lookup"><span data-stu-id="61a41-185">-or-</span></span> 
<span data-ttu-id="61a41-186">El tiempo de espera ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-186">The timeout has expired.</span></span></exception>
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="M:System.Messaging.MessageEnumerator.Reset" />
        <altmember cref="T:System.Messaging.Message" />
      </Docs>
    </Member>
    <MemberGroup MemberName="RemoveCurrent">
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="61a41-187">Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-187">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-188">Al quitar el mensaje, éste se elimina de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-188">Removing the message deletes it from the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-189">El comportamiento descrito para estas sobrecargas es aplicable solo si el <xref:System.Messaging.MessageEnumerator> instancia se recupera utilizando la <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-189">The behavior described for these overloads is applicable only if the <xref:System.Messaging.MessageEnumerator> instance is retrieved by using the <xref:System.Messaging.MessageQueue.GetMessageEnumerator2%2A>.</span></span> <span data-ttu-id="61a41-190">No use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> para recuperar una instancia de <xref:System.Messaging.MessageEnumerator> como este método está desusado.</span><span class="sxs-lookup"><span data-stu-id="61a41-190">Do not use <xref:System.Messaging.MessageQueue.GetMessageEnumerator%2A> to retrieve an instance of <xref:System.Messaging.MessageEnumerator> as this method has been deprecated.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent () As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent();" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : unit -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-191">Quita el mensaje actual de una cola transaccional o no transaccional y lo devuelve a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-191">Removes the current message from a transactional or non-transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-192">No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-192">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="61a41-193"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-193">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual.</span><span class="sxs-lookup"><span data-stu-id="61a41-194"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span>  
  
 <span data-ttu-id="61a41-195">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-195">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-196">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-196">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-197">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-197">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="61a41-198">Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.</span><span class="sxs-lookup"><span data-stu-id="61a41-198">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transaction" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="transaction"><span data-ttu-id="61a41-199">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica la transacción de la que se quitará el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-199">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction in which the message will be removed.</span></span></param>
        <summary><span data-ttu-id="61a41-200">Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-200">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-201">No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-201">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="61a41-202"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-202">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, utilizando el contexto de transacción interna definido por el `transaction` parámetro.</span><span class="sxs-lookup"><span data-stu-id="61a41-203"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using the internal transaction context defined by the `transaction` parameter.</span></span>  
  
 <span data-ttu-id="61a41-204">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-204">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-205">Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-205">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="61a41-206">La eliminación no es irreversible hasta que se confirma la transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-206">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="61a41-207">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-207">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-208">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-208">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61a41-209">El parámetro <paramref name="transaction" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-209">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent transactionType" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="transactionType"><span data-ttu-id="61a41-210">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-210">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="61a41-211">Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-211">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-212">No hay un tiempo de espera determinado para que un mensaje llegue a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-212">There is no timeout specified for a message to arrive in the queue.</span></span></summary>
        <returns><span data-ttu-id="61a41-213"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-213">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, mediante un contexto de transacción definido por el `transactionType` parámetro.</span><span class="sxs-lookup"><span data-stu-id="61a41-214"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span>  
  
 <span data-ttu-id="61a41-215">Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-215">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="61a41-216">Especificar `Single` si desea recibir el mensaje como una sola transacción interna.</span><span class="sxs-lookup"><span data-stu-id="61a41-216">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="61a41-217">Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-217">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="61a41-218">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-218">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-219">Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-219">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="61a41-220">La eliminación no es irreversible hasta que se confirma la transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-220">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="61a41-221">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-221">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-222">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-222">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="61a41-223">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-223">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="61a41-224">Intervalo de tiempo que hay que esperar a que un mensaje llegue a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-224">The interval of time to wait for a message to arrive in the queue.</span></span></param>
        <summary><span data-ttu-id="61a41-225">Quita el mensaje actual de la cola y lo devuelve a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-225">Removes the current message from the queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-226">Si hay un mensaje que quitar, el método lo devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="61a41-226">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="61a41-227">En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</span><span class="sxs-lookup"><span data-stu-id="61a41-227">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="61a41-228"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-228">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual.</span><span class="sxs-lookup"><span data-stu-id="61a41-229"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="61a41-230">Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-230">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="61a41-231">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-231">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-232">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-232">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-233">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-233">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 <span data-ttu-id="61a41-234">Si se llama a esta sobrecarga en una cola transaccional, Message Queue Server crea una sola transacción interna.</span><span class="sxs-lookup"><span data-stu-id="61a41-234">If you call this overload on a transactional queue, Message Queuing creates a single internal transaction.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="61a41-235">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="61a41-235">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-236">El tiempo de espera ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-236">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransaction transaction);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, class System.Messaging.MessageQueueTransaction transaction) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransaction)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transaction As MessageQueueTransaction) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransaction ^ transaction);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransaction -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transaction)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transaction" Type="System.Messaging.MessageQueueTransaction" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="61a41-237">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-237">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transaction"><span data-ttu-id="61a41-238">Objeto <see cref="T:System.Messaging.MessageQueueTransaction" /> que especifica el contexto de transacción para el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-238">The <see cref="T:System.Messaging.MessageQueueTransaction" /> object that specifies the transaction context for the message.</span></span></param>
        <summary><span data-ttu-id="61a41-239">Quita el mensaje actual de una cola transaccional y devuelve el mensaje a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-239">Removes the current message from a transactional queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-240">Si hay un mensaje que quitar, el método lo devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="61a41-240">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="61a41-241">En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</span><span class="sxs-lookup"><span data-stu-id="61a41-241">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="61a41-242"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-242">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual.</span><span class="sxs-lookup"><span data-stu-id="61a41-243"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location.</span></span> <span data-ttu-id="61a41-244">Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-244">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="61a41-245">Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-245">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="61a41-246">La eliminación no es irreversible hasta que se confirma la transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-246">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="61a41-247">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-247">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-248">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-248">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-249">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-249">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="61a41-250">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="61a41-250">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="61a41-251">El parámetro <paramref name="transaction" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-251">The <paramref name="transaction" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-252">El tiempo de espera ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-252">The timeout has expired.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransaction" />
      </Docs>
    </Member>
    <Member MemberName="RemoveCurrent">
      <MemberSignature Language="C#" Value="public System.Messaging.Message RemoveCurrent (TimeSpan timeout, System.Messaging.MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Messaging.Message RemoveCurrent(valuetype System.TimeSpan timeout, valuetype System.Messaging.MessageQueueTransactionType transactionType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.RemoveCurrent(System.TimeSpan,System.Messaging.MessageQueueTransactionType)" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveCurrent (timeout As TimeSpan, transactionType As MessageQueueTransactionType) As Message" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Messaging::Message ^ RemoveCurrent(TimeSpan timeout, System::Messaging::MessageQueueTransactionType transactionType);" />
      <MemberSignature Language="F#" Value="member this.RemoveCurrent : TimeSpan * System.Messaging.MessageQueueTransactionType -&gt; System.Messaging.Message" Usage="messageEnumerator.RemoveCurrent (timeout, transactionType)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Messaging.Message</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
        <Parameter Name="transactionType" Type="System.Messaging.MessageQueueTransactionType" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="61a41-253">Intervalo de tiempo que hay que esperar hasta que se quite el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-253">The interval of time to wait for the message to be removed.</span></span></param>
        <param name="transactionType"><span data-ttu-id="61a41-254">Uno de los valores de <see cref="T:System.Messaging.MessageQueueTransactionType" />, que describe el tipo de contexto de transacción que se va a asociar al mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-254">One of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> values, describing the type of transaction context to associate with the message.</span></span></param>
        <summary><span data-ttu-id="61a41-255">Quita el mensaje actual de una cola y lo devuelve a la aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="61a41-255">Removes the current message from a queue and returns the message to the calling application.</span></span> <span data-ttu-id="61a41-256">Si hay un mensaje que quitar, el método lo devuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="61a41-256">If there is a message to remove, the method returns it immediately.</span></span> <span data-ttu-id="61a41-257">En caso contrario, el método espera el tiempo de espera especificado hasta que llegue un mensaje nuevo.</span><span class="sxs-lookup"><span data-stu-id="61a41-257">Otherwise, the method waits the specified timeout for a new message to arrive.</span></span></summary>
        <returns><span data-ttu-id="61a41-258"><see cref="T:System.Messaging.Message" /> que hace referencia al primer mensaje disponible en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-258">A <see cref="T:System.Messaging.Message" /> that references the first message available in the queue.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> Quita y devuelve el mensaje a la posición del cursor actual, mediante un contexto de transacción definido por el `transactionType` parámetro.</span><span class="sxs-lookup"><span data-stu-id="61a41-259"><xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> removes and returns the message at the cursor's current location, using a transaction context defined by the `transactionType` parameter.</span></span> <span data-ttu-id="61a41-260">Si el cursor está al final de la cola, esta sobrecarga del método espera hasta que un mensaje esté disponible o el intervalo especificado por el `timeout` parámetro ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-260">If the cursor is at the end of the queue, this overload of the method waits until a message is available or the interval specified by the `timeout` parameter has expired.</span></span>  
  
 <span data-ttu-id="61a41-261">Especificar `Automatic` para el `transactionType` parámetro si ya existe un contexto de transacción externa asociado al subproceso que desea utilizar para recibir el mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-261">Specify `Automatic` for the `transactionType` parameter if there is already an external transaction context attached to the thread that you want to use to receive the message.</span></span> <span data-ttu-id="61a41-262">Especificar `Single` si desea recibir el mensaje como una sola transacción interna.</span><span class="sxs-lookup"><span data-stu-id="61a41-262">Specify `Single` if you want to receive the message as a single internal transaction.</span></span> <span data-ttu-id="61a41-263">Puede especificar `None` si desea recibir un mensaje de una cola transaccional fuera de un contexto de transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-263">You can specify `None` if you want to receive a message from a transactional queue outside of a transaction context.</span></span>  
  
 <span data-ttu-id="61a41-264">Si usa colas del diario, quitar el mensaje hace una copia que se conservarán en la cola del diario, al igual que el <xref:System.Messaging.MessageQueue> la clase <xref:System.Messaging.MessageQueue.Receive%2A> método.</span><span class="sxs-lookup"><span data-stu-id="61a41-264">If you are using queue journaling, removing the message causes a copy to be kept in the journal queue, just as the <xref:System.Messaging.MessageQueue> class's <xref:System.Messaging.MessageQueue.Receive%2A> method does.</span></span>  
  
 <span data-ttu-id="61a41-265">Al trabajar con colas transaccionales, una operación de reversión de una transacción hace que los mensajes que se quitan mediante una llamada a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> va a devolver a la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-265">When working with transactional queues, a rollback of a transaction causes any messages removed by a call to <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A> to be returned to the queue.</span></span> <span data-ttu-id="61a41-266">La eliminación no es irreversible hasta que se confirma la transacción.</span><span class="sxs-lookup"><span data-stu-id="61a41-266">The removal is not irreversible until the transaction is committed.</span></span>  
  
 <span data-ttu-id="61a41-267">Cuando se quita el mensaje actual, el cursor se mueve al siguiente mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-267">When you remove the current message, the cursor is moved to the next message.</span></span> <span data-ttu-id="61a41-268">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span><span class="sxs-lookup"><span data-stu-id="61a41-268">You do not have to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.RemoveCurrent%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="61a41-269">El valor especificado para el parámetro <paramref name="timeout" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="61a41-269">The value specified for the <paramref name="timeout" /> parameter is invalid.</span></span></exception>
        <exception cref="T:System.Messaging.MessageQueueException"><span data-ttu-id="61a41-270">El tiempo de espera ha expirado.</span><span class="sxs-lookup"><span data-stu-id="61a41-270">The timeout has expired.</span></span></exception>
        <exception cref="T:System.ComponentModel.InvalidEnumArgumentException"><span data-ttu-id="61a41-271">El parámetro <paramref name="transactionType" /> no es un miembro de <see cref="T:System.Messaging.MessageQueueTransactionType" />.</span><span class="sxs-lookup"><span data-stu-id="61a41-271">The <paramref name="transactionType" /> parameter is not one of the <see cref="T:System.Messaging.MessageQueueTransactionType" /> members.</span></span></exception>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
        <altmember cref="T:System.Messaging.MessageQueueTransactionType" />
      </Docs>
    </Member>
    <Member MemberName="Reset">
      <MemberSignature Language="C#" Value="public void Reset ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Reset() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Messaging.MessageEnumerator.Reset" />
      <MemberSignature Language="VB.NET" Value="Public Sub Reset ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Reset();" />
      <MemberSignature Language="F#" Value="abstract member Reset : unit -&gt; unit&#xA;override this.Reset : unit -&gt; unit" Usage="messageEnumerator.Reset " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerator.Reset</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="61a41-272">Restablece el enumerador actual de forma que señale al encabezado de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-272">Resets the current enumerator so it points to the head of the queue.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="61a41-273">Un enumerador sólo puede mover hacia delante.</span><span class="sxs-lookup"><span data-stu-id="61a41-273">An enumerator can only move in a forward direction.</span></span> <span data-ttu-id="61a41-274">Utilice este método para volver a empezar al principio de la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-274">Use this method to start over at the beginning of the queue.</span></span>  
  
 <span data-ttu-id="61a41-275">Después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A>, el cursor señala al primer mensaje.</span><span class="sxs-lookup"><span data-stu-id="61a41-275">After calling <xref:System.Messaging.MessageEnumerator.Reset%2A>, the cursor points to the first message.</span></span> <span data-ttu-id="61a41-276">No es necesario llamar a <xref:System.Messaging.MessageEnumerator.MoveNext%2A> después de llamar a <xref:System.Messaging.MessageEnumerator.Reset%2A> para mover el cursor hacia delante hasta el primer mensaje en la cola.</span><span class="sxs-lookup"><span data-stu-id="61a41-276">You do not need to call <xref:System.Messaging.MessageEnumerator.MoveNext%2A> after calling <xref:System.Messaging.MessageEnumerator.Reset%2A> to move the cursor forward to the first message in the queue.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Messaging.MessageEnumerator.MoveNext" />
        <altmember cref="P:System.Messaging.MessageEnumerator.Current" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerator.Current">
      <MemberSignature Language="C#" Value="object System.Collections.IEnumerator.Current { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object System.Collections.IEnumerator.Current" />
      <MemberSignature Language="DocId" Value="P:System.Messaging.MessageEnumerator.System#Collections#IEnumerator#Current" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property Current As Object Implements IEnumerator.Current" />
      <MemberSignature Language="C++ CLI" Value="property System::Object ^ System::Collections::IEnumerator::Current { System::Object ^ get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.IEnumerator.Current" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.IEnumerator.Current</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Messaging</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="61a41-277">Devuelve una <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</span><span class="sxs-lookup"><span data-stu-id="61a41-277">Returns a <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></summary>
        <value><span data-ttu-id="61a41-278">Una clase <see cref="T:System.Messaging.Message" /> que hace referencia al mensaje de la posición actual del cursor.</span><span class="sxs-lookup"><span data-stu-id="61a41-278">A <see cref="T:System.Messaging.Message" /> that references the message at the current cursor position.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>