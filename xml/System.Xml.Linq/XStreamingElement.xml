<Type Name="XStreamingElement" FullName="System.Xml.Linq.XStreamingElement">
  <TypeSignature Language="C#" Value="public class XStreamingElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XStreamingElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XStreamingElement" />
  <TypeSignature Language="VB.NET" Value="Public Class XStreamingElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class XStreamingElement" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="bcf71-101">Representa los elementos de un árbol XML que admite la salida de transmisión por secuencias diferida.</span><span class="sxs-lookup"><span data-stu-id="bcf71-101">Represents elements in an XML tree that supports deferred streaming output.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-102">Esta clase le permite crear un árbol XML que admite la salida de transmisión por secuencias diferida.</span><span class="sxs-lookup"><span data-stu-id="bcf71-102">This class allows you to create an XML tree that supports deferred streaming output.</span></span> <span data-ttu-id="bcf71-103">Utilice esta clase para crear un árbol XML en un modo muy similar a la creación de un árbol XML utilizando <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-103">You use this class to create an XML tree in a very similar fashion to creating an XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="bcf71-104">Sin embargo, hay una diferencia fundamental.</span><span class="sxs-lookup"><span data-stu-id="bcf71-104">However, there is a fundamental difference.</span></span> <span data-ttu-id="bcf71-105">Cuando se usa una consulta LINQ para especificar el contenido al crear un árbol XML usando <xref:System.Xml.Linq.XElement>, se recorre en iteración la variable de consulta en el momento de construcción del árbol XML y los resultados de la consulta se agregan al árbol XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-105">When you use a LINQ query to specify content when creating an XML tree using <xref:System.Xml.Linq.XElement>, the query variable is iterated at the time of construction of the XML tree, and the results of the query are added to the XML tree.</span></span> <span data-ttu-id="bcf71-106">En cambio, cuando se crea un árbol XML utilizando <xref:System.Xml.Linq.XStreamingElement>, una referencia a la variable de consulta se almacena en el árbol XML sin que se recorren en iteración.</span><span class="sxs-lookup"><span data-stu-id="bcf71-106">In contrast, when you create an XML tree using <xref:System.Xml.Linq.XStreamingElement>, a reference to the query variable is stored in the XML tree without being iterated.</span></span> <span data-ttu-id="bcf71-107">Las consultas se recorren en iteración en la serialización.</span><span class="sxs-lookup"><span data-stu-id="bcf71-107">Queries are iterated only upon serialization.</span></span> <span data-ttu-id="bcf71-108">Esto le permite crear árboles XML mayor manteniendo una superficie de memoria menor.</span><span class="sxs-lookup"><span data-stu-id="bcf71-108">This allows you to create larger XML trees while maintaining a smaller memory footprint.</span></span>  
  
 <span data-ttu-id="bcf71-109">Si está transmitiendo por secuencias desde un origen de entrada, como un archivo de texto, puede leer un archivo de texto muy grandes y generar un documento muy grande de XML manteniendo una superficie de memoria pequeña.</span><span class="sxs-lookup"><span data-stu-id="bcf71-109">If you are streaming from an input source, such as a text file, then you can read a very large text file, and generate a very large XML document while maintaining a small memory footprint.</span></span>  
  
 <span data-ttu-id="bcf71-110">Otro escenario es que tiene un árbol XML grande que se han cargado en memoria, y desea crear una versión transformada del documento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-110">Another scenario is that you have a large XML tree that has been loaded into memory, and you want to create a transformed version of the document.</span></span> <span data-ttu-id="bcf71-111">Si crea un documento nuevo mediante <xref:System.Xml.Linq.XElement>, tendrá dos árboles XML de gran tamaño en memoria durante la realización de la transformación.</span><span class="sxs-lookup"><span data-stu-id="bcf71-111">If you create a new document using <xref:System.Xml.Linq.XElement>, then you will have two large XML trees in memory upon completion of the transformation.</span></span> <span data-ttu-id="bcf71-112">Sin embargo, si crea el nuevo árbol XML mediante <xref:System.Xml.Linq.XStreamingElement>, a continuación, se eliminará el espacio de trabajo eficazmente por la mitad.</span><span class="sxs-lookup"><span data-stu-id="bcf71-112">However, if you create the new XML tree using <xref:System.Xml.Linq.XStreamingElement>, then your working set will be effectively cut in half.</span></span>  
  
 <span data-ttu-id="bcf71-113">Tenga en cuenta que, cuando se depura un programa que usa <xref:System.Xml.Linq.XStreamingElement>, mostrar el valor de un objeto hace que su <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método al que llamar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-113">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="bcf71-114">Esto hace que el XML que se va a serializar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-114">This causes the XML to be serialized.</span></span> <span data-ttu-id="bcf71-115">Si la semántica de la consulta de elemento de transmisión por secuencias es tal que el elemento de transmisión por secuencias solo se puede transmitir una vez, esto puede provocar un comportamiento no deseado en la experiencia de depuración.</span><span class="sxs-lookup"><span data-stu-id="bcf71-115">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-116">En el ejemplo siguiente se crea primero un árbol XML de origen.</span><span class="sxs-lookup"><span data-stu-id="bcf71-116">The following example first creates a source XML tree.</span></span> <span data-ttu-id="bcf71-117">A continuación, crea una transformación del árbol XML de origen utilizando <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-117">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XElement>.</span></span> <span data-ttu-id="bcf71-118">Esta transformación crea un nuevo árbol en memoria.</span><span class="sxs-lookup"><span data-stu-id="bcf71-118">This transform creates a new tree in memory.</span></span> <span data-ttu-id="bcf71-119">A continuación, crea una transformación del árbol XML de origen utilizando <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-119">It then creates a transform of the source XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-120">Esta transformación no ejecuta la consulta hasta que se serializa el árbol transformado a la consola.</span><span class="sxs-lookup"><span data-stu-id="bcf71-120">This transform doesn't execute the query until the transformed tree is serialized to the console.</span></span> <span data-ttu-id="bcf71-121">El uso de memoria es menor.</span><span class="sxs-lookup"><span data-stu-id="bcf71-121">Its memory usage is less.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XElement dstTree1 = new XElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
XStreamingElement dstTree2 = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree1);  
Console.WriteLine("------");  
Console.WriteLine(dstTree2);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree1 As XElement = _  
    <NewRoot>  
        <%= From el In srcTree.Elements _  
            Where (el.Value >= 3) _  
            Select <DifferentChild><%= el.Value %></DifferentChild> %>  
    </NewRoot>  
  
Dim dstTree2 As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree1)  
Console.WriteLine("------")  
Console.WriteLine(dstTree2)  
```  
  
 <span data-ttu-id="bcf71-122">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-122">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 <span data-ttu-id="bcf71-123">Un enfoque del procesamiento de un archivo de texto es escribir un método de extensión que transmita el archivo de texto por secuencias de línea en línea mediante la construcción `yield return`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-123">One approach to processing a text file is to write an extension method that streams the text file a line at a time using the `yield return` construct.</span></span> <span data-ttu-id="bcf71-124">Después, puede escribir una consulta LINQ que procese el archivo de texto de forma aplazada y lenta.</span><span class="sxs-lookup"><span data-stu-id="bcf71-124">You then can write a LINQ query that processes the text file in a lazy deferred fashion.</span></span> <span data-ttu-id="bcf71-125">Si, a continuación, utiliza el <xref:System.Xml.Linq.XStreamingElement> para transmitir el resultado, a continuación, puede crear una transformación del archivo de texto al XML usando una cantidad mínima de memoria, independientemente del tamaño del archivo de texto de origen.</span><span class="sxs-lookup"><span data-stu-id="bcf71-125">If you then use the <xref:System.Xml.Linq.XStreamingElement> to stream output, you then can create a transform from the text file to XML that uses a minimal amount of memory, regardless of the size of the source text file.</span></span>  
  
 <span data-ttu-id="bcf71-126">El siguiente archivo de texto, People.txt, es el origen de este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-126">The following text file, People.txt, is the source for this example.</span></span>  
  
```  
#This is a comment  
1,Tai,Yee,Writer  
2,Nikolay,Grachev,Programmer  
3,David,Wright,Inventor  
```  
  
 <span data-ttu-id="bcf71-127">El siguiente código contiene un método de extensión que transmite las líneas del archivo de texto por secuencias de forma diferida.</span><span class="sxs-lookup"><span data-stu-id="bcf71-127">The following code contains an extension method that streams the lines of the text file in a deferred fashion.</span></span>  
  
```csharp  
public static class StreamReaderSequence  
{  
    public static IEnumerable<string> Lines(this StreamReader source)  
    {  
        String line;  
  
        if (source == null)  
            throw new ArgumentNullException("source");  
        while ((line = source.ReadLine()) != null)  
        {  
            yield return line;  
        }  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        StreamReader sr = new StreamReader("People.txt");  
        XStreamingElement xmlTree = new XStreamingElement("Root",  
            from line in sr.Lines()  
            let items = line.Split(',')  
            where !line.StartsWith("#")  
            select new XElement("Person",  
                       new XAttribute("ID", items[0]),  
                       new XElement("First", items[1]),  
                       new XElement("Last", items[2]),  
                       new XElement("Occupation", items[3])  
                   )  
        );  
        Console.WriteLine(xmlTree);  
        sr.Close();  
    }  
}  
```  
  
```vb  
Module StreamReaderSequence  
  
    <Runtime.CompilerServices.Extension>  
    Public Iterator Function Lines(source As IO.StreamReader) As IEnumerable(Of String)  
        If source Is Nothing Then Throw New ArgumentNullException("source")  
        Dim line As String = source.ReadLine()  
        While (line <> Nothing)  
            Yield line  
            line = source.ReadLine()  
        End While  
    End Function  
  
End Module  
  
Module Module1  
    Sub Main()  
        Dim sr As New IO.StreamReader("People.txt")  
        Dim xmlTree As New XStreamingElement("Root",  
            From line In sr.Lines()  
            Let items = line.Split(","c)  
            Where Not line.StartsWith("#")  
            Select <Person ID=<%= items(0) %>>  
                       <First><%= items(1) %></First>  
                       <Last><%= items(2) %></Last>  
                       <Occupation><%= items(3) %></Occupation>  
                   </Person>)  
        Console.WriteLine(xmlTree)  
        sr.Close()  
    End Sub  
End Module  
```  
  
 <span data-ttu-id="bcf71-128">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-128">This example produces the following output:</span></span>  
  
```xml  
<Root>  
  <Person ID="1">  
    <First>Tai</First>  
    <Last>Yee</Last>  
    <Occupation>Writer</Occupation>  
  </Person>  
  <Person ID="2">  
    <First>Nikolay</First>  
    <Last>Grachev</Last>  
    <Occupation>Programmer</Occupation>  
  </Person>  
  <Person ID="3">  
    <First>David</First>  
    <Last>Wright</Last>  
    <Occupation>Inventor</Occupation>  
  </Person>  
</Root>  
```  
  
 <span data-ttu-id="bcf71-129">A veces tiene que transformar los archivos XML grandes y escribir la aplicación para que sea predecible la superficie en memoria de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bcf71-129">Sometimes you have to transform large XML files, and write your application so that the memory footprint of the application is predictable.</span></span> <span data-ttu-id="bcf71-130">Si intenta rellenar un árbol XML con un archivo XML de gran tamaño, su utilización de memoria será proporcional al tamaño del archivo (es decir, excesivo).</span><span class="sxs-lookup"><span data-stu-id="bcf71-130">If you try to populate an XML tree with a very large XML file, your memory usage will be proportional to the size of the file (that is, excessive).</span></span> <span data-ttu-id="bcf71-131">Por consiguiente, debe utilizar en su lugar una técnica de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-131">Therefore, you should use a streaming technique instead.</span></span>  
  
 <span data-ttu-id="bcf71-132">Ciertos operadores de consulta estándar, como <xref:System.Linq.Enumerable.OrderBy%2A>, recorren en iteración su origen, recaban todos los datos, los ordenan y finalmente producen el primer elemento de la secuencia.</span><span class="sxs-lookup"><span data-stu-id="bcf71-132">Certain standard query operators, such as <xref:System.Linq.Enumerable.OrderBy%2A>, iterate their source, collect all of the data, sort it, and then finally yield the first item in the sequence.</span></span> <span data-ttu-id="bcf71-133">Tenga en cuenta que si utiliza un operador de consulta que materializa su origen antes de producir el primer elemento, no retendrá una superficie de memoria pequeña para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="bcf71-133">Note that if you use a query operator that materializes its source before yielding the first item, you will not retain a small memory footprint for your application.</span></span>  
  
 <span data-ttu-id="bcf71-134">Incluso si utiliza la técnica descrita en, si intenta ensamblar un árbol XML que contiene el documento transformado, uso de memoria puede ser demasiado grande.</span><span class="sxs-lookup"><span data-stu-id="bcf71-134">Even if you use the technique described in , if you try to assemble an XML tree that contains the transformed document, memory usage may be too great.</span></span>  
  
 <span data-ttu-id="bcf71-135">En el siguiente ejemplo se basa en el ejemplo de [Cómo: transmitir por secuencias fragmentos de XML con acceso a la información de encabezado](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span><span class="sxs-lookup"><span data-stu-id="bcf71-135">The following example builds on the example in [How to: Stream XML Fragments with Access to Header Information](http://msdn.microsoft.com/library/01311522-9d03-4977-8641-2932c6f56092).</span></span>  
  
 <span data-ttu-id="bcf71-136">Este ejemplo utiliza las funciones de ejecución aplazada de <xref:System.Xml.Linq.XStreamingElement> para transmitir por secuencias el resultado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-136">This example uses the deferred execution capabilities of <xref:System.Xml.Linq.XStreamingElement> to stream the output.</span></span>  
  
 <span data-ttu-id="bcf71-137">Observe que se escribe el eje personalizado (`StreamCustomerItem`) específicamente para que espere un documento que tiene los elementos `Customer`, `Name` e `Item`, y que esos elementos se organizarán como en el documento Source.xml siguiente.</span><span class="sxs-lookup"><span data-stu-id="bcf71-137">Note that the custom axis (`StreamCustomerItem`) is specifically written so that it expects a document that has `Customer`, `Name`, and `Item` elements, and that those elements will be arranged as in the following Source.xml document.</span></span> <span data-ttu-id="bcf71-138">Una implementación más sólida, sin embargo, validaría el documento de origen con XSD o se prepararía para analizar un documento no válido.</span><span class="sxs-lookup"><span data-stu-id="bcf71-138">A more robust implementation, however, would either validate the source document with an XSD, or would be prepared to parse an invalid document.</span></span>  
  
 <span data-ttu-id="bcf71-139">A continuación, se muestra el documento de origen, Source.xml:</span><span class="sxs-lookup"><span data-stu-id="bcf71-139">The following is the source document, Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Customer>  
    <Name>A. Datum Corporation</Name>  
    <Item>  
      <Key>0001</Key>  
    </Item>  
    <Item>  
      <Key>0002</Key>  
    </Item>  
    <Item>  
      <Key>0003</Key>  
    </Item>  
    <Item>  
      <Key>0004</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Fabrikam, Inc.</Name>  
    <Item>  
      <Key>0005</Key>  
    </Item>  
    <Item>  
      <Key>0006</Key>  
    </Item>  
    <Item>  
      <Key>0007</Key>  
    </Item>  
    <Item>  
      <Key>0008</Key>  
    </Item>  
  </Customer>  
  <Customer>  
    <Name>Southridge Video</Name>  
    <Item>  
      <Key>0009</Key>  
    </Item>  
    <Item>  
      <Key>0010</Key>  
    </Item>  
  </Customer>  
</Root>  
```  
  
 <span data-ttu-id="bcf71-140">El código siguiente contiene un método que utiliza un <xref:System.Xml.XmlReader> para transmitir el código fuente XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-140">The following code contains a method that uses an <xref:System.Xml.XmlReader> to stream the source XML.</span></span> <span data-ttu-id="bcf71-141">Usa <xref:System.Xml.Linq.XStreamingElement> para transmitir por secuencias el nuevo XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-141">It uses <xref:System.Xml.Linq.XStreamingElement> to stream the new XML.</span></span>  
  
```csharp  
static IEnumerable<XElement> StreamCustomerItem(string uri)  
{  
    using (XmlReader reader = XmlReader.Create(uri))  
    {  
        XElement name = null;  
        XElement item = null;  
  
        reader.MoveToContent();  
  
        // Parse the file, save header information when encountered, and yield the  
        // Item XElement objects as they are created.  
  
        // loop through Customer elements  
        while (reader.Read())  
        {  
            if (reader.NodeType == XmlNodeType.Element  
                && reader.Name == "Customer")  
            {  
                // move to Name element  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.Element &&  
                        reader.Name == "Name")  
                    {  
                        name = XElement.ReadFrom(reader) as XElement;  
                        break;  
                    }  
                }  
  
                // loop through Item elements  
                while (reader.Read())  
                {  
                    if (reader.NodeType == XmlNodeType.EndElement)  
                        break;  
                    if (reader.NodeType == XmlNodeType.Element  
                        && reader.Name == "Item")  
                    {  
                        item = XElement.ReadFrom(reader) as XElement;  
                        if (item != null)  
                        {  
                            XElement tempRoot = new XElement("Root",  
                                new XElement(name)  
                            );  
                            tempRoot.Add(item);  
                            yield return item;  
                        }  
                    }  
                }  
            }  
        }  
    }  
}  
  
static void Main(string[] args)  
{  
    XStreamingElement root = new XStreamingElement("Root",  
        from el in StreamCustomerItem("Source.xml")  
        select new XElement("Item",  
            new XElement("Customer", (string)el.Parent.Element("Name")),  
            new XElement(el.Element("Key"))  
        )  
    );  
    root.Save("Test.xml");  
    Console.WriteLine(File.ReadAllText("Test.xml"));  
}  
```  
  
```vb  
Iterator Function StreamCustomerItem(uri As String) As IEnumerable(Of XElement)  
  
    Dim name As XElement = Nothing  
    Dim item As XElement = Nothing  
  
    Dim reader As XmlReader = XmlReader.Create(uri)  
    reader.MoveToContent()  
  
    ' Parse the file, save header information when encountered, and yield the  
    ' Item XElement objects as they are created.  
  
    ' Loop through Customer elements.  
    While (reader.Read())  
        If (reader.NodeType = XmlNodeType.Element And reader.Name = "Customer") Then  
            While (reader.Read())  
                ' Move to Name element  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Name") Then  
                    name = CType(XElement.ReadFrom(reader), XElement)  
                    Exit While  
                End If  
            End While  
  
            ' Loop through Item elements  
            While (reader.Read())  
                If (reader.NodeType = XmlNodeType.EndElement) Then  
                    Exit While  
                End If  
  
                If (reader.NodeType = XmlNodeType.Element And reader.Name = "Item") Then  
                    item = CType(XElement.ReadFrom(reader), XElement)  
                    If (Not (item Is Nothing)) Then  
                        Dim tempRoot = New XElement("Root",  
                            New XElement(name)  
                        )  
                        tempRoot.Add(item)  
                        Yield item  
                     End If  
                End If  
            End While  
        End If  
     End While  
    reader.Close()  
End Function  
  
Sub Main()  
    Dim root As New XStreamingElement("Root",  
        From el In StreamCustomerItem("c:\trash\Source.xml")  
        Select New XElement("Item",  
            New XElement("Customer", CStr(el.Parent.Element("Name"))),  
            New XElement(el.Element("Key"))))  
    root.Save("c:\trash\Test.xml")  
    Console.WriteLine(System.IO.File.ReadAllText("c:\trash\Test.xml"))  
End Sub  
```  
  
 <span data-ttu-id="bcf71-142">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-142">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<Root>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0001</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0002</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0003</Key>  
  </Item>  
  <Item>  
    <Customer>A. Datum Corporation</Customer>  
    <Key>0004</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0005</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0006</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0007</Key>  
  </Item>  
  <Item>  
    <Customer>Fabrikam, Inc.</Customer>  
    <Key>0008</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0009</Key>  
  </Item>  
  <Item>  
    <Customer>Southridge Video</Customer>  
    <Key>0010</Key>  
  </Item>  
</Root>  
```  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcf71-143">Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-143">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-144">Las consultas no se recorren en iteración hasta que el <xref:System.Xml.Linq.XStreamingElement> se serializa.</span><span class="sxs-lookup"><span data-stu-id="bcf71-144">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="bcf71-145">Esto difiere de usar consultas de contenido para un <xref:System.Xml.Linq.XElement>, donde las consultas se recorren en iteración en el momento de construcción del nuevo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-145">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="bcf71-146">Para obtener más información sobre el contenido válido que se puede pasar a este constructor, vea [válido contenido de objetos XElement y XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bcf71-146">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bcf71-147"><see cref="T:System.Xml.Linq.XName" /> que contiene el nombre del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-147">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of the element.</span></span></param>
        <summary><span data-ttu-id="bcf71-148">Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XElement" /> a partir del <see cref="T:System.Xml.Linq.XName" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-148">Initializes a new instance of the <see cref="T:System.Xml.Linq.XElement" /> class from the specified <see cref="T:System.Xml.Linq.XName" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-149">Este constructor crea un elemento de transmisión por secuencias sin ningún contenido ni ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-149">This constructor creates a streaming element with no content and no attributes.</span></span>  
  
 <span data-ttu-id="bcf71-150">Hay una conversión implícita de cadena a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-150">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="bcf71-151">Uso típico de este constructor es especificar una cadena como parámetro en lugar de crear un nuevo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-151">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
   
  
## Examples  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="bcf71-152">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-152">This example produces the following output:</span></span>  
  
```  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, System::Object ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bcf71-153"><see cref="T:System.Xml.Linq.XName" /> que contiene el nombre del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-153">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="bcf71-154">Contenido del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-154">The contents of the element.</span></span></param>
        <summary><span data-ttu-id="bcf71-155">Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XStreamingElement" /> con el nombre y el contenido especificados.</span><span class="sxs-lookup"><span data-stu-id="bcf71-155">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-156">Este constructor crea un elemento de transmisión por secuencias con los atributos y el contenido especificado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-156">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="bcf71-157">Hay una conversión implícita de cadena a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-157">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="bcf71-158">Uso típico de este constructor es especificar una cadena como parámetro en lugar de crear un nuevo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-158">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="bcf71-159">Las consultas no se recorren en iteración hasta que el <xref:System.Xml.Linq.XStreamingElement> se serializa.</span><span class="sxs-lookup"><span data-stu-id="bcf71-159">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="bcf71-160">Esto difiere de usar consultas de contenido para un <xref:System.Xml.Linq.XElement>, donde las consultas se recorren en iteración en el momento de construcción del nuevo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-160">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="bcf71-161">Para obtener más información sobre el contenido válido que se puede pasar a este constructor, vea [válido contenido de objetos XElement y XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bcf71-161">For details about the valid content that can be passed to this constructor, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-162">En este ejemplo se utiliza el siguiente archivo XML, denominado Source.xml:</span><span class="sxs-lookup"><span data-stu-id="bcf71-162">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XStreamingElement (System.Xml.Linq.XName name, params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XName name, object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.#ctor(System.Xml.Linq.XName,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As XName, ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XStreamingElement(System::Xml::Linq::XName ^ name, ... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.Xml.Linq.XName" />
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="bcf71-163"><see cref="T:System.Xml.Linq.XName" /> que contiene el nombre del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-163">An <see cref="T:System.Xml.Linq.XName" /> that contains the element name.</span></span></param>
        <param name="content"><span data-ttu-id="bcf71-164">Contenido del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-164">The contents of the element.</span></span></param>
        <summary><span data-ttu-id="bcf71-165">Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XStreamingElement" /> con el nombre y el contenido especificados.</span><span class="sxs-lookup"><span data-stu-id="bcf71-165">Initializes a new instance of the <see cref="T:System.Xml.Linq.XStreamingElement" /> class with the specified name and content.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-166">Este constructor crea un elemento de transmisión por secuencias con los atributos y el contenido especificado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-166">This constructor creates a streaming element with the specified content and attributes.</span></span>  
  
 <span data-ttu-id="bcf71-167">Hay una conversión implícita de cadena a <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-167">There is an implicit conversion from string to <xref:System.Xml.Linq.XName>.</span></span> <span data-ttu-id="bcf71-168">Uso típico de este constructor es especificar una cadena como parámetro en lugar de crear un nuevo <xref:System.Xml.Linq.XName>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-168">Typical use of this constructor is to specify a string as the parameter instead of creating a new <xref:System.Xml.Linq.XName>.</span></span>  
  
 <span data-ttu-id="bcf71-169">Las consultas no se recorren en iteración hasta que el <xref:System.Xml.Linq.XStreamingElement> se serializa.</span><span class="sxs-lookup"><span data-stu-id="bcf71-169">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="bcf71-170">Esto difiere de usar consultas de contenido para un <xref:System.Xml.Linq.XElement>, donde las consultas se recorren en iteración en el momento de construcción del nuevo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-170">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="bcf71-171">Para obtener más información sobre el contenido válido que se puede pasar a esta función, consulte [válido contenido de objetos XElement y XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bcf71-171">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-172">En este ejemplo se utiliza el siguiente archivo XML, denominado Source.xml:</span><span class="sxs-lookup"><span data-stu-id="bcf71-172">This example uses the following XML file, named Source.xml:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8" ?>   
<Root>  
  <Child Key="01">  
    <GrandChild>aaa</GrandChild>  
  </Child>  
  <Child Key="02">  
    <GrandChild>bbb</GrandChild>  
  </Child>  
  <Child Key="03">  
    <GrandChild>ccc</GrandChild>  
  </Child>  
</Root>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcf71-173">Agrega el contenido especificado como elementos secundarios a este <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-173">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (object content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (content As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(System::Object ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="bcf71-174">Contenido que se va a agregar al elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-174">Content to be added to the streaming element.</span></span></param>
        <summary><span data-ttu-id="bcf71-175">Agrega el contenido especificado como elementos secundarios a este <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-175">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-176">Este constructor agrega el contenido especificado y agregando atributos a la <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-176">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-177">Aunque a menudo es posible construir la <xref:System.Xml.Linq.XStreamingElement> en una sola instrucción, a veces resulta más cómodo agregar contenido al elemento de transmisión por secuencias de forma incremental.</span><span class="sxs-lookup"><span data-stu-id="bcf71-177">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="bcf71-178">Las consultas no se recorren en iteración hasta que el <xref:System.Xml.Linq.XStreamingElement> se serializa.</span><span class="sxs-lookup"><span data-stu-id="bcf71-178">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="bcf71-179">Esto difiere de usar consultas de contenido para un <xref:System.Xml.Linq.XElement>, donde las consultas se recorren en iteración en el momento de construcción del nuevo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-179">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="bcf71-180">Para obtener más información sobre el contenido válido que se puede pasar a esta función, consulte [válido contenido de objetos XElement y XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bcf71-180">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-181">En el ejemplo siguiente se crea un nuevo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-181">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-182">A continuación, agrega dos consultas al elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-182">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="bcf71-183">Las consultas no se recorren en iteración hasta que se serializa el elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-183">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="bcf71-184">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-184">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (params object[] content);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Add(object[] content) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Add(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub Add (ParamArray content As Object())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Add(... cli::array &lt;System::Object ^&gt; ^ content);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="content" Type="System.Object[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="content"><span data-ttu-id="bcf71-185">Contenido que se va a agregar al elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-185">Content to be added to the streaming element.</span></span></param>
        <summary><span data-ttu-id="bcf71-186">Agrega el contenido especificado como elementos secundarios a este <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-186">Adds the specified content as children to this <see cref="T:System.Xml.Linq.XStreamingElement" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-187">Este constructor agrega el contenido especificado y agregando atributos a la <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-187">This constructor adds the specified content and attributes to the <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-188">Aunque a menudo es posible construir la <xref:System.Xml.Linq.XStreamingElement> en una sola instrucción, a veces resulta más cómodo agregar contenido al elemento de transmisión por secuencias de forma incremental.</span><span class="sxs-lookup"><span data-stu-id="bcf71-188">While it is often possible to construct the <xref:System.Xml.Linq.XStreamingElement> in a single statement, it is sometimes more convenient to add content to the streaming element incrementally.</span></span>  
  
 <span data-ttu-id="bcf71-189">Las consultas no se recorren en iteración hasta que el <xref:System.Xml.Linq.XStreamingElement> se serializa.</span><span class="sxs-lookup"><span data-stu-id="bcf71-189">Queries are not iterated until the <xref:System.Xml.Linq.XStreamingElement> is serialized.</span></span> <span data-ttu-id="bcf71-190">Esto difiere de usar consultas de contenido para un <xref:System.Xml.Linq.XElement>, donde las consultas se recorren en iteración en el momento de construcción del nuevo <xref:System.Xml.Linq.XElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-190">This is in contrast to using queries for content for an <xref:System.Xml.Linq.XElement>, where queries are iterated at the time of construction of the new <xref:System.Xml.Linq.XElement>.</span></span>  
  
 <span data-ttu-id="bcf71-191">Para obtener más información sobre el contenido válido que se puede pasar a esta función, consulte [válido contenido de objetos XElement y XDocument](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span><span class="sxs-lookup"><span data-stu-id="bcf71-191">For details about the valid content that can be passed to this function, see [Valid Content of XElement and XDocument Objects](http://msdn.microsoft.com/library/aee2d319-5c5f-4b99-9bb4-2f58232577ae).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-192">En el ejemplo siguiente se crea un nuevo <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-192">The following example creates a new <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-193">A continuación, agrega dos consultas al elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-193">It then adds two queries to the streaming element.</span></span> <span data-ttu-id="bcf71-194">Las consultas no se recorren en iteración hasta que se serializa el elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-194">The queries are not iterated until the streaming element is serialized.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot");  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el <= 1  
    select new XElement("Child", (int)el)  
);  
  
dstTree.Add(  
    from el in srcTree.Elements()  
    where (int)el >= 3  
    select new XElement("DifferentChild", (int)el)  
);  
  
Console.WriteLine(dstTree);  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot")  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value <= 1 _  
    Select <Child><%= el.Value %></Child> _  
)  
  
dstTree.Add( _  
    From el In srcTree.Elements() _  
    Where el.Value >= 3 _  
    Select <DifferentChild><%= el.Value %></DifferentChild> _  
)  
  
Console.WriteLine(dstTree)  
```  
  
 <span data-ttu-id="bcf71-195">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-195">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <Child>1</Child>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XName Name { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XName Name" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XStreamingElement.Name" />
      <MemberSignature Language="VB.NET" Value="Public Property Name As XName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XName ^ Name { System::Xml::Linq::XName ^ get(); void set(System::Xml::Linq::XName ^ value); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XName</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bcf71-196">Obtiene o establece el nombre de esta transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-196">Gets or sets the name of this streaming element.</span></span></summary>
        <value><span data-ttu-id="bcf71-197"><see cref="T:System.Xml.Linq.XName" /> que contiene el nombre de este elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-197">An <see cref="T:System.Xml.Linq.XName" /> that contains the name of this streaming element.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bcf71-198">Este ejemplo crea un nuevo elemento de transmisión por secuencias y, a continuación, imprime el nombre del elemento.</span><span class="sxs-lookup"><span data-stu-id="bcf71-198">This example creates a new streaming element, and then prints the name of the element.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.Name);  
```  
  
```vb  
Dim srcTree As XElement = _  
        <Root>  
            <Child>1</Child>  
            <Child>2</Child>  
            <Child>3</Child>  
            <Child>4</Child>  
            <Child>5</Child>  
        </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                From el In srcTree.Elements _  
                Where el.Value >= 3 _  
                Select <DifferentChild><%= el.Value %></DifferentChild> _  
            )  
  
Console.WriteLine(dstTree.Name)  
```  
  
 <span data-ttu-id="bcf71-199">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-199">This example produces the following output:</span></span>  
  
```  
NewRoot  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Save">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcf71-200">Serialice este elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-200">Serialize this streaming element.</span></span> <span data-ttu-id="bcf71-201">El resultado se puede guardar en un archivo, <see cref="T:System.Xml.XmlTextWriter" />, <see cref="T:System.IO.TextWriter" /> o <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-201">The output can be saved to a file, an <see cref="T:System.Xml.XmlTextWriter" />, a <see cref="T:System.IO.TextWriter" />, or an <see cref="T:System.Xml.XmlWriter" />.</span></span> <span data-ttu-id="bcf71-202">Opcionalmente, se puede deshabilitar el formato (sangría).</span><span class="sxs-lookup"><span data-stu-id="bcf71-202">Optionally, formatting (indenting) can be disabled.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="bcf71-203">Secuencia que se envía a este <see cref="T:System.Xml.Linq.XDocument" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-203">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <summary><span data-ttu-id="bcf71-204">Genera este <see cref="T:System.Xml.Linq.XStreamingElement" /> en el objeto <see cref="T:System.IO.Stream" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-204">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-205">Se aplicará sangría al XML serializado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-205">The serialized XML will be indented.</span></span> <span data-ttu-id="bcf71-206">Se quitarán todos los espacios en blanco no significativos y se agregará el espacio en blanco adicional para que el código XML esté correctamente con sangría.</span><span class="sxs-lookup"><span data-stu-id="bcf71-206">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="bcf71-207">El comportamiento de este método es que no se conservan ese espacio en blanco no significativo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-207">The behavior of this method is that insignificant white space will not be preserved.</span></span>  
  
 <span data-ttu-id="bcf71-208">Si desea controlar los espacios en blanco, use la sobrecarga del <xref:System.Xml.Linq.XStreamingElement.Save%2A> que toma <xref:System.Xml.Linq.SaveOptions> como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcf71-208">If you want to control white space, use the overload of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that takes <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="bcf71-209">Use la <xref:System.Xml.Linq.SaveOptions.DisableFormatting> opción para guardar el archivo XML sin sangría.</span><span class="sxs-lookup"><span data-stu-id="bcf71-209">Use the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> option to save unindented XML.</span></span> <span data-ttu-id="bcf71-210">Esto hará que el sistema de escritura escribir todos los espacios en blanco exactamente como se representa en el árbol XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-210">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="bcf71-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opción si desea que se quitan las declaraciones de espacios de nombres duplicados.</span><span class="sxs-lookup"><span data-stu-id="bcf71-211">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="bcf71-212"><see cref="T:System.IO.TextWriter" /> en el que se escribirá un <see cref="T:System.Xml.Linq.XStreamingElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-212">A <see cref="T:System.IO.TextWriter" /> that the <see cref="T:System.Xml.Linq.XStreamingElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="bcf71-213">Serialice este elemento de transmisión por secuencias en un <see cref="T:System.IO.TextWriter" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-213">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-214">Se aplicará sangría al XML serializado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-214">The serialized XML will be indented.</span></span> <span data-ttu-id="bcf71-215">Se quitarán todos los espacios en blanco no significativos y se agregará el espacio en blanco adicional para que el código XML esté correctamente con sangría.</span><span class="sxs-lookup"><span data-stu-id="bcf71-215">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="bcf71-216">El comportamiento de este método es ese espacio en blanco insignificante nodos en el árbol XML no se conservan.</span><span class="sxs-lookup"><span data-stu-id="bcf71-216">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="bcf71-217">Si desea controlar los espacios en blanco, utilice una de las sobrecargas de <xref:System.Xml.Linq.XStreamingElement.Save%2A> que toman <xref:System.Xml.Linq.SaveOptions> como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcf71-217">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="bcf71-218">Para obtener más información, consulte [preservar los espacios en blanco al cargar o analizar XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) y [preservar los espacios en blanco al serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="bcf71-218">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-219">En el ejemplo siguiente se crea un árbol XML de origen, a continuación, crea una instancia de un <xref:System.Xml.Linq.XStreamingElement> mediante una consulta en el árbol XML de origen.</span><span class="sxs-lookup"><span data-stu-id="bcf71-219">The following example creates a source XML tree, then instantiates an <xref:System.Xml.Linq.XStreamingElement> using a query on the source XML tree.</span></span> <span data-ttu-id="bcf71-220">A continuación, escribe el elemento de transmisión por secuencias a un <xref:System.IO.StringWriter>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-220">It then writes the streaming element to a <xref:System.IO.StringWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb));  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb))  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="bcf71-221">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-221">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="bcf71-222">Objeto <see cref="T:System.String" /> que contiene el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-222">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <summary><span data-ttu-id="bcf71-223">Serialice este elemento de transmisión por secuencias en un archivo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-223">Serialize this streaming element to a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-224">Se aplicará sangría al XML serializado.</span><span class="sxs-lookup"><span data-stu-id="bcf71-224">The serialized XML will be indented.</span></span> <span data-ttu-id="bcf71-225">Se quitarán todos los espacios en blanco no significativos y se agregará el espacio en blanco adicional para que el código XML esté correctamente con sangría.</span><span class="sxs-lookup"><span data-stu-id="bcf71-225">All insignificant white space will be removed, and additional white space will be added so that the XML will be properly indented.</span></span> <span data-ttu-id="bcf71-226">El comportamiento de este método es ese espacio en blanco insignificante nodos en el árbol XML no se conservan.</span><span class="sxs-lookup"><span data-stu-id="bcf71-226">The behavior of this method is that insignificant white space nodes in the XML tree will not be preserved.</span></span>  
  
 <span data-ttu-id="bcf71-227">Si desea controlar los espacios en blanco, utilice una de las sobrecargas de <xref:System.Xml.Linq.XStreamingElement.Save%2A> que toman <xref:System.Xml.Linq.SaveOptions> como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcf71-227">If you want to control white space, use one of the overloads of <xref:System.Xml.Linq.XStreamingElement.Save%2A> that take <xref:System.Xml.Linq.SaveOptions> as a parameter.</span></span> <span data-ttu-id="bcf71-228">Para obtener más información, consulte [preservar los espacios en blanco al cargar o analizar XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) y [preservar los espacios en blanco al serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="bcf71-228">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-229">En el ejemplo siguiente se crea un árbol XML de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-229">The following example creates a streaming XML tree.</span></span> <span data-ttu-id="bcf71-230">A continuación, serializa el árbol XML transmisión por secuencias en un archivo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-230">It then serializes the streaming XML tree to a file.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el >= 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test.xml");  
Console.WriteLine(File.ReadAllText("Test.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value >= 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test.xml")  
Console.WriteLine(File.ReadAllText("Test.xml"))  
```  
  
 <span data-ttu-id="bcf71-231">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-231">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
  <DifferentChild>4</DifferentChild>  
  <DifferentChild>5</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="bcf71-232"><see cref="T:System.Xml.XmlWriter" /> en el que se escribirá un <see cref="T:System.Xml.Linq.XElement" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-232">A <see cref="T:System.Xml.XmlWriter" /> that the <see cref="T:System.Xml.Linq.XElement" /> will be written to.</span></span></param>
        <summary><span data-ttu-id="bcf71-233">Serialice este elemento de transmisión por secuencias en un <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-233">Serialize this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bcf71-234">En el ejemplo siguiente se crea un <xref:System.Xml.Linq.XStreamingElement> y lo escribe en un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-234">The following example creates an <xref:System.Xml.Linq.XStreamingElement> and writes it to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                            from el in srcTree.Elements()  
                            where (int)el == 5  
                            select new XElement("DifferentChild", (int)el)  
                        );  
  
    dstTree.Save(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                            From el In srcTree.Elements() _  
                            Where el.Value = 5 _  
                            Select <DifferentChild><%= el.Value %></DifferentChild> _  
                        )  
    dstTree.Save(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="bcf71-235">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-235">This example produces the following output:</span></span>  
  
```xml  
<NewRoot><DifferentChild>5</DifferentChild></NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.Stream stream, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.Stream stream, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.Stream,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::Stream ^ stream, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="stream" Type="System.IO.Stream" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="stream"><span data-ttu-id="bcf71-236">Secuencia que se envía a este <see cref="T:System.Xml.Linq.XDocument" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-236">The stream to output this <see cref="T:System.Xml.Linq.XDocument" /> to.</span></span></param>
        <param name="options"><span data-ttu-id="bcf71-237">Objeto <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica el comportamiento de formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-237">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="bcf71-238">Genera este <see cref="T:System.Xml.Linq.XStreamingElement" /> en el objeto <see cref="T:System.IO.Stream" /> especificado, especificando opcionalmente el comportamiento de formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-238">Outputs this <see cref="T:System.Xml.Linq.XStreamingElement" /> to the specified <see cref="T:System.IO.Stream" />, optionally specifying formatting behavior.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-239">De forma predeterminada el `options` se establecen en <xref:System.Xml.Linq.SaveOptions.None>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-239">By default the `options` are set to <xref:System.Xml.Linq.SaveOptions.None>.</span></span> <span data-ttu-id="bcf71-240">Esta opción quitará todos los espacios en blanco no significativos y agregar espacio en blanco no significativo correspondientes para que se aplique sangría correctamente al XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-240">This option will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span>  
  
 <span data-ttu-id="bcf71-241">Si desea guardar el archivo XML sin sangría, especifique el <xref:System.Xml.Linq.SaveOptions.DisableFormatting> una marca para `options`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-241">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="bcf71-242">Esto hará que el sistema de escritura escribir todos los espacios en blanco exactamente como se representa en el árbol XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-242">This will cause the writer to write all white spaces exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="bcf71-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> opción si desea que se quitan las declaraciones de espacios de nombres duplicados.</span><span class="sxs-lookup"><span data-stu-id="bcf71-243">Use <xref:System.Xml.Linq.SaveOptions.OmitDuplicateNamespaces> option if you want to remove duplicate namespace declarations.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (System.IO.TextWriter textWriter, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(class System.IO.TextWriter textWriter, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.IO.TextWriter,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::IO::TextWriter ^ textWriter, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="textWriter" Type="System.IO.TextWriter" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="textWriter"><span data-ttu-id="bcf71-244"><see cref="T:System.IO.TextWriter" /> al que se envía el XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-244">The <see cref="T:System.IO.TextWriter" /> to output the XML to.</span></span></param>
        <param name="options"><span data-ttu-id="bcf71-245"><see cref="T:System.Xml.Linq.SaveOptions" /> que especifica el comportamiento de formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-245">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="bcf71-246">Serialice este elemento de transmisión por secuencias en un <see cref="T:System.IO.TextWriter" />, de modo opcional, deshabilite el formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-246">Serialize this streaming element to a <see cref="T:System.IO.TextWriter" />, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-247">Si desea guardar el archivo XML sin sangría, especifique el <xref:System.Xml.Linq.SaveOptions.DisableFormatting> una marca para `options`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-247">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="bcf71-248">Esto hará que el sistema de escritura escribir todos los espacios en blanco exactamente como se representa en el árbol XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-248">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="bcf71-249">Si desea guardar el archivo XML con sangría, no especifique el <xref:System.Xml.Linq.SaveOptions.DisableFormatting> una marca para `options`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-249">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="bcf71-250">Esto quitará todos los espacios en blanco no significativos y agregar espacio en blanco no significativo correspondientes para que se aplique sangría correctamente al XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-250">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="bcf71-251">Este es el comportamiento predeterminado y el comportamiento de las sobrecargas de la <xref:System.Xml.Linq.XElement.Save%2A> métodos que no toman `options` como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcf71-251">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="bcf71-252">Para obtener más información, consulte [preservar los espacios en blanco al cargar o analizar XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) y [preservar los espacios en blanco al serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="bcf71-252">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-253">En el ejemplo siguiente se muestra dos usos de este método.</span><span class="sxs-lookup"><span data-stu-id="bcf71-253">The following example shows two uses of this method.</span></span> <span data-ttu-id="bcf71-254">El primer uso conserva los espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="bcf71-254">The first use preserves white space.</span></span> <span data-ttu-id="bcf71-255">La segunda se serializa la <xref:System.Xml.Linq.XStreamingElement> con formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-255">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.DisableFormatting);  
Console.WriteLine(sb.ToString());  
Console.WriteLine("------");  
sb = new StringBuilder();  
dstTree.Save(new StringWriter(sb), SaveOptions.None);  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Dim sb As StringBuilder = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.DisableFormatting)  
Console.WriteLine(sb.ToString())  
Console.WriteLine("------")  
sb = New StringBuilder()  
dstTree.Save(New StringWriter(sb), SaveOptions.None)  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="bcf71-256">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-256">This example produces the following output:</span></span>  
  
```xml  
<?xml version="1.0" encoding="utf-16"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-16"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Save">
      <MemberSignature Language="C#" Value="public void Save (string fileName, System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Save(string fileName, valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.Save(System.String,System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Save (fileName As String, options As SaveOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Save(System::String ^ fileName, System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="bcf71-257">Objeto <see cref="T:System.String" /> que contiene el nombre del archivo.</span><span class="sxs-lookup"><span data-stu-id="bcf71-257">A <see cref="T:System.String" /> that contains the name of the file.</span></span></param>
        <param name="options"><span data-ttu-id="bcf71-258">Objeto <see cref="T:System.Xml.Linq.SaveOptions" /> que especifica el comportamiento de formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-258">A <see cref="T:System.Xml.Linq.SaveOptions" /> object that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="bcf71-259">Serialice este elemento de transmisión por secuencias en un archivo y, de modo opcional, deshabilite el formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-259">Serialize this streaming element to a file, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-260">Si desea guardar el archivo XML sin sangría, especifique el <xref:System.Xml.Linq.SaveOptions.DisableFormatting> una marca para `options`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-260">If you want to save unindented XML, specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="bcf71-261">Esto hará que el sistema de escritura escribir todos los espacios en blanco exactamente como se representa en el árbol XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-261">This will cause the writer to write all white space exactly as represented in the XML tree.</span></span>  
  
 <span data-ttu-id="bcf71-262">Si desea guardar el archivo XML con sangría, no especifique el <xref:System.Xml.Linq.SaveOptions.DisableFormatting> una marca para `options`.</span><span class="sxs-lookup"><span data-stu-id="bcf71-262">If you want to save indented XML, do not specify the <xref:System.Xml.Linq.SaveOptions.DisableFormatting> flag for `options`.</span></span> <span data-ttu-id="bcf71-263">Esto quitará todos los espacios en blanco no significativos y agregar espacio en blanco no significativo correspondientes para que se aplique sangría correctamente al XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-263">This will remove all extraneous insignificant white space, and add appropriate insignificant white space so that the XML is properly indented.</span></span> <span data-ttu-id="bcf71-264">Este es el comportamiento predeterminado y el comportamiento de las sobrecargas de la <xref:System.Xml.Linq.XElement.Save%2A> métodos que no toman `options` como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="bcf71-264">This is the default behavior, and the behavior of the overloads of the <xref:System.Xml.Linq.XElement.Save%2A> methods that do not take `options` as a parameter.</span></span>  
  
 <span data-ttu-id="bcf71-265">Para obtener más información, consulte [preservar los espacios en blanco al cargar o analizar XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) y [preservar los espacios en blanco al serializar](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span><span class="sxs-lookup"><span data-stu-id="bcf71-265">For more information, see [Preserving White Space while Loading or Parsing XML](http://msdn.microsoft.com/library/093a7169-a04e-4638-b08c-d1cb98aa650d) and [Preserving White Space While Serializing](http://msdn.microsoft.com/library/fb146217-0a49-4efc-ac84-7265b91d3939).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-266">En el ejemplo siguiente se muestra dos usos de este método.</span><span class="sxs-lookup"><span data-stu-id="bcf71-266">The following example shows two uses of this method.</span></span> <span data-ttu-id="bcf71-267">El primer uso conserva los espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="bcf71-267">The first use preserves white space.</span></span> <span data-ttu-id="bcf71-268">La segunda se serializa la <xref:System.Xml.Linq.XStreamingElement> con formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-268">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting);  
dstTree.Save("Test2.xml", SaveOptions.None);  
Console.WriteLine(File.ReadAllText("Test1.xml"));  
Console.WriteLine("------");  
Console.WriteLine(File.ReadAllText("Test2.xml"));  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
dstTree.Save("Test1.xml", SaveOptions.DisableFormatting)  
dstTree.Save("Test2.xml", SaveOptions.None)  
Console.WriteLine(File.ReadAllText("Test1.xml"))  
Console.WriteLine("------")  
Console.WriteLine(File.ReadAllText("Test2.xml"))  
```  
  
 <span data-ttu-id="bcf71-269">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-269">This example produces the following output:</span></span>  
  
```  
<?xml version="1.0" encoding="utf-8"?><NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<?xml version="1.0" encoding="utf-8"?>  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bcf71-270">Devuelve el XML de este elemento de transmisión por secuencias y, opcionalmente, se deshabilita el formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-270">Returns the XML for this streaming element, optionally disabling formatting.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-271">Tenga en cuenta que, cuando se depura un programa que usa <xref:System.Xml.Linq.XStreamingElement>, mostrar el valor de un objeto hace que su <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método al que llamar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-271">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="bcf71-272">Esto hace que el XML que se va a serializar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-272">This causes the XML to be serialized.</span></span> <span data-ttu-id="bcf71-273">Si la semántica de la consulta de elemento de transmisión por secuencias es tal que el elemento de transmisión por secuencias solo se puede transmitir una vez, esto puede provocar un comportamiento no deseado en la experiencia de depuración.</span><span class="sxs-lookup"><span data-stu-id="bcf71-273">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bcf71-274">Devuelve el XML con formato (sangría) para este elemento de transmisión por secuencias.</span><span class="sxs-lookup"><span data-stu-id="bcf71-274">Returns the formatted (indented) XML for this streaming element.</span></span></summary>
        <returns><span data-ttu-id="bcf71-275"><see cref="T:System.String" /> que contiene el XML con sangría.</span><span class="sxs-lookup"><span data-stu-id="bcf71-275">A <see cref="T:System.String" /> containing the indented XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-276">Tenga en cuenta que, cuando se depura un programa que usa <xref:System.Xml.Linq.XStreamingElement>, mostrar el valor de un objeto hace que su <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método al que llamar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-276">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="bcf71-277">Esto hace que el XML que se va a serializar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-277">This causes the XML to be serialized.</span></span> <span data-ttu-id="bcf71-278">Si la semántica de la consulta de elemento de transmisión por secuencias es tal que el elemento de transmisión por secuencias solo se puede transmitir una vez, esto puede provocar un comportamiento no deseado en la experiencia de depuración.</span><span class="sxs-lookup"><span data-stu-id="bcf71-278">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-279">En el ejemplo siguiente se muestra dos usos de <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-279">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="bcf71-280">El primer uso conserva los espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="bcf71-280">The first use preserves white space.</span></span> <span data-ttu-id="bcf71-281">La segunda se serializa la <xref:System.Xml.Linq.XStreamingElement> con formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-281">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="bcf71-282">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-282">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (System.Xml.Linq.SaveOptions options);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(valuetype System.Xml.Linq.SaveOptions options) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.ToString(System.Xml.Linq.SaveOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (options As SaveOptions) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::Xml::Linq::SaveOptions options);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="options" Type="System.Xml.Linq.SaveOptions" />
      </Parameters>
      <Docs>
        <param name="options"><span data-ttu-id="bcf71-283"><see cref="T:System.Xml.Linq.SaveOptions" /> que especifica el comportamiento de formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-283">A <see cref="T:System.Xml.Linq.SaveOptions" /> that specifies formatting behavior.</span></span></param>
        <summary><span data-ttu-id="bcf71-284">Devuelve el XML de este elemento de transmisión por secuencias y, opcionalmente, se deshabilita el formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-284">Returns the XML for this streaming element, optionally disabling formatting.</span></span></summary>
        <returns><span data-ttu-id="bcf71-285"><see cref="T:System.String" /> que contiene el XML.</span><span class="sxs-lookup"><span data-stu-id="bcf71-285">A <see cref="T:System.String" /> containing the XML.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bcf71-286">Tenga en cuenta que, cuando se depura un programa que usa <xref:System.Xml.Linq.XStreamingElement>, mostrar el valor de un objeto hace que su <xref:System.Xml.Linq.XStreamingElement.ToString%2A> método al que llamar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-286">Note that when debugging a program that uses <xref:System.Xml.Linq.XStreamingElement>, displaying the value of an object causes its <xref:System.Xml.Linq.XStreamingElement.ToString%2A> method to be called.</span></span> <span data-ttu-id="bcf71-287">Esto hace que el XML que se va a serializar.</span><span class="sxs-lookup"><span data-stu-id="bcf71-287">This causes the XML to be serialized.</span></span> <span data-ttu-id="bcf71-288">Si la semántica de la consulta de elemento de transmisión por secuencias es tal que el elemento de transmisión por secuencias solo se puede transmitir una vez, esto puede provocar un comportamiento no deseado en la experiencia de depuración.</span><span class="sxs-lookup"><span data-stu-id="bcf71-288">If the semantics of your streaming element query are such that the streaming element can only be streamed once, this may cause undesirable behavior in your debugging experience.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bcf71-289">En el ejemplo siguiente se muestra dos usos de <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-289">The following example shows two uses of <xref:System.Xml.Linq.XStreamingElement.ToString%2A>.</span></span> <span data-ttu-id="bcf71-290">El primer uso conserva los espacios en blanco.</span><span class="sxs-lookup"><span data-stu-id="bcf71-290">The first use preserves white space.</span></span> <span data-ttu-id="bcf71-291">La segunda se serializa la <xref:System.Xml.Linq.XStreamingElement> con formato.</span><span class="sxs-lookup"><span data-stu-id="bcf71-291">The second one serializes the <xref:System.Xml.Linq.XStreamingElement> with formatting.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting));  
Console.WriteLine("------");  
Console.WriteLine(dstTree.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = New XStreamingElement("NewRoot", _  
                        From el In srcTree.Elements() _  
                        Where el.Value = 3 _  
                        Select <DifferentChild><%= el.Value %></DifferentChild> _  
                    )  
  
Console.WriteLine(dstTree.ToString(SaveOptions.DisableFormatting))  
Console.WriteLine("------")  
Console.WriteLine(dstTree.ToString())  
```  
  
 <span data-ttu-id="bcf71-292">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-292">This example produces the following output:</span></span>  
  
```  
<NewRoot><DifferentChild>3</DifferentChild></NewRoot>  
------  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XStreamingElement.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><span data-ttu-id="bcf71-293">Objeto <see cref="T:System.Xml.XmlWriter" /> en el que escribirá este método.</span><span class="sxs-lookup"><span data-stu-id="bcf71-293">An <see cref="T:System.Xml.XmlWriter" /> into which this method will write.</span></span></param>
        <summary><span data-ttu-id="bcf71-294">Escribe este elemento de transmisión por secuencias en un <see cref="T:System.Xml.XmlWriter" />.</span><span class="sxs-lookup"><span data-stu-id="bcf71-294">Writes this streaming element to an <see cref="T:System.Xml.XmlWriter" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bcf71-295">En el ejemplo siguiente se crea un árbol XML utilizando <xref:System.Xml.Linq.XStreamingElement>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-295">The following example creates an XML tree using <xref:System.Xml.Linq.XStreamingElement>.</span></span> <span data-ttu-id="bcf71-296">A continuación, escribe el elemento de transmisión por secuencias a un <xref:System.Xml.XmlWriter>.</span><span class="sxs-lookup"><span data-stu-id="bcf71-296">It then writes the streaming element to an <xref:System.Xml.XmlWriter>.</span></span>  
  
```csharp  
XElement srcTree = new XElement("Root",  
                       new XElement("Child", 1),  
                       new XElement("Child", 2),  
                       new XElement("Child", 3),  
                       new XElement("Child", 4),  
                       new XElement("Child", 5)  
                   );  
  
XStreamingElement dstTree = new XStreamingElement("NewRoot",  
                        from el in srcTree.Elements()  
                        where (int)el == 3  
                        select new XElement("DifferentChild", (int)el)  
                    );  
  
StringBuilder sb = new StringBuilder();  
XmlWriterSettings xws = new XmlWriterSettings();  
xws.OmitXmlDeclaration = true;  
xws.Indent = true;  
  
using (XmlWriter xw = XmlWriter.Create(sb, xws))  
{  
    dstTree.WriteTo(xw);  
}  
Console.WriteLine(sb.ToString());  
```  
  
```vb  
Dim srcTree As XElement = _  
    <Root>  
        <Child>1</Child>  
        <Child>2</Child>  
        <Child>3</Child>  
        <Child>4</Child>  
        <Child>5</Child>  
    </Root>  
  
Dim dstTree As XStreamingElement = _   
    New XStreamingElement("NewRoot", _  
        From el In srcTree.Elements() _  
        Where el.Value = 3 _  
        Select <DifferentChild><%= el.Value %></DifferentChild> )  
  
Dim sb As StringBuilder = New StringBuilder()  
Dim xws As XmlWriterSettings = New XmlWriterSettings()  
xws.OmitXmlDeclaration = True  
xws.Indent = True  
  
Using xw As XmlWriter = XmlWriter.Create(sb, xws)  
    dstTree.WriteTo(xw)  
End Using  
Console.WriteLine(sb.ToString())  
```  
  
 <span data-ttu-id="bcf71-297">Este ejemplo produce el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="bcf71-297">This example produces the following output:</span></span>  
  
```xml  
<NewRoot>  
  <DifferentChild>3</DifferentChild>  
</NewRoot>  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>