<Type Name="XProcessingInstruction" FullName="System.Xml.Linq.XProcessingInstruction">
  <Metadata><Meta Name="ms.openlocfilehash" Value="65e23bda0166af506414ff1b968688f6d9237c30" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58682890" /></Metadata><TypeSignature Language="C#" Value="public class XProcessingInstruction : System.Xml.Linq.XNode" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit XProcessingInstruction extends System.Xml.Linq.XNode" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XProcessingInstruction" />
  <TypeSignature Language="VB.NET" Value="Public Class XProcessingInstruction&#xA;Inherits XNode" />
  <TypeSignature Language="C++ CLI" Value="public ref class XProcessingInstruction : System::Xml::Linq::XNode" />
  <TypeSignature Language="F#" Value="type XProcessingInstruction = class&#xA;    inherit XNode" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Xml.Linq.XNode</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Representa una instrucción de procesamiento de XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar las instrucciones de procesamiento de XML para indicar que se puede procesar un documento XML algún tipo de procesador, como XSLT.  
  
 Las instrucciones de procesamiento son nodos en el árbol XML. Cuando una instrucción de procesamiento se encuentra en el XML que se está analizando, [!INCLUDE[sqltecxlinq](~/includes/sqltecxlinq-md.md)] crea un <xref:System.Xml.Linq.XProcessingInstruction> nodo.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XProcessingInstruction" />.</summary>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XProcessingInstruction (System.Xml.Linq.XProcessingInstruction other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Xml.Linq.XProcessingInstruction other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XProcessingInstruction.#ctor(System.Xml.Linq.XProcessingInstruction)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (other As XProcessingInstruction)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XProcessingInstruction(System::Xml::Linq::XProcessingInstruction ^ other);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XProcessingInstruction : System.Xml.Linq.XProcessingInstruction -&gt; System.Xml.Linq.XProcessingInstruction" Usage="new System.Xml.Linq.XProcessingInstruction other" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="other" Type="System.Xml.Linq.XProcessingInstruction" />
      </Parameters>
      <Docs>
        <param name="other">El nodo <see cref="T:System.Xml.Linq.XProcessingInstruction" /> del que se va a copiar.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XProcessingInstruction" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Principalmente, este constructor se usa internamente para realizar una copia en profundidad de un árbol XML.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public XProcessingInstruction (string target, string data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string target, string data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XProcessingInstruction.#ctor(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (target As String, data As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; XProcessingInstruction(System::String ^ target, System::String ^ data);" />
      <MemberSignature Language="F#" Value="new System.Xml.Linq.XProcessingInstruction : string * string -&gt; System.Xml.Linq.XProcessingInstruction" Usage="new System.Xml.Linq.XProcessingInstruction (target, data)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="target" Type="System.String" />
        <Parameter Name="data" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="target">Valor de tipo <see cref="T:System.String" /> que contiene la aplicación de destino de esta <see cref="T:System.Xml.Linq.XProcessingInstruction" />.</param>
        <param name="data">Los datos de cadena de esta <see cref="T:System.Xml.Linq.XProcessingInstruction" />.</param>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.Xml.Linq.XProcessingInstruction" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se crea un <xref:System.Xml.Linq.XProcessingInstruction>y especifica un destino y los datos de cadena para la instrucción de procesamiento.  
  
```csharp  
XProcessingInstruction pi = new XProcessingInstruction("xml-stylesheet", "type='text/xsl' href='hello.xsl'");  
Console.WriteLine(pi);  
```  
  
```vb  
Dim pi As XProcessingInstruction = <?xml-stylesheet type='text/xsl' href='hello.xsl'?>  
Console.WriteLine(pi)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
<?xml-stylesheet type='text/xsl' href='hello.xsl'?>  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">El parámetro <paramref name="target" /> o <paramref name="data" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="target" /> no sigue las restricciones de los nombres XML.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Data">
      <MemberSignature Language="C#" Value="public string Data { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Data" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XProcessingInstruction.Data" />
      <MemberSignature Language="VB.NET" Value="Public Property Data As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Data { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Data : string with get, set" Usage="System.Xml.Linq.XProcessingInstruction.Data" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece el valor de cadena de esta instrucción de procesamiento.</summary>
        <value>Un valor de tipo <see cref="T:System.String" /> que contiene el valor de cadena de esta instrucción de procesamiento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede utilizar esta propiedad para modificar un árbol XML. Esta propiedad hará que se producen eventos.  
  
   
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.Linq.XProcessingInstruction.Data%2A> propiedad para recuperar el valor de cadena de una instrucción de procesamiento.  
  
```csharp  
XProcessingInstruction pi =  
    new XProcessingInstruction("xml-stylesheet", "type='text/xsl' href='hello.xsl'");  
Console.WriteLine(pi.Data);  
pi.Data = "type='text/xsl' href='xform.xsl'";  
Console.WriteLine(pi.Data);  
```  
  
```vb  
Dim pi As XProcessingInstruction = <?xml-stylesheet type='text/xsl' href='hello.xsl'?>  
Console.WriteLine(pi.Data)  
pi.Data = "type='text/xsl' href='xform.xsl'"  
Console.WriteLine(pi.Data)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
type='text/xsl' href='hello.xsl'  
type='text/xsl' href='xform.xsl'  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La cadena <paramref name="value" /> no es <see langword="null" />.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public override System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XProcessingInstruction.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XProcessingInstruction.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de nodo de este nodo.</summary>
        <value>Tipo de nodo. Para los objetos <see cref="T:System.Xml.Linq.XProcessingInstruction" />, este valor es <see cref="F:System.Xml.XmlNodeType.ProcessingInstruction" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que todas las clases que derivan de <xref:System.Xml.Linq.XObject> contienen un <xref:System.Xml.Linq.XObject.NodeType%2A> propiedad, puede escribir código que opere en las colecciones de subclases concretas de <xref:System.Xml.Linq.XObject>. A continuación, puede probar el código para el tipo de nodo de cada nodo de la colección.  
  
   
  
## Examples  
 El ejemplo siguiente crea una instrucción de procesamiento y, a continuación, imprime su tipo de nodo.  
  
```csharp  
XProcessingInstruction pi =  
    new XProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"hello.xsl\"");  
Console.WriteLine(pi.NodeType);  
```  
  
```vb  
Dim pi As XProcessingInstruction = _  
    <?xml-stylesheet type="text/xsl" href="hello.xsl"?>  
Console.WriteLine(pi.NodeType.ToString)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
ProcessingInstruction  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public string Target { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Target" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XProcessingInstruction.Target" />
      <MemberSignature Language="VB.NET" Value="Public Property Target As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Target { System::String ^ get(); void set(System::String ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Target : string with get, set" Usage="System.Xml.Linq.XProcessingInstruction.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene o establece una cadena que contiene la aplicación de destino de esta instrucción de procesamiento.</summary>
        <value>Valor de tipo <see cref="T:System.String" /> que contiene la aplicación de destino de esta instrucción de procesamiento.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se usa el <xref:System.Xml.Linq.XProcessingInstruction.Target%2A> propiedad para recuperar la aplicación de destino de una instrucción de procesamiento.  
  
```csharp  
XProcessingInstruction pi =  
    new XProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"hello.xsl\"");  
Console.WriteLine(pi.Target);  
```  
  
```vb  
Dim pi As XProcessingInstruction = _  
    <?xml-stylesheet type="text/xsl" href="hello.xsl"?>  
Console.WriteLine(pi.Target)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
xml-stylesheet  
```  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">La cadena <paramref name="value" /> no es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">El parámetro <paramref name="target" /> no sigue las restricciones de los nombres XML.</exception>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="WriteTo">
      <MemberSignature Language="C#" Value="public override void WriteTo (System.Xml.XmlWriter writer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void WriteTo(class System.Xml.XmlWriter writer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XProcessingInstruction.WriteTo(System.Xml.XmlWriter)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub WriteTo (writer As XmlWriter)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void WriteTo(System::Xml::XmlWriter ^ writer);" />
      <MemberSignature Language="F#" Value="override this.WriteTo : System.Xml.XmlWriter -&gt; unit" Usage="xProcessingInstruction.WriteTo writer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" />
      </Parameters>
      <Docs>
        <param name="writer"><see cref="T:System.Xml.XmlWriter" /> en el que se va a escribir esta instrucción de procesamiento.</param>
        <summary>Escribe esta instrucción de procesamiento en un <see cref="T:System.Xml.XmlWriter" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método se usa principalmente por los métodos que escriben un árbol XML en un <xref:System.Xml.XmlWriter>.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="WriteToAsync">
      <MemberSignature Language="C#" Value="public override System.Threading.Tasks.Task WriteToAsync (System.Xml.XmlWriter writer, System.Threading.CancellationToken cancellationToken);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Threading.Tasks.Task WriteToAsync(class System.Xml.XmlWriter writer, valuetype System.Threading.CancellationToken cancellationToken) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XProcessingInstruction.WriteToAsync(System.Xml.XmlWriter,System.Threading.CancellationToken)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Threading::Tasks::Task ^ WriteToAsync(System::Xml::XmlWriter ^ writer, System::Threading::CancellationToken cancellationToken);" />
      <MemberSignature Language="F#" Value="override this.WriteToAsync : System.Xml.XmlWriter * System.Threading.CancellationToken -&gt; System.Threading.Tasks.Task" Usage="xProcessingInstruction.WriteToAsync (writer, cancellationToken)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="writer" Type="System.Xml.XmlWriter" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="cancellationToken" Type="System.Threading.CancellationToken" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="writer">To be added.</param>
        <param name="cancellationToken">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>