<Type Name="XObject" FullName="System.Xml.Linq.XObject">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5ff264a4b88ba2bc3e38576c7c42ba9803171539" /><Meta Name="ms.sourcegitcommit" Value="a3e01ec36374fac54a55add0dcc1e754e394abeb" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/30/2019" /><Meta Name="ms.locfileid" Value="58690709" /></Metadata><TypeSignature Language="C#" Value="public abstract class XObject : System.Xml.IXmlLineInfo" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit XObject extends System.Object implements class System.Xml.IXmlLineInfo" />
  <TypeSignature Language="DocId" Value="T:System.Xml.Linq.XObject" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class XObject&#xA;Implements IXmlLineInfo" />
  <TypeSignature Language="C++ CLI" Value="public ref class XObject abstract : System::Xml::IXmlLineInfo" />
  <TypeSignature Language="F#" Value="type XObject = class&#xA;    interface IXmlLineInfo" />
  <AssemblyInfo>
    <AssemblyName>System.Xml.XDocument</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Xml.Linq</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Xml.IXmlLineInfo</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Representa un nodo o un atributo en un árbol XML.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Esta clase es la clase base común abstracta para <xref:System.Xml.Linq.XNode> y <xref:System.Xml.Linq.XAttribute>. Proporciona cierta funcionalidad básica común a ambas clases, como las anotaciones y provoca eventos cuando han cambiado los nodos.  
  
 Tenga en cuenta que las anotaciones no forman parte del conjunto de información de XML, por lo que no se serializan o deserializan.  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
  </Docs>
  <Members>
    <Member MemberName="AddAnnotation">
      <MemberSignature Language="C#" Value="public void AddAnnotation (object annotation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddAnnotation(object annotation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.AddAnnotation(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddAnnotation (annotation As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddAnnotation(System::Object ^ annotation);" />
      <MemberSignature Language="F#" Value="member this.AddAnnotation : obj -&gt; unit" Usage="xObject.AddAnnotation annotation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="annotation" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="annotation">Objeto que contiene la anotación que se va a agregar.</param>
        <summary>Agrega un objeto a la lista de anotaciones de <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Tenga en cuenta que las anotaciones no forman parte del conjunto de información; no se conservan, o muestra <xref:System.Xml.Linq.XNode.ToString%2A>. Además, si importa un Namespace XML en el proyecto VB y llamar a AddAnnotation con el valor de enumeración SaveOptions.OmitDuplicateNamespaces, solo un elemento contendrá el atributo Namespace XML en lugar de todos los elementos. Para obtener más información, consulte [quitar espacios de nombres duplicados en los literales XML](https://devblogs.microsoft.com/vbteam/removing-duplicate-namespaces-in-xml-literals-shyam-namboodiripad/).  
  
   
  
## Examples  
 En el ejemplo siguiente se agrega una anotación a un <xref:System.Xml.Linq.XElement>.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
public class Program {  
    public static void Main(string[] args) {     
        MyAnnotation ma = new MyAnnotation("T1");  
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(ma);  
  
        MyAnnotation ma2 = (MyAnnotation)root.Annotation<MyAnnotation>();  
        Console.WriteLine(ma2.Tag);  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim ma As MyAnnotation = New MyAnnotation("T1")  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(ma)  
  
        Dim ma2 As MyAnnotation = DirectCast(root.Annotation(Of MyAnnotation)(), MyAnnotation)  
        Console.WriteLine(ma2.Tag)  
    End Sub  
  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
T1  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Annotation">
      <MemberSignature Language="C#" Value="public object Annotation (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Annotation(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.Annotation(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ Annotation(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.Annotation : Type -&gt; obj" Usage="xObject.Annotation type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de anotación que se va a recuperar.</param>
        <summary>Obtiene el primer objeto de anotación del tipo especificado de este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <returns>Valor <see cref="T:System.Object" /> que contiene el primer objeto de anotación que coincide con el tipo especificado o <see langword="null" /> si ninguna anotación es del tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se agrega una anotación a un <xref:System.Xml.Linq.XElement>. A continuación, recupera la anotación, especificando el tipo para recuperar.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
public class Program {  
    public static void Main(string[] args) {     
        MyAnnotation ma = new MyAnnotation("T1");  
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(ma);  
  
        MyAnnotation ma2 = (MyAnnotation)root.Annotation(typeof(MyAnnotation));  
        Console.WriteLine(ma2.Tag);  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim ma As MyAnnotation = New MyAnnotation("T1")  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(ma)  
  
        Dim ma2 As MyAnnotation = DirectCast(root.Annotation(GetType(MyAnnotation)), MyAnnotation)  
        Console.WriteLine(ma2.Tag)  
    End Sub  
  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
T1  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Annotation&lt;T&gt;">
      <MemberSignature Language="C#" Value="public T Annotation&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !!T Annotation&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.Annotation``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Annotation(Of T As Class) () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class T Annotation();" />
      <MemberSignature Language="F#" Value="member this.Annotation : unit -&gt; 'T (requires 'T : null)" Usage="xObject.Annotation " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo de anotación que se va a recuperar.</typeparam>
        <summary>Obtiene el primer objeto de anotación del tipo especificado de este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <returns>Primer objeto de anotación que coincide con el tipo especificado o <see langword="null" /> si ninguna anotación es del tipo especificado.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente agrega una anotación a un elemento y, a continuación, recupera a través de este método.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
public class Program {  
    public static void Main(string[] args) {     
        MyAnnotation ma = new MyAnnotation("T1");  
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(ma);  
  
        MyAnnotation ma2 = root.Annotation<MyAnnotation>();  
        Console.WriteLine(ma2.Tag);  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim ma As MyAnnotation = New MyAnnotation("T1")  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(ma)  
  
        Dim ma2 As MyAnnotation = root.Annotation(Of MyAnnotation)()  
        Console.WriteLine(ma2.Tag)  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
T1  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Annotations">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;object&gt; Annotations (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;object&gt; Annotations(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.Annotations(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::IEnumerable&lt;System::Object ^&gt; ^ Annotations(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.Annotations : Type -&gt; seq&lt;obj&gt;" Usage="xObject.Annotations type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de las anotaciones que se van a recuperar.</param>
        <summary>Obtiene una colección de anotaciones del tipo especificado para este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <returns>Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> de <see cref="T:System.Object" /> que contiene las anotaciones que coinciden con el tipo especificado para <see cref="T:System.Xml.Linq.XObject" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 En el ejemplo siguiente se agrega algunas anotaciones a un <xref:System.Xml.Linq.XElement>, a continuación, recupera una colección de anotaciones con este método.  
  
```csharp  
public class MyAnnotation  
{  
    private string tag;  
    public string Tag { get { return tag; } set { tag = value; } }  
    public MyAnnotation(string tag)  
    {  
        this.tag = tag;  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {  
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(new MyAnnotation("T1"));  
        root.AddAnnotation(new MyAnnotation("T2"));  
        root.AddAnnotation("abc");  
        root.AddAnnotation("def");  
  
        IEnumerable<object> annotationList;  
        annotationList = root.Annotations(typeof(MyAnnotation));  
        foreach (object ma in annotationList)  
            Console.WriteLine(((MyAnnotation)ma).Tag);  
        Console.WriteLine("----");  
  
        IEnumerable<object> stringAnnotationList;  
        stringAnnotationList = root.Annotations(typeof(string));  
        foreach (object str in stringAnnotationList)  
            Console.WriteLine((string)str);  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(New MyAnnotation("T1"))  
        root.AddAnnotation(New MyAnnotation("T2"))  
        root.AddAnnotation("abc")  
        root.AddAnnotation("def")  
  
        Dim annotationList As IEnumerable(Of Object)  
        annotationList = root.Annotations(GetType(MyAnnotation))  
        For Each ma As MyAnnotation In annotationList  
            Console.WriteLine(ma.Tag)  
        Next  
  
        Console.WriteLine("----")  
  
        Dim stringAnnotationList As IEnumerable(Of Object)  
        stringAnnotationList = root.Annotations(GetType(String))  
        For Each str As String In stringAnnotationList  
            Console.WriteLine(str)  
        Next  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
T1  
T2  
----  
abc  
def  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Annotations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;T&gt; Annotations&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Collections.Generic.IEnumerable`1&lt;!!T&gt; Annotations&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.Annotations``1" />
      <MemberSignature Language="VB.NET" Value="Public Function Annotations(Of T As Class) () As IEnumerable(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class System::Collections::Generic::IEnumerable&lt;T&gt; ^ Annotations();" />
      <MemberSignature Language="F#" Value="member this.Annotations : unit -&gt; seq&lt;'T (requires 'T : null)&gt; (requires 'T : null)" Usage="xObject.Annotations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XObject/&lt;Annotations&gt;d__2`1))</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Runtime.CompilerServices.IteratorStateMachine(typeof(System.Xml.Linq.XObject/&lt;Annotations&gt;d__16`1))</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;T&gt;</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo de las anotaciones que se van a recuperar.</typeparam>
        <summary>Obtiene una colección de anotaciones del tipo especificado para este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <returns>Interfaz <see cref="T:System.Collections.Generic.IEnumerable`1" /> que contiene las anotaciones de este <see cref="T:System.Xml.Linq.XObject" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente usa este método para recuperar las anotaciones en un elemento.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
class Program {  
    static void Main(string[] args) {     
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(new MyAnnotation("T1"));  
        root.AddAnnotation(new MyAnnotation("T2"));  
        root.AddAnnotation("abc");  
        root.AddAnnotation("def");  
  
        IEnumerable<MyAnnotation> annotationList;  
        annotationList = root.Annotations<MyAnnotation>();  
        foreach (MyAnnotation ma in annotationList)  
            Console.WriteLine(ma.Tag);  
        Console.WriteLine("----");  
  
        IEnumerable<string> stringAnnotationList;  
        stringAnnotationList = root.Annotations<string>();  
        foreach (string str in stringAnnotationList)  
            Console.WriteLine(str);  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(New MyAnnotation("T1"))  
        root.AddAnnotation(New MyAnnotation("T2"))  
        root.AddAnnotation("abc")  
        root.AddAnnotation("def")  
  
        Dim annotationList As IEnumerable(Of MyAnnotation)  
        annotationList = root.Annotations(Of MyAnnotation)()  
        For Each ma As MyAnnotation In annotationList  
            Console.WriteLine(ma.Tag)  
        Next  
        Console.WriteLine("----")  
  
        Dim stringAnnotationList As IEnumerable(Of String)  
        stringAnnotationList = root.Annotations(Of String)()  
        For Each str As String In stringAnnotationList  
            Console.WriteLine(str)  
        Next  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
T1  
T2  
----  
abc  
def  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="BaseUri">
      <MemberSignature Language="C#" Value="public string BaseUri { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseUri" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.BaseUri" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseUri As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseUri { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseUri : string" Usage="System.Xml.Linq.XObject.BaseUri" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el URI base de este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value><see cref="T:System.String" /> que contiene el URI base de este <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Con LINQ to XML, puede deserializar el XML en un número de moda. Puede analizar una cadena, cargarlo desde un archivo o leerlo desde una <xref:System.IO.TextReader> o <xref:System.Xml.XmlReader>. En todos estos casos, LINQ to XML utiliza una u otra de las subclases concretas de <xref:System.Xml.XmlReader>.  
  
 A veces el <xref:System.Xml.XmlReader> tiene el URI base y, a veces no. Por ejemplo, cuando se cargan desde un archivo, el <xref:System.Xml.XmlReader> conozca el identificador URI base, pero cuando se leen un <xref:System.Xml.XmlReader> que se creó debido a que realiza la llamada el <xref:System.Xml.Linq.XElement.Parse%2A> método, no hay ninguna posibilidad de que el <xref:System.Xml.XmlReader> informar de un URI base; el código XML se encontraba en un cadena.  
  
 Si, al analizar o cargar el archivo XML, especifica <xref:System.Xml.Linq.LoadOptions.SetBaseUri>, LINQ to XML solicitará el URI base para cada nodo como la <xref:System.Xml.XmlReader> devuelve el nodo. Si el lector tiene el URI base, LINQ to XML guardará la información con el nodo LINQ to XML. Esta propiedad devuelve esa información. Si subyacente <xref:System.Xml.XmlReader> no tiene el URI base, esta propiedad se devolverá una cadena vacía.  
  
 Establecer <xref:System.Xml.Linq.LoadOptions.SetBaseUri> cuando carga un árbol XML dará como resultado un análisis más lento.  
  
 Al establecer el URI base para un árbol XML, LINQ to XML coloca una anotación en la raíz del árbol. Esta propiedad es una propiedad calculada y navega por el árbol para encontrar el URI base.  
  
   
  
## Examples  
 El ejemplo siguiente carga la información de URI y línea base cuando se cargue el archivo. A continuación, imprime el URI base y la información de línea.  
  
 En este ejemplo se usa el siguiente documento XML: [Archivo XML de ejemplo: Pedido de compra común (LINQ to XML)](https://msdn.microsoft.com/library/0606c09f-6e43-4f8d-95c8-e8e2e08d2348).  
  
```csharp  
XElement po = XElement.Load("PurchaseOrder.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5),  
        ((IXmlLineInfo)e).LinePosition);  
```  
  
```vb  
Dim po As XElement = XElement.Load("PurchaseOrder.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
Dim splitUri() As String = po.BaseUri.Split("/"c)  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
        DirectCast(e, IXmlLineInfo).LinePosition)  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
BaseUri: PurchaseOrder.xml  
  
Element Name        Line Position  
------------        ---- --------  
PurchaseOrder       2    2  
  Address           3    4  
    Name            4    6  
    Street          5    6  
    City            6    6  
    State           7    6  
    Zip             8    6  
    Country         9    6  
  Address           11   4  
    Name            12   6  
    Street          13   6  
    City            14   6  
    State           15   6  
    Zip             16   6  
    Country         17   6  
  DeliveryNotes     19   4  
  Items             20   4  
    Item            21   6  
      ProductName   22   8  
      Quantity      23   8  
      USPrice       24   8  
      Comment       25   8  
    Item            27   6  
      ProductName   28   8  
      Quantity      29   8  
      USPrice       30   8  
      ShipDate      31   8  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Changed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; Changed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Xml.Linq.XObjectChangeEventArgs&gt; Changed" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Linq.XObject.Changed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changed As EventHandler(Of XObjectChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Xml::Linq::XObjectChangeEventArgs ^&gt; ^ Changed;" />
      <MemberSignature Language="F#" Value="member this.Changed : EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; " Usage="member this.Changed : System.EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se genera cuando este <see cref="T:System.Xml.Linq.XObject" /> o cualquiera de sus descendientes ha cambiado.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos se generan solo cuando se modifica un árbol XML, no cuando se construye. Esto es porque tiene que agregar un controlador de eventos a un evento antes de que puede recibir eventos y no se puede agregar un controlador de eventos antes de que tenga una referencia a un <xref:System.Xml.Linq.XObject>. No se puede obtener una referencia a un <xref:System.Xml.Linq.XObject> antes el XML se construye el árbol. Esto significa que durante la construcción funcional de un árbol XML, no recibirá los eventos.  
  
 Se debe tener cuidado al modificar un árbol XML en uno de estos eventos, porque al hacerlo podría provocar resultados inesperados. Por ejemplo, si recibe un <xref:System.Xml.Linq.XObject.Changing> eventos y mientras se procesa el evento quite el nodo del árbol, es posible que no reciba el <xref:System.Xml.Linq.XObject.Changed> eventos. Cuando se procesa un evento, es válido para modificar un árbol XML distinto a aquel que contiene el nodo que recibe el evento; es válido incluso para modificar el mismo árbol siempre las modificaciones no afectan a los nodos específicos en el que se generó el evento. Sin embargo, si modifica el área del árbol que contiene el nodo que recibe el evento, los eventos que reciba y el impacto en el árbol son indefinidos.  
  
   
  
## Examples  
 El ejemplo siguiente agrega un controlador de eventos para el elemento raíz de un árbol XML. A continuación, modifica el árbol, causando LINQ to XML para generar algunos eventos.  
  
```csharp  
XElement root = new XElement("Root", "content");  
root.Changing += new EventHandler<XObjectChangeEventArgs>(  
    (sender, cea) =>  
    {  
        Console.WriteLine("Changing event raised");  
        XElement xSender = (XElement)sender;  
        Console.WriteLine("  Sender: {0}", xSender.Name);  
        Console.WriteLine("  ObjectChange: {0}", cea.ObjectChange);  
    }  
);  
root.Changed += new EventHandler<XObjectChangeEventArgs>(  
    (sender, cea) =>  
    {  
        Console.WriteLine("Changed event raised");  
        XElement xSender = (XElement)sender;  
        Console.WriteLine("  Sender: {0}", xSender.Name);  
        Console.WriteLine("  ObjectChange: {0}", cea.ObjectChange);  
    }  
);  
root.Add(new XElement("Child", "child content"));  
```  
  
```vb  
Module Module1  
    WithEvents root As XElement = <Root>content</Root>  
  
    Sub Main()  
        root.Add(<Child>child content</Child>)  
    End Sub  
  
    Private Sub root_Changing( _  
            ByVal sender As Object, _  
            ByVal e As XObjectChangeEventArgs) _  
            Handles root.Changing  
        Dim xSender As XElement = DirectCast(sender, XElement)  
        Console.WriteLine("Changing event raised")  
        Console.WriteLine("  Sender: {0}", xSender.Name)  
        Console.WriteLine("  ObjectChange: {0}", e.ObjectChange)  
    End Sub  
  
    Private Sub root_Changed( _  
            ByVal sender As Object, _  
            ByVal e As XObjectChangeEventArgs) _  
            Handles root.Changed  
        Dim xSender As XElement = DirectCast(sender, XElement)  
        Console.WriteLine("Changed event raised")  
        Console.WriteLine("  Sender: {0}", xSender.Name)  
        Console.WriteLine("  ObjectChange: {0}", e.ObjectChange)  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
Changing event raised  
  Sender: Child  
  ObjectChange: Add  
Changed event raised  
  Sender: Child  
  ObjectChange: Add  
```  
  
 Los eventos resultan útiles cuando desea mantener cierta información de agregado en un árbol XML. Por ejemplo, quizá desee mantener el total de una factura que es la suma de los conceptos de la factura. Este ejemplo utiliza eventos para mantener el total de todos los elementos secundarios que se encuentran bajo el elemento complejo `Items`.  
  
```csharp  
XElement root = new XElement("Root",  
    new XElement("Total", 0),  
    new XElement("Items")  
);  
XElement total = root.Element("Total");  
XElement items = root.Element("Items");  
items.Changed += (object sender, XObjectChangeEventArgs cea) =>  
{  
    switch (cea.ObjectChange)  
    {  
        case XObjectChange.Add:  
            if (sender is XElement)  
                total.Value = ((int)total + (int)(XElement)sender).ToString();  
            if (sender is XText)  
                total.Value = ((int)total + (int)((XText)sender).Parent).ToString();  
            break;  
        case XObjectChange.Remove:  
            if (sender is XElement)  
                total.Value = ((int)total - (int)(XElement)sender).ToString();  
            if (sender is XText)  
                total.Value = ((int)total - Int32.Parse(((XText)sender).Value)).ToString();  
            break;  
    }  
    Console.WriteLine("Changed {0} {1}", sender.GetType().ToString(), cea.ObjectChange.ToString());  
};  
items.SetElementValue("Item1", 25);  
items.SetElementValue("Item2", 50);  
items.SetElementValue("Item2", 75);  
items.SetElementValue("Item3", 133);  
items.SetElementValue("Item1", null);  
items.SetElementValue("Item4", 100);  
Console.WriteLine("Total:{0}", (int)total);  
Console.WriteLine(root);  
```  
  
```vb  
Module Module1  
    Private total As XElement = Nothing  
    Private WithEvents items As XElement = Nothing  
    Private root As XElement = _  
            <Root>  
                <Total>0</Total>  
                <Items></Items>  
            </Root>  
  
    Sub Main()  
        total = root.<Total>(0)  
        items = root.<Items>(0)  
        items.SetElementValue("Item1", 25)  
        items.SetElementValue("Item2", 50)  
        items.SetElementValue("Item2", 75)  
        items.SetElementValue("Item3", 133)  
        items.SetElementValue("Item1", Nothing)  
        items.SetElementValue("Item4", 100)  
        Console.WriteLine("Total:{0}", CInt(total))  
        Console.WriteLine(root)  
    End Sub  
  
    Private Sub XObjectChanged( _  
            ByVal sender As Object, _  
            ByVal cea As XObjectChangeEventArgs) _  
            Handles items.Changed  
        Select Case cea.ObjectChange  
            Case XObjectChange.Add  
                If sender.GetType() Is GetType(XElement) Then  
                    total.Value = CStr(CInt(total.Value) + _  
                            CInt((DirectCast(sender, XElement)).Value))  
                End If  
                If sender.GetType() Is GetType(XText) Then  
                    total.Value = CStr(CInt(total.Value) + _  
                            CInt((DirectCast(sender, XText)).Value))  
                End If  
            Case XObjectChange.Remove  
                If sender.GetType() Is GetType(XElement) Then  
                    total.Value = CStr(CInt(total.Value) - _  
                            CInt((DirectCast(sender, XElement)).Value))  
                End If  
                If sender.GetType() Is GetType(XText) Then  
                    total.Value = CStr(CInt(total.Value) - _  
                            CInt((DirectCast(sender, XText)).Value))  
                End If  
        End Select  
        Console.WriteLine("Changed {0} {1}", _  
                            sender.GetType().ToString(), _  
                            cea.ObjectChange.ToString())  
    End Sub  
End Module  
```  
  
 Este código genera el siguiente resultado:  
  
```  
Changed System.Xml.Linq.XElement Add  
Changed System.Xml.Linq.XElement Add  
Changed System.Xml.Linq.XText Remove  
Changed System.Xml.Linq.XText Add  
Changed System.Xml.Linq.XElement Add  
Changed System.Xml.Linq.XElement Remove  
Changed System.Xml.Linq.XElement Add  
Total:308  
<Root>  
  <Total>308</Total>  
  <Items>  
    <Item2>75</Item2>  
    <Item3>133</Item3>  
    <Item4>100</Item4>  
  </Items>  
</Root>  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Changing">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; Changing;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Xml.Linq.XObjectChangeEventArgs&gt; Changing" />
      <MemberSignature Language="DocId" Value="E:System.Xml.Linq.XObject.Changing" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Changing As EventHandler(Of XObjectChangeEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Xml::Linq::XObjectChangeEventArgs ^&gt; ^ Changing;" />
      <MemberSignature Language="F#" Value="member this.Changing : EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; " Usage="member this.Changing : System.EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Xml.Linq.XObjectChangeEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Se genera cuando este <see cref="T:System.Xml.Linq.XObject" /> o cualquiera de sus descendientes está a punto de cambiar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Los eventos se generan solo de la modificación de un árbol XML, no de la construcción de un árbol XML. Tiene que agregar un controlador de eventos a un evento antes de que puede recibir eventos y no se puede agregar un controlador de eventos antes de que tenga una referencia a un <xref:System.Xml.Linq.XObject>. No se puede obtener una referencia a un <xref:System.Xml.Linq.XObject> antes el XML se construye el árbol. Esto significa que durante la construcción funcional de un árbol XML, no recibirá los eventos.  
  
 Se debe tener cuidado al modificar un árbol XML en uno de estos eventos, porque al hacerlo podría provocar resultados inesperados. Por ejemplo, si recibe un <xref:System.Xml.Linq.XObject.Changing> eventos y mientras se procesa el evento quite el nodo del árbol, es posible que no reciba el <xref:System.Xml.Linq.XObject.Changed> eventos. Cuando se procesa un evento, es válido para modificar un árbol XML distinto a aquel que contiene el nodo que recibe el evento; es válido incluso para modificar el mismo árbol siempre las modificaciones no afectan a los nodos específicos en el que se generó el evento. Sin embargo, si modifica el área del árbol que contiene el nodo que recibe el evento, los eventos que reciba y el impacto en el árbol son indefinidos.  
  
   
  
## Examples  
 El ejemplo siguiente agrega un controlador de eventos para el elemento raíz de un árbol XML. A continuación, modifica el árbol, causando LINQ to XML para generar algunos eventos.  
  
```csharp  
XElement root = new XElement("Root", "content");  
root.Changing += new EventHandler<XObjectChangeEventArgs>(  
    (sender, cea) =>  
    {  
        Console.WriteLine("Changing event raised");  
        XElement xSender = (XElement)sender;  
        Console.WriteLine("  Sender: {0}", xSender.Name);  
        Console.WriteLine("  ObjectChange: {0}", cea.ObjectChange);  
    }  
);  
root.Changed += new EventHandler<XObjectChangeEventArgs>(  
    (sender, cea) =>  
    {  
        Console.WriteLine("Changed event raised");  
        XElement xSender = (XElement)sender;  
        Console.WriteLine("  Sender: {0}", xSender.Name);  
        Console.WriteLine("  ObjectChange: {0}", cea.ObjectChange);  
    }  
);  
root.Add(new XElement("Child", "child content"));  
```  
  
```vb  
Module Module1  
    WithEvents root As XElement = <Root>content</Root>  
  
    Sub Main()  
        root.Add(<Child>child content</Child>)  
    End Sub  
  
    Private Sub root_Changing( _  
            ByVal sender As Object, _  
            ByVal e As XObjectChangeEventArgs) _  
            Handles root.Changing  
        Dim xSender As XElement = CType(sender, XElement)  
        Console.WriteLine("Changing event raised")  
        Console.WriteLine("  Sender: {0}", xSender.Name)  
        Console.WriteLine("  ObjectChange: {0}", e.ObjectChange)  
    End Sub  
  
    Private Sub root_Changed( _  
            ByVal sender As Object, _  
            ByVal e As XObjectChangeEventArgs) _  
            Handles root.Changed  
        Dim xSender As XElement = CType(sender, XElement)  
        Console.WriteLine("Changed event raised")  
        Console.WriteLine("  Sender: {0}", xSender.Name)  
        Console.WriteLine("  ObjectChange: {0}", e.ObjectChange)  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
Changing event raised  
  Sender: Child  
  ObjectChange: Add  
Changed event raised  
  Sender: Child  
  ObjectChange: Add  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Document">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XDocument Document { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XDocument Document" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.Document" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Document As XDocument" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XDocument ^ Document { System::Xml::Linq::XDocument ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Document : System.Xml.Linq.XDocument" Usage="System.Xml.Linq.XObject.Document" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XDocument</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el objeto <see cref="T:System.Xml.Linq.XDocument" /> para este objeto <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value><see cref="T:System.Xml.Linq.XDocument" /> para <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea un documento con algún contenido complejo. A continuación, utiliza esta propiedad para recuperar el documento para el `Child` elemento.  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("A comment in the document."),  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
XElement child = doc.Descendants("Child").First();  
XDocument documentOfChild = child.Document;  
Console.WriteLine(documentOfChild.FirstNode);  
```  
  
```vb  
Dim doc As XDocument = _  
        <?xml version="1.0"?>  
        <!--A comment in the document.-->  
        <Root>  
            <Child>content</Child>  
         </Root>  
Dim child As XElement = doc.Descendants("Child").First()  
Dim documentOfChild As XDocument = child.Document  
Console.WriteLine(documentOfChild.FirstNode)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
<!--A comment in the document.-->  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="NodeType">
      <MemberSignature Language="C#" Value="public abstract System.Xml.XmlNodeType NodeType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Xml.XmlNodeType NodeType" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.NodeType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property NodeType As XmlNodeType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Xml::XmlNodeType NodeType { System::Xml::XmlNodeType get(); };" />
      <MemberSignature Language="F#" Value="member this.NodeType : System.Xml.XmlNodeType" Usage="System.Xml.Linq.XObject.NodeType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.XmlNodeType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el tipo de nodo de este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value>El tipo de nodo de este <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dado que todas las clases que derivan de <xref:System.Xml.Linq.XObject> contienen un <xref:System.Xml.Linq.XObject.NodeType%2A> propiedad, puede escribir código que opere en las colecciones de subclases concretas de <xref:System.Xml.Linq.XObject>. A continuación, puede probar el código para el tipo de nodo de cada nodo de la colección.  
  
   
  
## Examples  
 El ejemplo siguiente usa este método para recuperar el tipo de nodo para una variedad de nodos.  
  
```csharp  
// Note that XNode uses XmlNodeType, which is in the System.Xml namespace.  
XDocument xmlTree = new XDocument(  
    new XComment("a comment"),  
    new XProcessingInstruction("xml-stylesheet", "type=\"text/xsl\" href=\"hello.xsl\""),  
    new XElement("Root",  
        new XAttribute("Att", "attContent"),  
        new XElement("Child1",  
            new XCData("CDATA content")  
        ),  
        new XElement("Child2",  
            new XText("Text content")  
        )  
    )  
);  
  
foreach (XNode node in xmlTree.DescendantNodes())  
{  
    Console.WriteLine(node.NodeType);  
    if (node.NodeType == XmlNodeType.Element)  
    {  
        foreach (XAttribute att in ((XElement)node).Attributes())  
            Console.WriteLine(att.NodeType);  
    }  
}  
```  
  
```vb  
' Note that XNode uses XmlNodeType, which is in the System.Xml  namespace.  
Dim xmlTree As XDocument = _   
    <?xml version="1.0"?>  
    <!--a comment-->  
    <?xml-stylesheet type="text/xsl" href="hello.xsl"?>  
    <Root Att="attContent">  
        <Child1><![CDATA[CDATA content]]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="Parent">
      <MemberSignature Language="C#" Value="public System.Xml.Linq.XElement Parent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Xml.Linq.XElement Parent" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.Parent" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Parent As XElement" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Xml::Linq::XElement ^ Parent { System::Xml::Linq::XElement ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Parent : System.Xml.Linq.XElement" Usage="System.Xml.Linq.XObject.Parent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Xml.Linq.XElement</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el <see cref="T:System.Xml.Linq.XElement" /> primario de <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value><see cref="T:System.Xml.Linq.XElement" /> primario de este <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Si este <xref:System.Xml.Linq.XObject> no tiene ningún elemento primario, esta propiedad devuelve `null`.  
  
> [!NOTE]
>  Esta propiedad devuelve el elemento primario y como nodos secundarios de un <xref:System.Xml.Linq.XDocument> no tener ningún elemento primario, esta propiedad devuelve `null` para ellos.  
  
   
  
## Examples  
 El ejemplo siguiente usa este método.  
  
```csharp  
XDocument doc = new XDocument(  
    new XComment("A comment in the document."),  
    new XElement("Root",  
        new XElement("Child", "content")  
    )  
);  
XElement child = doc.Descendants("Child").First();  
XElement root = child.Parent;  
Console.WriteLine(root.Name);  
```  
  
```vb  
Dim doc As XDocument = _   
    <?xml version="1.0"?>  
    <!--A comment in the document.-->  
    <Root>  
        <Child>content</Child>  
    </Root>  
Dim child As XElement = doc.Descendants("Child").First()  
Dim root As XElement = child.Parent  
Console.WriteLine(root.Name)  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
Root  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAnnotations">
      <MemberSignature Language="C#" Value="public void RemoveAnnotations (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAnnotations(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.RemoveAnnotations(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void RemoveAnnotations(Type ^ type);" />
      <MemberSignature Language="F#" Value="member this.RemoveAnnotations : Type -&gt; unit" Usage="xObject.RemoveAnnotations type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type">Tipo de las anotaciones que se van a quitar.</param>
        <summary>Quita las anotaciones del tipo especificado de <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea un elemento con cuatro anotaciones. A continuación, se usa este método para quitar dos de ellos.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
class Program  
{  
    static void Main(string[] args)  
    {     
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(new MyAnnotation("T1"));  
        root.AddAnnotation(new MyAnnotation("T2"));  
        root.AddAnnotation("abc");  
        root.AddAnnotation("def");  
  
        Console.WriteLine("Count before removing: {0}", root.Annotations<object>().Count());  
        root.RemoveAnnotations(typeof(MyAnnotation));  
        Console.WriteLine("Count after removing: {0}", root.Annotations<object>().Count());  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(New MyAnnotation("T1"))  
        root.AddAnnotation(New MyAnnotation("T2"))  
        root.AddAnnotation("abc")  
        root.AddAnnotation("def")  
  
        Console.WriteLine("Count before removing: {0}", root.Annotations(Of Object)().Count())  
        root.RemoveAnnotations(GetType(MyAnnotation))  
        Console.WriteLine("Count after removing: {0}", root.Annotations(Of Object)().Count())  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
Count before removing: 4  
Count after removing: 2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="RemoveAnnotations&lt;T&gt;">
      <MemberSignature Language="C#" Value="public void RemoveAnnotations&lt;T&gt; () where T : class;" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void RemoveAnnotations&lt;class T&gt;() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.RemoveAnnotations``1" />
      <MemberSignature Language="VB.NET" Value="Public Sub RemoveAnnotations(Of T As Class) ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA;generic &lt;typename T&gt;&#xA; where T : class void RemoveAnnotations();" />
      <MemberSignature Language="F#" Value="member this.RemoveAnnotations : unit -&gt; unit (requires 'T : null)" Usage="xObject.RemoveAnnotations " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <TypeParameters>
        <TypeParameter Name="T">
          <Constraints>
            <ParameterAttribute>ReferenceTypeConstraint</ParameterAttribute>
          </Constraints>
        </TypeParameter>
      </TypeParameters>
      <Parameters />
      <Docs>
        <typeparam name="T">Tipo de las anotaciones que se van a quitar.</typeparam>
        <summary>Quita las anotaciones del tipo especificado de <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 El ejemplo siguiente crea un elemento con cuatro anotaciones. A continuación, se usa este método para quitar dos de ellos.  
  
```csharp  
public class MyAnnotation {  
    private string tag;  
    public string Tag {get{return tag;} set{tag=value;}}  
    public MyAnnotation(string tag) {  
        this.tag = tag;  
    }  
}  
  
class Program {  
    static void Main(string[] args) {     
        XElement root = new XElement("Root", "content");  
        root.AddAnnotation(new MyAnnotation("T1"));  
        root.AddAnnotation(new MyAnnotation("T2"));  
        root.AddAnnotation("abc");  
        root.AddAnnotation("def");  
  
        Console.WriteLine("Count before removing: {0}", root.Annotations<object>().Count());  
        root.RemoveAnnotations<MyAnnotation>();  
        Console.WriteLine("Count after removing: {0}", root.Annotations<object>().Count());  
    }  
}  
```  
  
```vb  
Public Class MyAnnotation  
    Private _tag As String  
  
    Property Tag() As String  
        Get  
            Return Me._tag  
        End Get  
        Set(ByVal Value As String)  
            Me._tag = Value  
        End Set  
    End Property  
  
    Public Sub New(ByVal tag As String)  
        Me._tag = tag  
    End Sub  
End Class  
  
Module Module1  
    Sub Main()  
        Dim root As XElement = <Root>content</Root>  
        root.AddAnnotation(New MyAnnotation("T1"))  
        root.AddAnnotation(New MyAnnotation("T2"))  
        root.AddAnnotation("abc")  
        root.AddAnnotation("def")  
  
        Console.WriteLine("Count before removing: {0}", root.Annotations(Of Object)().Count())  
        root.RemoveAnnotations(Of MyAnnotation)()  
        Console.WriteLine("Count after removing: {0}", root.Annotations(Of Object)().Count())  
    End Sub  
End Module  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
Count before removing: 4  
Count after removing: 2  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlLineInfo.HasLineInfo">
      <MemberSignature Language="C#" Value="bool IXmlLineInfo.HasLineInfo ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.Xml.IXmlLineInfo.HasLineInfo() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#HasLineInfo" />
      <MemberSignature Language="VB.NET" Value="Function HasLineInfo () As Boolean Implements IXmlLineInfo.HasLineInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.Xml.IXmlLineInfo.HasLineInfo() = System::Xml::IXmlLineInfo::HasLineInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Xml.IXmlLineInfo.HasLineInfo</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Obtiene un valor que indica si <see cref="T:System.Xml.Linq.XObject" /> tiene información de línea o no.</summary>
        <returns><see langword="true" /> si el <see cref="T:System.Xml.Linq.XObject" /> tiene información de línea, de lo contrario <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Puede llamar a este método para determinar si el <xref:System.Xml.Linq.XObject> contiene información de línea válido.  
  
 Este método es una implementación de miembro de interfaz explícita de un método en el <xref:System.Xml.IXmlLineInfo> interfaz, por lo que para poder llamar a este método, es necesario convertir a <xref:System.Xml.IXmlLineInfo>.  
  
   
  
## Examples  
 Este ejemplo carga un árbol XML pequeño desde un archivo de configuración de las opciones para establecer el URI base y conservar la información de línea. A continuación, agrega otro elemento que no tiene información de línea. A continuación, imprime la información de línea para cada elemento en el árbol.  
  
```csharp  
string markup = @"<Root>  
    <Child1 />  
    <Child2 />  
    <Child4 />  
</Root>";  
  
File.WriteAllText("Test.xml", markup);  
  
XElement po = XElement.Load("Test.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
  
// add a node to the tree.  
// the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(new XElement("Child3"));  
  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5) :  
            "",  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LinePosition.ToString() :  
            "No Line Information");  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child1 />" & Environment.NewLine & _  
    "    <Child2 />" & Environment.NewLine & _  
    "    <Child4 />" & Environment.NewLine & _  
    "</Root>"  
  
File.WriteAllText("Test.xml", markup)  
  
Dim po As XElement = XElement.Load("Test.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
  
' add a node to the tree.  
' the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(New XElement("Child3"))  
  
Dim splitUri() As String = po.BaseUri.Split("/"c)  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
            ""), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LinePosition.ToString(), _  
            "No Line Information"))  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
BaseUri: Test.xml  
  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child1            2    6  
  Child2            3    6  
  Child3            No Line Information  
  Child4            4    6  
```  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlLineInfo.LineNumber">
      <MemberSignature Language="C#" Value="int System.Xml.IXmlLineInfo.LineNumber { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Xml.IXmlLineInfo.LineNumber" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LineNumber" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property LineNumber As Integer Implements IXmlLineInfo.LineNumber" />
      <MemberSignature Language="C++ CLI" Value="property int System::Xml::IXmlLineInfo::LineNumber { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Xml.IXmlLineInfo.LineNumber" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LineNumber</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el número de línea del que el <see cref="T:System.Xml.XmlReader" /> subyacente informó para este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value><see cref="T:System.Int32" /> que contiene el número de línea del que el <see cref="T:System.Xml.XmlReader" /> informó para este <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una implementación de miembro de interfaz explícita de un método en el <xref:System.Xml.IXmlLineInfo> interfaz, por lo que para poder llamar a este método, es necesario convertir a <xref:System.Xml.IXmlLineInfo>.  
  
   
  
## Examples  
 Este ejemplo carga un árbol XML pequeño desde un archivo de configuración de las opciones para establecer el URI base y conservar la información de línea. A continuación, agrega otro elemento que no tiene información de línea. A continuación, imprime la información de línea para cada elemento en el árbol.  
  
```csharp  
string markup = @"<Root>  
    <Child1 />  
    <Child2 />  
    <Child4 />  
</Root>";  
  
File.WriteAllText("Test.xml", markup);  
  
XElement po = XElement.Load("Test.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
  
// add a node to the tree.  
// the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(new XElement("Child3"));  
  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5) :  
            "",  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LinePosition.ToString() :  
            "No Line Information");  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child1 />" & Environment.NewLine & _  
    "    <Child2 />" & Environment.NewLine & _  
    "    <Child4 />" & Environment.NewLine & _  
    "</Root>"  
  
File.WriteAllText("Test.xml", markup)  
  
Dim po As XElement = XElement.Load("Test.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
  
' add a node to the tree.  
' the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(New XElement("Child3"))  
  
Dim splitUri() As String = po.BaseUri.Split("/"c)  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
            ""), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LinePosition.ToString(), _  
            "No Line Information"))  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
BaseUri: Test.xml  
  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child1            2    6  
  Child2            3    6  
  Child3            No Line Information  
  Child4            4    6  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
    <Member MemberName="System.Xml.IXmlLineInfo.LinePosition">
      <MemberSignature Language="C#" Value="int System.Xml.IXmlLineInfo.LinePosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 System.Xml.IXmlLineInfo.LinePosition" />
      <MemberSignature Language="DocId" Value="P:System.Xml.Linq.XObject.System#Xml#IXmlLineInfo#LinePosition" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property LinePosition As Integer Implements IXmlLineInfo.LinePosition" />
      <MemberSignature Language="C++ CLI" Value="property int System::Xml::IXmlLineInfo::LinePosition { int get(); };" />
      <MemberSignature Language="F#" Usage="System.Xml.IXmlLineInfo.LinePosition" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Xml.IXmlLineInfo.LinePosition</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Xml.XDocument</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Xml.Linq</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la posición de línea de la que el <see cref="T:System.Xml.XmlReader" /> subyacente informó para este <see cref="T:System.Xml.Linq.XObject" />.</summary>
        <value><see cref="T:System.Int32" /> que contiene la posición de línea de la que <see cref="T:System.Xml.XmlReader" /> informó para este <see cref="T:System.Xml.Linq.XObject" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Este método es una implementación de miembro de interfaz explícita de un método en el <xref:System.Xml.IXmlLineInfo> interfaz, por lo que para poder llamar a este método, es necesario convertir a <xref:System.Xml.IXmlLineInfo>.  
  
   
  
## Examples  
 Este ejemplo carga un árbol XML pequeño desde un archivo de configuración de las opciones para establecer el URI base y conservar la información de línea. A continuación, agrega otro elemento que no tiene información de línea. A continuación, imprime la información de línea para cada elemento en el árbol.  
  
```csharp  
string markup = @"<Root>  
    <Child1 />  
    <Child2 />  
    <Child4 />  
</Root>";  
  
File.WriteAllText("Test.xml", markup);  
  
XElement po = XElement.Load("Test.xml",  
    LoadOptions.SetBaseUri | LoadOptions.SetLineInfo);  
  
// add a node to the tree.  
// the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(new XElement("Child3"));  
  
string[] splitUri = po.BaseUri.Split('/');  
Console.WriteLine("BaseUri: {0}", splitUri[splitUri.Length - 1]);  
Console.WriteLine();  
Console.WriteLine("{0}{1}{2}",  
    "Element Name".PadRight(20),  
    "Line".PadRight(5),  
    "Position");  
Console.WriteLine("{0}{1}{2}",  
    "------------".PadRight(20),  
    "----".PadRight(5),  
    "--------");  
foreach (XElement e in po.DescendantsAndSelf())  
    Console.WriteLine("{0}{1}{2}",  
        ("".PadRight(e.Ancestors().Count() * 2) + e.Name).PadRight(20),  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LineNumber.ToString().PadRight(5) :  
            "",  
        ((IXmlLineInfo)e).HasLineInfo() ?  
            ((IXmlLineInfo)e).LinePosition.ToString() :  
            "No Line Information");  
```  
  
```vb  
Dim markup As String = _  
    "<Root>" & Environment.NewLine & _  
    "    <Child1 />" & Environment.NewLine & _  
    "    <Child2 />" & Environment.NewLine & _  
    "    <Child4 />" & Environment.NewLine & _  
    "</Root>"  
  
File.WriteAllText("Test.xml", markup)  
  
Dim po As XElement = XElement.Load("Test.xml", LoadOptions.SetBaseUri Or LoadOptions.SetLineInfo)  
  
' add a node to the tree.  
' the newly added node will not have line information.  
po.Element("Child2").AddAfterSelf(New XElement("Child3"))  
  
Dim splitUri() As String = po.BaseUri.Split("/"c)  
Console.WriteLine("BaseUri: {0}", splitUri(splitUri.Length - 1))  
Console.WriteLine()  
Console.WriteLine("{0}{1}{2}", _  
    "Element Name".PadRight(20), _  
    "Line".PadRight(5), _  
    "Position")  
Console.WriteLine("{0}{1}{2}", _  
    "------------".PadRight(20), _  
    "----".PadRight(5), _  
    "--------")  
For Each e As XElement In po.DescendantsAndSelf()  
    Console.WriteLine("{0}{1}{2}", _  
        ("".PadRight(e.Ancestors().Count() * 2) & e.Name.ToString).PadRight(20), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LineNumber.ToString().PadRight(5), _  
            ""), _  
        IIf(DirectCast(e, IXmlLineInfo).HasLineInfo(), _  
            DirectCast(e, IXmlLineInfo).LinePosition.ToString(), _  
            "No Line Information"))  
Next  
```  
  
 Este ejemplo produce el siguiente resultado:  
  
```  
BaseUri: Test.xml  
  
Element Name        Line Position  
------------        ---- --------  
Root                1    2  
  Child1            2    6  
  Child2            3    6  
  Child3            No Line Information  
  Child4            4    6  
```  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/f0fe21e9-ee43-4a55-b91a-0800e5782c13">LINQ to XML</related>
      </Docs>
    </Member>
  </Members>
</Type>