<Type Name="AssemblyLoadContext" FullName="System.Runtime.Loader.AssemblyLoadContext">
  <Metadata><Meta Name="ms.openlocfilehash" Value="1fe12898361e808786693310aaf210145e2d3f9a" /><Meta Name="ms.sourcegitcommit" Value="9a6da88bd5455e8274257ca7ad259b42f1de114f" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="05/22/2019" /><Meta Name="ms.locfileid" Value="66007903" /></Metadata><TypeSignature Language="C#" Value="public abstract class AssemblyLoadContext" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit AssemblyLoadContext extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Loader.AssemblyLoadContext" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class AssemblyLoadContext" />
  <TypeSignature Language="C++ CLI" Value="public ref class AssemblyLoadContext abstract" />
  <TypeSignature Language="F#" Value="type AssemblyLoadContext = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Loader</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.2.0</AssemblyVersion>
    <AssemblyVersion>4.0.3.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary><span data-ttu-id="a4444-101">Representa el concepto del tiempo de ejecución de un ámbito de enlace.</span><span class="sxs-lookup"><span data-stu-id="a4444-101">Represents the runtime's concept of a scope for binding.</span></span> <span data-ttu-id="a4444-102">Esta clase es abstracta.</span><span class="sxs-lookup"><span data-stu-id="a4444-102">This class is abstract.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="a4444-103">El <xref:System.Runtime.Loader.AssemblyLoadContext> representa un contexto de carga.</span><span class="sxs-lookup"><span data-stu-id="a4444-103">The <xref:System.Runtime.Loader.AssemblyLoadContext> represents a load context.</span></span> <span data-ttu-id="a4444-104">Conceptualmente, un contexto de carga crea un ámbito para cargar, resolución y potencialmente descarga un conjunto de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="a4444-104">Conceptually, a load context creates a scope for loading, resolving, and potentially unloading a set of assemblies.</span></span>
 
 <span data-ttu-id="a4444-105"><xref:System.Runtime.Loader.AssemblyLoadContext> es una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="a4444-105"><xref:System.Runtime.Loader.AssemblyLoadContext> is an abstract class.</span></span> <span data-ttu-id="a4444-106">El <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> debe implementarse para crear una clase concreta.</span><span class="sxs-lookup"><span data-stu-id="a4444-106">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> needs to be implemented to create a concrete class.</span></span>
 
 <span data-ttu-id="a4444-107">El <xref:System.Runtime.Loader.AssemblyLoadContext> existe principalmente para proporcionar aislamiento de enlaces de ensamblados.</span><span class="sxs-lookup"><span data-stu-id="a4444-107">The <xref:System.Runtime.Loader.AssemblyLoadContext> exists primarily to provide assembly binding isolation.</span></span> <span data-ttu-id="a4444-108">Permite que varias versiones del mismo ensamblado que se carguen en un único proceso.</span><span class="sxs-lookup"><span data-stu-id="a4444-108">It allows multiple versions of the same assembly to be loaded within a single process.</span></span> <span data-ttu-id="a4444-109">Reemplaza los mecanismos de aislamiento proporcionados por varios <xref:System.AppDomain> instancias en .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="a4444-109">It replaces the isolation mechanisms provided by multiple <xref:System.AppDomain> instances in the .NET Framework.</span></span>
 
 > [!NOTE]
 > <span data-ttu-id="a4444-110"><xref:System.Runtime.Loader.AssemblyLoadContext> no proporciona ninguna característica de seguridad.</span><span class="sxs-lookup"><span data-stu-id="a4444-110"><xref:System.Runtime.Loader.AssemblyLoadContext> does not provide any security features.</span></span> <span data-ttu-id="a4444-111">Todo el código tiene permisos totales del proceso.</span><span class="sxs-lookup"><span data-stu-id="a4444-111">All code has full permissions of the process.</span></span>

### <a name="usage-in-the-runtime"></a><span data-ttu-id="a4444-112">Uso en el tiempo de ejecución</span><span class="sxs-lookup"><span data-stu-id="a4444-112">Usage in the runtime</span></span>
 <span data-ttu-id="a4444-113">El tiempo de ejecución implementa dos contextos de carga de ensamblado:</span><span class="sxs-lookup"><span data-stu-id="a4444-113">The runtime implements two assembly load contexts:</span></span>
 * <span data-ttu-id="a4444-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> representa el contexto de enlace predeterminada del tiempo de ejecución que se usa para el ensamblado principal de la aplicación y sus dependencias estáticos.</span><span class="sxs-lookup"><span data-stu-id="a4444-114"><xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> represents the runtime's default binding context which is used for the application main assembly and its static dependencies.</span></span>
 * <span data-ttu-id="a4444-115">El <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> método aísla los ensamblados que carga creando más básica <xref:System.Runtime.Loader.AssemblyLoadContext>.</span><span class="sxs-lookup"><span data-stu-id="a4444-115">The <xref:System.Reflection.Assembly.LoadFile(System.String)?displayProperty=nameWithType> method isolates the assemblies it loads by instantiating the most basic <xref:System.Runtime.Loader.AssemblyLoadContext>.</span></span> <span data-ttu-id="a4444-116">Tiene un esquema de aislamiento simplista que carga cada ensamblado en su propio <xref:System.Runtime.Loader.AssemblyLoadContext> con ninguna resolución de dependencia.</span><span class="sxs-lookup"><span data-stu-id="a4444-116">It has a simplistic isolation scheme which loads each assembly in its own <xref:System.Runtime.Loader.AssemblyLoadContext> with no dependency resolution.</span></span>
 
### <a name="application-usage"></a><span data-ttu-id="a4444-117">Uso de la aplicación</span><span class="sxs-lookup"><span data-stu-id="a4444-117">Application usage</span></span>
 <span data-ttu-id="a4444-118">Una aplicación puede crear su propio <xref:System.Runtime.Loader.AssemblyLoadContext> para crear una solución personalizada para escenarios de enlace avanzada.</span><span class="sxs-lookup"><span data-stu-id="a4444-118">An application can create its own <xref:System.Runtime.Loader.AssemblyLoadContext> to create a custom solution for advanced binding scenarios.</span></span> <span data-ttu-id="a4444-119">La personalización se centra en la definición de los mecanismos de resolución de dependencia.</span><span class="sxs-lookup"><span data-stu-id="a4444-119">The customization focuses on defining dependency resolution mechanisms.</span></span>
 
 <span data-ttu-id="a4444-120">El <xref:System.Runtime.Loader.AssemblyLoadContext> proporciona dos puntos de extensión para implementar la resolución de ensamblado administrado:</span><span class="sxs-lookup"><span data-stu-id="a4444-120">The <xref:System.Runtime.Loader.AssemblyLoadContext> provides two extension points to implement managed assembly resolution:</span></span>
 1. <span data-ttu-id="a4444-121">El <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> proporciona la primera instancia posible para el <xref:System.Runtime.Loader.AssemblyLoadContext> para resolver el ensamblado, cargarlo y devolverlo.</span><span class="sxs-lookup"><span data-stu-id="a4444-121">The <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> provides the first chance for the <xref:System.Runtime.Loader.AssemblyLoadContext> to resolve the assembly, load it and return it.</span></span> <span data-ttu-id="a4444-122">Si el <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> devuelve `null`, el cargador intentará cargar el ensamblado en el <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="a4444-122">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> returns `null`, the loader will try to load the assembly into the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType>.</span></span>
 2. <span data-ttu-id="a4444-123">Si el <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> no puede resolver el ensamblado, el original <xref:System.Runtime.Loader.AssemblyLoadContext> Obtiene una segunda oportunidad para resolver el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-123">If the <xref:System.Runtime.Loader.AssemblyLoadContext.Default?displayProperty=nameWithType> is unable to resolve the assembly, the original <xref:System.Runtime.Loader.AssemblyLoadContext> gets a second chance to resolve the assembly.</span></span> <span data-ttu-id="a4444-124">El tiempo de ejecución genera el <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> eventos.</span><span class="sxs-lookup"><span data-stu-id="a4444-124">The runtime raises the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.</span></span>
 
 <span data-ttu-id="a4444-125">Además el <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> método virtual permite la personalización de la resolución de ensamblado no administrado predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a4444-125">Additionally the <xref:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)?displayProperty=nameWithType> virtual method allows customization of the default unmanaged assembly resolution.</span></span> <span data-ttu-id="a4444-126">La implementación predeterminada devuelve `null`, lo que hace que la búsqueda en tiempo de ejecución usar su directiva de búsqueda predeterminado que es suficiente para la mayoría de los escenarios.</span><span class="sxs-lookup"><span data-stu-id="a4444-126">The default implementation returns `null`, which causes the runtime search to use its default search policy which is sufficient for most scenarios.</span></span>

### <a name="technical-challenges"></a><span data-ttu-id="a4444-127">Desafíos técnicos</span><span class="sxs-lookup"><span data-stu-id="a4444-127">Technical challenges</span></span>
 * <span data-ttu-id="a4444-128">No es posible cargar varias versiones del tiempo de ejecución en un único proceso.</span><span class="sxs-lookup"><span data-stu-id="a4444-128">It is not possible to load multiple versions of the runtime in a single process.</span></span>
     > [!CAUTION]
     > <span data-ttu-id="a4444-129">Cargando varias copias o versiones diferentes de los ensamblados de framework puede provocar inesperado y difíciles de diagnosticar el comportamiento.</span><span class="sxs-lookup"><span data-stu-id="a4444-129">Loading multiple copies or different versions of framework assemblies can lead to unexpected and hard to diagnose behavior.</span></span>
     
     > [!TIP]
     > <span data-ttu-id="a4444-130">Use los límites del proceso con comunicación remota o la comunicación entre procesos para solucionar este problema de aislamiento.</span><span class="sxs-lookup"><span data-stu-id="a4444-130">Use process boundaries with remoting and/or interprocess communication to solve this isolation problem.</span></span>
 
 * <span data-ttu-id="a4444-131">El tiempo de carga de ensamblados puede dificultar las pruebas y depuración.</span><span class="sxs-lookup"><span data-stu-id="a4444-131">The timing of assembly loading can make testing and debugging difficult.</span></span> <span data-ttu-id="a4444-132">Los ensamblados se cargan normalmente sin sus dependencias se resuelven inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="a4444-132">Assemblies are typically loaded without their dependencies immediately being resolved.</span></span> <span data-ttu-id="a4444-133">Las dependencias se cargan según sean necesarios:</span><span class="sxs-lookup"><span data-stu-id="a4444-133">The dependencies are loaded as they are needed:</span></span>
     * <span data-ttu-id="a4444-134">Cuando el código se bifurca en un ensamblado dependiente.</span><span class="sxs-lookup"><span data-stu-id="a4444-134">When code branches into a dependent assembly.</span></span>
     * <span data-ttu-id="a4444-135">Cuando el código carga los recursos.</span><span class="sxs-lookup"><span data-stu-id="a4444-135">When code loads resources.</span></span>
     * <span data-ttu-id="a4444-136">Cuando el código carga explícitamente los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="a4444-136">When code explicitly loads assemblies.</span></span>
 
 * <span data-ttu-id="a4444-137">La implementación de <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> puede agregar nuevas dependencias que deben aislarse permiten que distintas versiones de existir.</span><span class="sxs-lookup"><span data-stu-id="a4444-137">The implementation of <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)?displayProperty=nameWithType> can add new dependencies which may need to be isolated to allow different versions to exist.</span></span> <span data-ttu-id="a4444-138">La implementación más natural se colocará estas dependencias en el contexto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a4444-138">The most natural implementation would place these dependencies in the default context.</span></span> <span data-ttu-id="a4444-139">Un cuidadoso diseño puede aislar las dependencias nuevo.</span><span class="sxs-lookup"><span data-stu-id="a4444-139">Careful design can isolate the new dependencies.</span></span>
 
 * <span data-ttu-id="a4444-140">El proceso de aislamiento de enlace crea varios tipos con el mismo nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="a4444-140">The binding isolation process creates multiple types with the same type name.</span></span>
     * <span data-ttu-id="a4444-141">Esto puede llevar a confusión de los mensajes de error, por ejemplo "tipo Foo.Foo no se puede convertir al tipo Foo.Foo."</span><span class="sxs-lookup"><span data-stu-id="a4444-141">This can lead to confusing error messages, for example "type Foo.Foo cannot be cast to type Foo.Foo."</span></span>
     * <span data-ttu-id="a4444-142">El cálculo de referencias entre los límites de aislamiento no es trivial.</span><span class="sxs-lookup"><span data-stu-id="a4444-142">Marshaling across isolation boundaries is non-trivial.</span></span> <span data-ttu-id="a4444-143">Una solución típica sería usar una interfaz definida en un ensamblado que solo se carga en el contexto de carga predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a4444-143">A typical solution would be to use an interface defined in an assembly which is only loaded into the default load context.</span></span>
 
 ]]></format>
    </remarks>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/assemblyloadcontext.md"><span data-ttu-id="a4444-144">Documento de diseño AssemblyLoadContext CoreCLR</span><span class="sxs-lookup"><span data-stu-id="a4444-144">AssemblyLoadContext CoreCLR design document</span></span></related>
    <related type="Article" href="~/docs/standard/assembly/unloadability-howto.md"><span data-ttu-id="a4444-145">Cómo usar y depurar unloadability de ensamblado de .NET Core</span><span class="sxs-lookup"><span data-stu-id="a4444-145">How to use and debug assembly unloadability in .NET Core</span></span></related>
    <related type="Article" href="https://github.com/dotnet/coreclr/blob/master/Documentation/design-docs/unloadability.md"><span data-ttu-id="a4444-146">Documento de diseño de AssemblyLoadContext unloadability</span><span class="sxs-lookup"><span data-stu-id="a4444-146">AssemblyLoadContext unloadability design document</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a4444-147">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-147">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="a4444-148">Este constructor está protegido.</span><span class="sxs-lookup"><span data-stu-id="a4444-148">This constructor is protected.</span></span> <span data-ttu-id="a4444-149">Solo se puede llamar desde el <xref:System.Runtime.Loader.AssemblyLoadContext> clase o sus clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="a4444-149">It can only be called from the <xref:System.Runtime.Loader.AssemblyLoadContext> class or its derived classes.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected AssemblyLoadContext (bool isCollectible);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (isCollectible As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; AssemblyLoadContext(bool isCollectible);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext isCollectible" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="isCollectible" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="isCollectible"><span data-ttu-id="a4444-150"><see langword="true" /> para habilitar la recolección de elementos no utilizados; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-150"><see langword="true" /> to enable garbage collection; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="a4444-151">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> con un valor que indica si una recolección de elementos no utilizados está habilitada.</span><span class="sxs-lookup"><span data-stu-id="a4444-151">Initializes a new instance of the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> class with a value that indicates whether garbage collection is enabled.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public AssemblyLoadContext (string name, bool isCollectible = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, bool isCollectible) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.#ctor(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional isCollectible As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Loader.AssemblyLoadContext : string * bool -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="new System.Runtime.Loader.AssemblyLoadContext (name, isCollectible)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="netcore-3.0" />
        <Parameter Name="isCollectible" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="isCollectible">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="All">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt; All { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Collections.Generic.IEnumerable`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; All" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property All As IEnumerable(Of AssemblyLoadContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ All { System::Collections::Generic::IEnumerable&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.All : seq&lt;System.Runtime.Loader.AssemblyLoadContext&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.All" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Assemblies">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt; Assemblies { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Assembly&gt; Assemblies" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Assemblies As IEnumerable(Of Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ Assemblies { System::Collections::Generic::IEnumerable&lt;System::Reflection::Assembly ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assemblies : seq&lt;System.Reflection.Assembly&gt;" Usage="System.Runtime.Loader.AssemblyLoadContext.Assemblies" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerable&lt;System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CurrentContextualReflectionContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext CurrentContextualReflectionContext" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentContextualReflectionContext As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ CurrentContextualReflectionContext { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentContextualReflectionContext : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.CurrentContextualReflectionContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Loader.AssemblyLoadContext Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As AssemblyLoadContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Loader::AssemblyLoadContext ^ Default { System::Runtime::Loader::AssemblyLoadContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a4444-152">Obtiene el <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a4444-152">Gets the default <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span> <span data-ttu-id="a4444-153">El contexto predeterminado contiene el ensamblado de aplicación principal y sus dependencias estáticas.</span><span class="sxs-lookup"><span data-stu-id="a4444-153">The default context contains the main application assembly and its static dependencies.</span></span></summary>
        <value><span data-ttu-id="a4444-154">Contexto de carga predeterminado del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-154">The default assembly load context.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection" />
      <MemberSignature Language="VB.NET" Value="Public Function EnterContextualReflection () As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection();" />
      <MemberSignature Language="F#" Value="member this.EnterContextualReflection : unit -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="assemblyLoadContext.EnterContextualReflection " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EnterContextualReflection">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope EnterContextualReflection (System.Reflection.Assembly activating);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.Loader.AssemblyLoadContext/ContextualReflectionScope EnterContextualReflection(class System.Reflection.Assembly activating) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection(System.Reflection.Assembly)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function EnterContextualReflection (activating As Assembly) As AssemblyLoadContext.ContextualReflectionScope" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext::ContextualReflectionScope EnterContextualReflection(System::Reflection::Assembly ^ activating);" />
      <MemberSignature Language="F#" Value="static member EnterContextualReflection : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext.ContextualReflectionScope" Usage="System.Runtime.Loader.AssemblyLoadContext.EnterContextualReflection activating" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext+ContextualReflectionScope</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="activating" Type="System.Reflection.Assembly" Index="0" FrameworkAlternate="netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="activating">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblyName">
      <MemberSignature Language="C#" Value="public static System.Reflection.AssemblyName GetAssemblyName (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Reflection.AssemblyName GetAssemblyName(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAssemblyName (assemblyPath As String) As AssemblyName" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Reflection::AssemblyName ^ GetAssemblyName(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="static member GetAssemblyName : string -&gt; System.Reflection.AssemblyName" Usage="System.Runtime.Loader.AssemblyLoadContext.GetAssemblyName assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.AssemblyName</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="a4444-155">Ruta de acceso al ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-155">The path to the assembly.</span></span></param>
        <summary><span data-ttu-id="a4444-156">Obtiene un elemento <see cref="T:System.Reflection.AssemblyName" /> de una ruta de acceso de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-156">Gets an <see cref="T:System.Reflection.AssemblyName" /> for an assembly path.</span></span></summary>
        <returns><span data-ttu-id="a4444-157">Objeto que contiene el nombre de ensamblado analizado totalmente del ensamblado en <paramref name="assemblyPath" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-157">An object that contains the fully parsed assembly name for the assembly at <paramref name="assemblyPath" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-158"><paramref name="assemblyPath" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-158"><paramref name="assemblyPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a4444-159">No se encuentra el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-159">The assembly cannot be found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-160">El ensamblado no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-160">The assembly is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetLoadContext">
      <MemberSignature Language="C#" Value="public static System.Runtime.Loader.AssemblyLoadContext GetLoadContext (System.Reflection.Assembly assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Runtime.Loader.AssemblyLoadContext GetLoadContext(class System.Reflection.Assembly assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.GetLoadContext(System.Reflection.Assembly)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::Loader::AssemblyLoadContext ^ GetLoadContext(System::Reflection::Assembly ^ assembly);" />
      <MemberSignature Language="F#" Value="static member GetLoadContext : System.Reflection.Assembly -&gt; System.Runtime.Loader.AssemblyLoadContext" Usage="System.Runtime.Loader.AssemblyLoadContext.GetLoadContext assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Loader.AssemblyLoadContext</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.Reflection.Assembly" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="a4444-161">Ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-161">An assembly.</span></span></param>
        <summary><span data-ttu-id="a4444-162">Obtiene el elemento <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> que contiene el elemento <see cref="T:System.Reflection.Assembly" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="a4444-162">Gets the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> containing the specified <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="a4444-163">Contexto de carga de ensamblado que contiene el elemento <paramref name="assembly" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-163">The assembly load context containing the <paramref name="assembly" />.</span></span> <span data-ttu-id="a4444-164">Si el runtime no proporciona <paramref name="assembly" />, este método devuelve NULL.</span><span class="sxs-lookup"><span data-stu-id="a4444-164">If the <paramref name="assembly" /> is not provided by the runtime, this method returns null.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-165"><paramref name="assembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-165"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsCollectible">
      <MemberSignature Language="C#" Value="public bool IsCollectible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCollectible" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCollectible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCollectible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCollectible : bool" Usage="System.Runtime.Loader.AssemblyLoadContext.IsCollectible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a4444-166">Obtiene un valor que indica si esta estructura <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> es recopilable.</span><span class="sxs-lookup"><span data-stu-id="a4444-166">Gets a value that indicates whether this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible.</span></span></summary>
        <value><span data-ttu-id="a4444-167"><see langword="true" /> Si este <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> recopilables; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-167"><see langword="true" /> if this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is collectible; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="a4444-168">Si no se especifica un valor en el constructor, el valor es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-168">If a value is not specified in the constructor, the value is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
<span data-ttu-id="a4444-169">Para obtener más información, consulte [cómo usar y depurar unloadability de ensamblado de .NET Core](~/docs/standard/assembly/unloadability-howto.md).</span><span class="sxs-lookup"><span data-stu-id="a4444-169">For more information, see [How to use and debug assembly unloadability in .NET Core](~/docs/standard/assembly/unloadability-howto.md).</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.Load assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="a4444-170">Objeto que describe el ensamblado que va a cargarse.</span><span class="sxs-lookup"><span data-stu-id="a4444-170">The object that describes the assembly to be loaded.</span></span></param>
        <summary><span data-ttu-id="a4444-171">Cuando se invalida en una clase derivada, permite que un ensamblado se resuelva y se cargue en función de su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-171">When overridden in a derived class, allows an assembly to be resolved and loaded based on its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="a4444-172">Ensamblado cargado o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-172">The loaded assembly, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
 
## Remarks
 <span data-ttu-id="a4444-173">Durante la resolución de ensamblado, el <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> método tiene la posibilidad de resolver el nombre de ensamblado en un ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="a4444-173">During assembly resolution, the <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> method has the first chance to resolve the assembly name to a loaded assembly.</span></span> <span data-ttu-id="a4444-174">Puede cargar un ensamblado o devolver `null`.</span><span class="sxs-lookup"><span data-stu-id="a4444-174">It can either load an assembly or return `null`.</span></span> <span data-ttu-id="a4444-175">Si devuelve `null`, continúa el proceso de resolución.</span><span class="sxs-lookup"><span data-stu-id="a4444-175">If it returns `null`, the resolution process continues.</span></span> <span data-ttu-id="a4444-176">Consulte <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> para la descripción del proceso completo.</span><span class="sxs-lookup"><span data-stu-id="a4444-176">See <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> for the full process description.</span></span>
 
 > [!IMPORTANT]
 > <span data-ttu-id="a4444-177">Para evitar el desbordamiento de pila recursivo, no llame a esta instancia <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> desde este método.</span><span class="sxs-lookup"><span data-stu-id="a4444-177">To prevent recursive stack overflow, do not call this instance's <xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)> method from this method.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyName">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyName (System.Reflection.AssemblyName assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyName(class System.Reflection.AssemblyName assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName(System.Reflection.AssemblyName)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyName(System::Reflection::AssemblyName ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyName : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="a4444-178">Objeto que describe el ensamblado que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="a4444-178">The object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="a4444-179">Resuelve y carga un ensamblado dado su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-179">Resolves and loads an assembly given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="a4444-180">Ensamblado cargado, o genera.</span><span class="sxs-lookup"><span data-stu-id="a4444-180">The loaded assembly, or throws.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="a4444-181"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> carga un ensamblado mediante la resolución de la <xref:System.Reflection.AssemblyName>.</span><span class="sxs-lookup"><span data-stu-id="a4444-181"><xref:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyName%2A> loads an assembly by resolving the <xref:System.Reflection.AssemblyName>.</span></span> <span data-ttu-id="a4444-182">Esto desencadena una resolución completa.</span><span class="sxs-lookup"><span data-stu-id="a4444-182">This triggers a full resolution.</span></span> <span data-ttu-id="a4444-183">La secuencia de resolución de reserva sigue este proceso: 1.</span><span class="sxs-lookup"><span data-stu-id="a4444-183">The resolution fallback sequence follows this process: 1.</span></span> <span data-ttu-id="a4444-184">Las llamadas al método <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span><span class="sxs-lookup"><span data-stu-id="a4444-184">The method calls <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)>.</span></span>
         > [!IMPORTANT]
         > <xref:System.Runtime.Loader.AssemblyLoadContext.Load(System.Reflection.AssemblyName)> must not call this method to prevent recursive stack overflow.
     2. Unless the assembly is loaded or an exception is thrown, the method attempts to load the assembly in the default <xref:System.Runtime.Loader.AssemblyLoadContext>.
     3. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.Runtime.Loader.AssemblyLoadContext.Resolving> event.
     4. Unless the assembly is loaded or an exception is thrown, the method fires the <xref:System.AppDomain.AssemblyResolve> event.
 
 > [!NOTE]
 > <span data-ttu-id="a4444-185"><xref:System.IO.FileLoadException> se produce si `assemblyRef` especifica el nombre completo del ensamblado y el primer ensamblado que coincida con el nombre sencillo tiene una versión incompatible o una referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="a4444-185"><xref:System.IO.FileLoadException> is thrown if `assemblyRef` specifies the full assembly name, and the first assembly that matches the simple name has a incompatible version or culture.</span></span> <span data-ttu-id="a4444-186">El cargador no continuará la búsqueda de otros ensamblados que coinciden con el nombre simple.</span><span class="sxs-lookup"><span data-stu-id="a4444-186">The loader does not continue probing for other assemblies that match the simple name.</span></span>
 
 <span data-ttu-id="a4444-187">Cada <xref:System.Runtime.Loader.AssemblyLoadContext> puede cargar solo: \* una versión de un ensamblado ejecutable.</span><span class="sxs-lookup"><span data-stu-id="a4444-187">Each <xref:System.Runtime.Loader.AssemblyLoadContext> can load only: \* One version of an executable assembly.</span></span>
<span data-ttu-id="a4444-188">\* Una versión de un ensamblado satélite para cada referencia cultural.</span><span class="sxs-lookup"><span data-stu-id="a4444-188">\* One version of a satellite assembly for each culture.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-189"><paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-189"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a4444-190">No se ha encontrado <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-190"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-191"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-191"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="a4444-192">Se ha cargado un ensamblado o módulo que no coincide con <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-192">An assembly or module was loaded which did not match the <paramref name="assemblyName" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromAssemblyPath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromAssemblyPath (string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromAssemblyPath(string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromAssemblyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromAssemblyPath (assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromAssemblyPath(System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromAssemblyPath : string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromAssemblyPath assemblyPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyPath"><span data-ttu-id="a4444-193">Ruta de acceso completa al archivo que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="a4444-193">The fully qualified path of the file to load.</span></span></param>
        <summary><span data-ttu-id="a4444-194">Carga el contenido de un archivo de ensamblado en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="a4444-194">Loads the contents of an assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="a4444-195">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="a4444-195">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a4444-196">El argumento <paramref name="assemblyPath" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="a4444-196">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-197">El parámetro <paramref name="assemblyPath" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-197">The <paramref name="assemblyPath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="a4444-198">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="a4444-198">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a4444-199">El parámetro <paramref name="assemblyPath" /> es una cadena vacía ("") o no existe.</span><span class="sxs-lookup"><span data-stu-id="a4444-199">The <paramref name="assemblyPath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-200"><paramref name="assemblyPath" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-200"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromNativeImagePath">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromNativeImagePath (string nativeImagePath, string assemblyPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromNativeImagePath(string nativeImagePath, string assemblyPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromNativeImagePath(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function LoadFromNativeImagePath (nativeImagePath As String, assemblyPath As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromNativeImagePath(System::String ^ nativeImagePath, System::String ^ assemblyPath);" />
      <MemberSignature Language="F#" Value="member this.LoadFromNativeImagePath : string * string -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromNativeImagePath (nativeImagePath, assemblyPath)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="nativeImagePath" Type="System.String" />
        <Parameter Name="assemblyPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="nativeImagePath"><span data-ttu-id="a4444-201">Ruta de acceso completa al archivo que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="a4444-201">The fully qualified path of the file to load.</span></span></param>
        <param name="assemblyPath"><span data-ttu-id="a4444-202">Ruta de acceso completa de la versión IL del archivo que se va a cargar, o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-202">The fully qualified path of the IL version of the file to load, or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="a4444-203">Carga el contenido de la imagen nativa de un archivo de ensamblado administrado en la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="a4444-203">Loads the contents of the native image of a managed assembly file on the specified path.</span></span></summary>
        <returns><span data-ttu-id="a4444-204">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="a4444-204">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="a4444-205">La imagen nativa de un ensamblado administrado es anterior a la compilación JIT para optimizar el que se ejecuta en una plataforma específica.</span><span class="sxs-lookup"><span data-stu-id="a4444-205">The native image of a managed assembly is pre-jitted to optimize running on a specific platform.</span></span>
 
 <span data-ttu-id="a4444-206">La ruta de acceso de ensamblado hace referencia a la ruta de acceso a la versión de IL del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-206">The assembly path refers to the path to the IL version of the assembly.</span></span> <span data-ttu-id="a4444-207">Es un argumento opcional como el IL normalmente se incluye en la imagen nativa.</span><span class="sxs-lookup"><span data-stu-id="a4444-207">It is an optional argument as the IL is typically included in the native image.</span></span> <span data-ttu-id="a4444-208">Se puede usar el tiempo de ejecución como una acción de reserva si no se encuentra la imagen nativa.</span><span class="sxs-lookup"><span data-stu-id="a4444-208">It can be used by the runtime as a fallback if the native image is not found.</span></span>
 
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a4444-209">El argumento <paramref name="nativeImagePath" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="a4444-209">The <paramref name="nativeImagePath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a4444-210">El argumento <paramref name="assemblyPath" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="a4444-210">The <paramref name="assemblyPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-211">El parámetro <paramref name="nativeImagePath" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-211">The <paramref name="nativeImagePath" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="a4444-212">No se pudo cargar un archivo que se encontró.</span><span class="sxs-lookup"><span data-stu-id="a4444-212">A file that was found could not be loaded.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a4444-213">El parámetro <paramref name="nativeImagePath" /> es una cadena vacía ("") o no existe.</span><span class="sxs-lookup"><span data-stu-id="a4444-213">The <paramref name="nativeImagePath" /> parameter is an empty string ("") or does not exist.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-214"><paramref name="assemblyPath" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-214"><paramref name="assemblyPath" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream assembly" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="a4444-215">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado administrado.</span><span class="sxs-lookup"><span data-stu-id="a4444-215">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <summary><span data-ttu-id="a4444-216">Carga el ensamblado con una imagen basada en el formato de archivo de objeto común (COFF) que contiene un ensamblado administrado.</span><span class="sxs-lookup"><span data-stu-id="a4444-216">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly.</span></span></summary>
        <returns><span data-ttu-id="a4444-217">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="a4444-217">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-218"><paramref name="assembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-218"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-219"><paramref name="assembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-219"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadFromStream">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly LoadFromStream (System.IO.Stream assembly, System.IO.Stream assemblySymbols);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly LoadFromStream(class System.IO.Stream assembly, class System.IO.Stream assemblySymbols) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadFromStream(System.IO.Stream,System.IO.Stream)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Assembly ^ LoadFromStream(System::IO::Stream ^ assembly, System::IO::Stream ^ assemblySymbols);" />
      <MemberSignature Language="F#" Value="member this.LoadFromStream : System.IO.Stream * System.IO.Stream -&gt; System.Reflection.Assembly" Usage="assemblyLoadContext.LoadFromStream (assembly, assemblySymbols)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assembly" Type="System.IO.Stream" />
        <Parameter Name="assemblySymbols" Type="System.IO.Stream" />
      </Parameters>
      <Docs>
        <param name="assembly"><span data-ttu-id="a4444-220">Matriz de bytes que es una imagen basada en COFF que contiene un ensamblado administrado.</span><span class="sxs-lookup"><span data-stu-id="a4444-220">A byte array that is a COFF-based image containing a managed assembly.</span></span></param>
        <param name="assemblySymbols"><span data-ttu-id="a4444-221">Matriz de bytes que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-221">A byte array that contains the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="a4444-222">Carga el ensamblado con una imagen basada en el formato de archivo de objeto común (COFF) que contiene un ensamblado administrado, incluyendo opcionalmente los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-222">Loads the assembly with a common object file format (COFF)-based image containing a managed assembly, optionally including symbols for the assembly.</span></span></summary>
        <returns><span data-ttu-id="a4444-223">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="a4444-223">The loaded assembly.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-224"><paramref name="assembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-224"><paramref name="assembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="a4444-225"><paramref name="assembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="a4444-225"><paramref name="assembly" /> is not a valid assembly.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDll">
      <MemberSignature Language="C#" Value="protected virtual IntPtr LoadUnmanagedDll (string unmanagedDllName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance native int LoadUnmanagedDll(string unmanagedDllName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDll(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function LoadUnmanagedDll (unmanagedDllName As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual IntPtr LoadUnmanagedDll(System::String ^ unmanagedDllName);" />
      <MemberSignature Language="F#" Value="abstract member LoadUnmanagedDll : string -&gt; nativeint&#xA;override this.LoadUnmanagedDll : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDll unmanagedDllName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllName"><span data-ttu-id="a4444-226">Nombre de la biblioteca no administrada.</span><span class="sxs-lookup"><span data-stu-id="a4444-226">Name of the unmanaged library.</span></span> <span data-ttu-id="a4444-227">Normalmente es el nombre de archivo sin su ruta de acceso ni extensiones.</span><span class="sxs-lookup"><span data-stu-id="a4444-227">Typically this is the filename without its path or extensions.</span></span></param>
        <summary><span data-ttu-id="a4444-228">Permite que una clase derivada cargue una biblioteca no administrada por nombre.</span><span class="sxs-lookup"><span data-stu-id="a4444-228">Allows derived class to load an unmanaged library by name.</span></span></summary>
        <returns><span data-ttu-id="a4444-229">Manipulador de la biblioteca cargada, o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-229">A handle to the loaded library, or <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="a4444-230">La implementación predeterminada siempre devuelven `null`.</span><span class="sxs-lookup"><span data-stu-id="a4444-230">The default implementation always return `null`.</span></span> <span data-ttu-id="a4444-231">Cuando `null` se devuelve, el tiempo de ejecución carga la biblioteca con su directiva predeterminada.</span><span class="sxs-lookup"><span data-stu-id="a4444-231">When `null` is returned, the runtime loads the library with its default policy.</span></span>
 
 <span data-ttu-id="a4444-232">Este método virtual se puede invalidar para personalizar el algoritmo de búsqueda de biblioteca no administrada.</span><span class="sxs-lookup"><span data-stu-id="a4444-232">This virtual method can be overridden to customize the unmanaged library search algorithm.</span></span> <span data-ttu-id="a4444-233">Cuando se invalida el nombre se puede utilizar para identificar la biblioteca.</span><span class="sxs-lookup"><span data-stu-id="a4444-233">When overridden the name can be used to identify the library.</span></span> <span data-ttu-id="a4444-234">La biblioteca cargada no es necesario para que coincida con la solicitada el nombre, pero se pueden transformar según sea necesario.</span><span class="sxs-lookup"><span data-stu-id="a4444-234">The loaded library does not need to match the requested name, but can be transformed as needed.</span></span> <span data-ttu-id="a4444-235">Esto puede incluir ajuste el nombre para asignar nombres específicos de plataforma.</span><span class="sxs-lookup"><span data-stu-id="a4444-235">This could include adjusting the name for platform specific naming.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LoadUnmanagedDllFromPath">
      <MemberSignature Language="C#" Value="protected IntPtr LoadUnmanagedDllFromPath (string unmanagedDllPath);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance native int LoadUnmanagedDllFromPath(string unmanagedDllPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.LoadUnmanagedDllFromPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Function LoadUnmanagedDllFromPath (unmanagedDllPath As String) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; IntPtr LoadUnmanagedDllFromPath(System::String ^ unmanagedDllPath);" />
      <MemberSignature Language="F#" Value="member this.LoadUnmanagedDllFromPath : string -&gt; nativeint" Usage="assemblyLoadContext.LoadUnmanagedDllFromPath unmanagedDllPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unmanagedDllPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="unmanagedDllPath"><span data-ttu-id="a4444-236">Ruta de acceso a la biblioteca no administrada.</span><span class="sxs-lookup"><span data-stu-id="a4444-236">The path to the unmanaged library.</span></span></param>
        <summary><span data-ttu-id="a4444-237">Carga una biblioteca no administrada desde la ruta de acceso especificada.</span><span class="sxs-lookup"><span data-stu-id="a4444-237">Loads an unmanaged library from the specified path.</span></span></summary>
        <returns><span data-ttu-id="a4444-238">Manipulador de la biblioteca cargada.</span><span class="sxs-lookup"><span data-stu-id="a4444-238">A handle to the loaded library.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="a4444-239"><paramref name="unmanagedDllPath" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-239"><paramref name="unmanagedDllPath" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="a4444-240">El argumento <paramref name="unmanagedDllPath" /> no es una ruta de acceso absoluta.</span><span class="sxs-lookup"><span data-stu-id="a4444-240">The <paramref name="unmanagedDllPath" /> argument is not an absolute path.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="a4444-241">No se encuentra la biblioteca no administrada.</span><span class="sxs-lookup"><span data-stu-id="a4444-241">The unmanaged library cannot be found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Loader.AssemblyLoadContext.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolving">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt; Resolving;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Runtime.Loader.AssemblyLoadContext, class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; Resolving" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Resolving" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Resolving As Func(Of AssemblyLoadContext, AssemblyName, Assembly) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Runtime::Loader::AssemblyLoadContext ^, System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ Resolving;" />
      <MemberSignature Language="F#" Value="member this.Resolving : Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " Usage="member this.Resolving : System.Func&lt;System.Runtime.Loader.AssemblyLoadContext, System.Reflection.AssemblyName, System.Reflection.Assembly&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Runtime.Loader.AssemblyLoadContext,System.Reflection.AssemblyName,System.Reflection.Assembly&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a4444-242">Se produce cuando ocurre un error en la resolución de un ensamblado al intentar cargar en el contexto de carga de este ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-242">Occurs when the resolution of an assembly fails when attempting to load into this assembly load context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks
 <span data-ttu-id="a4444-243">Es responsabilidad del controlador para este evento para devolver el ensamblado que se especifica, o para devolver `null` si no se reconoce el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="a4444-243">It is the responsibility of the handler for this event to return the assembly that is specified, or to return `null` if the assembly is not recognized.</span></span>
 
 > [!IMPORTANT]
 >  <span data-ttu-id="a4444-244">Si más de un controlador de eventos está registrado para este evento, los controladores de eventos se llaman en orden hasta que un controlador de eventos devuelve un valor que no sea `null`.</span><span class="sxs-lookup"><span data-stu-id="a4444-244">If more than one event handler is registered for this event, the event handlers are called in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="a4444-245">Controladores de eventos posteriores se omiten.</span><span class="sxs-lookup"><span data-stu-id="a4444-245">Subsequent event handlers are ignored.</span></span>
 
 <span data-ttu-id="a4444-246">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="a4444-246">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>
 
 <span data-ttu-id="a4444-247">Resulta valioso que se puede agregar un controlador para este evento en cualquier <xref:System.Runtime.Loader.AssemblyLoadContext>, incluido el contexto predeterminado.</span><span class="sxs-lookup"><span data-stu-id="a4444-247">It is noteworthy that a handler can be added for this event on any <xref:System.Runtime.Loader.AssemblyLoadContext>, including the default context.</span></span>
 
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ResolvingUnmanagedDll">
      <MemberSignature Language="C#" Value="public event Func&lt;System.Reflection.Assembly,string,IntPtr&gt; ResolvingUnmanagedDll;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Func`3&lt;class System.Reflection.Assembly, string, native int&gt; ResolvingUnmanagedDll" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.ResolvingUnmanagedDll" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResolvingUnmanagedDll As Func(Of Assembly, String, IntPtr) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Func&lt;System::Reflection::Assembly ^, System::String ^, IntPtr&gt; ^ ResolvingUnmanagedDll;" />
      <MemberSignature Language="F#" Value="member this.ResolvingUnmanagedDll : Func&lt;System.Reflection.Assembly, string, nativeint&gt; " Usage="member this.ResolvingUnmanagedDll : System.Func&lt;System.Reflection.Assembly, System.string, System.nativeint&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Func&lt;System.Reflection.Assembly,System.String,System.IntPtr&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetProfileOptimizationRoot">
      <MemberSignature Language="C#" Value="public void SetProfileOptimizationRoot (string directoryPath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetProfileOptimizationRoot(string directoryPath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.SetProfileOptimizationRoot(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetProfileOptimizationRoot (directoryPath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetProfileOptimizationRoot(System::String ^ directoryPath);" />
      <MemberSignature Language="F#" Value="member this.SetProfileOptimizationRoot : string -&gt; unit" Usage="assemblyLoadContext.SetProfileOptimizationRoot directoryPath" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="directoryPath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="directoryPath">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="StartProfileOptimization">
      <MemberSignature Language="C#" Value="public void StartProfileOptimization (string profile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void StartProfileOptimization(string profile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.StartProfileOptimization(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub StartProfileOptimization (profile As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void StartProfileOptimization(System::String ^ profile);" />
      <MemberSignature Language="F#" Value="member this.StartProfileOptimization : string -&gt; unit" Usage="assemblyLoadContext.StartProfileOptimization profile" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="profile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="profile">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public void Unload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Unload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Loader.AssemblyLoadContext.Unload" />
      <MemberSignature Language="VB.NET" Value="Public Sub Unload ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Unload();" />
      <MemberSignature Language="F#" Value="member this.Unload : unit -&gt; unit" Usage="assemblyLoadContext.Unload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="a4444-248">Inicia una descarga de este <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span><span class="sxs-lookup"><span data-stu-id="a4444-248">Initiates an unload of this <see cref="T:System.Runtime.Loader.AssemblyLoadContext" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

+ <span data-ttu-id="a4444-249">Un AssemblyLoadContext sólo se puede descargar si es recopilable.</span><span class="sxs-lookup"><span data-stu-id="a4444-249">An AssemblyLoadContext can only be unloaded if it is collectible.</span></span>
+ <span data-ttu-id="a4444-250">Descarga de forma asincrónica.</span><span class="sxs-lookup"><span data-stu-id="a4444-250">Unloading will occur asynchronously.</span></span>
+ <span data-ttu-id="a4444-251">No se producirá la descarga aunque hay referencias a la AssemblyLoadContext.</span><span class="sxs-lookup"><span data-stu-id="a4444-251">Unloading will not occur while there are references to the AssemblyLoadContext.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="a4444-252">No se permite la descarga.</span><span class="sxs-lookup"><span data-stu-id="a4444-252">Unloading is not allowed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Unloading">
      <MemberSignature Language="C#" Value="public event Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; Unloading;" />
      <MemberSignature Language="ILAsm" Value=".event class System.Action`1&lt;class System.Runtime.Loader.AssemblyLoadContext&gt; Unloading" />
      <MemberSignature Language="DocId" Value="E:System.Runtime.Loader.AssemblyLoadContext.Unloading" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Unloading As Action(Of AssemblyLoadContext) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event Action&lt;System::Runtime::Loader::AssemblyLoadContext ^&gt; ^ Unloading;" />
      <MemberSignature Language="F#" Value="member this.Unloading : Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " Usage="member this.Unloading : System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Loader</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.2.0</AssemblyVersion>
        <AssemblyVersion>4.0.3.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Action&lt;System.Runtime.Loader.AssemblyLoadContext&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="a4444-253">Se produce cuando <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> está sin cargar.</span><span class="sxs-lookup"><span data-stu-id="a4444-253">Occurs when the <see cref="T:System.Runtime.Loader.AssemblyLoadContext" /> is unloaded.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
  </Members>
</Type>
