<Type Name="IImmutableSet&lt;T&gt;" FullName="System.Collections.Immutable.IImmutableSet&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="271e7f13c3a7934654a655b83461a568199912f4" /><Meta Name="ms.sourcegitcommit" Value="723b8a6d92667ba86fcda96190bad3b4a03283b3" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/09/2018" /><Meta Name="ms.locfileid" Value="51314387" /></Metadata><TypeSignature Language="C#" Value="public interface IImmutableSet&lt;T&gt; : System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IImmutableSet`1&lt;T&gt; implements class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Immutable.IImmutableSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IImmutableSet(Of T)&#xA;Implements IEnumerable(Of T), IReadOnlyCollection(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IImmutableSet : System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;" />
  <TypeSignature Language="F#" Value="type IImmutableSet&lt;'T&gt; = interface&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable&#xA;    interface IReadOnlyCollection&lt;'T&gt;" />
  <AssemblyInfo>
    <AssemblyName>System.Collections.Immutable</AssemblyName>
    <AssemblyVersion>1.2.0.0</AssemblyVersion>
    <AssemblyVersion>1.2.1.0</AssemblyVersion>
    <AssemblyVersion>1.2.2.0</AssemblyVersion>
    <AssemblyVersion>1.2.3.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <typeparam name="T"><span data-ttu-id="04ee2-101">Tipo de elemento almacenado en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-101">The type of element stored in the set.</span></span></typeparam>
    <summary><span data-ttu-id="04ee2-102">Representa un conjunto de elementos que solo pueden modificarse mediante la creación de una nueva instancia del conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-102">Represents a set of elements that can only be modified by creating a new instance of the set.</span></span>  
  
 <span data-ttu-id="04ee2-103">**Paquete NuGet**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">sobre las colecciones inmutables y la instalación</see>)</span><span class="sxs-lookup"><span data-stu-id="04ee2-103">**NuGet package**: <see href="https://www.nuget.org/packages/System.Collections.Immutable/">System.Collections.Immutable</see> (<see href="https://docs.microsoft.com/dotnet/api/system.collections.immutable?#remarks">about immutable collections and how to install</see>)</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04ee2-104">Mutaciones en este conjunto de generan nuevos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-104">Mutations on this set generate new sets.</span></span> <span data-ttu-id="04ee2-105">Los cambios incrementales en un conjunto compartan tanta memoria como sea posible con las versiones anteriores de un conjunto, permitiendo la recolección de elementos limpiar los datos de conjunto único que ya no se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="04ee2-105">Incremental changes to a set share as much memory as possible with the prior versions of a set, while allowing garbage collection to clean up any unique set data that is no longer being referenced.</span></span>  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Add (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Add(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (value As T) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Add(T value);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Add value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="04ee2-106">Elemento que se va a agregar.</span><span class="sxs-lookup"><span data-stu-id="04ee2-106">The element to add.</span></span></param>
        <summary><span data-ttu-id="04ee2-107">Agrega el elemento especificado a este conjunto inmutable.</span><span class="sxs-lookup"><span data-stu-id="04ee2-107">Adds the specified element to this immutable set.</span></span></summary>
        <returns><span data-ttu-id="04ee2-108">Nuevo conjunto con el elemento agregado o este conjunto si el elemento ya está en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-108">A new set with the element added, or this set if the element is already in the set.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Function Clear () As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="04ee2-109">Recupera un conjunto inmutable vacío que tiene la misma ordenación y semántica de orden que esta instancia.</span><span class="sxs-lookup"><span data-stu-id="04ee2-109">Retrieves an empty immutable set that has the same sorting and ordering semantics as this instance.</span></span></summary>
        <returns><span data-ttu-id="04ee2-110">Conjunto vacío que tiene la misma ordenación y semántica de orden que esta instancia.</span><span class="sxs-lookup"><span data-stu-id="04ee2-110">An empty set that has the same sorting and ordering semantics as this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (value As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Contains(T value);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool" Usage="iImmutableSet.Contains value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="04ee2-111">Elemento que se debe buscar en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-111">The element to locate in the set.</span></span></param>
        <summary><span data-ttu-id="04ee2-112">Determina si este conjunto inmutable contiene un elemento especificado.</span><span class="sxs-lookup"><span data-stu-id="04ee2-112">Determines whether this immutable set contains a specified element.</span></span></summary>
        <returns><span data-ttu-id="04ee2-113">Es <see langword="true" /> si el conjunto contiene el valor especificado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-113"><see langword="true" /> if the set contains the specified value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Except">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Except (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Except(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Except(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Except (other As IEnumerable(Of T)) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Except(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Except : seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Except other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-114">Colección de elementos que se van a quitar de este conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-114">The collection of items to remove from this set.</span></span></param>
        <summary><span data-ttu-id="04ee2-115">Quita del conjunto inmutable actual los elementos de la colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-115">Removes the elements in the specified collection from the current immutable set.</span></span></summary>
        <returns><span data-ttu-id="04ee2-116">Nuevo conjunto con los elementos que se han quitado; o el conjunto original si no se encontraba ninguno de los elementos en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-116">A new set with the items removed; or the original set if none of the items were in the set.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Intersect">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Intersect (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Intersect(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Intersect(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Intersect (other As IEnumerable(Of T)) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Intersect(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Intersect : seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Intersect other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-117">Colección que se va a comparar con el <see cref="T:System.Collections.Immutable.IImmutableSet`1" /> actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-117">The collection to compare to the current <see cref="T:System.Collections.Immutable.IImmutableSet`1" />.</span></span></param>
        <summary><span data-ttu-id="04ee2-118">Crea un conjunto inmutable que contiene solo elementos que existen en este conjunto y en el conjunto especificado.</span><span class="sxs-lookup"><span data-stu-id="04ee2-118">Creates an immutable set that contains only elements that exist in this set and the specified set.</span></span></summary>
        <returns><span data-ttu-id="04ee2-119">Nuevo conjunto inmutable que contiene elementos que existen en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-119">A new immutable set that contains elements that exist in both sets.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-120">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-120">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-121">Determina si el conjunto inmutable actual es un subconjunto apropiado (estricto) de la colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-121">Determines whether the current immutable set is a proper (strict) subset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-122"><see langword="true" /> si el conjunto actual es un subconjunto apropiado de la colección especificada; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-122"><see langword="true" /> if the current set is a proper subset of the specified collection; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04ee2-123">Si el conjunto actual es un subconjunto apropiado de `other`, `other` debe tener al menos un elemento que no tiene el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-123">If the current set is a proper subset of `other`, `other` must have at least one element that the current set does not have.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-124">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-124">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-125">Determina si el conjunto inmutable actual es un supraconjunto apropiado (estricto) de la colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-125">Determines whether the current immutable set is a proper (strict) superset of the specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-126"><see langword="true" /> si el conjunto actual es un supraconjunto apropiado de la colección especificada; de lo contrario, es falso.</span><span class="sxs-lookup"><span data-stu-id="04ee2-126"><see langword="true" /> if the current set is a proper superset of the specified collection; otherwise, false.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04ee2-127">Si el conjunto actual es un supraconjunto apropiado de `other`, el conjunto actual debe tener al menos un elemento que `other` no tiene.</span><span class="sxs-lookup"><span data-stu-id="04ee2-127">If the current set is a proper superset of `other`, the current set must have at least one element that `other` does not have.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-128">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-128">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-129">Determina si el conjunto inmutable actual es un subconjunto apropiado (estricto) de una colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-129">Determines whether the current immutable set is a subset of a specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-130"><see langword="true" /> si el conjunto actual es un subconjunto de la colección especificada; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-130"><see langword="true" /> if the current set is a subset of the specified collection; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-131">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-131">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-132">Determina si el conjunto inmutable actual es un supraconjunto apropiado (estricto) de una colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-132">Determines whether the current immutable set is a superset of a specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-133"><see langword="true" /> si el conjunto actual es un supraconjunto de la colección especificada; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-133"><see langword="true" /> if the current set is a superset of the specified collection; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-134">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-134">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-135">Determina si el conjunto inmutable actual se superpone a la colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-135">Determines whether the current immutable set overlaps with the specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-136"><see langword="true" /> si el conjunto actual y la colección especificada comparten al menos un elemento común; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-136"><see langword="true" /> if the current set and the specified collection share at least one common element; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Remove (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Remove(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (value As T) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Remove(T value);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Remove value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="04ee2-137">Elemento que se va a quitar.</span><span class="sxs-lookup"><span data-stu-id="04ee2-137">The element to remove.</span></span></param>
        <summary><span data-ttu-id="04ee2-138">Elimina el elemento especificado de este conjunto inmutable.</span><span class="sxs-lookup"><span data-stu-id="04ee2-138">Removes the specified element from this immutable set.</span></span></summary>
        <returns><span data-ttu-id="04ee2-139">Nuevo conjunto con el elemento especificado eliminado o el conjunto actual si no se encuentra el elemento en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-139">A new set with the specified element removed, or the current set if the element cannot be found in the set.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="iImmutableSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-140">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-140">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-141">Determina si el conjunto inmutable actual y la colección especificada contienen los mismos elementos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-141">Determines whether the current immutable set and the specified collection contain the same elements.</span></span></summary>
        <returns><span data-ttu-id="04ee2-142">Es <see langword="true" /> si los conjuntos son iguales; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-142"><see langword="true" /> if the sets are equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExcept">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; SymmetricExcept (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; SymmetricExcept(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.SymmetricExcept(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SymmetricExcept (other As IEnumerable(Of T)) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ SymmetricExcept(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExcept : seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.SymmetricExcept other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-143">Colección que se va a comparar con el conjunto actual.</span><span class="sxs-lookup"><span data-stu-id="04ee2-143">The collection to compare to the current set.</span></span></param>
        <summary><span data-ttu-id="04ee2-144">Crea un conjunto inmutable que únicamente contiene elementos que están presentes en el conjunto actual o en la colección especificada, pero no en ambos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-144">Creates an immutable set that contains only elements that are present either in the current set or in the specified collection, but not both.</span></span></summary>
        <returns><span data-ttu-id="04ee2-145">Conjunto nuevo que únicamente contiene elementos que están presentes en el conjunto actual o en la colección especificada, pero no en ambos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-145">A new set that contains the elements that are present only in the current set or in the specified collection, but not both.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="abstract member TryGetValue : 'T *  -&gt; bool" Usage="iImmutableSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue"><span data-ttu-id="04ee2-146">Valor que se va a buscar.</span><span class="sxs-lookup"><span data-stu-id="04ee2-146">The value to search for.</span></span></param>
        <param name="actualValue"><span data-ttu-id="04ee2-147">Valor coincidente del conjunto, si se encuentra, o <c>equalvalue</c> si no hay ninguna coincidencia.</span><span class="sxs-lookup"><span data-stu-id="04ee2-147">The matching value from the set, if found, or <c>equalvalue</c> if there are no matches.</span></span></param>
        <summary><span data-ttu-id="04ee2-148">Determina si el conjunto contiene un valor específico.</span><span class="sxs-lookup"><span data-stu-id="04ee2-148">Determines whether the set contains a specified value.</span></span></summary>
        <returns><span data-ttu-id="04ee2-149"><see langword="true" /> si se encuentra un valor coincidente; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="04ee2-149"><see langword="true" /> if a matching value was found; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04ee2-150">Estos son algunos escenarios donde <xref:System.Collections.Immutable.IImmutableSet%601.TryGetValue%2A> puede resultar útil:</span><span class="sxs-lookup"><span data-stu-id="04ee2-150">Following are some scenarios where <xref:System.Collections.Immutable.IImmutableSet%601.TryGetValue%2A> may be useful:</span></span>  
  
-   <span data-ttu-id="04ee2-151">Desea volver a usar una referencia de objeto previamente almacenado en lugar de crear una nueva referencia.</span><span class="sxs-lookup"><span data-stu-id="04ee2-151">You want to reuse a previously stored object reference instead of creating a new reference.</span></span>  
  
-   <span data-ttu-id="04ee2-152">Van a recuperar los datos más completos sobre un objeto</span><span class="sxs-lookup"><span data-stu-id="04ee2-152">You want to retrieve more complete data about an object</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Union">
      <MemberSignature Language="C#" Value="public System.Collections.Immutable.IImmutableSet&lt;T&gt; Union (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Immutable.IImmutableSet`1&lt;!T&gt; Union(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Immutable.IImmutableSet`1.Union(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Union (other As IEnumerable(Of T)) As IImmutableSet(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Immutable::IImmutableSet&lt;T&gt; ^ Union(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Union : seq&lt;'T&gt; -&gt; System.Collections.Immutable.IImmutableSet&lt;'T&gt;" Usage="iImmutableSet.Union other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections.Immutable</AssemblyName>
        <AssemblyVersion>1.2.0.0</AssemblyVersion>
        <AssemblyVersion>1.2.1.0</AssemblyVersion>
        <AssemblyVersion>1.2.2.0</AssemblyVersion>
        <AssemblyVersion>1.2.3.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Immutable.IImmutableSet&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="04ee2-153">Colección de la que se van a agregar elementos.</span><span class="sxs-lookup"><span data-stu-id="04ee2-153">The collection to add elements from.</span></span></param>
        <summary><span data-ttu-id="04ee2-154">Crea un conjunto inmutable que contiene todos los elementos que están presentes en el conjunto actual o en la colección especificada.</span><span class="sxs-lookup"><span data-stu-id="04ee2-154">Creates a new immutable set that contains all elements that are present in either the current set or in the specified collection.</span></span></summary>
        <returns><span data-ttu-id="04ee2-155">Nuevo conjunto inmutable con los elementos agregados; o conjunto original si ya estaban todos los elementos en el conjunto.</span><span class="sxs-lookup"><span data-stu-id="04ee2-155">A new immutable set with the items added; or the original set if all the items were already in the set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="04ee2-156">Cualquier duplicar los elementos contenidos en `other` se omiten.</span><span class="sxs-lookup"><span data-stu-id="04ee2-156">Any duplicate elements contained in `other` are ignored.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>