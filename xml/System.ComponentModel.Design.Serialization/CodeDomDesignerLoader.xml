<Type Name="CodeDomDesignerLoader" FullName="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader">
  <Metadata><Meta Name="ms.openlocfilehash" Value="23fb88e8437c267e723f3c8166b53ef27ea27cee" /><Meta Name="ms.sourcegitcommit" Value="0e1f030650a307c745ee84ed547ef858acaea587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="11/29/2018" /><Meta Name="ms.locfileid" Value="52610074" /></Metadata><TypeSignature Language="C#" Value="public abstract class CodeDomDesignerLoader : System.ComponentModel.Design.Serialization.BasicDesignerLoader, System.ComponentModel.Design.Serialization.IDesignerSerializationService, System.ComponentModel.Design.Serialization.INameCreationService" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit CodeDomDesignerLoader extends System.ComponentModel.Design.Serialization.BasicDesignerLoader implements class System.ComponentModel.Design.Serialization.IDesignerSerializationService, class System.ComponentModel.Design.Serialization.INameCreationService" />
  <TypeSignature Language="DocId" Value="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class CodeDomDesignerLoader&#xA;Inherits BasicDesignerLoader&#xA;Implements IDesignerSerializationService, INameCreationService" />
  <TypeSignature Language="C++ CLI" Value="public ref class CodeDomDesignerLoader abstract : System::ComponentModel::Design::Serialization::BasicDesignerLoader, System::ComponentModel::Design::Serialization::IDesignerSerializationService, System::ComponentModel::Design::Serialization::INameCreationService" />
  <TypeSignature Language="F#" Value="type CodeDomDesignerLoader = class&#xA;    inherit BasicDesignerLoader&#xA;    interface INameCreationService&#xA;    interface IDesignerSerializationService" />
  <AssemblyInfo>
    <AssemblyName>System.Design</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ComponentModel.Design.Serialization.BasicDesignerLoader</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.IDesignerSerializationService</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.ComponentModel.Design.Serialization.INameCreationService</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Proporciona la clase base para implementar un cargador de diseñadores basado en CodeDOM.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> es una clase abstracta que proporciona un cargador de diseñadores completo según el Code Document Object Model (CodeDOM). Proporcionar un servicio de resolución de tipos y generador y el analizador de CodeDOM.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Security.NamedPermissionSet">Para obtener acceso completo a los recursos del sistema. Valores de petición: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />, <see cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand" />. Estado asociado:</permission>
    <altmember cref="T:System.ComponentModel.Design.Serialization.BasicDesignerLoader" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderService" />
    <altmember cref="T:System.ComponentModel.Design.IDesignerHost" />
    <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
    <altmember cref="N:System.CodeDom" />
    <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected CodeDomDesignerLoader ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; CodeDomDesignerLoader();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Inicializa una nueva instancia de la clase <see cref="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CodeDomProvider">
      <MemberSignature Language="C#" Value="protected abstract System.CodeDom.Compiler.CodeDomProvider CodeDomProvider { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.CodeDom.Compiler.CodeDomProvider CodeDomProvider" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property CodeDomProvider As CodeDomProvider" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property System::CodeDom::Compiler::CodeDomProvider ^ CodeDomProvider { System::CodeDom::Compiler::CodeDomProvider ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CodeDomProvider : System.CodeDom.Compiler.CodeDomProvider" Usage="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.Compiler.CodeDomProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene la propiedad <see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /> que va a utilizar este cargador de diseñadores.</summary>
        <value>Propiedad <see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /> que va a utilizar este cargador de diseñadores</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El cargador de diseñadores no analizar o generar código devueltos <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A>, pero utiliza el proveedor para obtener un <xref:System.CodeDom.Compiler.ICodeGenerator> que puede usar para validar los identificadores en el servicio de creación de nombres. El cargador de diseñadores también comprobará la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A> para ver si implementa el <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload> interfaz. Para obtener más información sobre cómo analizar o generar el código, vea el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A> y <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> métodos.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public override void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Dispose();" />
      <MemberSignature Language="F#" Value="override this.Dispose : unit -&gt; unit" Usage="codeDomDesignerLoader.Dispose " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Libera los recursos que usa la clase <see cref="T:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> método quita servicios agregados por el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize%2A> método.  
  
 Llame a <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> cuando haya terminado de usar <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader>. El método <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> deja el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> en un estado no utilizable. Después de llamar a <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A>, debe liberar todas las referencias a la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> por lo que el recolector de elementos no utilizados pueda reclamar la memoria que el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> estaba ocupando. Para obtener más información, consulte [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md) y [implementar un método Dispose](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Realice siempre una llamada a <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Dispose%2A> antes de liberar la última referencia al objeto <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader>. En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> del objeto `Finalize`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Initialize">
      <MemberSignature Language="C#" Value="protected override void Initialize ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Initialize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub Initialize ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void Initialize();" />
      <MemberSignature Language="F#" Value="override this.Initialize : unit -&gt; unit" Usage="codeDomDesignerLoader.Initialize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Inicializa los servicios.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 En la tabla siguiente se describe los reemplazable de servicios que la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> agrega al contenedor de servicios.  
  
|Término|de esquema JSON|  
|----------|----------------|  
|<xref:System.ComponentModel.Design.Serialization.INameCreationService>|Proporciona la semántica para crear nombres de objetos. El servicio utiliza el proveedor de CodeDOM <xref:System.CodeDom.Compiler.ICodeGenerator> interfaz para crear nombres de identificadores válidos para el idioma. Además, el servicio de creación de nombres admite nombres vacíos. Nombres vacíos se deben interpretar como variables locales temporales durante la serialización.|  
|<xref:System.ComponentModel.Design.Serialization.IDesignerSerializationService>|Permite que otros objetos serializar un grupo de componentes en un objeto binario. Este servicio se suele utilizar características tales como copiar y pegar o deshacer y rehacer. La <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> clase proporciona un servicio de serialización de diseñador que se basa en crear árboles CodeDOM para los objetos.|  
|<xref:System.ComponentModel.Design.Serialization.ComponentSerializationService>|Este servicio reemplaza <xref:System.ComponentModel.Design.Serialization.IDesignerSerializationService> como un medio para serializar los componentes en un objeto binario.|  
  
 Para obtener más información sobre los servicios reemplazables y que no sean reemplazables, consulte <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">No se ha inicializado la interfaz <see cref="T:System.ComponentModel.Design.Serialization.IDesignerLoaderHost" /> o el cargador de diseñadores no ha proporcionado un servicio de resolución de tipos, tal y como requiere la serialización de CodeDOM.</exception>
        <altmember cref="T:System.CodeDom.Compiler.ICodeGenerator" />
        <altmember cref="T:System.ComponentModel.Design.ITypeResolutionService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.ComponentSerializationService" />
        <altmember cref="T:System.ComponentModel.Design.Serialization.INameCreationService" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
      </Docs>
    </Member>
    <Member MemberName="IsReloadNeeded">
      <MemberSignature Language="C#" Value="protected override bool IsReloadNeeded ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool IsReloadNeeded() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.IsReloadNeeded" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function IsReloadNeeded () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool IsReloadNeeded();" />
      <MemberSignature Language="F#" Value="override this.IsReloadNeeded : unit -&gt; bool" Usage="codeDomDesignerLoader.IsReloadNeeded " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Devuelve un valor que indica si es necesario volver a cargar.</summary>
        <returns><see langword="true" /> si la propiedad <see cref="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider" /> decide que es necesario volver a cargar; en caso contrario, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.IsReloadNeeded%2A> método comprueba la presencia de la <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload> interfaz en el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.CodeDomProvider%2A>. El proveedor de repetición de análisis de árbol CodeDOM y pasar el árbol de análisis resultante a la <xref:System.ComponentModel.Design.Serialization.ICodeDomDesignerReload.ShouldReloadDesigner%2A> método. Si este método devuelve `false`, no se volverá a cargar el diseñador.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El lenguaje no ha proporcionado un analizador de código para este archivo; puede que este tipo de archivo no admita un diseñador.</exception>
        <exception cref="T:System.InvalidOperationException">Aunque se haya diseñado la clase, no es la primera clase en el archivo o no se ha podido mostrar el diseñador para ese archivo en particular porque no es posible diseñar ninguna de las clases que contiene.</exception>
      </Docs>
    </Member>
    <Member MemberName="OnBeginLoad">
      <MemberSignature Language="C#" Value="protected override void OnBeginLoad ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBeginLoad() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginLoad" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBeginLoad ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBeginLoad();" />
      <MemberSignature Language="F#" Value="override this.OnBeginLoad : unit -&gt; unit" Usage="codeDomDesignerLoader.OnBeginLoad " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica al cargador de diseñadores que la carga está a punto de comenzar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginLoad%2A> método, consulte <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnBeginLoad%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnBeginUnload">
      <MemberSignature Language="C#" Value="protected override void OnBeginUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnBeginUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginUnload" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnBeginUnload ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnBeginUnload();" />
      <MemberSignature Language="F#" Value="override this.OnBeginUnload : unit -&gt; unit" Usage="codeDomDesignerLoader.OnBeginUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Notifica al cargador de diseñadores que la descarga está a punto de comenzar.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnBeginUnload%2A> método, consulte <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnBeginUnload%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="OnComponentRename">
      <MemberSignature Language="C#" Value="protected virtual void OnComponentRename (object component, string oldName, string newName);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnComponentRename(object component, string oldName, string newName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnComponentRename(System.Object,System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnComponentRename (component As Object, oldName As String, newName As String)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnComponentRename(System::Object ^ component, System::String ^ oldName, System::String ^ newName);" />
      <MemberSignature Language="F#" Value="abstract member OnComponentRename : obj * string * string -&gt; unit&#xA;override this.OnComponentRename : obj * string * string -&gt; unit" Usage="codeDomDesignerLoader.OnComponentRename (component, oldName, newName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="component" Type="System.Object" />
        <Parameter Name="oldName" Type="System.String" />
        <Parameter Name="newName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="component">Componente al que se va a cambiar el nombre.</param>
        <param name="oldName">Nombre original del componente.</param>
        <param name="newName">Nombre nuevo del componente.</param>
        <summary>Genera el evento <see cref="E:System.ComponentModel.Design.IComponentChangeService.ComponentRename" />.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="OnEndLoad">
      <MemberSignature Language="C#" Value="protected override void OnEndLoad (bool successful, System.Collections.ICollection errors);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void OnEndLoad(bool successful, class System.Collections.ICollection errors) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnEndLoad(System.Boolean,System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub OnEndLoad (successful As Boolean, errors As ICollection)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void OnEndLoad(bool successful, System::Collections::ICollection ^ errors);" />
      <MemberSignature Language="F#" Value="override this.OnEndLoad : bool * System.Collections.ICollection -&gt; unit" Usage="codeDomDesignerLoader.OnEndLoad (successful, errors)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="successful" Type="System.Boolean" />
        <Parameter Name="errors" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="successful">Es <see langword="true" /> para indicar que la carga se ha completado satisfactoriamente; de lo contrario, es <see langword="false" />.</param>
        <param name="errors">Interfaz <see cref="T:System.Collections.ICollection" /> de objetos (normalmente excepciones) de los cuales se han creado informes de error.</param>
        <summary>Notifica al cargador de diseñadores que se ha completado la carga.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Para obtener más información sobre la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.OnEndLoad%2A> método, consulte <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.OnEndLoad%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="protected abstract System.CodeDom.CodeCompileUnit Parse ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.CodeDom.CodeCompileUnit Parse() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function Parse () As CodeCompileUnit" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::CodeDom::CodeCompileUnit ^ Parse();" />
      <MemberSignature Language="F#" Value="abstract member Parse : unit -&gt; System.CodeDom.CodeCompileUnit" Usage="codeDomDesignerLoader.Parse " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.CodeDom.CodeCompileUnit</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Analiza el texto u otro almacenamiento persistente y devuelve un objeto <see cref="T:System.CodeDom.CodeCompileUnit" />.</summary>
        <returns>Objeto <see cref="T:System.CodeDom.CodeCompileUnit" /> resultante de una operación de análisis.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A> método se llama cuando el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> necesita analizar el código fuente. Al derivar clases, se deben especificar la ubicación del código fuente y el formato.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
      </Docs>
    </Member>
    <Member MemberName="PerformFlush">
      <MemberSignature Language="C#" Value="protected override void PerformFlush (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PerformFlush(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush(System.ComponentModel.Design.Serialization.IDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PerformFlush (manager As IDesignerSerializationManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PerformFlush(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="override this.PerformFlush : System.ComponentModel.Design.Serialization.IDesignerSerializationManager -&gt; unit" Usage="codeDomDesignerLoader.PerformFlush manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Interfaz <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> a partir de la cual se va a solicitar el serializador.</param>
        <summary>Solicita la serialización del componente raíz del diseñador.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> método obtiene el objeto raíz <xref:System.ComponentModel.Design.Serialization.CodeDomSerializer> para el componente raíz del diseñador e invoca el serializador para serializar el componente. Si el resultado de esta operación es un <xref:System.CodeDom.CodeTypeDeclaration>, a continuación, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> se integra el <xref:System.CodeDom.CodeTypeDeclaration> con CodeDOM existente de árbol. El resultado es el árbol CodeDOM original con los miembros y reemplazarlos las instrucciones de coincidencia. Por último, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> llama al resumen <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> método para guardar este árbol CodeDOM.  
  
 Si la serialización de componente de diseñador raíz no tiene como resultado un <xref:System.CodeDom.CodeTypeDeclaration>, a continuación, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformFlush%2A> no hace nada más.  
  
> [!IMPORTANT]
>  Es responsabilidad del llamador asegurarse de que un CodeDOM se origina en un origen de confianza. Acepta un objeto CodeDOM de una entidad de confianza podría permitir que esta entidad ejecutar código malintencionado. Al vaciar un CodeDOM en un archivo, el marco de trabajo ejecutará el código representado por el objeto CodeDOM y el contenido serializado del objeto tal y como se proporciona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El lenguaje no ha proporcionado un analizador de código para este archivo; puede que este tipo de archivo no admita un diseñador.</exception>
        <exception cref="T:System.InvalidOperationException">Aunque se haya diseñado la clase, no es la primera clase en el archivo o no se ha podido mostrar el diseñador para ese archivo en particular porque no es posible diseñar ninguna de las clases que contiene.</exception>
      </Docs>
    </Member>
    <Member MemberName="PerformLoad">
      <MemberSignature Language="C#" Value="protected override void PerformLoad (System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void PerformLoad(class System.ComponentModel.Design.Serialization.IDesignerSerializationManager manager) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad(System.ComponentModel.Design.Serialization.IDesignerSerializationManager)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub PerformLoad (manager As IDesignerSerializationManager)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void PerformLoad(System::ComponentModel::Design::Serialization::IDesignerSerializationManager ^ manager);" />
      <MemberSignature Language="F#" Value="override this.PerformLoad : System.ComponentModel.Design.Serialization.IDesignerSerializationManager -&gt; unit" Usage="codeDomDesignerLoader.PerformLoad manager" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="manager" Type="System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
      </Parameters>
      <Docs>
        <param name="manager">Interfaz <see cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" /> a partir de la cual se va a solicitar el serializador.</param>
        <summary>Analiza el código de un proveedor CodeDOM.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> método obtiene un <xref:System.CodeDom.Compiler.ICodeParser> del proveedor CodeDOM y analiza el código. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> busca la primera clase en el archivo, obtiene un objeto raíz <xref:System.ComponentModel.Design.Serialization.CodeDomSerializer> para el tipo de datos y, a continuación, invoca el serializador para deserializar el tipo de datos. <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> se da por supuesto que este proceso creará todos los componentes necesarios en el <xref:System.ComponentModel.IContainer> de la <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.LoaderHost%2A> propiedad. Por último, <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.PerformLoad%2A> llamadas la <xref:System.ComponentModel.Design.Serialization.BasicDesignerLoader.SetBaseComponentClassName%2A> método con el nombre completo del tipo pasado al serializador de CodeDOM.  
  
> [!IMPORTANT]
>  Es responsabilidad del llamador asegurarse de que un CodeDOM se origina en un origen de confianza. Acepta un objeto CodeDOM de una entidad de confianza podría permitir que esta entidad ejecutar código malintencionado. Al cargar un CodeDOM en la superficie de diseño, el marco de trabajo ejecutará el código representado por el objeto CodeDOM y el contenido serializado del objeto tal y como se proporciona.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">El lenguaje no ha proporcionado un analizador de código para este archivo; puede que este tipo de archivo no admita un diseñador.</exception>
        <exception cref="T:System.InvalidOperationException">Aunque se haya diseñado la clase, no es la primera clase en el archivo o no se ha podido mostrar el diseñador para ese archivo en particular porque no es posible diseñar ninguna de las clases que contiene.</exception>
        <altmember cref="T:System.ComponentModel.Design.Serialization.IDesignerSerializationManager" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize">
      <MemberSignature Language="C#" Value="System.Collections.ICollection IDesignerSerializationService.Deserialize (object serializationData);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.ICollection System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize(object serializationData) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#IDesignerSerializationService#Deserialize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function Deserialize (serializationData As Object) As ICollection Implements IDesignerSerializationService.Deserialize" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::ICollection ^ System.ComponentModel.Design.Serialization.IDesignerSerializationService.Deserialize(System::Object ^ serializationData) = System::ComponentModel::Design::Serialization::IDesignerSerializationService::Deserialize;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.ICollection</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="serializationData" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="serializationData">Objeto formado por datos serializados.</param>
        <summary>Deserializa el objeto de datos de serialización especificado y devuelve una colección de objetos representada por dichos datos.</summary>
        <returns>Colección de objetos representada por <paramref name="serializationData" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><paramref name="serializationData" /> no es un <see cref="T:System.ComponentModel.Design.Serialization.SerializationStore" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize">
      <MemberSignature Language="C#" Value="object IDesignerSerializationService.Serialize (System.Collections.ICollection objects);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance object System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize(class System.Collections.ICollection objects) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#IDesignerSerializationService#Serialize(System.Collections.ICollection)" />
      <MemberSignature Language="VB.NET" Value="Function Serialize (objects As ICollection) As Object Implements IDesignerSerializationService.Serialize" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Object ^ System.ComponentModel.Design.Serialization.IDesignerSerializationService.Serialize(System::Collections::ICollection ^ objects) = System::ComponentModel::Design::Serialization::IDesignerSerializationService::Serialize;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="objects" Type="System.Collections.ICollection" />
      </Parameters>
      <Docs>
        <param name="objects">Colección de objetos que se va a serializar.</param>
        <summary>Serializa la colección de objetos especificada y almacena dichos objetos en un objeto de datos de serialización.</summary>
        <returns>Un objeto que contiene el estado serializado de la colección de objetos especificada.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException">No se encontró el objeto <see cref="T:System.ComponentModel.Design.Serialization.ComponentSerializationService" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.CreateName">
      <MemberSignature Language="C#" Value="string INameCreationService.CreateName (System.ComponentModel.IContainer container, Type dataType);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance string System.ComponentModel.Design.Serialization.INameCreationService.CreateName(class System.ComponentModel.IContainer container, class System.Type dataType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#CreateName(System.ComponentModel.IContainer,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Function CreateName (container As IContainer, dataType As Type) As String Implements INameCreationService.CreateName" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::String ^ System.ComponentModel.Design.Serialization.INameCreationService.CreateName(System::ComponentModel::IContainer ^ container, Type ^ dataType) = System::ComponentModel::Design::Serialization::INameCreationService::CreateName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="container" Type="System.ComponentModel.IContainer" />
        <Parameter Name="dataType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="container">Contenedor al que se agrega el objeto nuevo.</param>
        <param name="dataType">Tipo de datos del objeto que recibe el nombre.</param>
        <summary>Crea un nombre nuevo que es único para todos los componentes del contenedor especificado.</summary>
        <returns>Nombre único para el tipo de datos.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="dataType" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.IsValidName">
      <MemberSignature Language="C#" Value="bool INameCreationService.IsValidName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.ComponentModel.Design.Serialization.INameCreationService.IsValidName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#IsValidName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Function IsValidName (name As String) As Boolean Implements INameCreationService.IsValidName" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.ComponentModel.Design.Serialization.INameCreationService.IsValidName(System::String ^ name) = System::ComponentModel::Design::Serialization::INameCreationService::IsValidName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a validar.</param>
        <summary>Obtiene un valor que indica si el nombre especificado es válido.</summary>
        <returns>Es <see langword="true" /> si el nombre es válido; en caso contrario, es <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.ComponentModel.Design.Serialization.INameCreationService.ValidateName">
      <MemberSignature Language="C#" Value="void INameCreationService.ValidateName (string name);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.ComponentModel.Design.Serialization.INameCreationService.ValidateName(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.System#ComponentModel#Design#Serialization#INameCreationService#ValidateName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Sub ValidateName (name As String) Implements INameCreationService.ValidateName" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.ComponentModel.Design.Serialization.INameCreationService.ValidateName(System::String ^ name) = System::ComponentModel::Design::Serialization::INameCreationService::ValidateName;" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name">Nombre que se va a validar.</param>
        <summary>Obtiene un valor que indica si el nombre especificado es válido.</summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException">El valor de <paramref name="name" /> es <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="name" /> no es un identificador válido, o ya existe un componente con el mismo nombre.</exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolutionService">
      <MemberSignature Language="C#" Value="protected abstract System.ComponentModel.Design.ITypeResolutionService TypeResolutionService { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ComponentModel.Design.ITypeResolutionService TypeResolutionService" />
      <MemberSignature Language="DocId" Value="P:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.TypeResolutionService" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride ReadOnly Property TypeResolutionService As ITypeResolutionService" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract property System::ComponentModel::Design::ITypeResolutionService ^ TypeResolutionService { System::ComponentModel::Design::ITypeResolutionService ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeResolutionService : System.ComponentModel.Design.ITypeResolutionService" Usage="System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.TypeResolutionService" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ComponentModel.Design.ITypeResolutionService</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Obtiene el servicio de resolución de tipos que se va a utilizar con este cargador de diseñadores.</summary>
        <value>Interfaz <see cref="T:System.ComponentModel.Design.ITypeResolutionService" /> que los serializadores CodeDOM van a utilizar para la resolución de tipos.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> agrega automáticamente este <xref:System.ComponentModel.Design.ITypeResolutionService> al contenedor de servicios cuando el <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Initialize%2A> se invoca el método. Aunque el servicio de resolución de tipos es opcional en muchos escenarios, es necesario para la interpretación de código como código fuente contiene el tipo de nombres, pero ninguna referencia de ensamblado.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.ComponentModel.Design.ITypeResolutionService" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
      </Docs>
    </Member>
    <Member MemberName="Write">
      <MemberSignature Language="C#" Value="protected abstract void Write (System.CodeDom.CodeCompileUnit unit);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Write(class System.CodeDom.CodeCompileUnit unit) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write(System.CodeDom.CodeCompileUnit)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Write (unit As CodeCompileUnit)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Write(System::CodeDom::CodeCompileUnit ^ unit);" />
      <MemberSignature Language="F#" Value="abstract member Write : System.CodeDom.CodeCompileUnit -&gt; unit" Usage="codeDomDesignerLoader.Write unit" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Design</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="unit" Type="System.CodeDom.CodeCompileUnit" />
      </Parameters>
      <Docs>
        <param name="unit">Objeto <see cref="T:System.CodeDom.CodeCompileUnit" /> que se va a conservar.</param>
        <summary>Escribe los cambios de la unidad de compilación en un almacenamiento persistente.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> método ahorra un <xref:System.CodeDom.CodeCompileUnit> al almacenamiento persistente. La clase derivada es responsable de invocar el <xref:System.CodeDom.Compiler.ICodeGenerator> en el escritor de texto adecuado para guardar el código. El <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader> garantiza que los objetos CodeDOM que se pasan a <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> son las mismas instancias de objetos que se recuperaron de <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Parse%2A>, excepto en casos donde el proceso de serialización se tenía que realizar cambios en el código. Esto permite que un cargador de diseñadores optimizado almacenar datos adicionales en el <xref:System.CodeDom.CodeObject.UserData%2A> propiedad de los elementos de código. Estos datos estarán disponibles durante la <xref:System.ComponentModel.Design.Serialization.CodeDomDesignerLoader.Write%2A> método para cualquier elemento que no se han reemplazado por el proceso de serialización.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.CodeDom.CodeCompileUnit" />
        <related type="Article" href="https://msdn.microsoft.com/library/d077a3e8-bd81-4bdf-b6a3-323857ea30fb">Generación y compilación dinámicas de código fuente</related>
      </Docs>
    </Member>
  </Members>
</Type>