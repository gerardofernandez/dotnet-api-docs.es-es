<Type Name="SafeHandle" FullName="System.Runtime.InteropServices.SafeHandle">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d2b9e9ff0e52b9e5a2e934301d96f816c0615296" /><Meta Name="ms.sourcegitcommit" Value="2dd0eede6edd6dd3d2aa8f79010848658b967609" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="04/17/2019" /><Meta Name="ms.locfileid" Value="59676525" /></Metadata><TypeSignature Language="C#" Value="public abstract class SafeHandle : System.Runtime.ConstrainedExecution.CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi abstract beforefieldinit SafeHandle extends System.Runtime.ConstrainedExecution.CriticalFinalizerObject implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.SafeHandle" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class SafeHandle&#xA;Inherits CriticalFinalizerObject&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SafeHandle abstract : System::Runtime::ConstrainedExecution::CriticalFinalizerObject, IDisposable" />
  <TypeSignature Language="F#" Value="type SafeHandle = class&#xA;    inherit CriticalFinalizerObject&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Handles</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Runtime.ConstrainedExecution.CriticalFinalizerObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
      <AttributeName>System.Security.SecurityCritical</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="3f28a-101">Representa una clase contenedora para los identificadores del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-101">Represents a wrapper class for operating system handles.</span></span> <span data-ttu-id="3f28a-102">Se debe heredar esta clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-102">This class must be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-103">La <xref:System.Runtime.InteropServices.SafeHandle> clase proporciona finalización crítica de los recursos de controlador, que impide identificadores reclame prematuramente por la recolección y se recicle por Windows para hacer referencia a objetos no administrados no deseados.</span><span class="sxs-lookup"><span data-stu-id="3f28a-103">The <xref:System.Runtime.InteropServices.SafeHandle> class provides critical finalization of handle resources, preventing handles from being reclaimed prematurely by garbage collection and from being recycled by Windows to reference unintended unmanaged objects.</span></span>  
  
 <span data-ttu-id="3f28a-104">En este tema, se incluyen las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="3f28a-104">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="3f28a-105">[¿Por qué SafeHandle?](#Why) </span><span class="sxs-lookup"><span data-stu-id="3f28a-105">[Why SafeHandle?](#Why) </span></span>  
 <span data-ttu-id="3f28a-106">[¿Qué SafeHandle](#Does) </span><span class="sxs-lookup"><span data-stu-id="3f28a-106">[What SafeHandle does](#Does) </span></span>  
 [<span data-ttu-id="3f28a-107">Clases derivadas de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="3f28a-107">Classes derived from SafeHandle</span></span>](#Derived)  
  
<a name="Why"></a>   
## <a name="why-safehandle"></a><span data-ttu-id="3f28a-108">¿Por qué SafeHandle?</span><span class="sxs-lookup"><span data-stu-id="3f28a-108">Why SafeHandle?</span></span>  
 <span data-ttu-id="3f28a-109">Antes de .NET Framework versión 2.0, todos los sistema operativos identificadores solo se pueden encapsular en el <xref:System.IntPtr> objeto contenedor administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-109">Before the .NET Framework version 2.0, all operating system handles could only be encapsulated in the <xref:System.IntPtr> managed wrapper object.</span></span> <span data-ttu-id="3f28a-110">Aunque esto fue una manera cómoda de interoperar con código nativo, se filtre controla las excepciones asincrónicas, por ejemplo, un subproceso que se anulase inesperadamente o un desbordamiento de pila.</span><span class="sxs-lookup"><span data-stu-id="3f28a-110">While this was a convenient way to interoperate with native code, handles could be leaked by asynchronous exceptions, such as a thread aborting unexpectedly or a stack overflow.</span></span> <span data-ttu-id="3f28a-111">Estas excepciones asincrónicas son un obstáculo para limpiar los recursos del sistema operativo y se pueden producir prácticamente en cualquier parte de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="3f28a-111">These asynchronous exceptions are an obstacle to cleaning up operating system resources, and they can occur almost anywhere in your app.</span></span>  
  
 <span data-ttu-id="3f28a-112">Aunque reemplaza a la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método permitir la limpieza de recursos no administrados cuando un objeto se recopila en algunas circunstancias, los objetos finalizables pueden ser reclamados por la recolección al ejecutar un método dentro de una plataforma de invocación llamada.</span><span class="sxs-lookup"><span data-stu-id="3f28a-112">Although overrides to the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method allow cleanup of unmanaged resources when an object is being garbage collected, in some circumstances, finalizable objects can be reclaimed by garbage collection while executing a method within a platform invoke call.</span></span> <span data-ttu-id="3f28a-113">Si un finalizador libera el identificador pasado a esa plataforma llamada de invocación, que podría dar lugar a dañar el identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-113">If a finalizer frees the handle passed to that platform invoke call, it could lead to handle corruption.</span></span> <span data-ttu-id="3f28a-114">El identificador también se podría recuperar mientras el método se bloquea durante una plataforma de la llamada, como al leer un archivo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-114">The handle could also be reclaimed while your method is blocked during a platform invoke call, such as while reading a file.</span></span>  
  
 <span data-ttu-id="3f28a-115">Más fundamental, porque Windows recicla agresivamente los identificadores, un identificador podría se recicle y apunte a otro recurso que podría contener datos confidenciales.</span><span class="sxs-lookup"><span data-stu-id="3f28a-115">More critically, because Windows aggressively recycles handles, a handle could be recycled and point to another resource that might contain sensitive data.</span></span> <span data-ttu-id="3f28a-116">Esto se conoce como ataque de reciclaje y puede dañar los datos y ser una amenaza de seguridad.</span><span class="sxs-lookup"><span data-stu-id="3f28a-116">This is known as a recycle attack and can potentially corrupt data and be a security threat.</span></span>  
  
<a name="Does"></a>   
## <a name="what-safehandle-does"></a><span data-ttu-id="3f28a-117">¿Qué SafeHandle</span><span class="sxs-lookup"><span data-stu-id="3f28a-117">What SafeHandle does</span></span>  
 <span data-ttu-id="3f28a-118">La <xref:System.Runtime.InteropServices.SafeHandle> clase simplifica algunos de estos problemas de duración de objetos y se integra con la plataforma de invocación de modo que no haya fugas de recursos del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-118">The <xref:System.Runtime.InteropServices.SafeHandle> class simplifies several of these object lifetime issues, and is integrated with platform invoke so that operating system resources are not leaked.</span></span> <span data-ttu-id="3f28a-119">La <xref:System.Runtime.InteropServices.SafeHandle> clase resuelve los problemas de duración de objetos asignando y liberando identificadores sin interrupción.</span><span class="sxs-lookup"><span data-stu-id="3f28a-119">The <xref:System.Runtime.InteropServices.SafeHandle> class resolves object lifetime issues by assigning and releasing handles without interruption.</span></span> <span data-ttu-id="3f28a-120">Contiene un finalizador crítico que garantiza que el identificador se cierra y se garantiza la ejecución durante inesperado <xref:System.AppDomain> descarga, incluso en casos cuando la llamada de invocación de plataforma se supone que en un estado dañado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-120">It contains a critical finalizer that ensures that the handle is closed and is guaranteed to run during unexpected <xref:System.AppDomain> unloads, even in cases when the platform invoke call is assumed to be in a corrupted state.</span></span>  
  
 <span data-ttu-id="3f28a-121">Dado que <xref:System.Runtime.InteropServices.SafeHandle> hereda <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, se llama a todos los finalizadores no críticos antes que cualquiera de los finalizadores críticos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-121">Because <xref:System.Runtime.InteropServices.SafeHandle> inherits from <xref:System.Runtime.ConstrainedExecution.CriticalFinalizerObject>, all the noncritical finalizers are called before any of the critical finalizers.</span></span> <span data-ttu-id="3f28a-122">Se llaman a los finalizadores en los objetos que ya no están activos durante el mismo paso de la colección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="3f28a-122">The finalizers are called on objects that are no longer live during the same garbage collection pass.</span></span> <span data-ttu-id="3f28a-123">Por ejemplo, un <xref:System.IO.FileStream> objeto puede ejecutar un finalizador normal para vaciar los datos almacenados en búfer existentes sin el riesgo de que el identificador que se pierda o se recicle.</span><span class="sxs-lookup"><span data-stu-id="3f28a-123">For example, a <xref:System.IO.FileStream> object can run a normal finalizer to flush out existing buffered data without the risk of the handle being leaked or recycled.</span></span> <span data-ttu-id="3f28a-124">Esta ordenación muy débil entre los finalizadores críticos y no está pensada para uso general.</span><span class="sxs-lookup"><span data-stu-id="3f28a-124">This very weak ordering between critical and noncritical finalizers is not intended for general use.</span></span> <span data-ttu-id="3f28a-125">Existe principalmente para ayudar en la migración de bibliotecas existentes al permitir que esas bibliotecas utilizar <xref:System.Runtime.InteropServices.SafeHandle> sin modificar su semántica.</span><span class="sxs-lookup"><span data-stu-id="3f28a-125">It exists primarily to assist in the migration of existing libraries by allowing those libraries to use <xref:System.Runtime.InteropServices.SafeHandle> without altering their semantics.</span></span> <span data-ttu-id="3f28a-126">Además, el finalizador crítico y cualquier otra cosa las llamadas, como el <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> método, debe estar en una región de ejecución restringida.</span><span class="sxs-lookup"><span data-stu-id="3f28a-126">Additionally, the critical finalizer and anything it calls, such as the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle?displayProperty=nameWithType> method, must be in a constrained execution region.</span></span> <span data-ttu-id="3f28a-127">Esto impone restricciones sobre qué código se puede escribir en el gráfico de llamadas del finalizador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-127">This imposes constraints on what code can be written within the finalizer's call graph.</span></span>  
  
 <span data-ttu-id="3f28a-128">Las operaciones de invocación de plataforma automáticamente incrementar el recuento de referencias de identificadores encapsulados por un <xref:System.Runtime.InteropServices.SafeHandle> y ellos decremento tras la finalización.</span><span class="sxs-lookup"><span data-stu-id="3f28a-128">Platform invoke operations automatically increment the reference count of handles encapsulated by a <xref:System.Runtime.InteropServices.SafeHandle> and decrement them upon completion.</span></span> <span data-ttu-id="3f28a-129">Esto garantiza que el identificador no se recicle o cerró de forma inesperada.</span><span class="sxs-lookup"><span data-stu-id="3f28a-129">This ensures that the handle will not be recycled or closed unexpectedly.</span></span>  
  
 <span data-ttu-id="3f28a-130">Puede especificar la propiedad del identificador subyacente al construir <xref:System.Runtime.InteropServices.SafeHandle> objetos proporcionando un valor para el `ownsHandle` argumento en el <xref:System.Runtime.InteropServices.SafeHandle> constructor de clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-130">You can specify ownership of the underlying handle when constructing <xref:System.Runtime.InteropServices.SafeHandle> objects by supplying a value to the `ownsHandle` argument in the <xref:System.Runtime.InteropServices.SafeHandle> class constructor.</span></span> <span data-ttu-id="3f28a-131">Esta opción controla si el <xref:System.Runtime.InteropServices.SafeHandle> objeto libere el identificador después de que el objeto se ha eliminado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-131">This controls whether the <xref:System.Runtime.InteropServices.SafeHandle> object will release the handle after the object has been disposed.</span></span>  <span data-ttu-id="3f28a-132">Esto es útil para los identificadores con requisitos de duración específicos o para utilizar un identificador cuya duración está controlada por otra persona.</span><span class="sxs-lookup"><span data-stu-id="3f28a-132">This is useful for handles with peculiar lifetime requirements or for consuming a handle whose lifetime is controlled by someone else.</span></span>  
  
<a name="Derived"></a>   
## <a name="classes-derived-from-safehandle"></a><span data-ttu-id="3f28a-133">Clases derivadas de SafeHandle</span><span class="sxs-lookup"><span data-stu-id="3f28a-133">Classes derived from SafeHandle</span></span>  
 <span data-ttu-id="3f28a-134"><xref:System.Runtime.InteropServices.SafeHandle> es una clase contenedora abstracta para los identificadores del sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-134"><xref:System.Runtime.InteropServices.SafeHandle> is an abstract wrapper class for operating system handles.</span></span> <span data-ttu-id="3f28a-135">Es difícil derivar de esta clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-135">Deriving from this class is difficult.</span></span> <span data-ttu-id="3f28a-136">En su lugar, use las clases derivadas del espacio de nombres <xref:Microsoft.Win32.SafeHandles> que proporcionan controladores seguros para lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="3f28a-136">Instead, use the derived classes in the <xref:Microsoft.Win32.SafeHandles> namespace that provide safe handles for the following:</span></span>  
  
-   <span data-ttu-id="3f28a-137">Los archivos (el <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-137">Files (the <xref:Microsoft.Win32.SafeHandles.SafeFileHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-138">Archivos asignados a memoria (el <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-138">Memory mapped files (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedFileHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-139">Canalizaciones (el <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-139">Pipes (the <xref:Microsoft.Win32.SafeHandles.SafePipeHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-140">Vistas de memoria (el <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-140">Memory views (the <xref:Microsoft.Win32.SafeHandles.SafeMemoryMappedViewHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-141">Construcciones de criptografía (el <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, y <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> clases).</span><span class="sxs-lookup"><span data-stu-id="3f28a-141">Cryptography constructs (the <xref:Microsoft.Win32.SafeHandles.SafeNCryptHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle>, <xref:Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle>, and <xref:Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle> classes).</span></span>  
  
-   <span data-ttu-id="3f28a-142">Los procesos (el <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-142">Processes (the <xref:Microsoft.Win32.SafeHandles.SafeProcessHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-143">Las claves del registro (el <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-143">Registry keys (the <xref:Microsoft.Win32.SafeHandles.SafeRegistryHandle> class).</span></span>  
  
-   <span data-ttu-id="3f28a-144">Identificadores de espera (el <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> clase).</span><span class="sxs-lookup"><span data-stu-id="3f28a-144">Wait handles (the <xref:Microsoft.Win32.SafeHandles.SafeWaitHandle> class).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f28a-145">En el ejemplo de código siguiente se crea un identificador seguro personalizado para un identificador de archivo del sistema operativo, derivar de <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-145">The following code example creates a custom safe handle for an operating system file handle, deriving from <xref:Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid>.</span></span> <span data-ttu-id="3f28a-146">Lee los bytes de un archivo y muestra sus valores hexadecimales.</span><span class="sxs-lookup"><span data-stu-id="3f28a-146">It reads bytes from a file and displays their hexadecimal values.</span></span> <span data-ttu-id="3f28a-147">También contiene un error en la herramienta de comprobación que hace que el subproceso se anule, pero el valor de identificador se libera.</span><span class="sxs-lookup"><span data-stu-id="3f28a-147">It also contains a fault testing harness that causes the thread to abort, but the handle value is freed.</span></span>  <span data-ttu-id="3f28a-148">Cuando se usa un <xref:System.IntPtr> para representar los identificadores, el identificador en ocasiones, se pierde debido a la anulación de subproceso asincrónicas.</span><span class="sxs-lookup"><span data-stu-id="3f28a-148">When using an <xref:System.IntPtr> to represent handles, the handle is occasionally leaked due to the asynchronous thread abort.</span></span>  
  
 <span data-ttu-id="3f28a-149">Necesitará un archivo de texto en la misma carpeta que la aplicación compilada.</span><span class="sxs-lookup"><span data-stu-id="3f28a-149">You will need a text file in the same folder as the compiled application.</span></span> <span data-ttu-id="3f28a-150">Suponiendo que el nombre de la aplicación "HexViewer", el uso de la línea de comandos es:</span><span class="sxs-lookup"><span data-stu-id="3f28a-150">Assuming that you name the application "HexViewer", the command line usage is:</span></span>  
  
 `HexViewer <filename> -Fault`  
  
 <span data-ttu-id="3f28a-151">Opcionalmente, especificar `-Fault` para intentar intencionadamente a perder el identificador anulando el subproceso en una ventana de determinados.</span><span class="sxs-lookup"><span data-stu-id="3f28a-151">Optionally specify `-Fault` to intentionally attempt to leak the handle by aborting the thread in a certain window.</span></span> <span data-ttu-id="3f28a-152">Utilice la herramienta Windows Perfmon.exe para supervisar los contadores del identificador al insertar los errores.</span><span class="sxs-lookup"><span data-stu-id="3f28a-152">Use the Windows Perfmon.exe tool to monitor handle counts while injecting faults.</span></span>  
  
 [!code-csharp[SafeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="3f28a-153">para plena confianza para los herederos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-153">for full trust for inheritors.</span></span> <span data-ttu-id="3f28a-154">Este miembro no puede heredarse mediante código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="3f28a-154">This member cannot be inherited by partially trusted code.</span></span></permission>
    <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3f28a-155">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3f28a-155">requires full trust for the immediate caller.</span></span> <span data-ttu-id="3f28a-156">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-156">This member cannot be used by partially trusted or transparent code.</span></span></permission>
    <block subset="none" type="overrides"><para><span data-ttu-id="3f28a-157">Para crear una clase derivada de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, debe saber cómo crear y liberar un identificador de sistema operativo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-157">To create a class derived from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must know how to create and free an operating system handle.</span></span> <span data-ttu-id="3f28a-158">Este proceso es diferente para los tipos de identificador distintos porque algunos utilizan el [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) funcione, mientras que otros usan funciones más específicas, como [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) o [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span><span class="sxs-lookup"><span data-stu-id="3f28a-158">This process is different for different handle types because some use the [CloseHandle](https://msdn.microsoft.com/library/windows/desktop/ms724211.aspx) function, while others use more specific functions such as [UnmapViewOfFile](https://msdn.microsoft.com/library/windows/desktop/aa366882.aspx) or [FindClose](https://msdn.microsoft.com/library/windows/desktop/aa364413.aspx).</span></span> <span data-ttu-id="3f28a-159">Por este motivo, debe crear una clase derivada de <see cref="T:System.Runtime.InteropServices.SafeHandle" /> para cada tipo de identificador de sistema operativo que se va a incluir en un controlador seguro.</span><span class="sxs-lookup"><span data-stu-id="3f28a-159">For this reason, you must create a derived class of <see cref="T:System.Runtime.InteropServices.SafeHandle" /> for each operating system handle type that you want to wrap in a safe handle.</span></span>  
  
<span data-ttu-id="3f28a-160">Al heredar de <see cref="T:System.Runtime.InteropServices.SafeHandle" />, es necesario reemplazar los miembros siguientes: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> y <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-160">When you inherit from <see cref="T:System.Runtime.InteropServices.SafeHandle" />, you must override the following members: <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> and <see cref="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />.</span></span>  
  
<span data-ttu-id="3f28a-161">También debe proporcionar un constructor predeterminado que llama al constructor base con un valor que representan un valor de identificador no válido, y un <see cref="T:System.Boolean" /> valor que indica si el identificador nativo es propiedad del <see cref="T:System.Runtime.InteropServices.SafeHandle" /> y por lo tanto debe liberarse cuando que <see cref="T:System.Runtime.InteropServices.SafeHandle" /> se ha eliminado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-161">You should also provide a default constructor that calls the base constructor with a value that represent an invalid handle value, and a <see cref="T:System.Boolean" /> value indicating whether the native handle is owned by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> and consequently should be freed when that <see cref="T:System.Runtime.InteropServices.SafeHandle" /> has been disposed.</span></span></para></block>
    <altmember cref="N:Microsoft.Win32.SafeHandles" />
    <altmember cref="T:System.Runtime.InteropServices.CriticalHandle" />
    <altmember cref="T:System.Runtime.ConstrainedExecution.CriticalFinalizerObject" />
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected SafeHandle (IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(native int invalidHandleValue, bool ownsHandle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.#ctor(System.IntPtr,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (invalidHandleValue As IntPtr, ownsHandle As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);" />
      <MemberSignature Language="F#" Value="new System.Runtime.InteropServices.SafeHandle : nativeint * bool -&gt; System.Runtime.InteropServices.SafeHandle" Usage="new System.Runtime.InteropServices.SafeHandle (invalidHandleValue, ownsHandle)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="invalidHandleValue" Type="System.IntPtr" />
        <Parameter Name="ownsHandle" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="invalidHandleValue"><span data-ttu-id="3f28a-162">Valor de un identificador no válido (normalmente 0 ó -1).</span><span class="sxs-lookup"><span data-stu-id="3f28a-162">The value of an invalid handle (usually 0 or -1).</span></span>  <span data-ttu-id="3f28a-163">La implementación de <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> debería devolver <see langword="true" /> para este valor.</span><span class="sxs-lookup"><span data-stu-id="3f28a-163">Your implementation of <see cref="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" /> should return <see langword="true" /> for this value.</span></span></param>
        <param name="ownsHandle"><span data-ttu-id="3f28a-164"><see langword="true" /> para permitir con confiabilidad que <see cref="T:System.Runtime.InteropServices.SafeHandle" /> libere el identificador durante la fase de finalización; de lo contrario, <see langword="false" /> (no se recomienda).</span><span class="sxs-lookup"><span data-stu-id="3f28a-164"><see langword="true" /> to reliably let <see cref="T:System.Runtime.InteropServices.SafeHandle" /> release the handle during the finalization phase; otherwise, <see langword="false" /> (not recommended).</span></span></param>
        <summary><span data-ttu-id="3f28a-165">Inicializa una nueva instancia de la clase <see cref="T:System.Runtime.InteropServices.SafeHandle" /> con un valor de identificador no válido especificado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-165">Initializes a new instance of the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class with the specified invalid handle value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-166">Si el `ownsHandle` parámetro es `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nunca se llama; por lo tanto, no se recomienda usar este valor de parámetro como su código puede producir pérdida de recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-166">If the `ownsHandle` parameter is `false`, <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> is never called; thus, it is not recommended to use this parameter value as your code may leak resources.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="3f28a-167">La clase derivada reside en un ensamblado sin permiso de acceso a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-167">The derived class resides in an assembly without unmanaged code access permission.</span></span></exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.InheritanceDemand"><span data-ttu-id="3f28a-168">para plena confianza para los herederos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-168">for full trust for inheritors.</span></span> <span data-ttu-id="3f28a-169">Este miembro no puede heredarse mediante código de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="3f28a-169">This member cannot be inherited by partially trusted code.</span></span></permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="3f28a-170">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="3f28a-170">requires full trust for the immediate caller.</span></span> <span data-ttu-id="3f28a-171">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-171">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="safeHandle.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0;netstandard-1.5">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-172">Marca el identificador para soltar y liberar recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-172">Marks the handle for releasing and freeing resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-173">Una llamada a la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método permite que se liberen los recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-173">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="3f28a-174">Esto podría no reflejarse inmediatamente si otros subprocesos utilizan el mismo objeto de controlador seguro, pero se realizará en cuanto ya no es así.</span><span class="sxs-lookup"><span data-stu-id="3f28a-174">This might not happen immediately if other threads are using the same safe handle object, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="3f28a-175">Aunque la mayoría de las clases que usan el <xref:System.Runtime.InteropServices.SafeHandle> clase no es necesario proporcionar un finalizador, esto a veces es necesario (por ejemplo, para vaciar los búferes de archivos o para escribir algunos datos de copia en la memoria).</span><span class="sxs-lookup"><span data-stu-id="3f28a-175">Although most classes that use the <xref:System.Runtime.InteropServices.SafeHandle> class do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="3f28a-176">En este caso, la clase puede proporcionar un finalizador que garantiza la ejecución antes de la <xref:System.Runtime.InteropServices.SafeHandle> ejecute finalizador crítico.</span><span class="sxs-lookup"><span data-stu-id="3f28a-176">In this case, the class can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="3f28a-177">Llame a la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método cuando haya terminado con el <xref:System.Runtime.InteropServices.SafeHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-177">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f28a-178">Llame siempre a <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> antes de liberar la última referencia a la <xref:System.Runtime.InteropServices.SafeHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-178">Always call <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="3f28a-179">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Runtime.InteropServices.SafeHandle> del objeto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-179">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-180">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-180">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-181">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-181">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-182">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-182">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousAddRef">
      <MemberSignature Language="C#" Value="public void DangerousAddRef (ref bool success);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousAddRef(bool&amp; success) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousAddRef (ByRef success As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousAddRef(bool % success);" />
      <MemberSignature Language="F#" Value="member this.DangerousAddRef :  -&gt; unit" Usage="safeHandle.DangerousAddRef success" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="success" Type="System.Boolean" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="success"><span data-ttu-id="3f28a-183">Es <see langword="true" /> si se ha aumentado correctamente el recuento de referencias; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-183"><see langword="true" /> if the reference counter was successfully incremented; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="3f28a-184">Aumenta manualmente el recuento de referencias en instancias de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-184">Manually increments the reference counter on <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instances.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-185">El <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> método evita que common language runtime reclame memoria utilizada por un identificador (que se produce cuando el tiempo de ejecución llama a la <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> método).</span><span class="sxs-lookup"><span data-stu-id="3f28a-185">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> method prevents the common language runtime from reclaiming memory used by a handle (which occurs when the runtime calls the <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method).</span></span> <span data-ttu-id="3f28a-186">Puede usar este método aumentarás manualmente el recuento de referencias en un <xref:System.Runtime.InteropServices.SafeHandle> instancia.</span><span class="sxs-lookup"><span data-stu-id="3f28a-186">You can use this method to manually increment the reference count on a <xref:System.Runtime.InteropServices.SafeHandle> instance.</span></span> <span data-ttu-id="3f28a-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> Devuelve un valor booleano mediante un `ref` parámetro (`success`) que indica si el recuento de referencias se incrementa correctamente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-187"><xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> returns a Boolean value using a `ref` parameter (`success`) that indicates whether the reference count was incremented successfully.</span></span> <span data-ttu-id="3f28a-188">Esto permite que la lógica del programa hacia atrás en caso de error.</span><span class="sxs-lookup"><span data-stu-id="3f28a-188">This allows your program logic to back out in case of failure.</span></span> <span data-ttu-id="3f28a-189">Debe establecer `success` a `false` antes de llamar a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-189">You should set `success` to `false` before calling <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="3f28a-190">Si `success` es `true`, evitar pérdidas de recursos haciendo coincidir la llamada a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> con una llamada correspondiente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-190">If `success` is `true`, avoid resource leaks by matching the call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> with a corresponding call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3f28a-191">Este método está pensado para usuarios avanzados y siempre debe utilizarse con cuidado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-191">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="3f28a-192">Para evitar la pérdida de los recursos de controlador, llame siempre a este método dentro de una región de ejecución restringida (CER), donde una anulación de subproceso no puede interrumpir el procesamiento.</span><span class="sxs-lookup"><span data-stu-id="3f28a-192">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-193">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-193">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-194">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-194">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-195">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-195">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      </Docs>
    </Member>
    <Member MemberName="DangerousGetHandle">
      <MemberSignature Language="C#" Value="public IntPtr DangerousGetHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int DangerousGetHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetHandle () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr DangerousGetHandle();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetHandle : unit -&gt; nativeint" Usage="safeHandle.DangerousGetHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-196">Devuelve el valor del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-196">Returns the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span></span></summary>
        <returns><span data-ttu-id="3f28a-197"><see langword="IntPtr" /> que representa el valor del campo <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-197">An <see langword="IntPtr" /> representing the value of the <see cref="F:System.Runtime.InteropServices.SafeHandle.handle" /> field.</span></span> <span data-ttu-id="3f28a-198">Si el identificador se ha marcado como no válido con <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, este método todavía devuelve el valor del identificador original, que puede ser un valor obsoleto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-198">If the handle has been marked invalid with <see cref="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />, this method still returns the original handle value, which can be a stale value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-199">Puede usar este método para recuperar el valor del identificador real de una instancia de la <xref:System.Runtime.InteropServices.SafeHandle> clase derivada.</span><span class="sxs-lookup"><span data-stu-id="3f28a-199">You can use this method to retrieve the actual handle value from an instance of the <xref:System.Runtime.InteropServices.SafeHandle> derived class.</span></span> <span data-ttu-id="3f28a-200">Este método es necesaria para hacia atrás compatibilidad porque muchas propiedades de .NET Framework devuelven `IntPtr` controlar tipos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-200">This method is needed for backwards compatibility because many properties in the .NET Framework return `IntPtr` handle types.</span></span> <span data-ttu-id="3f28a-201">`IntPtr` tipos de identificador son tipos específicos de la plataforma utilizados para representar un puntero o un identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-201">`IntPtr` handle types are platform-specific types used to represent a pointer or a handle.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3f28a-202">Mediante el <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> método puede suponer riesgos de seguridad porque, si se ha marcado como no válido con el identificador <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> sigue devolviendo el valor del identificador original, potencialmente obsoletos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-202">Using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> method can pose security risks because, if the handle has been marked as invalid with <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A>, <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> still returns the original, potentially stale handle value.</span></span> <span data-ttu-id="3f28a-203">También se puede reciclar en cualquier momento el identificador devuelto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-203">The returned handle can also be recycled at any point.</span></span> <span data-ttu-id="3f28a-204">En el mejor, esto significa que el identificador, de repente, es posible que dejen de funcionar.</span><span class="sxs-lookup"><span data-stu-id="3f28a-204">At best, this means the handle might suddenly stop working.</span></span> <span data-ttu-id="3f28a-205">En el peor, si el identificador o el recurso que representa el identificador se expone al código de confianza, esto puede provocar un ataque de seguridad de reciclaje en el identificador reutilizado o devuelto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-205">At worst, if the handle or the resource that the handle represents is exposed to untrusted code, this can lead to a recycling security attack on the reused or returned handle.</span></span> <span data-ttu-id="3f28a-206">Por ejemplo, un llamador de confianza puede consultar datos en el controlador simplemente devueltos y recibir información para un recurso completamente no relacionado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-206">For example, an untrusted caller can query data on the handle just returned and receive information for an entirely unrelated resource.</span></span> <span data-ttu-id="3f28a-207">Consulte la <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> y <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> métodos para obtener más información sobre el uso de la <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span><span class="sxs-lookup"><span data-stu-id="3f28a-207">See the <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> and the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> methods for more information about using the <xref:System.Runtime.InteropServices.SafeHandle.DangerousGetHandle%2A> methodsafely.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-208">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-208">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-209">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-209">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-210">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-210">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DangerousRelease">
      <MemberSignature Language="C#" Value="public void DangerousRelease ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DangerousRelease() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.DangerousRelease" />
      <MemberSignature Language="VB.NET" Value="Public Sub DangerousRelease ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DangerousRelease();" />
      <MemberSignature Language="F#" Value="member this.DangerousRelease : unit -&gt; unit" Usage="safeHandle.DangerousRelease " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-211">Disminuye manualmente el recuento de referencias en una instancia de <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-211">Manually decrements the reference counter on a <see cref="T:System.Runtime.InteropServices.SafeHandle" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-212">El <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> método es el equivalente a <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-212">The <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method is the counterpart to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span> <span data-ttu-id="3f28a-213">Siempre debe coincidir con una llamada a la <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> método con una llamada correcta al <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-213">You should always match a call to the <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> method with a successful call to <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A>.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="3f28a-214">Este método está pensado para usuarios avanzados y siempre debe utilizarse con cuidado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-214">This method is intended for advanced users and must always be used carefully.</span></span> <span data-ttu-id="3f28a-215">Para evitar la pérdida de los recursos de controlador, llame siempre a este método dentro de una región de ejecución restringida (CER), donde una anulación de subproceso no puede interrumpir el procesamiento.</span><span class="sxs-lookup"><span data-stu-id="3f28a-215">To avoid leaking handle resources, always call this method inside a constrained execution region (CER), where a thread abort cannot interrupt processing.</span></span> <span data-ttu-id="3f28a-216">En la misma manera que no coincidentes <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> llamadas pueden producir pérdidas de recursos, sin parangón <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> llamadas pueden hacer que sea visible para otros subprocesos los Estados de identificador no válido.</span><span class="sxs-lookup"><span data-stu-id="3f28a-216">In the same way that unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> calls can cause resource leaks, unmatched <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls can cause invalid handle states to become visible to other threads.</span></span> <span data-ttu-id="3f28a-217">No exponga <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> o <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> las llamadas a código no seguro.</span><span class="sxs-lookup"><span data-stu-id="3f28a-217">Do not expose <xref:System.Runtime.InteropServices.SafeHandle.DangerousAddRef%2A> or <xref:System.Runtime.InteropServices.SafeHandle.DangerousRelease%2A> calls to untrusted code.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-218">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-218">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-219">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-219">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-220">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-220">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.DangerousAddRef(System.Boolean@)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="3f28a-221">Libera los recursos que usa la clase <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-221">Releases the resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="safeHandle.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-222">Libera todos los recursos que utiliza la clase <see cref="T:System.Runtime.InteropServices.SafeHandle" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-222">Releases all resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-223">Una llamada a la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método permite que se liberen los recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-223">Calling the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method allows the resources to be freed.</span></span> <span data-ttu-id="3f28a-224">Esto podría no reflejarse inmediatamente si otros subprocesos utilizan la misma instancia del controlador seguro, pero se realizará en cuanto ya no es así.</span><span class="sxs-lookup"><span data-stu-id="3f28a-224">This might not happen immediately if other threads are using the same instance of the safe handle, but will happen as soon as that is no longer the case.</span></span> <span data-ttu-id="3f28a-225">Aunque más clases con <xref:System.Runtime.InteropServices.SafeHandle> no es necesario proporcionar un finalizador, esto a veces es necesario (por ejemplo, para vaciar los búferes de archivo o para escribir algunos datos en memoria).</span><span class="sxs-lookup"><span data-stu-id="3f28a-225">Although most classes using <xref:System.Runtime.InteropServices.SafeHandle> do not need to provide a finalizer, this is sometimes necessary (for example, to flush out file buffers or to write some data back into memory).</span></span> <span data-ttu-id="3f28a-226">En este caso, puede proporcionar un finalizador que garantiza la ejecución antes de la <xref:System.Runtime.InteropServices.SafeHandle> ejecute finalizador crítico.</span><span class="sxs-lookup"><span data-stu-id="3f28a-226">In this case, they can provide a finalizer that is guaranteed to run before the <xref:System.Runtime.InteropServices.SafeHandle> critical finalizer runs.</span></span>  
  
 <span data-ttu-id="3f28a-227">Llame a la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método cuando haya terminado con el <xref:System.Runtime.InteropServices.SafeHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-227">Call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method when you are finished using the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="3f28a-228">El <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> método deja la <xref:System.Runtime.InteropServices.SafeHandle> objeto en un estado inutilizable.</span><span class="sxs-lookup"><span data-stu-id="3f28a-228">The <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method leaves the <xref:System.Runtime.InteropServices.SafeHandle> object in an unusable state.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="3f28a-229">Llame siempre a la <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> o <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método antes de liberar la última referencia a la <xref:System.Runtime.InteropServices.SafeHandle> objeto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-229">Always call the <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> or <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method before you release your last reference to the <xref:System.Runtime.InteropServices.SafeHandle> object.</span></span> <span data-ttu-id="3f28a-230">En caso contrario, los recursos que está usando no se liberarán hasta que el recolector de elementos no utilizados llame al método <xref:System.Runtime.InteropServices.SafeHandle> del objeto <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-230">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Runtime.InteropServices.SafeHandle> object's <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-231">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-231">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-232">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-232">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-233">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-233">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="safeHandle.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="3f28a-234"><see langword="true" /> para una operación de desecho normal; <see langword="false" /> para finalizar el identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-234"><see langword="true" /> for a normal dispose operation; <see langword="false" /> to finalize the handle.</span></span></param>
        <summary><span data-ttu-id="3f28a-235">Libera los recursos no administrados utilizados por la clase <see cref="T:System.Runtime.InteropServices.SafeHandle" /> que especifica si se va a realizar una operación de desecho normal.</span><span class="sxs-lookup"><span data-stu-id="3f28a-235">Releases the unmanaged resources used by the <see cref="T:System.Runtime.InteropServices.SafeHandle" /> class specifying whether to perform a normal dispose operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-236">Se debe llamar nunca explícitamente la <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método con el `disposing` parámetro establecido en `false`.</span><span class="sxs-lookup"><span data-stu-id="3f28a-236">You should never explicitly call the <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method with the `disposing` parameter set to `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-237">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-237">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-238">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-238">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-239">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-239">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SafeHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SafeHandle ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="safeHandle.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-240">Libera todos los recursos asociados al identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-240">Frees all resources associated with the handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-241">El <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> método es el destructor para la <xref:System.Runtime.InteropServices.SafeHandle> clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-241">The <xref:System.Runtime.InteropServices.SafeHandle.Finalize%2A> method is the destructor for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span> <span data-ttu-id="3f28a-242">Código de la aplicación no debe llamar directamente a este método.</span><span class="sxs-lookup"><span data-stu-id="3f28a-242">Application code should not call this method directly.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-243">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-243">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-244">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-244">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-245">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-245">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.SafeHandle.Dispose" />
      </Docs>
    </Member>
    <Member MemberName="handle">
      <MemberSignature Language="C#" Value="protected IntPtr handle;" />
      <MemberSignature Language="ILAsm" Value=".field family native int handle" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberSignature Language="VB.NET" Value="Protected handle As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="protected: IntPtr handle;" />
      <MemberSignature Language="F#" Value="val mutable handle : nativeint" Usage="System.Runtime.InteropServices.SafeHandle.handle" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f28a-246">Especifica el identificador que se va a ajustar.</span><span class="sxs-lookup"><span data-stu-id="3f28a-246">Specifies the handle to be wrapped.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-247">No exponer públicamente el identificador (es decir, fuera de la clase derivada).</span><span class="sxs-lookup"><span data-stu-id="3f28a-247">Do not expose the handle publicly (that is, outside of the derived class).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClosed">
      <MemberSignature Language="C#" Value="public bool IsClosed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClosed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClosed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClosed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClosed : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsClosed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f28a-248">Obtiene un valor que indica si el identificador está cerrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-248">Gets a value indicating whether the handle is closed.</span></span></summary>
        <value><span data-ttu-id="3f28a-249">Es <see langword="true" /> si el identificador está cerrado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-249"><see langword="true" /> if the handle is closed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-250">El <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> método devuelve un valor que indica si el <xref:System.Runtime.InteropServices.SafeHandle> identificador del objeto ya no está asociado con un recurso nativo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-250">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a value indicating whether the <xref:System.Runtime.InteropServices.SafeHandle> object's handle is no longer associated with a native resource.</span></span> <span data-ttu-id="3f28a-251">Esto difiere de la definición de la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propiedad, que calcula si un identificador determinado siempre se considera no válido.</span><span class="sxs-lookup"><span data-stu-id="3f28a-251">This differs from the definition of the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property, which computes whether a given handle is always considered invalid.</span></span> <span data-ttu-id="3f28a-252">El <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> método devuelve un `true` valor en los casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="3f28a-252">The <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> method returns a `true` value in the following cases:</span></span>  
  
-   <span data-ttu-id="3f28a-253">El <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> se llamó al método.</span><span class="sxs-lookup"><span data-stu-id="3f28a-253">The <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method was called.</span></span>  
  
-   <span data-ttu-id="3f28a-254">El <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> método o <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> se llamó al método y no hay ninguna referencia a la <xref:System.Runtime.InteropServices.SafeHandle> objeto en otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-254">The <xref:System.Runtime.InteropServices.SafeHandle.Dispose%2A> method or <xref:System.Runtime.InteropServices.SafeHandle.Close%2A> method was called and there are no references to the <xref:System.Runtime.InteropServices.SafeHandle> object on other threads.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-255">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-255">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-256">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-256">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-257">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-257">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsInvalid">
      <MemberSignature Language="C#" Value="public abstract bool IsInvalid { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInvalid" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property IsInvalid As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property bool IsInvalid { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInvalid : bool" Usage="System.Runtime.InteropServices.SafeHandle.IsInvalid" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="3f28a-258">Cuando se invalida en una clase derivada, obtiene un valor que indica si este identificador es no válido.</span><span class="sxs-lookup"><span data-stu-id="3f28a-258">When overridden in a derived class, gets a value indicating whether the handle value is invalid.</span></span></summary>
        <value><span data-ttu-id="3f28a-259">Es <see langword="true" /> si el identificador no es válido; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-259"><see langword="true" /> if the handle value is invalid; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-260">Las clases derivadas deben implementar la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propiedad para que common language runtime pueda determinar si se requiere la finalización crítica.</span><span class="sxs-lookup"><span data-stu-id="3f28a-260">Derived classes must implement the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property so that the common language runtime can determine whether critical finalization is required.</span></span> <span data-ttu-id="3f28a-261">Las clases derivadas deben proporcionar una implementación que se ajuste al tipo de identificador que admiten general (0 o -1 no es válido).</span><span class="sxs-lookup"><span data-stu-id="3f28a-261">Derived classes must provide an implementation that suits the general type of handle they support (0 or -1 is invalid).</span></span> <span data-ttu-id="3f28a-262">Estas clases, a continuación, se pueden derivar para tipos específicos de controlador seguro.</span><span class="sxs-lookup"><span data-stu-id="3f28a-262">These classes can then be further derived for specific safe handle types.</span></span>  
  
 <span data-ttu-id="3f28a-263">A diferencia de la <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> propiedad, que informa de si el <xref:System.Runtime.InteropServices.SafeHandle> objeto ha finalizado con el identificador subyacente, la <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propiedad calcula si el valor de identificador determinado siempre se considera no válido.</span><span class="sxs-lookup"><span data-stu-id="3f28a-263">Unlike the <xref:System.Runtime.InteropServices.SafeHandle.IsClosed%2A> property, which reports whether the <xref:System.Runtime.InteropServices.SafeHandle> object has finished using the underlying handle, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property calculates whether the given handle value is always considered invalid.</span></span> <span data-ttu-id="3f28a-264">Por lo tanto, el <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propiedad siempre devuelve el mismo valor para cualquier valor de identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-264">Therefore, the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property always returns the same value for any one handle value.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f28a-265">El ejemplo siguiente comprueba si un archivo se abrió correctamente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-265">The following example checks if a file was opened successfully.</span></span> <span data-ttu-id="3f28a-266">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Runtime.InteropServices.SafeHandle> clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-266">This code example is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#2](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#2)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-267">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-267">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-268">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-268">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-269">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-269">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ReleaseHandle">
      <MemberSignature Language="C#" Value="protected abstract bool ReleaseHandle ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool ReleaseHandle() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.ReleaseHandle" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function ReleaseHandle () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool ReleaseHandle();" />
      <MemberSignature Language="F#" Value="abstract member ReleaseHandle : unit -&gt; bool" Usage="safeHandle.ReleaseHandle " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-270">Cuando se invalida en una clase derivada, ejecuta el código necesario para liberar el identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-270">When overridden in a derived class, executes the code required to free the handle.</span></span></summary>
        <returns><span data-ttu-id="3f28a-271"><see langword="true" /> si el identificador se libera correctamente; en caso contrario, si se produce un error grave, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-271"><see langword="true" /> if the handle is released successfully; otherwise, in the event of a catastrophic failure, <see langword="false" />.</span></span> <span data-ttu-id="3f28a-272">En este caso, genera un Asistente para depuración administrada <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-272">In this case, it generates a <see href="https://docs.microsoft.com/dotnet/framework/debug-trace-profile/releasehandlefailed-mda">releaseHandleFailed</see> Managed Debugging Assistant.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-273">El <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> se garantiza que el método se llama solo una vez y solo si el identificador es válido según se define en el <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="3f28a-273">The <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method is guaranteed to be called only once and only if the handle is valid as defined by the <xref:System.Runtime.InteropServices.SafeHandle.IsInvalid%2A> property.</span></span> <span data-ttu-id="3f28a-274">Implemente este método en su <xref:System.Runtime.InteropServices.SafeHandle> sus clases derivadas para ejecutar cualquier código necesario para liberar el identificador.</span><span class="sxs-lookup"><span data-stu-id="3f28a-274">Implement this method in your <xref:System.Runtime.InteropServices.SafeHandle> derived classes to execute any code that is required to free the handle.</span></span> <span data-ttu-id="3f28a-275">Dado que una de las funciones de <xref:System.Runtime.InteropServices.SafeHandle> es garantizar la prevención de pérdidas de recursos, el código en la implementación de <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> nunca debe producir un error.</span><span class="sxs-lookup"><span data-stu-id="3f28a-275">Because one of the functions of <xref:System.Runtime.InteropServices.SafeHandle> is to guarantee prevention of resource leaks, the code in your implementation of <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> must never fail.</span></span> <span data-ttu-id="3f28a-276">El recolector de elementos no utilizados llame al <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> después de que se han ejecutado los finalizadores normales para los objetos que se recolectan al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="3f28a-276">The garbage collector calls <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> after normal finalizers have been run for objects that were garbage collected at the same time.</span></span> <span data-ttu-id="3f28a-277">El recolector de elementos no utilizados garantiza que los recursos para invocar este método y el método no se interrumpirán mientras está en curso.</span><span class="sxs-lookup"><span data-stu-id="3f28a-277">The garbage collector guarantees the resources to invoke this method and that the method will not be interrupted while it is in progress.</span></span> <span data-ttu-id="3f28a-278">Este método se preparará como una región de ejecución restringida (CER) en tiempo de construcción de la instancia (junto con todos los métodos en su gráfico de llamadas determinarse de forma estática).</span><span class="sxs-lookup"><span data-stu-id="3f28a-278">This method will be prepared as a constrained execution region (CER) at instance construction time (along with all the methods in its statically determinable call graph).</span></span> <span data-ttu-id="3f28a-279">Aunque esto evita las interrupciones de anulación de subproceso, aún debe procurar no introducir las rutas de acceso de cualquier error en anulado <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> método.</span><span class="sxs-lookup"><span data-stu-id="3f28a-279">Although this prevents thread abort interrupts, you must still be careful not to introduce any fault paths in your overridden <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> method.</span></span> <span data-ttu-id="3f28a-280">En particular, aplique el <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atribuir a los métodos que llama desde <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span><span class="sxs-lookup"><span data-stu-id="3f28a-280">In particular, apply the <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute to any methods you call from <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A>.</span></span> <span data-ttu-id="3f28a-281">En la mayoría de los casos, este código debe ser:</span><span class="sxs-lookup"><span data-stu-id="3f28a-281">In most cases this code should be:</span></span>  
  
 `ReliabilityContract(Consistency.WillNotCorruptState, Cer.Success)`  
  
 <span data-ttu-id="3f28a-282">Además, para la limpieza sencilla (por ejemplo, al llamar a la API de Windows `CloseHandle` en un identificador de archivo) puede comprobar el valor devuelto de la llamada de invocación de plataforma única.</span><span class="sxs-lookup"><span data-stu-id="3f28a-282">Additionally, for simple cleanup (for example, calling the Windows API `CloseHandle` on a file handle) you can check the return value for the single platform invoke call.</span></span> <span data-ttu-id="3f28a-283">Para la limpieza compleja, es posible que tiene mucha lógica del programa y muchas llamadas a métodos, algunos de los cuales pueden producir un error.</span><span class="sxs-lookup"><span data-stu-id="3f28a-283">For complex cleanup, you may have a lot of program logic and many method calls, some of which might fail.</span></span> <span data-ttu-id="3f28a-284">Debe asegurarse de que la lógica del programa tiene código de reserva para cada uno de los casos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-284">You must ensure that your program logic has fallback code for each of those cases.</span></span>  
  
 <span data-ttu-id="3f28a-285">Si <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> devuelve `false` por cualquier motivo, genera un [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Asistente para depuración administrada.</span><span class="sxs-lookup"><span data-stu-id="3f28a-285">If <xref:System.Runtime.InteropServices.SafeHandle.ReleaseHandle%2A> returns `false` for any reason, it generates a [releaseHandleFailed](~/docs/framework/debug-trace-profile/releasehandlefailed-mda.md) Managed Debugging Assistant.</span></span>  <span data-ttu-id="3f28a-286">Esto ayuda a detectar los casos donde se produce un error en el intento de liberar los recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-286">This helps you detect cases where your attempt to release resources fails.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="3f28a-287">En el ejemplo de código siguiente se libera el identificador y forma parte de un ejemplo más extenso proporcionado para el <xref:System.Runtime.InteropServices.SafeHandle> clase.</span><span class="sxs-lookup"><span data-stu-id="3f28a-287">The following code example releases the handle and is part of a larger example provided for the <xref:System.Runtime.InteropServices.SafeHandle> class.</span></span>  
  
 [!code-csharp[SafeHandle#3](~/samples/snippets/csharp/VS_Snippets_CLR/SafeHandle/CS/program.cs#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-288">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-288">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-289">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-289">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-290">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-290">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/76994ee6-9fa9-4059-b813-26578d24427c"><span data-ttu-id="3f28a-291">Diagnóstico de errores de tiempo de ejecución con asistentes para la depuración administradas</span><span class="sxs-lookup"><span data-stu-id="3f28a-291">Diagnosing Run-time Errors with Managed Debugging Assistants</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/44cd98ba-95e5-40a1-874d-e8e163612c51"><span data-ttu-id="3f28a-292">ReleaseHandleFailed</span><span class="sxs-lookup"><span data-stu-id="3f28a-292">ReleaseHandleFailed</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetHandle">
      <MemberSignature Language="C#" Value="protected void SetHandle (IntPtr handle);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void SetHandle(native int handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandle(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub SetHandle (handle As IntPtr)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void SetHandle(IntPtr handle);" />
      <MemberSignature Language="F#" Value="member this.SetHandle : nativeint -&gt; unit" Usage="safeHandle.SetHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="3f28a-293">El identificador preexistente que se va a utilizar.</span><span class="sxs-lookup"><span data-stu-id="3f28a-293">The pre-existing handle to use.</span></span></param>
        <summary><span data-ttu-id="3f28a-294">Establece el identificador en el identificador preexistente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-294">Sets the handle to the specified pre-existing handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-295">Use el <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> identificadores en una estructura de salida del método solo si tiene que proporcionar compatibilidad con un identificador ya existente (por ejemplo, si se devuelve el identificador en una estructura) porque la infraestructura de interoperabilidad COM de .NET Framework no admite el cálculo de referencias.</span><span class="sxs-lookup"><span data-stu-id="3f28a-295">Use the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method only if you need to support a pre-existing handle (for example, if the handle is returned in a structure) because the .NET Framework COM interop infrastructure does not support marshaling output handles in a structure.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-296">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-296">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-297">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-297">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-298">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-298">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetHandleAsInvalid">
      <MemberSignature Language="C#" Value="public void SetHandleAsInvalid ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetHandleAsInvalid() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetHandleAsInvalid ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetHandleAsInvalid();" />
      <MemberSignature Language="F#" Value="member this.SetHandleAsInvalid : unit -&gt; unit" Usage="safeHandle.SetHandleAsInvalid " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Handles</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netstandard-1.5">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-1.5;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="3f28a-299">Marca un identificador para indicar que ya no se utiliza.</span><span class="sxs-lookup"><span data-stu-id="3f28a-299">Marks a handle as no longer used.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="3f28a-300">Llame a la <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> método solo cuando sepa que el identificador ya no hace referencia a un recurso.</span><span class="sxs-lookup"><span data-stu-id="3f28a-300">Call the <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> method only when you know that your handle no longer references a resource.</span></span> <span data-ttu-id="3f28a-301">Si lo hace, no cambia el valor de la <xref:System.Runtime.InteropServices.SafeHandle.handle> campo; solo marca el identificador como cerrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-301">Doing so does not change the value of the <xref:System.Runtime.InteropServices.SafeHandle.handle> field; it only marks the handle as closed.</span></span> <span data-ttu-id="3f28a-302">El identificador puede contener, a continuación, un valor potencialmente obsoleto.</span><span class="sxs-lookup"><span data-stu-id="3f28a-302">The handle might then contain a potentially stale value.</span></span> <span data-ttu-id="3f28a-303">El efecto de esta llamada es que se realiza ningún intento para liberar los recursos.</span><span class="sxs-lookup"><span data-stu-id="3f28a-303">The effect of this call is that no attempt is made to free the resources.</span></span>  
  
 <span data-ttu-id="3f28a-304">Igual que con el <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> método, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> solo si tiene que proporcionar compatibilidad con un identificador preexistente.</span><span class="sxs-lookup"><span data-stu-id="3f28a-304">As with the <xref:System.Runtime.InteropServices.SafeHandle.SetHandle%2A> method, use <xref:System.Runtime.InteropServices.SafeHandle.SetHandleAsInvalid%2A> only if you need to support a pre-existing handle.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="3f28a-305">Para obtener permiso llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="3f28a-305">for permission to call unmanaged code.</span></span> <span data-ttu-id="3f28a-306">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span><span class="sxs-lookup"><span data-stu-id="3f28a-306">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span></span> <span data-ttu-id="3f28a-307">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="3f28a-307">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>