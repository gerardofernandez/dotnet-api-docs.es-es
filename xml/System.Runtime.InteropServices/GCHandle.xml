<Type Name="GCHandle" FullName="System.Runtime.InteropServices.GCHandle">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="b20a2203f75e0e9b7932a09da51f7c716cc49dfd" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36538350" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct GCHandle" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit GCHandle extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.InteropServices.GCHandle" />
  <TypeSignature Language="VB.NET" Value="Public Structure GCHandle" />
  <TypeSignature Language="C++ CLI" Value="public value class GCHandle" />
  <TypeSignature Language="F#" Value="type GCHandle = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.InteropServices</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>
      <span data-ttu-id="0cd05-101">Proporciona una forma de obtener acceso a un objeto administrado desde la memoria no administrada.</span>
      <span class="sxs-lookup">
        <span data-stu-id="0cd05-101">Provides a way to access a managed object from unmanaged memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-102">El <xref:System.Runtime.InteropServices.GCHandle> estructura se usa con el <xref:System.Runtime.InteropServices.GCHandleType> enumeración para crear un identificador que corresponde a los objetos administrados.</span><span class="sxs-lookup"><span data-stu-id="0cd05-102">The <xref:System.Runtime.InteropServices.GCHandle> structure is used with the <xref:System.Runtime.InteropServices.GCHandleType> enumeration to create a handle corresponding to any managed object.</span></span> <span data-ttu-id="0cd05-103">Este identificador puede ser uno de cuatro tipos: `Weak`, `WeakTrackResurrection`, `Normal`, o `Pinned`.</span><span class="sxs-lookup"><span data-stu-id="0cd05-103">This handle can be one of four types: `Weak`, `WeakTrackResurrection`, `Normal`, or `Pinned`.</span></span> <span data-ttu-id="0cd05-104">Cuando se ha asignado el identificador, se puede usar para impedir que el objeto administrado que se recopilan por el recolector de elementos no utilizados cuando un cliente no administrado contiene la única referencia.</span><span class="sxs-lookup"><span data-stu-id="0cd05-104">When the handle has been allocated, you can use it to prevent the managed object from being collected by the garbage collector when an unmanaged client holds the only reference.</span></span> <span data-ttu-id="0cd05-105">Sin un identificador de este tipo, el objeto se puede recopilar el recolector de elementos no utilizados antes de completar su trabajo en nombre del cliente no administrado.</span><span class="sxs-lookup"><span data-stu-id="0cd05-105">Without such a handle, the object can be collected by the garbage collector before completing its work on behalf of the unmanaged client.</span></span>  
  
 <span data-ttu-id="0cd05-106">También puede usar <xref:System.Runtime.InteropServices.GCHandle> para crear un objeto anclado que devuelva una dirección de memoria para evitar que el recolector de elementos no utilizados al mover el objeto en la memoria.</span><span class="sxs-lookup"><span data-stu-id="0cd05-106">You can also use <xref:System.Runtime.InteropServices.GCHandle> to create a pinned object that returns a memory address to prevent the garbage collector from moving the object in memory.</span></span>  
  
 <span data-ttu-id="0cd05-107">Cuando el controlador sale del ámbito debe libere de forma explícita mediante una llamada a la <xref:System.Runtime.InteropServices.GCHandle.Free%2A> método; pueden producirse pérdidas de memoria en caso contrario,.</span><span class="sxs-lookup"><span data-stu-id="0cd05-107">When the handle goes out of scope you must explicitly release it by calling the <xref:System.Runtime.InteropServices.GCHandle.Free%2A> method; otherwise, memory leaks may occur.</span></span> <span data-ttu-id="0cd05-108">Al liberar un controlador anclado, el objeto asociado se liberarán y estará apto para la recolección de elementos no utilizados, si no hay ninguna otra referencia a él.</span><span class="sxs-lookup"><span data-stu-id="0cd05-108">When you free a pinned handle, the associated object will be unpinned and will become eligible for garbage collection, if there are no other references to it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0cd05-109">El ejemplo siguiente muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-109">The following example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-110">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-110">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr>.</span></span> <span data-ttu-id="0cd05-111">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-111">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
  </Docs>
  <Members>
    <Member MemberName="AddrOfPinnedObject">
      <MemberSignature Language="C#" Value="public IntPtr AddrOfPinnedObject ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance native int AddrOfPinnedObject() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.AddrOfPinnedObject" />
      <MemberSignature Language="VB.NET" Value="Public Function AddrOfPinnedObject () As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr AddrOfPinnedObject();" />
      <MemberSignature Language="F#" Value="member this.AddrOfPinnedObject : unit -&gt; nativeint" Usage="gCHandle.AddrOfPinnedObject " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-112">Recupera la dirección de un objeto en un identificador <see cref="F:System.Runtime.InteropServices.GCHandleType.Pinned" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-112">Retrieves the address of an object in a <see cref="F:System.Runtime.InteropServices.GCHandleType.Pinned" /> handle.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-113">Dirección del objeto anclado como <see cref="T:System.IntPtr" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-113">The address of the pinned object as an <see cref="T:System.IntPtr" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-114">Este método se utiliza para obtener un puntero estable al objeto.</span><span class="sxs-lookup"><span data-stu-id="0cd05-114">This method is used to get a stable pointer to the object.</span></span> <span data-ttu-id="0cd05-115">Al anclar un objeto impide que el recolector de elementos no utilizados moverlo en la memoria, lo que reduce la eficacia del recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="0cd05-115">Pinning an object prevents the garbage collector from moving it around in memory, thereby reducing the efficiency of the garbage collector.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0cd05-116">El identificador es de cualquier tipo menos <see cref="F:System.Runtime.InteropServices.GCHandleType.Pinned" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-116">The handle is any type other than <see cref="F:System.Runtime.InteropServices.GCHandleType.Pinned" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-117">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-117">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-118">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-118">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Alloc">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-119">Asigna un identificador para el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-119">Allocates a handle for the specified object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Alloc">
      <MemberSignature Language="C#" Value="public static System.Runtime.InteropServices.GCHandle Alloc (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.InteropServices.GCHandle Alloc(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.Alloc(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Alloc (value As Object) As GCHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::InteropServices::GCHandle Alloc(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="static member Alloc : obj -&gt; System.Runtime.InteropServices.GCHandle" Usage="System.Runtime.InteropServices.GCHandle.Alloc value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.GCHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-120">Objeto que utiliza <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-120">The object that uses the <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-121">Asigna un identificador <see cref="F:System.Runtime.InteropServices.GCHandleType.Normal" /> para el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-121">Allocates a <see cref="F:System.Runtime.InteropServices.GCHandleType.Normal" /> handle for the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-122">Nuevo <see cref="T:System.Runtime.InteropServices.GCHandle" /> que protege al objeto de la recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-122">A new <see cref="T:System.Runtime.InteropServices.GCHandle" /> that protects the object from garbage collection.</span>
          </span>
          <span data-ttu-id="0cd05-123">
            <see cref="T:System.Runtime.InteropServices.GCHandle" /> debe liberarse con <see cref="M:System.Runtime.InteropServices.GCHandle.Free" /> cuando ya no sea necesario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-123">This <see cref="T:System.Runtime.InteropServices.GCHandle" /> must be released with <see cref="M:System.Runtime.InteropServices.GCHandle.Free" /> when it is no longer needed.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-124"><xref:System.Runtime.InteropServices.GCHandleType.Normal> identificadores son opacos, lo que significa que no se puede resolver la dirección del objeto que contiene a través del identificador.</span><span class="sxs-lookup"><span data-stu-id="0cd05-124"><xref:System.Runtime.InteropServices.GCHandleType.Normal> handles are opaque, which means that you cannot resolve the address of the object it contains through the handle.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0cd05-125">El ejemplo siguiente muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-125">The following example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-126">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-126">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr>.</span></span> <span data-ttu-id="0cd05-127">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-127">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0cd05-128">Una instancia con miembros no primitivos (que no pueden transferirse en bloque de bits) no puede anclarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-128">An instance with nonprimitive (non-blittable) members cannot be pinned.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-129">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-129">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-130">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-130">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="Alloc">
      <MemberSignature Language="C#" Value="public static System.Runtime.InteropServices.GCHandle Alloc (object value, System.Runtime.InteropServices.GCHandleType type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.InteropServices.GCHandle Alloc(object value, valuetype System.Runtime.InteropServices.GCHandleType type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.Alloc(System.Object,System.Runtime.InteropServices.GCHandleType)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Alloc (value As Object, type As GCHandleType) As GCHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::InteropServices::GCHandle Alloc(System::Object ^ value, System::Runtime::InteropServices::GCHandleType type);" />
      <MemberSignature Language="F#" Value="static member Alloc : obj * System.Runtime.InteropServices.GCHandleType -&gt; System.Runtime.InteropServices.GCHandle" Usage="System.Runtime.InteropServices.GCHandle.Alloc (value, type)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.GCHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="type" Type="System.Runtime.InteropServices.GCHandleType" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-131">Objeto que utiliza <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-131">The object that uses the <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          </span>
        </param>
        <param name="type">
          <span data-ttu-id="0cd05-132">Uno de los valores de <see cref="T:System.Runtime.InteropServices.GCHandleType" />, que indica el tipo de <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a crear.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-132">One of the <see cref="T:System.Runtime.InteropServices.GCHandleType" /> values, indicating the type of <see cref="T:System.Runtime.InteropServices.GCHandle" /> to create.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-133">Asigna un identificador del tipo especificado para el objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-133">Allocates a handle of the specified type for the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-134">Nuevo <see cref="T:System.Runtime.InteropServices.GCHandle" /> del tipo especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-134">A new <see cref="T:System.Runtime.InteropServices.GCHandle" /> of the specified type.</span>
          </span>
          <span data-ttu-id="0cd05-135">
            <see cref="T:System.Runtime.InteropServices.GCHandle" /> debe liberarse con <see cref="M:System.Runtime.InteropServices.GCHandle.Free" /> cuando ya no sea necesario.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-135">This <see cref="T:System.Runtime.InteropServices.GCHandle" /> must be released with <see cref="M:System.Runtime.InteropServices.GCHandle.Free" /> when it is no longer needed.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="0cd05-136">Una instancia con miembros no primitivos (que no pueden transferirse en bloque de bits) no puede anclarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-136">An instance with nonprimitive (non-blittable) members cannot be pinned.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-137">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-137">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-138">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-138">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="gCHandle.Equals o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">
          <span data-ttu-id="0cd05-139">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a comparar con el objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-139">The <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to compare with the current <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-140">Determina si el objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> especificado es igual al objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-140">Determines whether the specified <see cref="T:System.Runtime.InteropServices.GCHandle" /> object is equal to the current <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-141">Es <see langword="true" /> si el objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> especificado es igual al objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> actual; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-141">
              <see langword="true" /> if the specified <see cref="T:System.Runtime.InteropServices.GCHandle" /> object is equal to the current <see cref="T:System.Runtime.InteropServices.GCHandle" /> object; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-142">Dos <xref:System.Runtime.InteropServices.GCHandle> objetos son iguales si señalan al mismo identificador de memoria.</span><span class="sxs-lookup"><span data-stu-id="0cd05-142">Two <xref:System.Runtime.InteropServices.GCHandle> objects are equal if they point to the same memory handle.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Free">
      <MemberSignature Language="C#" Value="public void Free ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Free() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.Free" />
      <MemberSignature Language="VB.NET" Value="Public Sub Free ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Free();" />
      <MemberSignature Language="F#" Value="member this.Free : unit -&gt; unit" Usage="gCHandle.Free " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-143">Libera un <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-143">Releases a <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-144">El llamador debe asegurarse de que para un identificador dado, <xref:System.Runtime.InteropServices.GCHandle.Free%2A> se llama solo una vez.</span><span class="sxs-lookup"><span data-stu-id="0cd05-144">The caller must ensure that for a given handle, <xref:System.Runtime.InteropServices.GCHandle.Free%2A> is called only once.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="0cd05-145">El ejemplo siguiente muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-145">The following example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-146">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-146">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr>.</span></span> <span data-ttu-id="0cd05-147">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-147">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0cd05-148">El identificador fue liberado o nunca se inicializó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-148">The handle was freed or never initialized.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-149">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-149">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-150">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-150">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="FromIntPtr">
      <MemberSignature Language="C#" Value="public static System.Runtime.InteropServices.GCHandle FromIntPtr (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Runtime.InteropServices.GCHandle FromIntPtr(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.FromIntPtr(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromIntPtr (value As IntPtr) As GCHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Runtime::InteropServices::GCHandle FromIntPtr(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member FromIntPtr : nativeint -&gt; System.Runtime.InteropServices.GCHandle" Usage="System.Runtime.InteropServices.GCHandle.FromIntPtr value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.GCHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-151">Identificador <see cref="T:System.IntPtr" /> a un objeto administrado del que se va a crear un objeto <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-151">An <see cref="T:System.IntPtr" /> handle to a managed object to create a <see cref="T:System.Runtime.InteropServices.GCHandle" /> object from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-152">Devuelve un nuevo objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> creado a partir de un identificador a un objeto administrado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-152">Returns a new <see cref="T:System.Runtime.InteropServices.GCHandle" /> object created from a handle to a managed object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-153">Nuevo objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que corresponde al parámetro por valor.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-153">A new <see cref="T:System.Runtime.InteropServices.GCHandle" /> object that corresponds to the value parameter.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0cd05-154">El siguiente ejemplo de código muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-154">The following code example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-155">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr> objeto.</span><span class="sxs-lookup"><span data-stu-id="0cd05-155">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr> object.</span></span> <span data-ttu-id="0cd05-156">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-156">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0cd05-157">El valor del parámetro <paramref name="value" /> es <see cref="F:System.IntPtr.Zero" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-157">The value of the <paramref name="value" /> parameter is <see cref="F:System.IntPtr.Zero" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-158">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-158">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-159">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-159">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="gCHandle.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-160">Devuelve un identificador para el objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-160">Returns an identifier for the current <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-161">Identificador para el objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-161">An identifier for the current <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-162">El <xref:System.Runtime.InteropServices.GCHandle.GetHashCode%2A> método devuelve una representación de entero del identificador de memoria interna encapsulado por el <xref:System.Runtime.InteropServices.GCHandle> estructura.</span><span class="sxs-lookup"><span data-stu-id="0cd05-162">The <xref:System.Runtime.InteropServices.GCHandle.GetHashCode%2A> method returns an integer representation of the internal memory handle encapsulated by the <xref:System.Runtime.InteropServices.GCHandle> structure.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAllocated">
      <MemberSignature Language="C#" Value="public bool IsAllocated { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAllocated" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.GCHandle.IsAllocated" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAllocated As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAllocated { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAllocated : bool" Usage="System.Runtime.InteropServices.GCHandle.IsAllocated" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-163">Obtiene un valor que indica si el identificador está asignado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-163">Gets a value indicating whether the handle is allocated.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0cd05-164">Es <see langword="true" /> si el identificador está asignado; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-164">
              <see langword="true" /> if the handle is allocated; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-165">Utilice esta propiedad cuando se usa <xref:System.Runtime.InteropServices.GCHandleType.Weak> controladores para determinar si el <xref:System.Runtime.InteropServices.GCHandle> sigue estando disponible.</span><span class="sxs-lookup"><span data-stu-id="0cd05-165">Use this property when using <xref:System.Runtime.InteropServices.GCHandleType.Weak> handles to determine if the <xref:System.Runtime.InteropServices.GCHandle> is still available.</span></span> <span data-ttu-id="0cd05-166">Cuando el recolector de elementos no utilizados recoge el objeto, el <xref:System.Runtime.InteropServices.GCHandleType.Weak> identificador aún puede restablecerse en el finalizador.</span><span class="sxs-lookup"><span data-stu-id="0cd05-166">When the garbage collector collects the object, the <xref:System.Runtime.InteropServices.GCHandleType.Weak> handle can still be resurrected in the finalizer.</span></span> <span data-ttu-id="0cd05-167">En ese caso, el identificador no se asigna (se pierde cuando el recolector de elementos no utilizados intenta recoger el objeto), aunque el objeto de destino es válido.</span><span class="sxs-lookup"><span data-stu-id="0cd05-167">In that case, the handle is not allocated (it is lost when the garbage collector attempts to collect the object), even though the target object is valid.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Runtime.InteropServices.GCHandle a, valuetype System.Runtime.InteropServices.GCHandle b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.op_Equality(System.Runtime.InteropServices.GCHandle,System.Runtime.InteropServices.GCHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (a As GCHandle, b As GCHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Runtime::InteropServices::GCHandle a, System::Runtime::InteropServices::GCHandle b);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Runtime.InteropServices.GCHandle * System.Runtime.InteropServices.GCHandle -&gt; bool" Usage="a = b" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Runtime.InteropServices.GCHandle" />
        <Parameter Name="b" Type="System.Runtime.InteropServices.GCHandle" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="0cd05-168">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a comparar con el parámetro <c>b</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-168">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to compare with the <c>b</c> parameter.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="0cd05-169">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a comparar con el parámetro <c>a</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-169">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to compare with the <c>a</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-170">Devuelve un valor que indica si dos objetos <see cref="T:System.Runtime.InteropServices.GCHandle" /> son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-170">Returns a value indicating whether two <see cref="T:System.Runtime.InteropServices.GCHandle" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-171">Es <see langword="true" /> si los parámetros <paramref name="a" /> y <paramref name="b" /> son iguales; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-171">
              <see langword="true" /> if the <paramref name="a" /> and <paramref name="b" /> parameters are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="0cd05-172">El método equivalente para este operador es <xref:System.Runtime.InteropServices.GCHandle.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-172">The equivalent method for this operator is <xref:System.Runtime.InteropServices.GCHandle.Equals%2A?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-173">Convierte el valor de un objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> en otro tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-173">Converts the value of a <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to another type.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Runtime.InteropServices.GCHandle (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Runtime.InteropServices.GCHandle op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.op_Explicit(System.IntPtr)~System.Runtime.InteropServices.GCHandle" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As GCHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Runtime::InteropServices::GCHandle(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; System.Runtime.InteropServices.GCHandle" Usage="System.Runtime.InteropServices.GCHandle.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.GCHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-174">
            <see cref="T:System.IntPtr" /> que indica el identificador para el que se requiere la conversión.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-174">An <see cref="T:System.IntPtr" /> that indicates the handle for which the conversion is required.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-175">Un <see cref="T:System.Runtime.InteropServices.GCHandle" /> se almacena mediante una representación de entero interna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-175">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> is stored using an internal integer representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-176">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> almacenado mediante una representación de entero interna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-176">The stored <see cref="T:System.Runtime.InteropServices.GCHandle" /> object using an internal integer representation.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-177">Este método le permite recuperar una <xref:System.Runtime.InteropServices.GCHandle> de un valor entero.</span><span class="sxs-lookup"><span data-stu-id="0cd05-177">This method allows you to retrieve a <xref:System.Runtime.InteropServices.GCHandle> from an integer value.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-178">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-178">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-179">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-179">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (System.Runtime.InteropServices.GCHandle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(valuetype System.Runtime.InteropServices.GCHandle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.op_Explicit(System.Runtime.InteropServices.GCHandle)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As GCHandle) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(System::Runtime::InteropServices::GCHandle value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Runtime.InteropServices.GCHandle -&gt; nativeint" Usage="System.Runtime.InteropServices.GCHandle.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.InteropServices.GCHandle" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-180">
            <see cref="T:System.Runtime.InteropServices.GCHandle" /> para el que se requiere el entero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-180">The <see cref="T:System.Runtime.InteropServices.GCHandle" /> for which the integer is required.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-181">Un <see cref="T:System.Runtime.InteropServices.GCHandle" /> se almacena mediante una representación de entero interna.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-181">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> is stored using an internal integer representation.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-182">Valor entero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-182">The integer value.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="0cd05-183">Este método se puede utilizar para recuperar el valor entero de un <xref:System.Runtime.InteropServices.GCHandle>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-183">This method can be used to retrieve the integer value from a <xref:System.Runtime.InteropServices.GCHandle>.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-184">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-184">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-185">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-185">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Runtime.InteropServices.GCHandle a, System.Runtime.InteropServices.GCHandle b);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Runtime.InteropServices.GCHandle a, valuetype System.Runtime.InteropServices.GCHandle b) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.op_Inequality(System.Runtime.InteropServices.GCHandle,System.Runtime.InteropServices.GCHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (a As GCHandle, b As GCHandle) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Runtime::InteropServices::GCHandle a, System::Runtime::InteropServices::GCHandle b);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Runtime.InteropServices.GCHandle * System.Runtime.InteropServices.GCHandle -&gt; bool" Usage="System.Runtime.InteropServices.GCHandle.op_Inequality (a, b)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="a" Type="System.Runtime.InteropServices.GCHandle" />
        <Parameter Name="b" Type="System.Runtime.InteropServices.GCHandle" />
      </Parameters>
      <Docs>
        <param name="a">
          <span data-ttu-id="0cd05-186">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a comparar con el parámetro <c>b</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-186">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to compare with the <c>b</c> parameter.</span>
          </span>
        </param>
        <param name="b">
          <span data-ttu-id="0cd05-187">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> que se va a comparar con el parámetro <c>a</c>.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-187">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to compare with the <c>a</c> parameter.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-188">Devuelve un valor que indica si dos objetos <see cref="T:System.Runtime.InteropServices.GCHandle" /> no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-188">Returns a value indicating whether two <see cref="T:System.Runtime.InteropServices.GCHandle" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-189">Es <see langword="true" /> si los parámetros <paramref name="a" /> y <paramref name="b" /> no son iguales; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-189">
              <see langword="true" /> if the <paramref name="a" /> and <paramref name="b" /> parameters are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="0cd05-190">El método equivalente para este operador es <xref:System.Runtime.InteropServices.GCHandle.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-190">The equivalent method for this operator is <xref:System.Runtime.InteropServices.GCHandle.Equals%2A?displayProperty=nameWithType>.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="public object Target { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Target" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.InteropServices.GCHandle.Target" />
      <MemberSignature Language="VB.NET" Value="Public Property Target As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ Target { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Target : obj with get, set" Usage="System.Runtime.InteropServices.GCHandle.Target" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="0cd05-191">Obtiene o establece el objeto al que representa este identificador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-191">Gets or sets the object this handle represents.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="0cd05-192">Objeto que representa este identificador.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-192">The object this handle represents.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0cd05-193">El ejemplo siguiente muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-193">The following example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-194">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="0cd05-194">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr>.</span></span> <span data-ttu-id="0cd05-195">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-195">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="0cd05-196">El identificador fue liberado o nunca se inicializó.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-196">The handle was freed, or never initialized.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="0cd05-197">Requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-197">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="0cd05-198">Este miembro no puede usarse por código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-198">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <altmember cref="T:System.Runtime.InteropServices.GCHandleType" />
      </Docs>
    </Member>
    <Member MemberName="ToIntPtr">
      <MemberSignature Language="C#" Value="public static IntPtr ToIntPtr (System.Runtime.InteropServices.GCHandle value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int ToIntPtr(valuetype System.Runtime.InteropServices.GCHandle value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.InteropServices.GCHandle.ToIntPtr(System.Runtime.InteropServices.GCHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ToIntPtr (value As GCHandle) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr ToIntPtr(System::Runtime::InteropServices::GCHandle value);" />
      <MemberSignature Language="F#" Value="static member ToIntPtr : System.Runtime.InteropServices.GCHandle -&gt; nativeint" Usage="System.Runtime.InteropServices.GCHandle.ToIntPtr value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.InteropServices</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.InteropServices.GCHandle" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="0cd05-199">Objeto <see cref="T:System.Runtime.InteropServices.GCHandle" /> del que se va a recuperar una representación de entero interno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-199">A <see cref="T:System.Runtime.InteropServices.GCHandle" /> object to retrieve an internal integer representation from.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="0cd05-200">Devuelve la representación entera interna de un objeto <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-200">Returns the internal integer representation of a <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="0cd05-201">Objeto <see cref="T:System.IntPtr" /> que representa un objeto <see cref="T:System.Runtime.InteropServices.GCHandle" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="0cd05-201">An <see cref="T:System.IntPtr" /> object that represents a <see cref="T:System.Runtime.InteropServices.GCHandle" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="0cd05-202">El siguiente ejemplo de código muestra un `App` clase que crea un identificador a un objeto administrado mediante el `GCHandle.Alloc` método, lo que impide que el objeto administrado que se recopilan.</span><span class="sxs-lookup"><span data-stu-id="0cd05-202">The following code example shows an `App` class that creates a handle to a managed object using the `GCHandle.Alloc` method, which prevents the managed object from being collected.</span></span> <span data-ttu-id="0cd05-203">Una llamada a la `EnumWindows` método pasa un delegado y un objeto administrado (ambos declarados como tipos administrados, pero no se muestra) y convierte el identificador a un <xref:System.IntPtr> objeto.</span><span class="sxs-lookup"><span data-stu-id="0cd05-203">A call to the `EnumWindows` method passes a delegate and a managed object (both declared as managed types, but not shown), and casts the handle to an <xref:System.IntPtr> object.</span></span> <span data-ttu-id="0cd05-204">La función no administrada pasa el tipo de vuelta al llamador como un parámetro de la función de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="0cd05-204">The unmanaged function passes the type back to the caller as a parameter of the callback function.</span></span>  
  
 [!code-csharp[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/cs/sample.cs#1)]
 [!code-vb[System.Runtime.InteropServices.GCHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Runtime.InteropServices.GCHandle/vb/sample.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>