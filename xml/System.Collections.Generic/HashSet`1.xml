<Type Name="HashSet&lt;T&gt;" FullName="System.Collections.Generic.HashSet&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="212f75fe746aa168bd9cf3eae4f8af439a0d9247" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52202748" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class HashSet&lt;T&gt; : System.Collections.Generic.ICollection&lt;T&gt;, System.Collections.Generic.IEnumerable&lt;T&gt;, System.Collections.Generic.IReadOnlyCollection&lt;T&gt;, System.Collections.Generic.ISet&lt;T&gt;, System.Runtime.Serialization.IDeserializationCallback, System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable beforefieldinit HashSet`1&lt;T&gt; extends System.Object implements class System.Collections.Generic.ICollection`1&lt;!T&gt;, class System.Collections.Generic.IEnumerable`1&lt;!T&gt;, class System.Collections.Generic.IReadOnlyCollection`1&lt;!T&gt;, class System.Collections.Generic.ISet`1&lt;!T&gt;, class System.Collections.IEnumerable, class System.Runtime.Serialization.IDeserializationCallback, class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.Collections.Generic.HashSet`1" />
  <TypeSignature Language="VB.NET" Value="Public Class HashSet(Of T)&#xA;Implements ICollection(Of T), IDeserializationCallback, IEnumerable(Of T), IReadOnlyCollection(Of T), ISerializable, ISet(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public ref class HashSet : System::Collections::Generic::ICollection&lt;T&gt;, System::Collections::Generic::IEnumerable&lt;T&gt;, System::Collections::Generic::IReadOnlyCollection&lt;T&gt;, System::Collections::Generic::ISet&lt;T&gt;, System::Runtime::Serialization::IDeserializationCallback, System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type HashSet&lt;'T&gt; = class&#xA;    interface ICollection&lt;'T&gt;&#xA;    interface ISerializable&#xA;    interface IDeserializationCallback&#xA;    interface ISet&lt;'T&gt;&#xA;    interface IReadOnlyCollection&lt;'T&gt;&#xA;    interface seq&lt;'T&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Collections</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>3.5.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.ICollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.IReadOnlyCollection&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.Generic.ISet&lt;T&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.IDeserializationCallback</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerDisplay("Count = {Count}")</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Diagnostics.DebuggerTypeProxy(typeof(System.Collections.Generic.HashSetDebugView`1))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="84253-101">Tipo de los elementos del conjunto hash.</span>
      <span class="sxs-lookup">
        <span data-stu-id="84253-101">The type of elements in the hash set.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="84253-102">Representa un conjunto de valores.</span>
      <span class="sxs-lookup">
        <span data-stu-id="84253-102">Represents a set of values.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-103">La <xref:System.Collections.Generic.HashSet%601> clase proporciona las operaciones de configuración de alto rendimiento.</span><span class="sxs-lookup"><span data-stu-id="84253-103">The <xref:System.Collections.Generic.HashSet%601> class provides high-performance set operations.</span></span> <span data-ttu-id="84253-104">Un conjunto es una colección que no contiene elementos duplicados, y cuyos elementos están en ningún orden concreto.</span><span class="sxs-lookup"><span data-stu-id="84253-104">A set is a collection that contains no duplicate elements, and whose elements are in no particular order.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="84253-105"><xref:System.Collections.Generic.HashSet%601> implementa el <xref:System.Collections.Generic.IReadOnlyCollection%601> interfaz a partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; en versiones anteriores de .NET Framework, el <xref:System.Collections.Generic.HashSet%601> clase no implementa esta interfaz.</span><span class="sxs-lookup"><span data-stu-id="84253-105"><xref:System.Collections.Generic.HashSet%601> implements the <xref:System.Collections.Generic.IReadOnlyCollection%601> interface starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)]; in previous versions of the .NET Framework, the <xref:System.Collections.Generic.HashSet%601> class did not implement this interface.</span></span>  
  
 <span data-ttu-id="84253-106">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-106">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-107">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-107">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-108">El <xref:System.Collections.Generic.HashSet%601> clase se basa en el modelo de conjuntos matemáticos y proporciona las operaciones de configuración de alto rendimiento similar al acceso a las claves de la <xref:System.Collections.Generic.Dictionary%602> o <xref:System.Collections.Hashtable> colecciones.</span><span class="sxs-lookup"><span data-stu-id="84253-108">The <xref:System.Collections.Generic.HashSet%601> class is based on the model of mathematical sets and provides high-performance set operations similar to accessing the keys of the <xref:System.Collections.Generic.Dictionary%602> or <xref:System.Collections.Hashtable> collections.</span></span> <span data-ttu-id="84253-109">En términos sencillos, la <xref:System.Collections.Generic.HashSet%601> clase puede considerarse como un <xref:System.Collections.Generic.Dictionary%602> colección sin valores.</span><span class="sxs-lookup"><span data-stu-id="84253-109">In simple terms, the <xref:System.Collections.Generic.HashSet%601> class can be thought of as a <xref:System.Collections.Generic.Dictionary%602> collection without values.</span></span>  
  
 <span data-ttu-id="84253-110">Un <xref:System.Collections.Generic.HashSet%601> colección no está ordenada y no puede contener elementos duplicados.</span><span class="sxs-lookup"><span data-stu-id="84253-110">A <xref:System.Collections.Generic.HashSet%601> collection is not sorted and cannot contain duplicate elements.</span></span> <span data-ttu-id="84253-111">Si el pedido o un elemento de duplicación es más importante que el rendimiento de su aplicación, considere el uso de la <xref:System.Collections.Generic.List%601> clase junto con el <xref:System.Collections.Generic.List%601.Sort%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-111">If order or element duplication is more important than performance for your application, consider using the <xref:System.Collections.Generic.List%601> class together with the <xref:System.Collections.Generic.List%601.Sort%2A> method.</span></span>  
  
 <span data-ttu-id="84253-112"><xref:System.Collections.Generic.HashSet%601> proporciona muchas matemáticas establezca operaciones, como la suma de conjuntos (uniones) y resta.</span><span class="sxs-lookup"><span data-stu-id="84253-112"><xref:System.Collections.Generic.HashSet%601> provides many mathematical set operations, such as set addition (unions) and set subtraction.</span></span> <span data-ttu-id="84253-113">La tabla siguiente enumeran proporcionado <xref:System.Collections.Generic.HashSet%601> operaciones y sus equivalentes de matemáticas.</span><span class="sxs-lookup"><span data-stu-id="84253-113">The following table lists the provided <xref:System.Collections.Generic.HashSet%601> operations and their mathematical equivalents.</span></span>  
  
|<span data-ttu-id="84253-114">Operación HashSet</span><span class="sxs-lookup"><span data-stu-id="84253-114">HashSet operation</span></span>|<span data-ttu-id="84253-115">Equivalente matemático</span><span class="sxs-lookup"><span data-stu-id="84253-115">Mathematical equivalent</span></span>|  
|-------------------------------|-----------------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<span data-ttu-id="84253-116">Adición de unión o establezca</span><span class="sxs-lookup"><span data-stu-id="84253-116">Union or set addition</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<span data-ttu-id="84253-117">Intersección</span><span class="sxs-lookup"><span data-stu-id="84253-117">Intersection</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<span data-ttu-id="84253-118">Resta de conjuntos</span><span class="sxs-lookup"><span data-stu-id="84253-118">Set subtraction</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="84253-119">Diferencia simétrica</span><span class="sxs-lookup"><span data-stu-id="84253-119">Symmetric difference</span></span>|  
  
 <span data-ttu-id="84253-120">Además de las operaciones de conjunto, la <xref:System.Collections.Generic.HashSet%601> clase también proporciona métodos para determinar la igualdad de conjunto, superposición de conjuntos, y si un conjunto es un subconjunto o superconjunto de otro conjunto.</span><span class="sxs-lookup"><span data-stu-id="84253-120">In addition to the listed set operations, the <xref:System.Collections.Generic.HashSet%601> class also provides methods for determining set equality, overlap of sets, and whether a set is a subset or superset of another set.</span></span>  
  
 <span data-ttu-id="84253-121">Para grandes <xref:System.Collections.Generic.HashSet%601> objetos, puede aumentar la capacidad máxima de 2 millones de elementos en un sistema de 64 bits estableciendo el `enabled` atributo del elemento de configuración para `true` en el entorno de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="84253-121">For very large <xref:System.Collections.Generic.HashSet%601> objects, you can increase the maximum capacity to 2 billion elements on a 64-bit system by setting the `enabled` attribute of the  configuration element to `true` in the run-time environment.</span></span>  
  
 <span data-ttu-id="84253-122">A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], <xref:System.Collections.Generic.HashSet%601> la clase implementa la <xref:System.Collections.Generic.ISet%601> interfaz.</span><span class="sxs-lookup"><span data-stu-id="84253-122">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.Collections.Generic.HashSet%601> class implements the <xref:System.Collections.Generic.ISet%601> interface.</span></span>  
  
## <a name="hashset-and-linq-set-operations"></a><span data-ttu-id="84253-123">Operaciones HashSet y Set de LINQ</span><span class="sxs-lookup"><span data-stu-id="84253-123">HashSet and LINQ Set Operations</span></span>  
 <span data-ttu-id="84253-124">LINQ proporciona acceso a la `Distinct`, `Union`, `Intersect` y `Except` establecer operaciones en cualquier origen de datos que implementa el <xref:System.Collections.IEnumerable> o <xref:System.Linq.IQueryable> interfaces.</span><span class="sxs-lookup"><span data-stu-id="84253-124">LINQ provides access to the `Distinct`, `Union`, `Intersect` and `Except` set operations on any data source that implements the <xref:System.Collections.IEnumerable> or <xref:System.Linq.IQueryable> interfaces.</span></span>  <span data-ttu-id="84253-125"><xref:System.Collections.Generic.HashSet%601> Proporciona una colección de más grande y más eficaz de las operaciones de conjunto.</span><span class="sxs-lookup"><span data-stu-id="84253-125"><xref:System.Collections.Generic.HashSet%601> provides a larger and more robust collection of set operations.</span></span> <span data-ttu-id="84253-126">Por ejemplo, <xref:System.Collections.Generic.HashSet%601> proporciona comparaciones como <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> y <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-126">For example, <xref:System.Collections.Generic.HashSet%601> provides comparisons such as <xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A> and <xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>.</span></span>  
  
 <span data-ttu-id="84253-127">Las operaciones de configuración de la diferencia principal entre LINQ y <xref:System.Collections.Generic.HashSet%601> operaciones es que las operaciones set LINQ siempre devuelven un nuevo <xref:System.Collections.Generic.IEnumerable%601> colección, mientras que el <xref:System.Collections.Generic.HashSet%601> métodos equivalentes modifican la colección actual.</span><span class="sxs-lookup"><span data-stu-id="84253-127">The primary difference between LINQ set operations and <xref:System.Collections.Generic.HashSet%601> operations is that LINQ set operations always return a new <xref:System.Collections.Generic.IEnumerable%601> collection, whereas the <xref:System.Collections.Generic.HashSet%601> equivalent methods modify the current collection.</span></span>  
  
 <span data-ttu-id="84253-128">Por lo general, si tiene que crear un nuevo conjunto o si la aplicación necesita acceso únicamente a las operaciones del conjunto proporcionado, con LINQ operaciones set en cualquier <xref:System.Collections.Generic.IEnumerable%601> colección o matriz será suficiente.</span><span class="sxs-lookup"><span data-stu-id="84253-128">Typically, if you must create a new set or if your application needs access only to the provided set operations, using LINQ set operations on any <xref:System.Collections.Generic.IEnumerable%601> collection or array will be sufficient.</span></span> <span data-ttu-id="84253-129">Sin embargo, si la aplicación requiere acceso a las operaciones de conjunto adicional, o si no es conveniente o necesario crear una nueva colección, utilice el <xref:System.Collections.Generic.HashSet%601> clase.</span><span class="sxs-lookup"><span data-stu-id="84253-129">However, if your application requires access to additional set operations, or if it is not desirable or necessary to create a new collection, use the <xref:System.Collections.Generic.HashSet%601> class.</span></span>  
  
 <span data-ttu-id="84253-130">La tabla siguiente muestra el <xref:System.Collections.Generic.HashSet%601> operaciones de conjunto de operaciones y su equivalente LINQ.</span><span class="sxs-lookup"><span data-stu-id="84253-130">The following table shows the <xref:System.Collections.Generic.HashSet%601> operations and their equivalent LINQ set operations.</span></span>  
  
|<span data-ttu-id="84253-131">Operación HashSet</span><span class="sxs-lookup"><span data-stu-id="84253-131">HashSet operation</span></span>|<span data-ttu-id="84253-132">Equivalente LINQ</span><span class="sxs-lookup"><span data-stu-id="84253-132">LINQ equivalent</span></span>|  
|-------------------------------|---------------------|  
|<xref:System.Collections.Generic.HashSet%601.UnionWith%2A>|<xref:System.Linq.Enumerable.Union%2A>|  
|<xref:System.Collections.Generic.HashSet%601.IntersectWith%2A>|<xref:System.Linq.Enumerable.Intersect%2A>|  
|<xref:System.Collections.Generic.HashSet%601.ExceptWith%2A>|<xref:System.Linq.Enumerable.Except%2A>|  
|<span data-ttu-id="84253-133">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-133">Not provided.</span></span>|<xref:System.Linq.Enumerable.Distinct%2A>|  
|<xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A>|<span data-ttu-id="84253-134">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-134">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.Overlaps%2A>|<span data-ttu-id="84253-135">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-135">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSubsetOf%2A>|<span data-ttu-id="84253-136">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-136">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSubsetOf%2A>|<span data-ttu-id="84253-137">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-137">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsSupersetOf%2A>|<span data-ttu-id="84253-138">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-138">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.IsProperSupersetOf%2A>|<span data-ttu-id="84253-139">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-139">Not provided.</span></span>|  
|<xref:System.Collections.Generic.HashSet%601.SetEquals%2A>|<span data-ttu-id="84253-140">No se proporciona.</span><span class="sxs-lookup"><span data-stu-id="84253-140">Not provided.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="84253-141">El ejemplo siguiente muestra cómo combinar dos conjuntos dispares.</span><span class="sxs-lookup"><span data-stu-id="84253-141">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="84253-142">En este ejemplo se crea dos <xref:System.Collections.Generic.HashSet%601> objetos y la rellena con números pares e impares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="84253-142">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="84253-143">Una tercera <xref:System.Collections.Generic.HashSet%601> se crea el objeto del conjunto que contiene los números pares.</span><span class="sxs-lookup"><span data-stu-id="84253-143">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="84253-144">El ejemplo llama a la <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método, que agrega el conjunto de números impar al tercer conjunto.</span><span class="sxs-lookup"><span data-stu-id="84253-144">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Collections.Generic.SortedSet`1" />
    <altmember cref="T:System.Collections.Generic.ISet`1" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="84253-145">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-145">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-146">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que está vacía y utiliza el comparador de igualdad predeterminado para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-146">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the default equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-147">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-147">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-148">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-148">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-149">Este constructor es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-149">This constructor is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-150">En el ejemplo siguiente se muestra cómo crear y rellenar dos <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="84253-150">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="84253-151">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-151">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; collection" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="84253-152">Colección cuyos elementos se copian en el nuevo conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-152">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-153">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que utiliza el comparador de igualdad predeterminado para el tipo de conjunto, contiene elementos copiados de la colección especificada y tiene capacidad suficiente para dar cabida al número de elementos copiados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-153">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the default equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-154">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-154">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-155">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-155">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-156">Si `collection` contiene duplicados, el conjunto contendrá uno de cada elemento único.</span><span class="sxs-lookup"><span data-stu-id="84253-156">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="84253-157">No se producirá ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="84253-157">No exception will be thrown.</span></span> <span data-ttu-id="84253-158">Por lo tanto, el tamaño del conjunto resultante no es idéntico al tamaño de `collection`.</span><span class="sxs-lookup"><span data-stu-id="84253-158">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="84253-159">Este constructor es O (`n`) operación, donde `n` es el número de elementos de la `collection` parámetro.</span><span class="sxs-lookup"><span data-stu-id="84253-159">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-160">El ejemplo siguiente muestra cómo crear un <xref:System.Collections.Generic.HashSet%601> colección de un conjunto existente.</span><span class="sxs-lookup"><span data-stu-id="84253-160">The following example shows how to create a <xref:System.Collections.Generic.HashSet%601> collection from an existing set.</span></span> <span data-ttu-id="84253-161">En este ejemplo, se crean dos conjuntos con enteros pares e impares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="84253-161">In this example, two sets are created with even and odd integers, respectively.</span></span> <span data-ttu-id="84253-162">Una tercera <xref:System.Collections.Generic.HashSet%601> , a continuación, se crea el objeto de conjunto de números enteros incluso.</span><span class="sxs-lookup"><span data-stu-id="84253-162">A third <xref:System.Collections.Generic.HashSet%601> object is then created from the even integer set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-163">El valor de <paramref name="collection" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-163">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; comparer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="comparer">
          <span data-ttu-id="84253-164">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar para comparar valores del conjunto o <see langword="null" /> si se va a usar la implementación de <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predeterminada para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-164">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-165">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que está vacía y utiliza el comparador de igualdad especificado para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-165">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty and uses the specified equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-166">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-166">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-167">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-167">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-168">Este constructor es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-168">This constructor is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; capacity" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="84253-169">Tamaño inicial de <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-169">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-170">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que está vacía, pero que tiene espacio reservado para los elementos <paramref name="capacity" /> y usa el comparador de igualdad predeterminado para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-170">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that is empty, but has reserved space for <paramref name="capacity" /> items and uses the default equality comparer for the set type.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-171">Puesto que los cambios de tamaño son relativamente costosas (requieren recombinando), este intenta minimizar la necesidad de cambiar el tamaño mediante el establecimiento de la capacidad inicial en función del valor de la `capacity`.</span><span class="sxs-lookup"><span data-stu-id="84253-171">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (System.Collections.Generic.IEnumerable&lt;T&gt; collection, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; collection, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Collections.Generic.IEnumerable{`0},System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (collection As IEnumerable(Of T), comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(System::Collections::Generic::IEnumerable&lt;T&gt; ^ collection, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : seq&lt;'T&gt; * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (collection, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="collection" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="collection">
          <span data-ttu-id="84253-172">Colección cuyos elementos se copian en el nuevo conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-172">The collection whose elements are copied to the new set.</span>
          </span>
        </param>
        <param name="comparer">
          <span data-ttu-id="84253-173">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar para comparar valores del conjunto o <see langword="null" /> si se va a usar la implementación de <see cref="T:System.Collections.Generic.EqualityComparer`1" /> predeterminada para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-173">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or <see langword="null" /> to use the default <see cref="T:System.Collections.Generic.EqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-174">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que utiliza el comparador de igualdad especificado para el tipo de conjunto, contiene elementos copiados de la colección especificada y tiene capacidad suficiente para alojar el número de elementos copiados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-174">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, contains elements copied from the specified collection, and has sufficient capacity to accommodate the number of elements copied.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-175">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-175">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-176">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-176">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-177">Si `collection` contiene duplicados, el conjunto contendrá uno de cada elemento único.</span><span class="sxs-lookup"><span data-stu-id="84253-177">If `collection` contains duplicates, the set will contain one of each unique element.</span></span> <span data-ttu-id="84253-178">No se producirá ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="84253-178">No exception will be thrown.</span></span> <span data-ttu-id="84253-179">Por lo tanto, el tamaño del conjunto resultante no es idéntico al tamaño de `collection`.</span><span class="sxs-lookup"><span data-stu-id="84253-179">Therefore, the size of the resulting set is not identical to the size of `collection`.</span></span>  
  
 <span data-ttu-id="84253-180">Este constructor es O (`n`) operación, donde `n` es el número de elementos de la `collection` parámetro.</span><span class="sxs-lookup"><span data-stu-id="84253-180">This constructor is an O(`n`) operation, where `n` is the number of elements in the `collection` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-181">En el ejemplo siguiente se usa un proporcionado <xref:System.Collections.Generic.IEqualityComparer%601> para permitir que las comparaciones entre mayúsculas y minúsculas en los elementos de un <xref:System.Collections.Generic.HashSet%601> colección de tipos de vehículos.</span><span class="sxs-lookup"><span data-stu-id="84253-181">The following example uses a supplied <xref:System.Collections.Generic.IEqualityComparer%601> to allow case-insensitive comparisons on the elements of a  <xref:System.Collections.Generic.HashSet%601> collection of vehicle types.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/source2.cpp#03)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/source2.cs#03)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#03](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/source2.vb#03)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-182">El valor de <paramref name="collection" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-182">
              <paramref name="collection" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public HashSet (int capacity, System.Collections.Generic.IEqualityComparer&lt;T&gt; comparer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 capacity, class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; comparer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Int32,System.Collections.Generic.IEqualityComparer{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (capacity As Integer, comparer As IEqualityComparer(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; HashSet(int capacity, System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ comparer);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : int * System.Collections.Generic.IEqualityComparer&lt;'T&gt; -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (capacity, comparer)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
        <Parameter Name="comparer" Type="System.Collections.Generic.IEqualityComparer&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="capacity">
          <span data-ttu-id="84253-183">Tamaño inicial de <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-183">The initial size of the <see cref="T:System.Collections.Generic.HashSet`1" /></span>
          </span>
        </param>
        <param name="comparer">
          <span data-ttu-id="84253-184">Implementación de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se va a usar para comparar valores del conjunto, o bien Null (Nothing en Visual Basic) para usar la implementación predeterminada de <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> para el tipo de conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-184">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation to use when comparing values in the set, or null (Nothing in Visual Basic) to use the default <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> implementation for the set type.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-185">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> que usa el comparador de igualdad especificado para el tipo de conjunto y que tiene capacidad suficiente para alojar elementos <paramref name="capacity" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-185">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class that uses the specified equality comparer for the set type, and has sufficient capacity to accommodate <paramref name="capacity" /> elements.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-186">Puesto que los cambios de tamaño son relativamente costosas (requieren recombinando), este intenta minimizar la necesidad de cambiar el tamaño mediante el establecimiento de la capacidad inicial en función del valor de la `capacity`.</span><span class="sxs-lookup"><span data-stu-id="84253-186">Since resizes are relatively expensive (require rehashing), this attempts to minimize the need to resize by setting the initial capacity based on the value of the `capacity`.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected HashSet (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; HashSet(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="new System.Collections.Generic.HashSet&lt;'T&gt; : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; System.Collections.Generic.HashSet&lt;'T&gt;" Usage="new System.Collections.Generic.HashSet&lt;'T&gt; (info, context)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="84253-187">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene información necesaria para serializar el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-187">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="84253-188">Estructura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino del flujo serializado asociado al objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-188">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-189">Inicializa una nueva instancia de la clase <see cref="T:System.Collections.Generic.HashSet`1" /> con datos serializados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-189">Initializes a new instance of the <see cref="T:System.Collections.Generic.HashSet`1" /> class with serialized data.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-190">Este constructor se llama durante la deserialización para reconstituir el objeto que se transmite a través de una secuencia.</span><span class="sxs-lookup"><span data-stu-id="84253-190">This constructor is called during deserialization to reconstitute an object that is transmitted over a stream.</span></span> <span data-ttu-id="84253-191">Para obtener más información, consulte [serialización SOAP y XML](~/docs/standard/serialization/xml-and-soap-serialization.md).</span><span class="sxs-lookup"><span data-stu-id="84253-191">For more information, see [XML and SOAP Serialization](~/docs/standard/serialization/xml-and-soap-serialization.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public bool Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Add (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(T item);" />
      <MemberSignature Language="F#" Value="abstract member Add : 'T -&gt; bool&#xA;override this.Add : 'T -&gt; bool" Usage="hashSet.Add item" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="84253-192">Elemento que se va a agregar al conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-192">The element to add to the set.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-193">Agrega el elemento especificado a un conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-193">Adds the specified element to a set.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-194">Es <see langword="true" /> si el elemento se agrega al objeto <see cref="T:System.Collections.Generic.HashSet`1" />; es <see langword="false" /> si el elemento ya está presente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-194">
              <see langword="true" /> if the element is added to the <see cref="T:System.Collections.Generic.HashSet`1" /> object; <see langword="false" /> if the element is already present.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-195">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> ya es igual a la capacidad de la <xref:System.Collections.Generic.HashSet%601> de objeto, la capacidad se ajusta automáticamente para alojar el nuevo elemento.</span><span class="sxs-lookup"><span data-stu-id="84253-195">If <xref:System.Collections.Generic.HashSet%601.Count%2A> already equals the capacity of the <xref:System.Collections.Generic.HashSet%601> object, the capacity is automatically adjusted to accommodate the new item.</span></span>  
  
 <span data-ttu-id="84253-196">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> es menor que la capacidad de la matriz interna, este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-196">If <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the capacity of the internal array, this method is an O(1) operation.</span></span> <span data-ttu-id="84253-197">Si el <xref:System.Collections.Generic.HashSet%601> debe cambiarse el objeto, este método se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-197">If the <xref:System.Collections.Generic.HashSet%601> object must be resized, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-198">En el ejemplo siguiente se muestra cómo crear y rellenar dos <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="84253-198">The following example demonstrates how to create and populate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="84253-199">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-199">This example is part of a larger example provided for the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#03](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#03)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Clear();" />
      <MemberSignature Language="F#" Value="abstract member Clear : unit -&gt; unit&#xA;override this.Clear : unit -&gt; unit" Usage="hashSet.Clear " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Clear</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-200">Quita todos los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-200">Removes all elements from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> se establece en cero y también se liberan las referencias a otros objetos de elementos de la colección.</span><span class="sxs-lookup"><span data-stu-id="84253-201"><xref:System.Collections.Generic.HashSet%601.Count%2A> is set to zero and references to other objects from elements of the collection are also released.</span></span> <span data-ttu-id="84253-202">La capacidad no cambia hasta que una llamada a <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> se realiza.</span><span class="sxs-lookup"><span data-stu-id="84253-202">The capacity remains unchanged until a call to <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> is made.</span></span>  
  
 <span data-ttu-id="84253-203">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-203">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-204">El ejemplo siguiente se crea y rellena un <xref:System.Collections.Generic.HashSet%601> colección, a continuación, se borra y libera la memoria que se hace referencia a la colección.</span><span class="sxs-lookup"><span data-stu-id="84253-204">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, then clears it and releases the memory referenced by the collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Comparer">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IEqualityComparer&lt;T&gt; Comparer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IEqualityComparer`1&lt;!T&gt; Comparer" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Comparer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Comparer As IEqualityComparer(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ Comparer { System::Collections::Generic::IEqualityComparer&lt;T&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Comparer : System.Collections.Generic.IEqualityComparer&lt;'T&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Comparer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84253-205">Obtiene el objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se utiliza para determinar la igualdad de los valores del conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-205">Gets the <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84253-206">Objeto <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> que se utiliza para determinar la igualdad de los valores del conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-206">The <see cref="T:System.Collections.Generic.IEqualityComparer`1" /> object that is used to determine equality for the values in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-207">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="84253-207">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public bool Contains (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Contains(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Contains (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Contains(T item);" />
      <MemberSignature Language="F#" Value="abstract member Contains : 'T -&gt; bool&#xA;override this.Contains : 'T -&gt; bool" Usage="hashSet.Contains item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Contains(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="84253-208">Elemento que debe buscarse en el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-208">The element to locate in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-209">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene el elemento especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-209">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-210">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> contiene el elemento especificado; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-210">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object contains the specified element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-211">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-211">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-212">En el ejemplo siguiente se muestra cómo quitar valores de un <xref:System.Collections.Generic.HashSet%601> colección utilizando el <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-212">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="84253-213">En este ejemplo, el <xref:System.Collections.Generic.HashSet%601.Contains%2A> método comprueba que el conjunto contiene un valor antes de quitarla.</span><span class="sxs-lookup"><span data-stu-id="84253-213">In this example, the <xref:System.Collections.Generic.HashSet%601.Contains%2A> method verifies that the set contains a value before removing it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="CopyTo">
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="84253-214">Copia los elementos de una colección <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-214">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> collection to an array.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] -&gt; unit" Usage="hashSet.CopyTo array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="84253-215">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-215">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="84253-216">La matriz debe tener una indización de base cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-216">The array must have zero-based indexing.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-217">Copia los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-217">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-218">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-218">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-219">El valor de <paramref name="array" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-219">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void CopyTo(!T[] array, int32 arrayIndex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex);" />
      <MemberSignature Language="F#" Value="abstract member CopyTo : 'T[] * int -&gt; unit&#xA;override this.CopyTo : 'T[] * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.CopyTo(`0[],System.Int32)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="84253-220">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-220">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="84253-221">La matriz debe tener una indización de base cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-221">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="84253-222">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-222">The zero-based index in <paramref name="array" /> at which copying begins.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-223">Copia los elementos de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz, comenzando en el índice especificado de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-223">Copies the elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-224">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-224">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-225">El valor de <paramref name="array" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-225">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="84253-226">
            <paramref name="arrayIndex" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-226">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="84253-227">
            <paramref name="arrayIndex" /> es mayor que la longitud de la <paramref name="array" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-227">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (T[] array, int arrayIndex, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(!T[] array, int32 arrayIndex, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CopyTo(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (array As T(), arrayIndex As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(cli::array &lt;T&gt; ^ array, int arrayIndex, int count);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : 'T[] * int * int -&gt; unit" Usage="hashSet.CopyTo (array, arrayIndex, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="arrayIndex" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="84253-228">Matriz unidimensional que constituye el destino de los elementos copiados desde el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-228">The one-dimensional array that is the destination of the elements copied from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
          <span data-ttu-id="84253-229">La matriz debe tener una indización de base cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-229">The array must have zero-based indexing.</span>
          </span>
        </param>
        <param name="arrayIndex">
          <span data-ttu-id="84253-230">Índice de base cero en la <paramref name="array" /> donde comienza la copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-230">The zero-based index in <paramref name="array" /> at which copying begins.</span>
          </span>
        </param>
        <param name="count">
          <span data-ttu-id="84253-231">Número de elementos que se van a copiar en <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-231">The number of elements to copy to <paramref name="array" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-232">Copia el número de elementos especificado de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en una matriz, comenzando en el índice especificado de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-232">Copies the specified number of elements of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to an array, starting at the specified array index.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-233">Este método es O (`n`) operación, donde `n` es `count`.</span><span class="sxs-lookup"><span data-stu-id="84253-233">This method is an O(`n`) operation, where `n` is `count`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-234">El valor de <paramref name="array" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-234">
              <paramref name="array" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="84253-235">
            <paramref name="arrayIndex" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-235">
              <paramref name="arrayIndex" /> is less than 0.</span>
          </span>
          <span data-ttu-id="84253-236">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-236">-or-</span>
          </span>
          <span data-ttu-id="84253-237">
            <paramref name="count" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-237">
              <paramref name="count" /> is less than 0.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="84253-238">
            <paramref name="arrayIndex" /> es mayor que la longitud de la <paramref name="array" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-238">
              <paramref name="arrayIndex" /> is greater than the length of the destination <paramref name="array" />.</span>
          </span>
          <span data-ttu-id="84253-239">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-239">-or-</span>
          </span>
          <span data-ttu-id="84253-240">
            <paramref name="count" /> es mayor que el espacio disponible desde <paramref name="index" /> hasta el final de la <paramref name="array" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-240">
              <paramref name="count" /> is greater than the available space from the <paramref name="index" /> to the end of the destination <paramref name="array" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.Count" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.Count</InterfaceMember>
        <InterfaceMember>P:System.Collections.Generic.IReadOnlyCollection`1.Count</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84253-241">Obtiene el número de elementos contenidos en un conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-241">Gets the number of elements that are contained in a set.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84253-242">Número de elementos contenidos en el conjunto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-242">The number of elements that are contained in the set.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-243">La capacidad de un <xref:System.Collections.Generic.HashSet%601> objeto es el número de elementos que puede contener el objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-243">The capacity of a <xref:System.Collections.Generic.HashSet%601> object is the number of elements that the object can hold.</span></span> <span data-ttu-id="84253-244">Un <xref:System.Collections.Generic.HashSet%601> capacidad del objeto aumenta automáticamente cuando se agregan elementos al objeto.</span><span class="sxs-lookup"><span data-stu-id="84253-244">A <xref:System.Collections.Generic.HashSet%601> object's capacity automatically increases as elements are added to the object.</span></span>  
  
 <span data-ttu-id="84253-245">La capacidad siempre es mayor o igual que <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-245">The capacity is always greater than or equal to <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span> <span data-ttu-id="84253-246">Si <xref:System.Collections.Generic.HashSet%601.Count%2A> supera la capacidad al agregar elementos, la capacidad se establece en el primer número primo mayor que el doble de capacidad anterior.</span><span class="sxs-lookup"><span data-stu-id="84253-246">If <xref:System.Collections.Generic.HashSet%601.Count%2A> exceeds the capacity while adding elements, the capacity is set to the first prime number that is greater than double the previous capacity.</span></span>  
  
 <span data-ttu-id="84253-247">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="84253-247">Retrieving the value of this property is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-248">En el ejemplo siguiente se muestra cómo crear, rellenar y manipular dos <xref:System.Collections.Generic.HashSet%601> objetos.</span><span class="sxs-lookup"><span data-stu-id="84253-248">The following example demonstrates how to create, populate, and manipulate two <xref:System.Collections.Generic.HashSet%601> objects.</span></span> <span data-ttu-id="84253-249">En este ejemplo, el contenido del conjunto y <xref:System.Collections.Generic.HashSet%601.Count%2A> mostrar en la consola.</span><span class="sxs-lookup"><span data-stu-id="84253-249">In this example, both the contents of the set and <xref:System.Collections.Generic.HashSet%601.Count%2A> display to the console.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateSetComparer">
      <MemberSignature Language="C#" Value="public static System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt; CreateSetComparer ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Collections.Generic.IEqualityComparer`1&lt;class System.Collections.Generic.HashSet`1&lt;!T&gt;&gt; CreateSetComparer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.CreateSetComparer" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateSetComparer () As IEqualityComparer(Of HashSet(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Collections::Generic::IEqualityComparer&lt;System::Collections::Generic::HashSet&lt;T&gt; ^&gt; ^ CreateSetComparer();" />
      <MemberSignature Language="F#" Value="static member CreateSetComparer : unit -&gt; System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;'T&gt;&gt;" Usage="System.Collections.Generic.HashSet&lt;'T&gt;.CreateSetComparer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEqualityComparer&lt;System.Collections.Generic.HashSet&lt;T&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-250">Devuelve un objeto <see cref="T:System.Collections.IEqualityComparer" /> que se puede usar para comprobar la igualdad de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-250">Returns an <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for equality testing of a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-251">Objeto <see cref="T:System.Collections.IEqualityComparer" /> que puede utilizarse para la comprobación de igualdad en profundidad del objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-251">An <see cref="T:System.Collections.IEqualityComparer" /> object that can be used for deep equality testing of the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-252">La <xref:System.Collections.IEqualityComparer> objeto comprueba la igualdad en un solo nivel; sin embargo, puede encadenar comparadores en niveles adicionales para llevar a cabo la comprobación de igualdad más profundo.</span><span class="sxs-lookup"><span data-stu-id="84253-252">The <xref:System.Collections.IEqualityComparer> object checks for equality at only one level; however, you can chain together comparers at additional levels to perform deeper equality testing.</span></span>  
  
 <span data-ttu-id="84253-253">Llamar a este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-253">Calling this method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EnsureCapacity">
      <MemberSignature Language="C#" Value="public int EnsureCapacity (int capacity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EnsureCapacity(int32 capacity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.EnsureCapacity(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function EnsureCapacity (capacity As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EnsureCapacity(int capacity);" />
      <MemberSignature Language="F#" Value="member this.EnsureCapacity : int -&gt; int" Usage="hashSet.EnsureCapacity capacity" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="capacity" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="capacity">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ExceptWith">
      <MemberSignature Language="C#" Value="public void ExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub ExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member ExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.ExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.ExceptWith other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-254">Colección de elementos que se van a quitar del objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-254">The collection of items to remove from the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-255">Quita del objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual todos los elementos de la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-255">Removes all elements in the specified collection from the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-256">El <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> método es el equivalente de resta de conjunto matemáticas.</span><span class="sxs-lookup"><span data-stu-id="84253-256">The <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method is the equivalent of mathematical set subtraction.</span></span>  
  
 <span data-ttu-id="84253-257">Este método es O (`n`) operación, donde `n` es el número de elementos de la `other` parámetro.</span><span class="sxs-lookup"><span data-stu-id="84253-257">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-258">En el ejemplo siguiente se crean dos <xref:System.Collections.Generic.HashSet%601> colecciones con la superposición de conjuntos de datos.</span><span class="sxs-lookup"><span data-stu-id="84253-258">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="84253-259">El intervalo de valores inferior, a continuación, se quita el conjunto más grande mediante el <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-259">The lower range of values is then removed from the larger set using the <xref:System.Collections.Generic.HashSet%601.ExceptWith%2A> method.</span></span>  
  
 [!code-cpp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cpp/program.cpp#02)]
 [!code-csharp[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_ExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_ExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-260">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-260">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.HashSet&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.Generic.HashSet`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As HashSet(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Collections::Generic::HashSet&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; System.Collections.Generic.HashSet&lt;'T&gt;.Enumerator" Usage="hashSet.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.HashSet&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-261">Devuelve un enumerador que recorre en iteración un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-261">Returns an enumerator that iterates through a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-262">Objeto <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> para el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-262">A <see cref="T:System.Collections.Generic.HashSet`1.Enumerator" /> object for the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-263">El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.</span><span class="sxs-lookup"><span data-stu-id="84253-263">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="84253-264">Por lo tanto, uso `foreach` se recomienda en lugar de manipular directamente el enumerador.</span><span class="sxs-lookup"><span data-stu-id="84253-264">Therefore, using `foreach` is recommended instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="84253-265">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</span><span class="sxs-lookup"><span data-stu-id="84253-265">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="84253-266">En principio, el enumerador se coloca antes del primer elemento de la colección.</span><span class="sxs-lookup"><span data-stu-id="84253-266">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="84253-267">En esta posición, el <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propiedad no está definida.</span><span class="sxs-lookup"><span data-stu-id="84253-267">At this position, the <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="84253-268">Por lo tanto, debe llamar a la <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-268">Therefore, you must call the <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="84253-269">El <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="84253-269">The <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> property returns the same object until <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="84253-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> establece <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> en el siguiente elemento.</span><span class="sxs-lookup"><span data-stu-id="84253-270"><xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> sets <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="84253-271">Si <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-271">If <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="84253-272">Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> también devolver `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-272">When the enumerator is at this position, subsequent calls to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="84253-273">Si la última llamada a <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> es indefinido.</span><span class="sxs-lookup"><span data-stu-id="84253-273">If the last call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="84253-274">No puede establecer <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> al primer elemento de la colección, debe crear un nuevo objeto de enumerador en su lugar.</span><span class="sxs-lookup"><span data-stu-id="84253-274">You cannot set <xref:System.Collections.Generic.HashSet%601.Enumerator.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="84253-275">Un enumerador es válido mientras la colección no cambie.</span><span class="sxs-lookup"><span data-stu-id="84253-275">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="84253-276">Si se realizan cambios en la colección, como agregar, modificar, o eliminar elementos, el enumerador queda invalida invalidado y la siguiente llamada a <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> o <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="84253-276">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and the next call to <xref:System.Collections.Generic.HashSet%601.Enumerator.MoveNext%2A> or <xref:System.Collections.Generic.HashSet%601.Enumerator.System%23Collections%23IEnumerator%23Reset%2A> throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="84253-277">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="84253-277">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="84253-278">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</span><span class="sxs-lookup"><span data-stu-id="84253-278">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="84253-279">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="84253-279">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="84253-280">Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="84253-280">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="84253-281">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-281">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetObjectData">
      <MemberSignature Language="C#" Value="public virtual void GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub GetObjectData (info As SerializationInfo, context As StreamingContext)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context);" />
      <MemberSignature Language="F#" Value="abstract member GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit&#xA;override this.GetObjectData : System.Runtime.Serialization.SerializationInfo * System.Runtime.Serialization.StreamingContext -&gt; unit" Usage="hashSet.GetObjectData (info, context)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" />
      </Parameters>
      <Docs>
        <param name="info">
          <span data-ttu-id="84253-282">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que contiene información necesaria para serializar el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-282">A <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object that contains the information required to serialize the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <param name="context">
          <span data-ttu-id="84253-283">Estructura <see cref="T:System.Runtime.Serialization.StreamingContext" /> que contiene el origen y el destino del flujo serializado asociado al objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-283">A <see cref="T:System.Runtime.Serialization.StreamingContext" /> structure that contains the source and destination of the serialized stream associated with the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-284">Implementa la interfaz <see cref="T:System.Runtime.Serialization.ISerializable" /> y devuelve los datos necesarios para serializar un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-284">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and returns the data needed to serialize a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-285">Llamar a este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-285">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-286">El valor de <paramref name="info" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-286">
              <paramref name="info" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="84253-287">para proporcionar servicios de serialización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-287">for providing serialization services.</span>
          </span>
          <span data-ttu-id="84253-288">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-288">Security action: <see cref="F:System.Security.Permissions.SecurityAction.LinkDemand" />.</span>
          </span>
          <span data-ttu-id="84253-289">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.SerializationFormatter" /></span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="IntersectWith">
      <MemberSignature Language="C#" Value="public void IntersectWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void IntersectWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub IntersectWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void IntersectWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IntersectWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.IntersectWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.IntersectWith other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-290">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-290">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-291">Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que solo contenga elementos que están presentes en ese objeto y en la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-291">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present in that object and in the specified collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-292">Si la colección representada por el `other` parámetro es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-292">If the collection represented by the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-293">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A> y `m` es el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-293">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-294">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-294">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSubsetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-295">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-295">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-296">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto apropiado de la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-296">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-297">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto apropiado de <paramref name="other" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-297">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-298">Un conjunto vacío es un subconjunto apropiado de cualquier otra colección.</span><span class="sxs-lookup"><span data-stu-id="84253-298">An empty set is a proper subset of any other collection.</span></span> <span data-ttu-id="84253-299">Por lo tanto, este método devuelve `true` si la colección representada por el actual <xref:System.Collections.Generic.HashSet%601> objeto está vacío, a menos que el `other` parámetro también es un conjunto vacío.</span><span class="sxs-lookup"><span data-stu-id="84253-299">Therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty unless the `other` parameter is also an empty set.</span></span>  
  
 <span data-ttu-id="84253-300">Este método siempre devuelve `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> es mayor o igual que el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-300">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="84253-301">Si la colección representada por `other` es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-301">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, then this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-302">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A> y `m` es el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-302">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-303">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-303">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="84253-304">En este ejemplo, `lowNumbers` es un subconjunto y un subconjunto apropiado de `allNumbers` hasta `allNumbers` se modifica, usando la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para incluir solo los valores que están presentes en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="84253-304">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="84253-305">Una vez `allNumbers` y `lowNumbers` son idénticas, `lowNumbers` sigue siendo un subconjunto de `allNumbers` pero ya no es un subconjunto apropiado.</span><span class="sxs-lookup"><span data-stu-id="84253-305">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-306">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-306">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsProperSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsProperSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsProperSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsProperSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsProperSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsProperSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsProperSupersetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-307">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-307">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-308">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto apropiado de la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-308">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-309">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto apropiado de <paramref name="other" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-309">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a proper superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-310">Un conjunto vacío es un supraconjunto apropiado de cualquier otra colección.</span><span class="sxs-lookup"><span data-stu-id="84253-310">An empty set is a proper superset of any other collection.</span></span> <span data-ttu-id="84253-311">Por lo tanto, este método devuelve `true` si la colección representada por el `other` parámetro está vacío, a menos que el actual <xref:System.Collections.Generic.HashSet%601> colección también está vacía.</span><span class="sxs-lookup"><span data-stu-id="84253-311">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty unless the current <xref:System.Collections.Generic.HashSet%601> collection is also empty.</span></span>  
  
 <span data-ttu-id="84253-312">Este método siempre devuelve `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> es menor o igual que el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-312">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than or equal to the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="84253-313">Si la colección representada por `other` es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-313">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-314">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es el número de elementos de `other` y `m` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-314">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-315">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-315">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="84253-316">En este ejemplo, `allNumbers` es un superconjunto y un supraconjunto apropiado de `lowNumbers` hasta `allNumbers` se modifica, usando la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para incluir solo los valores que están presentes en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="84253-316">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="84253-317">Una vez `allNumbers` y `lowNumbers` son idénticas, `allNumbers` sigue siendo un superconjunto de `lowNumbers` pero ya no es un supraconjunto apropiado.</span><span class="sxs-lookup"><span data-stu-id="84253-317">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-318">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-318">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSubsetOf">
      <MemberSignature Language="C#" Value="public bool IsSubsetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubsetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSubsetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubsetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSubsetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSubsetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSubsetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-319">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-319">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-320">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto de la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-320">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-321">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un subconjunto de <paramref name="other" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-321">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a subset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-322">Un conjunto vacío es un subconjunto de otra colección, incluido un conjunto vacío; por lo tanto, este método devuelve `true` si la colección representada por el actual <xref:System.Collections.Generic.HashSet%601> objeto está vacío, incluso si la `other` parámetro es un conjunto vacío.</span><span class="sxs-lookup"><span data-stu-id="84253-322">An empty set is a subset of any other collection, including an empty set; therefore, this method returns `true` if the collection represented by the current <xref:System.Collections.Generic.HashSet%601> object is empty, even if the `other` parameter is an empty set.</span></span>  
  
 <span data-ttu-id="84253-323">Este método siempre devuelve `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> es mayor que el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-323">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is greater than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="84253-324">Si la colección representada por `other` es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-324">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-325">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A> y `m` es el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-325">Otherwise, this method is an O(`n` + `m`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A> and `m` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-326">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-326">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="84253-327">En este ejemplo, `lowNumbers` es un subconjunto y un subconjunto apropiado de `allNumbers` hasta `allNumbers` se modifica, usando la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para incluir solo los valores que están presentes en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="84253-327">In this example, `lowNumbers` is both a subset and a proper subset of `allNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="84253-328">Una vez `allNumbers` y `lowNumbers` son idénticas, `lowNumbers` sigue siendo un subconjunto de `allNumbers` pero ya no es un subconjunto apropiado.</span><span class="sxs-lookup"><span data-stu-id="84253-328">Once `allNumbers` and `lowNumbers` are identical, `lowNumbers` is still a subset of `allNumbers` but is no longer a proper subset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-329">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-329">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="IsSupersetOf">
      <MemberSignature Language="C#" Value="public bool IsSupersetOf (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSupersetOf(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function IsSupersetOf (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSupersetOf(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsSupersetOf : seq&lt;'T&gt; -&gt; bool&#xA;override this.IsSupersetOf : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.IsSupersetOf other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-330">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-330">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-331">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto de la colección especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-331">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of the specified collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-332">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es un supraconjunto de <paramref name="other" />; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-332">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is a superset of <paramref name="other" />; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-333">Todas las colecciones, incluido el conjunto vacío, son supraconjuntos de un conjunto vacío.</span><span class="sxs-lookup"><span data-stu-id="84253-333">All collections, including the empty set, are supersets of the empty set.</span></span> <span data-ttu-id="84253-334">Por lo tanto, este método devuelve `true` si la colección representada por el `other` parámetro está vacío, incluso si el actual <xref:System.Collections.Generic.HashSet%601> objeto está vacío.</span><span class="sxs-lookup"><span data-stu-id="84253-334">Therefore, this method returns `true` if the collection represented by the `other` parameter is empty, even if the current <xref:System.Collections.Generic.HashSet%601> object is empty.</span></span>  
  
 <span data-ttu-id="84253-335">Este método siempre devuelve `false` si <xref:System.Collections.Generic.HashSet%601.Count%2A> es menor que el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-335">This method always returns `false` if <xref:System.Collections.Generic.HashSet%601.Count%2A> is less than the number of elements in `other`.</span></span>  
  
 <span data-ttu-id="84253-336">Si la colección representada por `other` es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-336">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-337">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es el número de elementos de `other` y `m` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-337">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-338">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-338">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each other.</span></span> <span data-ttu-id="84253-339">En este ejemplo, `allNumbers` es un superconjunto y un supraconjunto apropiado de `lowNumbers` hasta `allNumbers` se modifica, usando la <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> método para incluir solo los valores que están presentes en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="84253-339">In this example, `allNumbers` is both a superset and a proper superset of `lowNumbers` until `allNumbers` is modified, using the <xref:System.Collections.Generic.HashSet%601.IntersectWith%2A> method, to contain only values that are present in both sets.</span></span> <span data-ttu-id="84253-340">Una vez `allNumbers` y `lowNumbers` son idénticas, `allNumbers` sigue siendo un superconjunto de `lowNumbers` pero ya no es un supraconjunto apropiado.</span><span class="sxs-lookup"><span data-stu-id="84253-340">Once `allNumbers` and `lowNumbers` are identical, `allNumbers` is still a superset of `lowNumbers` but is no longer a proper superset.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-341">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-341">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="OnDeserialization">
      <MemberSignature Language="C#" Value="public virtual void OnDeserialization (object sender);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void OnDeserialization(object sender) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.OnDeserialization(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Sub OnDeserialization (sender As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void OnDeserialization(System::Object ^ sender);" />
      <MemberSignature Language="F#" Value="abstract member OnDeserialization : obj -&gt; unit&#xA;override this.OnDeserialization : obj -&gt; unit" Usage="hashSet.OnDeserialization sender" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="sender" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="sender">
          <span data-ttu-id="84253-342">Origen del evento de deserialización.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-342">The source of the deserialization event.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-343">Implementa la interfaz <see cref="T:System.Runtime.Serialization.ISerializable" /> y genera el evento de deserialización cuando esta ha finalizado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-343">Implements the <see cref="T:System.Runtime.Serialization.ISerializable" /> interface and raises the deserialization event when the deserialization is complete.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-344">Llamar a este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-344">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Runtime.Serialization.SerializationException">
          <span data-ttu-id="84253-345">El objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> asociado al objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-345">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object associated with the current <see cref="T:System.Collections.Generic.HashSet`1" /> object is invalid.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Overlaps">
      <MemberSignature Language="C#" Value="public bool Overlaps (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Overlaps(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function Overlaps (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Overlaps(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member Overlaps : seq&lt;'T&gt; -&gt; bool&#xA;override this.Overlaps : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.Overlaps other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-346">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-346">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-347">Determina si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual y una colección especificada comparten elementos comunes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-347">Determines whether the current <see cref="T:System.Collections.Generic.HashSet`1" /> object and a specified collection share common elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-348">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> y <paramref name="other" /> comparten al menos un elemento común; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-348">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object and <paramref name="other" /> share at least one common element; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-349">Este método es O (`n`) operación, donde `n` es el número de elementos de `other`.</span><span class="sxs-lookup"><span data-stu-id="84253-349">This method is an O(`n`) operation, where `n` is the number of elements in `other`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-350">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-350">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="84253-351">En este ejemplo, `allNumbers` y `lowNumbers` se muestran para compartir elementos comunes mediante el <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-351">In this example, `allNumbers` and `lowNumbers` are shown to share common elements using the <xref:System.Collections.Generic.HashSet%601.Overlaps%2A> method.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-352">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-352">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public bool Remove (T item);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Remove(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.Remove(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (item As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Remove(T item);" />
      <MemberSignature Language="F#" Value="abstract member Remove : 'T -&gt; bool&#xA;override this.Remove : 'T -&gt; bool" Usage="hashSet.Remove item" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Remove(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="84253-353">Elemento que se va a quitar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-353">The element to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-354">Quita el elemento especificado de un objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-354">Removes the specified element from a <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-355">
            <see langword="true" /> si el elemento se encuentra y quita correctamente; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-355">
              <see langword="true" /> if the element is successfully found and removed; otherwise, <see langword="false" />.</span>
          </span>
          <span data-ttu-id="84253-356">Este método devuelve <see langword="false" /> si <paramref name="item" /> no se encuentra en el objeto <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-356">This method returns <see langword="false" /> if <paramref name="item" /> is not found in the <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-357">Si el <xref:System.Collections.Generic.HashSet%601> objeto no contiene el elemento especificado, el objeto permanece sin cambios.</span><span class="sxs-lookup"><span data-stu-id="84253-357">If the <xref:System.Collections.Generic.HashSet%601> object does not contain the specified element, the object remains unchanged.</span></span> <span data-ttu-id="84253-358">No se inicia ninguna excepción.</span><span class="sxs-lookup"><span data-stu-id="84253-358">No exception is thrown.</span></span>  
  
 <span data-ttu-id="84253-359">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-359">This method is an O(1) operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-360">En el ejemplo siguiente se muestra cómo quitar valores de un <xref:System.Collections.Generic.HashSet%601> colección utilizando el <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-360">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="84253-361">En este ejemplo, se quita arbitrariamente cero de la <xref:System.Collections.Generic.HashSet%601> colección.</span><span class="sxs-lookup"><span data-stu-id="84253-361">In this example, zero is arbitrarily removed from the <xref:System.Collections.Generic.HashSet%601> collection.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="RemoveWhere">
      <MemberSignature Language="C#" Value="public int RemoveWhere (Predicate&lt;T&gt; match);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 RemoveWhere(class System.Predicate`1&lt;!T&gt; match) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.RemoveWhere(System.Predicate{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function RemoveWhere (match As Predicate(Of T)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int RemoveWhere(Predicate&lt;T&gt; ^ match);" />
      <MemberSignature Language="F#" Value="member this.RemoveWhere : Predicate&lt;'T&gt; -&gt; int" Usage="hashSet.RemoveWhere match" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="match" Type="System.Predicate&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="match">
          <span data-ttu-id="84253-362">Delegado <see cref="T:System.Predicate`1" /> que define las condiciones de los elementos que se van a quitar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-362">The <see cref="T:System.Predicate`1" /> delegate that defines the conditions of the elements to remove.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-363">Quita todos los elementos que cumplen las condiciones definidas por el predicado especificado de una colección <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-363">Removes all elements that match the conditions defined by the specified predicate from a <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-364">Número de elementos que se quitaron de la colección <see cref="T:System.Collections.Generic.HashSet`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-364">The number of elements that were removed from the <see cref="T:System.Collections.Generic.HashSet`1" /> collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-365">Llamar a este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-365">Calling this method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-366">En el ejemplo siguiente se muestra cómo quitar valores de un <xref:System.Collections.Generic.HashSet%601> colección utilizando el <xref:System.Collections.Generic.HashSet%601.Remove%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-366">The following example demonstrates how to remove values from a <xref:System.Collections.Generic.HashSet%601> collection using the <xref:System.Collections.Generic.HashSet%601.Remove%2A> method.</span></span> <span data-ttu-id="84253-367">En este ejemplo, se quitan todos los valores enteros impares de la <xref:System.Collections.Generic.HashSet%601> colección especificado por el `match` delegar.</span><span class="sxs-lookup"><span data-stu-id="84253-367">In this example, all odd integers are removed from the <xref:System.Collections.Generic.HashSet%601> collection as specified by the `match` delegate.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_RemoveWhere#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_RemoveWhere/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-368">El valor de <paramref name="match" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-368">
              <paramref name="match" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SetEquals">
      <MemberSignature Language="C#" Value="public bool SetEquals (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool SetEquals(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function SetEquals (other As IEnumerable(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool SetEquals(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SetEquals : seq&lt;'T&gt; -&gt; bool&#xA;override this.SetEquals : seq&lt;'T&gt; -&gt; bool" Usage="hashSet.SetEquals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-369">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-369">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-370">Determina si un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> y la colección especificada contienen los mismos elementos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-370">Determines whether a <see cref="T:System.Collections.Generic.HashSet`1" /> object and the specified collection contain the same elements.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-371">Es <see langword="true" /> si el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> es igual a <paramref name="other" />; de lo contrario, es false.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-371">
              <see langword="true" /> if the <see cref="T:System.Collections.Generic.HashSet`1" /> object is equal to <paramref name="other" />; otherwise, false.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-372">El <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> método omite las entradas duplicadas y el orden de los elementos en el `other` parámetro.</span><span class="sxs-lookup"><span data-stu-id="84253-372">The <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method ignores duplicate entries and the order of elements in the `other` parameter.</span></span>  
  
 <span data-ttu-id="84253-373">Si la colección representada por `other` es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-373">If the collection represented by `other` is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-374">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es el número de elementos de `other` y `m` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-374">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-375">El ejemplo siguiente crea dos dispares <xref:System.Collections.Generic.HashSet%601> objetos y se comparan entre sí.</span><span class="sxs-lookup"><span data-stu-id="84253-375">The following example creates two disparate <xref:System.Collections.Generic.HashSet%601> objects and compares them to each another.</span></span> <span data-ttu-id="84253-376">Inicialmente, los dos conjuntos no son iguales, que se muestra utilizando el <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-376">Initially, the two sets are not equal, which is demonstrated by using the <xref:System.Collections.Generic.HashSet%601.SetEquals%2A> method.</span></span> <span data-ttu-id="84253-377">El `allNumbers` <xref:System.Collections.Generic.HashSet%601> , a continuación, se modifica el objeto, tras el cual los conjuntos son iguales.</span><span class="sxs-lookup"><span data-stu-id="84253-377">The `allNumbers`<xref:System.Collections.Generic.HashSet%601> object is then modified, after which the sets are equal.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_boolMethods#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_boolMethods/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-378">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-378">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="SymmetricExceptWith">
      <MemberSignature Language="C#" Value="public void SymmetricExceptWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SymmetricExceptWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SymmetricExceptWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SymmetricExceptWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.SymmetricExceptWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.SymmetricExceptWith other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-3.5;netframework-4.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-379">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-379">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-380">Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que contenga únicamente los elementos que están presentes en ese objeto o en la colección especificada, pero no en ambos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-380">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain only elements that are present either in that object or in the specified collection, but not both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-381">Si el `other` parámetro es un <xref:System.Collections.Generic.HashSet%601> colección con el mismo comparador de igualdad que actual <xref:System.Collections.Generic.HashSet%601> objeto, este método es O (`n`) operación.</span><span class="sxs-lookup"><span data-stu-id="84253-381">If the `other` parameter is a <xref:System.Collections.Generic.HashSet%601> collection with the same equality comparer as the current <xref:System.Collections.Generic.HashSet%601> object, this method is an O(`n`) operation.</span></span> <span data-ttu-id="84253-382">En caso contrario, este método es O (`n` + `m`) operación, donde `n` es el número de elementos de `other` y `m` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-382">Otherwise, this method is an O(`n` + `m`) operation, where `n` is the number of elements in `other` and `m` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-383">En el ejemplo siguiente se crean dos <xref:System.Collections.Generic.HashSet%601> colecciones con la superposición de conjuntos de datos.</span><span class="sxs-lookup"><span data-stu-id="84253-383">The following example creates two <xref:System.Collections.Generic.HashSet%601> collections with overlapping sets of data.</span></span> <span data-ttu-id="84253-384">El conjunto que contiene los valores más bajos, a continuación, se modifica, usando la <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> método contenga solo los valores que no están presentes en ambos conjuntos.</span><span class="sxs-lookup"><span data-stu-id="84253-384">The set that contains the lower values is then modified, using the <xref:System.Collections.Generic.HashSet%601.SymmetricExceptWith%2A> method, to contain only the values that are not present in both sets.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_SymmetricExceptWith#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_SymmetricExceptWith/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-385">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-385">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.Add">
      <MemberSignature Language="C#" Value="void ICollection&lt;T&gt;.Add (T item);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Collections.Generic.ICollection&lt;T&gt;.Add(!T item) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#Add(`0)" />
      <MemberSignature Language="VB.NET" Value="Sub Add (item As T) Implements ICollection(Of T).Add" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Collections.Generic.ICollection&lt;T&gt;.Add(T item) = System::Collections::Generic::ICollection&lt;T&gt;::Add;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.ICollection`1.Add(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="T" />
      </Parameters>
      <Docs>
        <param name="item">
          <span data-ttu-id="84253-386">Objeto que se va a agregar al objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-386">The object to add to the <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-387">Agrega un elemento a un objeto <see cref="T:System.Collections.Generic.ICollection`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-387">Adds an item to an <see cref="T:System.Collections.Generic.ICollection`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-388">Si <xref:System.Collections.Generic.List%601.Count%2A> es menor que <xref:System.Collections.Generic.List%601.Capacity%2A>, este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-388">If <xref:System.Collections.Generic.List%601.Count%2A> is less than <xref:System.Collections.Generic.List%601.Capacity%2A>, this method is an O(1) operation.</span></span> <span data-ttu-id="84253-389">Si la capacidad debe aumentarse para alojar el nuevo elemento, este método se convierte en una O (`n`) operación, donde `n` es <xref:System.Collections.Generic.List%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-389">If the capacity must be increased to accommodate the new element, this method becomes an O(`n`) operation, where `n` is <xref:System.Collections.Generic.List%601.Count%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="84253-390">
            <see cref="T:System.Collections.Generic.ICollection`1" /> es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-390">The <see cref="T:System.Collections.Generic.ICollection`1" /> is read-only.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly">
      <MemberSignature Language="C#" Value="bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberSignature Language="DocId" Value="P:System.Collections.Generic.HashSet`1.System#Collections#Generic#ICollection&lt;T&gt;#IsReadOnly" />
      <MemberSignature Language="VB.NET" Value=" ReadOnly Property IsReadOnly As Boolean Implements ICollection(Of T).IsReadOnly" />
      <MemberSignature Language="C++ CLI" Value="property bool System::Collections::Generic::ICollection&lt;T&gt;::IsReadOnly { bool get(); };" />
      <MemberSignature Language="F#" Usage="System.Collections.Generic.ICollection&lt;T&gt;.IsReadOnly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Collections.Generic.ICollection`1.IsReadOnly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="84253-391">Obtiene un valor que indica si una colección es de solo lectura.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-391">Gets a value indicating whether a collection is read-only.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="84253-392">
            <see langword="true" /> si la colección es de solo lectura; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-392">
              <see langword="true" /> if the collection is read-only; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-393">La recuperación del valor de esta propiedad es una operación O(1).</span><span class="sxs-lookup"><span data-stu-id="84253-393">Retrieving the value of this property is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;T&gt; IEnumerable&lt;T&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;!T&gt; System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#Generic#IEnumerable&lt;T&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of T) Implements IEnumerable(Of T).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;T&gt; ^ System.Collections.Generic.IEnumerable&lt;T&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;T&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-394">Devuelve un enumerador que recorre en iteración una colección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-394">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-395">Objeto <see cref="T:System.Collections.Generic.IEnumerator`1" /> que puede usarse para recorrer en iteración la colección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-395">An <see cref="T:System.Collections.Generic.IEnumerator`1" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-396">El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.</span><span class="sxs-lookup"><span data-stu-id="84253-396">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="84253-397">Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.</span><span class="sxs-lookup"><span data-stu-id="84253-397">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="84253-398">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</span><span class="sxs-lookup"><span data-stu-id="84253-398">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="84253-399">En principio, el enumerador se coloca antes del primer elemento de la colección.</span><span class="sxs-lookup"><span data-stu-id="84253-399">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="84253-400">En esta posición, el <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propiedad no está definida.</span><span class="sxs-lookup"><span data-stu-id="84253-400">At this position, the <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property is undefined.</span></span> <span data-ttu-id="84253-401">Por lo tanto, debe llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-401">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.Generic.IEnumerator%601.Current%2A>.</span></span>  
  
 <span data-ttu-id="84253-402">El <xref:System.Collections.Generic.IEnumerator%601.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.IEnumerator.MoveNext%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="84253-402">The <xref:System.Collections.Generic.IEnumerator%601.Current%2A> property returns the same object until <xref:System.Collections.IEnumerator.MoveNext%2A> is called.</span></span> <span data-ttu-id="84253-403"><xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.Generic.IEnumerator%601.Current%2A> en el siguiente elemento.</span><span class="sxs-lookup"><span data-stu-id="84253-403"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="84253-404">Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-404">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="84253-405">Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-405">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="84253-406">Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> es indefinido.</span><span class="sxs-lookup"><span data-stu-id="84253-406">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.Generic.IEnumerator%601.Current%2A> is undefined.</span></span> <span data-ttu-id="84253-407">No puede establecer <xref:System.Collections.Generic.IEnumerator%601.Current%2A> al primer elemento de la colección, debe crear un nuevo objeto de enumerador en su lugar.</span><span class="sxs-lookup"><span data-stu-id="84253-407">You cannot set <xref:System.Collections.Generic.IEnumerator%601.Current%2A> to the first element of the collection again; you must create a new enumerator object instead.</span></span>  
  
 <span data-ttu-id="84253-408">Un enumerador es válido mientras la colección no cambie.</span><span class="sxs-lookup"><span data-stu-id="84253-408">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="84253-409">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</span><span class="sxs-lookup"><span data-stu-id="84253-409">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="84253-410">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="84253-410">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span> <span data-ttu-id="84253-411">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</span><span class="sxs-lookup"><span data-stu-id="84253-411">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="84253-412">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="84253-412">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="84253-413">Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="84253-413">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="84253-414">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-414">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.Generic.IEnumerator`1" />
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-415">Devuelve un enumerador que recorre en iteración una colección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-415">Returns an enumerator that iterates through a collection.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-416">Objeto <see cref="T:System.Collections.IEnumerator" /> que puede usarse para recorrer en iteración la colección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-416">An <see cref="T:System.Collections.IEnumerator" /> object that can be used to iterate through the collection.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-417">El `foreach` instrucción del lenguaje C# (`for each` en C++, `For Each` en Visual Basic) oculta la complejidad de los enumeradores.</span><span class="sxs-lookup"><span data-stu-id="84253-417">The `foreach` statement of the C# language (`for each` in C++, `For Each` in Visual Basic) hides the complexity of enumerators.</span></span> <span data-ttu-id="84253-418">Por lo tanto, se recomienda el uso de `foreach`, en lugar de manipular directamente el enumerador.</span><span class="sxs-lookup"><span data-stu-id="84253-418">Therefore, using `foreach` is recommended, instead of directly manipulating the enumerator.</span></span>  
  
 <span data-ttu-id="84253-419">Los enumeradores pueden usarse para leer los datos de la colección, pero no para modificar la colección subyacente.</span><span class="sxs-lookup"><span data-stu-id="84253-419">Enumerators can be used to read the data in the collection, but they cannot be used to modify the underlying collection.</span></span>  
  
 <span data-ttu-id="84253-420">En principio, el enumerador se coloca antes del primer elemento de la colección.</span><span class="sxs-lookup"><span data-stu-id="84253-420">Initially, the enumerator is positioned before the first element in the collection.</span></span> <span data-ttu-id="84253-421"><xref:System.Collections.IEnumerator.Reset%2A> también devuelve el enumerador a esta posición.</span><span class="sxs-lookup"><span data-stu-id="84253-421"><xref:System.Collections.IEnumerator.Reset%2A> also brings the enumerator back to this position.</span></span>  <span data-ttu-id="84253-422">En esta posición, el <xref:System.Collections.IEnumerator.Current%2A> propiedad no está definida.</span><span class="sxs-lookup"><span data-stu-id="84253-422">At this position, the <xref:System.Collections.IEnumerator.Current%2A> property is undefined.</span></span> <span data-ttu-id="84253-423">Por lo tanto, debe llamar a la <xref:System.Collections.IEnumerator.MoveNext%2A> método para hacer avanzar el enumerador hasta el primer elemento de la colección antes de leer el valor de <xref:System.Collections.IEnumerator.Current%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-423">Therefore, you must call the <xref:System.Collections.IEnumerator.MoveNext%2A> method to advance the enumerator to the first element of the collection before reading the value of <xref:System.Collections.IEnumerator.Current%2A>.</span></span>  
  
 <span data-ttu-id="84253-424">El <xref:System.Collections.IEnumerator.Current%2A> propiedad devuelve el mismo objeto hasta que <xref:System.Collections.IEnumerator.MoveNext%2A> o <xref:System.Collections.IEnumerator.Reset%2A> se llama.</span><span class="sxs-lookup"><span data-stu-id="84253-424">The <xref:System.Collections.IEnumerator.Current%2A> property returns the same object until either <xref:System.Collections.IEnumerator.MoveNext%2A> or <xref:System.Collections.IEnumerator.Reset%2A> is called.</span></span> <span data-ttu-id="84253-425"><xref:System.Collections.IEnumerator.MoveNext%2A> establece <xref:System.Collections.IEnumerator.Current%2A> en el siguiente elemento.</span><span class="sxs-lookup"><span data-stu-id="84253-425"><xref:System.Collections.IEnumerator.MoveNext%2A> sets <xref:System.Collections.IEnumerator.Current%2A> to the next element.</span></span>  
  
 <span data-ttu-id="84253-426">Si <xref:System.Collections.IEnumerator.MoveNext%2A> pasa el final de la colección, el enumerador se coloca después del último elemento de la colección y <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-426">If <xref:System.Collections.IEnumerator.MoveNext%2A> passes the end of the collection, the enumerator is positioned after the last element in the collection and <xref:System.Collections.IEnumerator.MoveNext%2A> returns `false`.</span></span> <span data-ttu-id="84253-427">Cuando el enumerador está en esta posición, las llamadas subsiguientes a <xref:System.Collections.IEnumerator.MoveNext%2A> también devolver `false`.</span><span class="sxs-lookup"><span data-stu-id="84253-427">When the enumerator is at this position, subsequent calls to <xref:System.Collections.IEnumerator.MoveNext%2A> also return `false`.</span></span> <span data-ttu-id="84253-428">Si la última llamada a <xref:System.Collections.IEnumerator.MoveNext%2A> devuelve `false`, <xref:System.Collections.IEnumerator.Current%2A> es indefinido.</span><span class="sxs-lookup"><span data-stu-id="84253-428">If the last call to <xref:System.Collections.IEnumerator.MoveNext%2A> returned `false`, <xref:System.Collections.IEnumerator.Current%2A> is undefined.</span></span> <span data-ttu-id="84253-429">Para volver a establecer el valor de <xref:System.Collections.IEnumerator.Current%2A> en el primer elemento de la colección, se puede llamar primero a <xref:System.Collections.IEnumerator.Reset%2A> y después a <xref:System.Collections.IEnumerator.MoveNext%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-429">To set <xref:System.Collections.IEnumerator.Current%2A> to the first element of the collection again, you can call <xref:System.Collections.IEnumerator.Reset%2A> followed by <xref:System.Collections.IEnumerator.MoveNext%2A>.</span></span>  
  
 <span data-ttu-id="84253-430">Un enumerador es válido mientras la colección no cambie.</span><span class="sxs-lookup"><span data-stu-id="84253-430">An enumerator remains valid as long as the collection remains unchanged.</span></span> <span data-ttu-id="84253-431">Si se hacen cambios en la colección (como agregar, modificar o eliminar elementos), el enumerador queda invalidado permanentemente y su comportamiento es indefinido.</span><span class="sxs-lookup"><span data-stu-id="84253-431">If changes are made to the collection, such as adding, modifying, or deleting elements, the enumerator is irrecoverably invalidated and its behavior is undefined.</span></span>  
  
 <span data-ttu-id="84253-432">El enumerador no tiene acceso exclusivo a la colección y, por tanto, la enumeración en una colección no es intrínsicamente un procedimiento seguro para subprocesos.</span><span class="sxs-lookup"><span data-stu-id="84253-432">The enumerator does not have exclusive access to the collection; therefore, enumerating through a collection is intrinsically not a thread-safe procedure.</span></span>  <span data-ttu-id="84253-433">A fin de garantizar la seguridad de los subprocesos, se puede bloquear la colección durante toda la enumeración.</span><span class="sxs-lookup"><span data-stu-id="84253-433">To guarantee thread safety during enumeration, you can lock the collection during the entire enumeration.</span></span>  <span data-ttu-id="84253-434">Para permitir que varios subprocesos obtengan acceso de lectura y escritura a la colección, debe implementar su propia sincronización.</span><span class="sxs-lookup"><span data-stu-id="84253-434">To allow the collection to be accessed by multiple threads for reading and writing, you must implement your own synchronization.</span></span>  
  
 <span data-ttu-id="84253-435">Las implementaciones predeterminadas de las colecciones del espacio de nombres <xref:System.Collections.Generic?displayProperty=nameWithType> no están sincronizadas.</span><span class="sxs-lookup"><span data-stu-id="84253-435">Default implementations of collections in the <xref:System.Collections.Generic?displayProperty=nameWithType> namespace are not synchronized.</span></span>  
  
 <span data-ttu-id="84253-436">Este método es una operación o (1).</span><span class="sxs-lookup"><span data-stu-id="84253-436">This method is an O(1) operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Collections.IEnumerator" />
      </Docs>
    </Member>
    <Member MemberName="TrimExcess">
      <MemberSignature Language="C#" Value="public void TrimExcess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void TrimExcess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TrimExcess" />
      <MemberSignature Language="VB.NET" Value="Public Sub TrimExcess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void TrimExcess();" />
      <MemberSignature Language="F#" Value="member this.TrimExcess : unit -&gt; unit" Usage="hashSet.TrimExcess " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="84253-437">Establece la capacidad de un objeto <see cref="T:System.Collections.Generic.HashSet`1" /> en el número real de elementos que contiene, redondeado a un valor próximo específico de la implementación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-437">Sets the capacity of a <see cref="T:System.Collections.Generic.HashSet`1" /> object to the actual number of elements it contains, rounded up to a nearby, implementation-specific value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-438">Puede usar el <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> método minimizar una <xref:System.Collections.Generic.HashSet%601> sobrecarga de memoria del objeto una vez que se sabe que no se agregará ningún elemento nuevo.</span><span class="sxs-lookup"><span data-stu-id="84253-438">You can use the <xref:System.Collections.Generic.HashSet%601.TrimExcess%2A> method to minimize a <xref:System.Collections.Generic.HashSet%601> object's memory overhead once it is known that no new elements will be added.</span></span> <span data-ttu-id="84253-439">Para borrar completamente una <xref:System.Collections.Generic.HashSet%601> de objeto y liberar memoria todos los que hace referencia a él, llame a este método después de llamar a la <xref:System.Collections.Generic.HashSet%601.Clear%2A> método.</span><span class="sxs-lookup"><span data-stu-id="84253-439">To completely clear a <xref:System.Collections.Generic.HashSet%601> object and release all memory referenced by it, call this method after calling the <xref:System.Collections.Generic.HashSet%601.Clear%2A> method.</span></span>  
  
 <span data-ttu-id="84253-440">Este método es O (`n`) operación, donde `n` es <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span><span class="sxs-lookup"><span data-stu-id="84253-440">This method is an O(`n`) operation, where `n` is <xref:System.Collections.Generic.HashSet%601.Count%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-441">El ejemplo siguiente se crea y rellena un <xref:System.Collections.Generic.HashSet%601> colección y, a continuación, borra la colección y libera la memoria que se hace referencia a él.</span><span class="sxs-lookup"><span data-stu-id="84253-441">The following example creates and populates a <xref:System.Collections.Generic.HashSet%601> collection, and then clears the collection and releases the memory referenced by it.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/cs/Program.cs#02)]
 [!code-vb[System.Collections.Generic.HashSet_Clear#02](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_Clear/vb/Program.vb#02)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryGetValue">
      <MemberSignature Language="C#" Value="public bool TryGetValue (T equalValue, out T actualValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryGetValue(!T equalValue, [out] !T&amp; actualValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.TryGetValue(`0,`0@)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryGetValue (equalValue As T, ByRef actualValue As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryGetValue(T equalValue, [Runtime::InteropServices::Out] T % actualValue);" />
      <MemberSignature Language="F#" Value="member this.TryGetValue : 'T *  -&gt; bool" Usage="hashSet.TryGetValue (equalValue, actualValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="equalValue" Type="T" />
        <Parameter Name="actualValue" Type="T" RefType="out" />
      </Parameters>
      <Docs>
        <param name="equalValue">
          <span data-ttu-id="84253-442">Valor que se va a buscar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-442">The value to search for.</span>
          </span>
        </param>
        <param name="actualValue">
          <span data-ttu-id="84253-443">Valor del conjunto encontrado por la búsqueda o el valor predeterminado de T si la búsqueda no ha devuelto ninguna coincidencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-443">The value from the set that the search found, or the default value of T when the search yielded no match.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-444">Busca en el conjunto un valor determinado y devuelve un valor igual al que encuentra, si encuentra alguno.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-444">Searches the set for a given value and returns the equal value it finds, if any.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="84253-445">Valor que indica si la búsqueda se ha realizado correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-445">A value indicating whether the search was successful.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-446">Esto puede ser útil cuando desea reutilizar una referencia almacenada previamente en lugar de uno recién construida (de modo que puede producirse más uso compartido de referencias) o para buscar un valor que tenga más completa de los datos que el valor que tiene actualmente, aunque sus funciones comparador indicar son iguales.</span><span class="sxs-lookup"><span data-stu-id="84253-446">This can be useful when you want to reuse a previously stored reference instead of a newly constructed one (so that more sharing of references can occur) or to look up a value that has more complete data than the value you currently have, although their comparer functions indicate they are equal.</span></span>
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="UnionWith">
      <MemberSignature Language="C#" Value="public void UnionWith (System.Collections.Generic.IEnumerable&lt;T&gt; other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void UnionWith(class System.Collections.Generic.IEnumerable`1&lt;!T&gt; other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Collections.Generic.HashSet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub UnionWith (other As IEnumerable(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void UnionWith(System::Collections::Generic::IEnumerable&lt;T&gt; ^ other);" />
      <MemberSignature Language="F#" Value="abstract member UnionWith : seq&lt;'T&gt; -&gt; unit&#xA;override this.UnionWith : seq&lt;'T&gt; -&gt; unit" Usage="hashSet.UnionWith other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Collections</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>3.5.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Collections.Generic.IEnumerable&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="84253-447">Colección que se va a comparar con el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-447">The collection to compare to the current <see cref="T:System.Collections.Generic.HashSet`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="84253-448">Modifica el objeto <see cref="T:System.Collections.Generic.HashSet`1" /> actual para que contenga todos los elementos que están presentes en él y en la colección especificada o en ambos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-448">Modifies the current <see cref="T:System.Collections.Generic.HashSet`1" /> object to contain all elements that are present in itself, the specified collection, or both.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="84253-449">Este método es O (`n`) operación, donde `n` es el número de elementos de la `other` parámetro.</span><span class="sxs-lookup"><span data-stu-id="84253-449">This method is an O(`n`) operation, where `n` is the number of elements in the `other` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="84253-450">El ejemplo siguiente muestra cómo combinar dos conjuntos dispares.</span><span class="sxs-lookup"><span data-stu-id="84253-450">The following example demonstrates how to merge two disparate sets.</span></span> <span data-ttu-id="84253-451">En este ejemplo se crea dos <xref:System.Collections.Generic.HashSet%601> objetos y la rellena con números pares e impares, respectivamente.</span><span class="sxs-lookup"><span data-stu-id="84253-451">This example creates two <xref:System.Collections.Generic.HashSet%601> objects, and populates them with even and odd numbers, respectively.</span></span> <span data-ttu-id="84253-452">Una tercera <xref:System.Collections.Generic.HashSet%601> se crea el objeto del conjunto que contiene los números pares.</span><span class="sxs-lookup"><span data-stu-id="84253-452">A third <xref:System.Collections.Generic.HashSet%601> object is created from the set that contains the even numbers.</span></span> <span data-ttu-id="84253-453">El ejemplo llama a la <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> método, que agrega el conjunto de números impar al tercer conjunto.</span><span class="sxs-lookup"><span data-stu-id="84253-453">The example then calls the <xref:System.Collections.Generic.HashSet%601.UnionWith%2A> method, which adds the odd number set to the third set.</span></span>  
  
 [!code-csharp[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/cs/Program.cs#01)]
 [!code-vb[System.Collections.Generic.HashSet_UnionWith#01](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Collections.Generic.HashSet_UnionWith/vb/Program.vb#01)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="84253-454">El valor de <paramref name="other" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="84253-454">
              <paramref name="other" /> is <see langword="null" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
  </Members>
</Type>