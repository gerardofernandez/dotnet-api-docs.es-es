<Type Name="Span&lt;T&gt;" FullName="System.Span&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="6348ca48e2f74be9e672b6f8b005472eeb3f48ce" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52213399" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct Span&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Span`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.Span`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure Span(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class Span" />
  <TypeSignature Language="F#" Value="type Span&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="ab474-101">El tipo de elementos en el <see cref="System.Span`1" />.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ab474-101">The type of items in the <see cref="System.Span`1" />.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="ab474-102">Proporciona una representación para tipos y memoria de una región contigua de memoria arbitraria.</span>
      <span class="sxs-lookup">
        <span data-stu-id="ab474-102">Provides a type- and memory-safe representation of a contiguous region of arbitrary memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-103">`Span<T>` es un [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) que se asigna en la pila, en lugar de en el montón administrado.</span><span class="sxs-lookup"><span data-stu-id="ab474-103">`Span<T>` is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that is allocated on the stack rather than on the managed heap.</span></span> <span data-ttu-id="ab474-104">Tipos de struct ref tienen un número de restricciones para asegurarse de que no se puede promocionar al montón administrado, incluidos los que no se puede realizar la conversión boxing, no se puede asignar a variables de tipo <xref:System.Object>, `dynamic` o a cualquier tipo de interfaz no pueden ser campos de un tipo de referencia y no se puede usar a través de `await` y `yield` los límites.</span><span class="sxs-lookup"><span data-stu-id="ab474-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, they can't be assigned to variables of type <xref:System.Object>, `dynamic` or to any interface type, they can't be fields in a reference type, and they can't be used across `await` and `yield` boundaries.</span></span> <span data-ttu-id="ab474-105">Además, las llamadas a dos métodos, <xref:System.Span%601.Equals(System.Object)> y <xref:System.Span%601.GetHashCode%2A>, producir una <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="ab474-105">In addition, calls to two methods, <xref:System.Span%601.Equals(System.Object)> and <xref:System.Span%601.GetHashCode%2A>, throw a <xref:System.NotSupportedException>.</span></span> 

> [!IMPORTANT]
> <span data-ttu-id="ab474-106">Porque es un tipo de solo pila `Span<T>` no es adecuado para muchos escenarios que requieren almacenar referencias a los búferes en el montón.</span><span class="sxs-lookup"><span data-stu-id="ab474-106">Because it is a stack-only type, `Span<T>` is unsuitable for many scenarios that require storing references to buffers on the heap.</span></span> <span data-ttu-id="ab474-107">Esto es así, por ejemplo, de rutinas que realizan llamadas de método asynchrous.</span><span class="sxs-lookup"><span data-stu-id="ab474-107">This is true, for example, of routines that make asynchrous method calls.</span></span> <span data-ttu-id="ab474-108">Para este tipo scenarious, puede usar el gratuitos <xref:System.Memory%601?displayProperty=nameWithType> y <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> tipos.</span><span class="sxs-lookup"><span data-stu-id="ab474-108">For such scenarious, you can use the complimentary <xref:System.Memory%601?displayProperty=nameWithType> and <xref:System.ReadOnlyMemory%601?displayProperty=nameWithType> types.</span></span>

<span data-ttu-id="ab474-109">Para los intervalos que representan las estructuras inmutables o de solo lectura, utilice <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="ab474-109">For spans that represent immutable or read-only structures, use <xref:System.ReadOnlySpan%601?displayProperty=nameWithType>.</span></span>

## <a name="spant-and-memory"></a><span data-ttu-id="ab474-110">Intervalo\<T > y la memoria</span><span class="sxs-lookup"><span data-stu-id="ab474-110">Span\<T> and memory</span></span>

<span data-ttu-id="ab474-111">Un `Span<T>` representa una región contigua de memoria arbitraria.</span><span class="sxs-lookup"><span data-stu-id="ab474-111">A `Span<T>` represents a contiguous region of arbitrary memory.</span></span> <span data-ttu-id="ab474-112">Un `Span<T>` instancia a menudo se usa para contener los elementos de una matriz o una parte de una matriz.</span><span class="sxs-lookup"><span data-stu-id="ab474-112">A `Span<T>` instance is often used to hold the elements of an array or a portion of an array.</span></span> <span data-ttu-id="ab474-113">A diferencia de una matriz, sin embargo, un `Span<T>` instancia puede apuntar a la memoria administrada, memoria nativa, o memoria administrada en la pila.</span><span class="sxs-lookup"><span data-stu-id="ab474-113">Unlike an array, however, a `Span<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span> <span data-ttu-id="ab474-114">En el ejemplo siguiente se crea un `Span<Byte>` desde una matriz:</span><span class="sxs-lookup"><span data-stu-id="ab474-114">The following example creates a `Span<Byte>` from an array:</span></span>

[!code-csharp[Creating a Span\<Byte> from an array](~/samples/snippets/csharp/api/system/span/program.cs#1)]
     
<span data-ttu-id="ab474-115">En el ejemplo siguiente se crea un `Span<Byte>` de 100 bytes de memoria nativa:</span><span class="sxs-lookup"><span data-stu-id="ab474-115">The following example creates a `Span<Byte>` from 100 bytes of native memory:</span></span>

[!code-csharp[Creating a Span\<Byte> from native memory](~/samples/snippets/csharp/api/system/span/program.cs#2)]

<span data-ttu-id="ab474-116">En el ejemplo siguiente se usa el C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) palabra clave para asignar 100 bytes de memoria en la pila:</span><span class="sxs-lookup"><span data-stu-id="ab474-116">The following example uses the C# [stackalloc](~/docs/csharp/language-reference/keywords/stackalloc.md) keyword to allocate 100 bytes of memory on the stack:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#3)]

<span data-ttu-id="ab474-117">Dado que `Span<T>` es una abstracción sobre un bloque arbitrario de memoria, los métodos de la `Span<T>` clases y métodos con `Span<T>` parámetros operan en cualquier `Span<T>` objeto independientemente del tipo de memoria encapsula.</span><span class="sxs-lookup"><span data-stu-id="ab474-117">Because `Span<T>` is an abstraction over an arbitrary block of memory, methods of the `Span<T>` class and methods with `Span<T>` parameters operate on any `Span<T>` object regardless of the kind of memory it encapsulates.</span></span> <span data-ttu-id="ab474-118">Por ejemplo, cada una de las secciones de código independientes que inicializar el intervalo y calcular que la suma de sus elementos se puede cambiar en la inicialización única y métodos de cálculo, como en el ejemplo siguiente se muestra:</span><span class="sxs-lookup"><span data-stu-id="ab474-118">For example, each of the separate sections of code that initialize the span and calculate the sum of its elements can be changed into single initialization and calculation methods, as the following example illustrates:</span></span>

[!code-csharp[Creating a Span\<Byte> from stack-allocated memory](~/samples/snippets/csharp/api/system/span/program.cs#4)]

## <a name="spant-and-arrays"></a><span data-ttu-id="ab474-119">Intervalo\<T > y matrices</span><span class="sxs-lookup"><span data-stu-id="ab474-119">Span\<T> and arrays</span></span>

<span data-ttu-id="ab474-120">Cuando se ajusta una matriz, `Span<T>` puede encapsular la matriz completa, como lo hacía en los ejemplos de la [intervalo\<T > y la memoria](#spant-and-memory) sección.</span><span class="sxs-lookup"><span data-stu-id="ab474-120">When it wraps an array, `Span<T>` can wrap an entire array, as it did in the examples in the [Span\<T> and memory](#spant-and-memory) section.</span></span> <span data-ttu-id="ab474-121">Ya que admite la segmentación, `Span<T>` también puede señalar a un intervalo contiguo dentro de la matriz.</span><span class="sxs-lookup"><span data-stu-id="ab474-121">Because it supports slicing, `Span<T>` can also point to any contiguous range within the array.</span></span>  

<span data-ttu-id="ab474-122">El ejemplo siguiente crea un segmento de los elementos de cinco centrales de una matriz de enteros de 10 elementos.</span><span class="sxs-lookup"><span data-stu-id="ab474-122">The following example creates a slice of the middle five elements of a 10-element integer array.</span></span> <span data-ttu-id="ab474-123">Tenga en cuenta que el código duplica los valores de cada entero en el segmento.</span><span class="sxs-lookup"><span data-stu-id="ab474-123">Note that the code doubles the values of each integer in the slice.</span></span> <span data-ttu-id="ab474-124">Como se muestra el resultado, los cambios realizados por el intervalo se reflejan en los valores de la matriz.</span><span class="sxs-lookup"><span data-stu-id="ab474-124">As the output shows, the changes made by the span are reflected in the values of the array.</span></span>

[!code-csharp[Creating a slice from a portion of a span](~/samples/snippets/csharp/api/system/span/slice/program.cs)]

## <a name="spant-and-slices"></a><span data-ttu-id="ab474-125">Intervalo\<T > y los segmentos</span><span class="sxs-lookup"><span data-stu-id="ab474-125">Span\<T> and slices</span></span>

<span data-ttu-id="ab474-126">`Span\<T>` incluye dos sobrecargas de los <xref:System.Span%601.Slice%2A> método que forman un segmento fuera del intervalo actual que se inicia en el índice especificado.</span><span class="sxs-lookup"><span data-stu-id="ab474-126">`Span\<T>` includes two overloads of the <xref:System.Span%601.Slice%2A> method that form a slice out of the current span that starts at a specified index.</span></span> <span data-ttu-id="ab474-127">Esto permite tratar los datos en un `Span\<T>` como un conjunto de fragmentos lógicos que se pueden procesar según sea necesario por las partes de una canalización de procesamiento de datos con un impacto mínimo en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="ab474-127">This makes it possible to treat the data in a `Span\<T>` as a set of logical chunks that can be processed as needed by portions of a data processing pipeline with minimal performance impact.</span></span> <span data-ttu-id="ab474-128">Por ejemplo, puesto que los protocolos de servidor moderno son a menudo basado en texto, manipulación de cadenas y las subcadenas es especialmente importante.</span><span class="sxs-lookup"><span data-stu-id="ab474-128">For example, since modern server protocols are often text-based, manipulation of strings and substrings is particularly important.</span></span> <span data-ttu-id="ab474-129">En el <xref:System.String> clase, el método principal para extraer subcadenas es <xref:System.String.Substring%2A>.</span><span class="sxs-lookup"><span data-stu-id="ab474-129">In the <xref:System.String> class, the major method for extracting substrings is <xref:System.String.Substring%2A>.</span></span> <span data-ttu-id="ab474-130">Para las canalizaciones de datos que se basan en la manipulación de cadenas amplia, su uso ofrece algunos disminuciones de rendimiento, ya que:</span><span class="sxs-lookup"><span data-stu-id="ab474-130">For data pipelines that rely on extensive string manipulation, its use offers some performance penalties, since it:</span></span>

1. <span data-ttu-id="ab474-131">Crea una nueva cadena que contenga la subcadena.</span><span class="sxs-lookup"><span data-stu-id="ab474-131">Creates a new string to hold the substring.</span></span>

2. <span data-ttu-id="ab474-132">Copia un subconjunto de los caracteres de la cadena original a la nueva cadena.</span><span class="sxs-lookup"><span data-stu-id="ab474-132">Copies a subset of the characters from the original string to the new string.</span></span>

<span data-ttu-id="ab474-133">Esta operación de asignación y la copia se puede eliminar mediante el uso `Span\<T>` o <xref:System.ReadOnlySpan%601>, tal y como se muestra en el ejemplo siguiente:</span><span class="sxs-lookup"><span data-stu-id="ab474-133">This allocation and copy operation can be eliminated by using either `Span\<T>` or <xref:System.ReadOnlySpan%601>, as the following example shows:</span></span>

[!code-csharp[Creating a slice from a substring](~/samples/snippets/csharp/api/system/span/slice2/program.cs)]


      ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ab474-134">Matriz desde la que se va a crear el objeto <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-134">The array from which to create the <see cref="T:System.Span`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-135">Crea un nuevo objeto <see cref="T:System.Span`1" /> a través de la totalidad de una matriz especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-135">Creates a new <see cref="T:System.Span`1" /> object over the entirety of a specified array.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-136">Si `array` es `null`, este constructor devuelve una `null` `Span<T>`.</span><span class="sxs-lookup"><span data-stu-id="ab474-136">If `array` is `null`, this constructor returns a `null` `Span<T>`.</span></span>

      ]]></format>
        </remarks>
        <exception cref="T:System.TypeMismatchException">
          <span data-ttu-id="ab474-137">
            <paramref name="T" /> es un tipo de referencia y <paramref name="array" /> no es una matriz de tipo <paramref name="T" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-137">
              <paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer">
          <span data-ttu-id="ab474-138">Un puntero a la dirección inicial de un número especificado de bytes en memoria.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-138">A pointer to the starting address of a specified number of bytes in memory.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="ab474-139">Número de bytes que se van a incluir en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-139">The number of bytes to be included in the <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-140">Crea un nuevo objeto <see cref="T:System.Span`1" /> a partir de un número especificado de bytes desde una dirección de memoria especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-140">Creates a new <see cref="T:System.Span`1" /> object  from a specified number of bytes starting at a specified memory address.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

        This constructor should be used with care, since it creates arbitrarily typed `T`s from a `void*`-typed block of memory, and `length` is not checked. However, if the constructor succeeds in creating a new <xref:System.Span%601> object, all subsequent uses are correct.        

      ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ab474-141">
            <paramref name="T" /> es un tipo de referencia o contiene punteros y, por tanto, no se puede almacenar en memoria no administrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-141">
              <paramref name="T" /> is a reference type or contains pointers and therefore cannot be stored in unmanaged memory.</span>
          </span>
        </exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ab474-142">
            <paramref name="length" /> es negativo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-142">
              <paramref name="length" /> is negative.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ab474-143">Matriz de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-143">The source array.</span>
          </span>
        </param>
        <param name="start">
          <span data-ttu-id="ab474-144">Índice del primer elemento de la matriz que se va a incluir en el objeto <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-144">The index of the first element in the array to include in the <see cref="T:System.Span`1" /> object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-145">Crea un nuevo objeto <see cref="T:System.Span`1" /> a partir de una matriz especificada desde una posición de índice especificada hasta el final de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-145">Creates a new <see cref="T:System.Span`1" /> object from a specified array starting at a specifed index position and continuing to the end of the array.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Span (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new Span&lt;'T&gt; : 'T[] * int * int -&gt; Span&lt;'T&gt;" Usage="new System.Span&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ab474-146">Matriz de origen.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-146">The source array.</span>
          </span>
        </param>
        <param name="start">
          <span data-ttu-id="ab474-147">Índice del primer elemento que se va a incluir en el nuevo elemento <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-147">The index of the first element to include in the new <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="ab474-148">Número de elementos que se van a incluir en el nuevo elemento <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-148">The number of elements to include in the new <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-149">Crea un nuevo objeto <see cref="T:System.Span`1" /> que incluye un número especificado de elementos de una matriz a partir de un índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-149">Creates a new <see cref="T:System.Span`1" /> object that includes a specified number of elements of an array starting at a specified index.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ab474-150">
            <paramref name="array" /> es <see langword="null" />, pero <paramref name="start" /> o <paramref name="length" /> es distinto de cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-150">
              <paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span>
          </span>
          <p />
          <span data-ttu-id="ab474-151">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-151">--or--</span>
          </span>
          <p />
          <span data-ttu-id="ab474-152">
            <paramref name="start" /> está fuera de los límites de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-152">
              <paramref name="start" /> is outside the bounds of the array.</span>
          </span>
          <p />
          <span data-ttu-id="ab474-153">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-153">--or--</span>
          </span>
          <p />
          <span data-ttu-id="ab474-154">
            <paramref name="start" /> y <paramref name="length" /> superan el número de elementos de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-154">
              <paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span>
          </span>
        </exception>
        <exception cref="T:System.TypeMismatchException">
          <span data-ttu-id="ab474-155">
            <paramref name="T" /> es un tipo de referencia y <paramref name="array" /> no es una matriz de tipo <paramref name="T" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-155">
              <paramref name="T" /> is a reference type, and <paramref name="array" /> is not an array of type <paramref name="T" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Clear">
      <MemberSignature Language="C#" Value="public void Clear ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Clear() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Clear" />
      <MemberSignature Language="VB.NET" Value="Public Sub Clear ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Clear();" />
      <MemberSignature Language="F#" Value="member this.Clear : unit -&gt; unit" Usage="span.Clear " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-156">Borra el contenido de este objeto <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-156">Clears the contents of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-157">El `Clear` método establece los elementos de la <xref:System.Span%601> objeto en sus valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="ab474-157">The `Clear` method sets the items in the <xref:System.Span%601> object to their default values.</span></span> <span data-ttu-id="ab474-158">No quita los elementos de la <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="ab474-158">It does not remove items from the <xref:System.Span%601>.</span></span>  

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="span.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <summary>
          <span data-ttu-id="ab474-159">Copia el contenido de este elemento <see cref="System.Span`1" /> en un elemento <see cref="System.Span`1" /> de destino.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-159">Copies the contents of this <see cref="System.Span`1" /> into a destination <see cref="System.Span`1" />.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-160">Este método copia todos `source` a `destination` aunque `source` y `destination` se superponen.</span><span class="sxs-lookup"><span data-stu-id="ab474-160">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

         ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="ab474-161">
            <paramref name="destination" /> es más corto que el origen <see cref="System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-161">
              <paramref name="destination" /> is shorter than the source <see cref="System.Span`1" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="DangerousCreate">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; DangerousCreate (object obj, ref T objectData, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Span`1&lt;!T&gt; DangerousCreate(object obj, !T&amp; objectData, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousCreate(System.Object,`0@,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DangerousCreate (obj As Object, ByRef objectData As T, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Span&lt;T&gt; DangerousCreate(System::Object ^ obj, T % objectData, int length);" />
      <MemberSignature Language="F#" Value="static member DangerousCreate : obj *  * int -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.DangerousCreate (obj, objectData, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
        <Parameter Name="objectData" Type="T" RefType="ref" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <param name="objectData">To be added.</param>
        <param name="length">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DangerousGetPinnableReference">
      <MemberSignature Language="C#" Value="public T DangerousGetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T DangerousGetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.DangerousGetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function DangerousGetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % DangerousGetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.DangerousGetPinnableReference : unit -&gt; " Usage="span.DangerousGetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static Span&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Span`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property Span&lt;T&gt; Empty { Span&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ab474-162">Devuelve un objeto <see cref="T:System.Span`1" /> vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-162">Returns an empty <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ab474-163">Objeto <see cref="T:System.Span`1" /> vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-163">An empty <see cref="T:System.Span`1" /> object.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="span.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Equals() on Span will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="ab474-164">No se admite.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-164">Not supported.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-165">No se admiten llamadas a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-165">Calls to this method are not supported.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-166">No se admiten llamadas a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-166">Calls to this method are not supported.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="ab474-167">Las llamadas a la <xref:System.Span%601.Equals%2A> no se admite el método.</span><span class="sxs-lookup"><span data-stu-id="ab474-167">Calls to the <xref:System.Span%601.Equals%2A> method are not supported.</span></span> <span data-ttu-id="ab474-168">Las llamadas a la < xref:System.Span%601.Equals%2A métodos generan cualquiera de los dos resultados:</span><span class="sxs-lookup"><span data-stu-id="ab474-168">Calls to the <xref:System.Span%601.Equals%2A methods produce either of two results:</span></span>

- <span data-ttu-id="ab474-169">Si `obj` es un <xref:System.Span%601>, la llamada al método genera el error del compilador CS1503: "no se puede convertir de 'System.Span' a 'object'". Esto es porque <xref:System.Span%601> es un [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) que no se puede realizar la conversión boxing y, por tanto, no puede convertirse en un <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="ab474-169">If `obj` is a <xref:System.Span%601>, the method call generates compiler error CS1503: "cannot convert from 'System.Span' to 'object'." This is because <xref:System.Span%601> is a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type) that cannot be boxed and therefore cannot be converted to an <xref:System.Object>.</span></span>

- <span data-ttu-id="ab474-170">Si el tipo de `obj` no es un <xref:System.Span%601>, la llamada al método produce una <xref:System.NotSupportedException>.</span><span class="sxs-lookup"><span data-stu-id="ab474-170">If the type of `obj` is not a <xref:System.Span%601>, the method call throws a <xref:System.NotSupportedException>.</span></span> 

<span data-ttu-id="ab474-171">Para comparar dos <xref:System.Span%601> objetos para la igualdad, utilice el <xref:System.Span%601.op_Equality%2A> operador de comparación.</span><span class="sxs-lookup"><span data-stu-id="ab474-171">To compare two <xref:System.Span%601> objects for equality, use the <xref:System.Span%601.op_Equality%2A> comparison operator.</span></span>

        ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ab474-172">No se admiten llamadas a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-172">Calls to this method are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Fill">
      <MemberSignature Language="C#" Value="public void Fill (T value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Fill(!T value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Fill(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Fill (value As T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Fill(T value);" />
      <MemberSignature Language="F#" Value="member this.Fill : 'T -&gt; unit" Usage="span.Fill value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="T" />
      </Parameters>
      <Docs>
        <param name="value">
          <span data-ttu-id="ab474-173">El valor que se va a asignar a cada elemento del intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-173">The value to assign to each element of the span.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-174">Rellena los elementos de este intervalo con un valor especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-174">Fills the elements of this span with a specified value.</span>
          </span>
        </summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As Span(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; Span&lt;'T&gt;.Enumerator" Usage="span.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-175">Devuelve un enumerador para este elemento <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-175">Returns an enumerator for this <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-176">Un enumerador para este intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-176">An enumerator for this span.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="ab474-177">En lugar de llamar el <xref:System.Span%601.GetEnumerator%2A> método directamente, puede utilizar el C# `foreach` instrucción y Visual Basic `For Each`... `Next` construcción para enumerar un <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="ab474-177">Instead of calling the <xref:System.Span%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.Span%601>.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="span.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("GetHashCode() on Span will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-178">Produce una excepción <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-178">Throws a <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-179">Las llamadas a este método siempre producen una excepción <see cref="T:System.NotSupportedException" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-179">Calls to this method always throw a <see cref="T:System.NotSupportedException" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException">
          <span data-ttu-id="ab474-180">No se admiten llamadas a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-180">Calls to this method are not supported.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="GetPinnableReference">
      <MemberSignature Language="C#" Value="public T GetPinnableReference ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T GetPinnableReference() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.GetPinnableReference" />
      <MemberSignature Language="VB.NET" Value="Public Function GetPinnableReference () As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; T % GetPinnableReference();" />
      <MemberSignature Language="F#" Value="member this.GetPinnableReference : unit -&gt; " Usage="span.GetPinnableReference " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T@</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-181">Devuelve una referencia al elemento de <see cref="T:System.Span`1" /> en el índice cero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-181">Returns a reference to the element of the <see cref="T:System.Span`1" /> at index zero.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-182">Una referencia al elemento de <see cref="T:System.Span`1" /> en el índice cero o <see langword="null" /> si <see cref="M:System.Span`1.IsEmpty" /> es <see langword="true" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-182">A reference to the element of the <see cref="T:System.Span`1" /> at index zero, or <see langword="null" /> if <see cref="M:System.Span`1.IsEmpty" /> is  <see langword="true" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-183">El `GetPinnableReference` método devuelve un [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span><span class="sxs-lookup"><span data-stu-id="ab474-183">The `GetPinnableReference` method returns a [ref struct](~/docs/csharp/reference-semantics-with-value-types.md#ref-struct-type).</span></span> <span data-ttu-id="ab474-184">Se puede usar para anclar un <xref:System.Span%601> en memoria.</span><span class="sxs-lookup"><span data-stu-id="ab474-184">It can be used for pinning a <xref:System.Span%601> in memory.</span></span> <span data-ttu-id="ab474-185">Es necesario para admitir el uso de un <xref:System.Span%601> dentro de un [fijo](~/docs/csharp/language-reference/keywords/fixed-statement.md) instrucción.</span><span class="sxs-lookup"><span data-stu-id="ab474-185">It is required to support the use of a <xref:System.Span%601> within a [fixed](~/docs/csharp/language-reference/keywords/fixed-statement.md) statement.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.Span&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ab474-186">Devuelve un valor que indica si el elemento <see cref="T:System.Span`1" /> actual está vacío.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-186">Returns a value that indicates whether the current <see cref="T:System.Span`1" /> is empty.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ab474-187">
            <see langword="true" /> Si el intervalo actual está vacío; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-187">
              <see langword="true" /> if the current span is empty; otherwise, <see langword="false" />.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance !T Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T % default[int] { T % get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : " Usage="System.Span&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue RefType="Ref">
        <ReturnType>T</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index">To be added.</param>
        <summary>
          <span data-ttu-id="ab474-188">Obtiene o establece el elemento en el índice basado en cero especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-188">Gets or sets the element at the specified zero-based index.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ab474-189">Elemento en el índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-189">The element at the specified index.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException">
          <span data-ttu-id="ab474-190">
            <paramref name="index" /> es menor que cero o mayor o igual a <see cref="P:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-190">
              <paramref name="index" /> is less then zero or greater than or equal to <see cref="P:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.Span`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.Span&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="ab474-191">Devuelve la longitud del intervalo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-191">Returns the length of the current span.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="ab474-192">La longitud del intervalo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-192">The length of the current span.</span>
          </span>
        </value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ab474-193">Primer intervalo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-193">The first span to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ab474-194">Segundo intervalo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-194">The second span to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-195">Devuelve un valor que indica si dos objetos <see cref="T:System.Span`1" /> son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-195">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-196">Es <see langword="true" /> si los dos objetos <see cref="T:System.Span`1" /> son iguales; en caso contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-196">
              <see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-197">Dos <xref:System.Span%601> objetos son iguales si tienen la misma longitud y los elementos correspondientes de `left` y `right` apunte a la misma memoria.</span><span class="sxs-lookup"><span data-stu-id="ab474-197">Two <xref:System.Span%601> objects are equal if they have the same length and the corresponding elements of `left` and `right` point to the same memory.</span></span> <span data-ttu-id="ab474-198">Tenga en cuenta que la prueba de igualdad *no* intenta determinar si el contenido es igual.</span><span class="sxs-lookup"><span data-stu-id="ab474-198">Note that the test for equality does *not* attempt to determine whether the contents are equal.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (Span&lt;T&gt; span);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.Span`1&lt;!T&gt; span) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.Span{`0})~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (span As Span(Of T)) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(Span&lt;T&gt; span);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : Span&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit span" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="span" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="span">
          <span data-ttu-id="ab474-199">Objeto que se va a convertir en un <see cref="T:System.ReadOnlySpan`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-199">The object to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-200">Define una conversión implícita de un elemento <see cref="T:System.Span`1" /> en <see cref="T:System.ReadOnlySpan`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-200">Defines an implicit conversion of a <see cref="T:System.Span`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-201">Intervalo de solo lectura que corresponde a la instancia actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-201">A read-only span that corresponds to the current instance.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(`0[])~System.Span{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array">
          <span data-ttu-id="ab474-202">Matriz que se va a convertir en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-202">The array to convert to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-203">Define una conversión implícita de una matriz en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-203">Defines an implicit conversion of an array to a <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-204">Intervalo que se corresponde con <paramref name="array" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-204">The span that corresponds to <paramref name="array" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator Span&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Span`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Implicit(System.ArraySegment{`0})~System.Span{`0}" FrameworkAlternate="netcore-2.1;netcore-2.0;netcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As Span(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator Span&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; Span&lt;'T&gt;" Usage="System.Span&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arraySegment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      </Parameters>
      <Docs>
        <param name="arraySegment">
          <span data-ttu-id="ab474-205">Segmento de la matriz que se va a convertir en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-205">The array segment to be converted to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <param name="segment">
          <span data-ttu-id="ab474-206">Segmento de la matriz que se va a convertir en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-206">The array segment to be converted to a <see cref="T:System.Span`1" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-207">Define una conversión implícita de un elemento <see cref="T:System.ArraySegment`1" /> en <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-207">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.Span`1" />.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-208">Intervalo que se corresponde con el segmento de la matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-208">A span that corresponds to the array segment.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Span`1&lt;!T&gt; left, valuetype System.Span`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Span(Of T), right As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Span&lt;T&gt; left, Span&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Span&lt;'T&gt; * Span&lt;'T&gt; -&gt; bool" Usage="System.Span&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Span&lt;T&gt;" />
        <Parameter Name="right" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left">
          <span data-ttu-id="ab474-209">Primer intervalo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-209">The first span to compare.</span>
          </span>
        </param>
        <param name="right">
          <span data-ttu-id="ab474-210">Segundo intervalo que se va a comparar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-210">The second span to compare.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-211">Devuelve un valor que indica si dos objetos <see cref="T:System.Span`1" /> no son iguales.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-211">Returns a value that indicates whether two <see cref="T:System.Span`1" /> objects are not equal.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-212">Es <see langword="true" /> si los dos objetos <see cref="T:System.Span`1" /> no son iguales; de lo contrario, es <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-212">
              <see langword="true" /> if the two <see cref="T:System.Span`1" /> objects are not equal; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-213">Dos <xref:System.Span%601> objetos son iguales si tienen longitudes diferentes o si los elementos correspondientes de `left` y `right` no señalan a la misma memoria.</span><span class="sxs-lookup"><span data-stu-id="ab474-213">Two <xref:System.Span%601> objects are equal if they have different lengths or if the corresponding elements of `left` and `right` do not point to the same memory.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; Span&lt;'T&gt;" Usage="span.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="ab474-214">Índice en el que va a comenzar el segmento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-214">The index at which to begin the slice.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-215">Forma un segmento fuera del intervalo actual que comienza en un índice especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-215">Forms a slice out of the current span that begins at a specified index.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-216">Intervalo que consta de todos los elementos del intervalo actual desde <paramref name="index" /> hasta el final del intervalo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-216">A span that consists of all elements of the current span from <paramref name="index" /> to the end of the span.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ab474-217">
            <paramref name="index" /> es menor que cero o mayor o igual a <see cref="T:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-217">
              <paramref name="index" /> is less than zero or greater than or equal to <see cref="T:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public Span&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Span`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As Span(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Span&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; Span&lt;'T&gt;" Usage="span.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Span&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start">
          <span data-ttu-id="ab474-218">Índice en el que va a comenzar este segmento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-218">The index at which to begin this slice.</span>
          </span>
        </param>
        <param name="length">
          <span data-ttu-id="ab474-219">Longitud deseada del segmento.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-219">The desired length for the slice.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-220">Forma un segmento fuera del intervalo actual a partir de un índice especificado durante una longitud determinada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-220">Forms a slice out of the current span starting at a specified index for a specified length.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-221">&gt;Intervalo que consta de elementos <paramref name="length" /> desde el intervalo actual a partir de <paramref name="index" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-221">&gt;A span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="index" />.</span>
          </span>
        </returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="ab474-222">
            <paramref name="start" /> o <paramref name="start" /> + <paramref name="index" /> es menor que cero o mayor que <see cref="T:System.Span`1.Length" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-222">
              <paramref name="start" /> or <paramref name="start" /> + <paramref name="index" /> is less than zero or greater than <see cref="T:System.Span`1.Length" />.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="span.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-223">Copia el contenido de este intervalo en una nueva matriz.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-223">Copies the contents of this span into a new array.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-224">Matriz que contiene los datos del intervalo actual.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-224">An array containing the data in the current span.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-225">Este método realiza una asignación del montón y, por tanto, debe evitarse si es posible.</span><span class="sxs-lookup"><span data-stu-id="ab474-225">This method performs a heap allocation and therefore should be avoided if possible.</span></span> <span data-ttu-id="ab474-226">Lo que a veces es necesario cuando las API que admiten <xref:System.Span%601> objetos no están disponibles pero son las API que funcionan con matrices.</span><span class="sxs-lookup"><span data-stu-id="ab474-226">It it sometimes necessary when APIs that support <xref:System.Span%601> objects are not available but APIs that work with arrays are.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="span.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="ab474-227">Devuelve la representación en forma de cadena de este objeto <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-227">Returns the string representation of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-228">Representación en forma de cadena de este objeto <see cref="T:System.Span`1" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-228">The string representation of this <see cref="T:System.Span`1" /> object.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
<span data-ttu-id="ab474-229">Para un `Span<Char>`, `ToString` método devuelve un <xref:System.String> que contiene los caracteres que apunta el <xref:System.Span%601>.</span><span class="sxs-lookup"><span data-stu-id="ab474-229">For a `Span<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the <xref:System.Span%601>.</span></span> <span data-ttu-id="ab474-230">De lo contrario, devuelve un <xref:System.String> con el nombre del tipo y el número de elementos que el <xref:System.Span%601> contiene.</span><span class="sxs-lookup"><span data-stu-id="ab474-230">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the <xref:System.Span%601> contains.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Span`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="span.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination">
          <span data-ttu-id="ab474-231">Destino de la operación de copia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-231">The target of the copy operation.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="ab474-232">Intenta copiar el elemento <see cref="T:System.Span`1" /> actual en un destino <see cref="T:System.Span`1" /> y devuelve un valor que indica si la operación de copia se ha realizado correctamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-232">Attempts to copy the current <see cref="T:System.Span`1" /> to a destination <see cref="T:System.Span`1" /> and returns a value that indicates whether the copy operation succeeded.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="ab474-233">
            <see langword="true" /> si la operación de copia se ha realizado correctamente; de lo contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="ab474-233">
              <see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  

<span data-ttu-id="ab474-234">Este método copia todos `source` a `destination` aunque `source` y `destination` se superponen.</span><span class="sxs-lookup"><span data-stu-id="ab474-234">This method copies all of `source` to `destination` even if `source` and `destination` overlap.</span></span>

<span data-ttu-id="ab474-235">Si `destination` es menor que el origen <xref:System.Span%601>, este método devuelve `false`, y no se escribe ningún dato en `destination`.</span><span class="sxs-lookup"><span data-stu-id="ab474-235">If `destination` is shorter than the source <xref:System.Span%601>, this method returns `false`, and no data is written to `destination`.</span></span>

         ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>