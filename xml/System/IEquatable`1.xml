<Type Name="IEquatable&lt;T&gt;" FullName="System.IEquatable&lt;T&gt;">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="c71b1ce8bef586f2453604f33dc3ca2e6f5af9bc" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37728044" />
  </Metadata>
  <TypeSignature Language="C#" Value="public interface IEquatable&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public interface auto ansi abstract IEquatable`1&lt;T&gt;" />
  <TypeSignature Language="DocId" Value="T:System.IEquatable`1" />
  <TypeSignature Language="VB.NET" Value="Public Interface IEquatable(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public interface class IEquatable" />
  <TypeSignature Language="F#" Value="type IEquatable&lt;'T&gt; = interface" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Interfaces />
  <Docs>
    <typeparam name="T">
      <span data-ttu-id="5ecdf-101">Tipo de objetos que se van a comparar.</span>
      <span class="sxs-lookup">
        <span data-stu-id="5ecdf-101">The type of objects to compare.</span>
      </span>
    </typeparam>
    <summary>
      <span data-ttu-id="5ecdf-102">Define un método generalizado que implementa un tipo o una clase de valor con el fin de crear un método específico del tipo para determinar la igualdad de las instancias.</span>
      <span class="sxs-lookup">
        <span data-stu-id="5ecdf-102">Defines a generalized method that a value type or class implements to create a type-specific method for determining equality of instances.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ecdf-103">Esta interfaz se implementa mediante tipos cuyos valores se pueden igualar (por ejemplo, el numéricas y cadena de clases).</span><span class="sxs-lookup"><span data-stu-id="5ecdf-103">This interface is implemented by types whose values can be equated (for example, the numeric and string classes).</span></span> <span data-ttu-id="5ecdf-104">Un tipo de valor o una clase implementa la <xref:System.IEquatable%601.Equals%2A> método para crear un método específico del tipo adecuado para determinar la igualdad de las instancias.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-104">A value type or class implements the <xref:System.IEquatable%601.Equals%2A> method to create a type-specific method suitable for determining equality of instances.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="5ecdf-105">El <xref:System.IComparable%601> interfaz define el <xref:System.IComparable%601.CompareTo%2A> método, que determina el criterio de ordenación de las instancias del tipo de implementación.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-105">The <xref:System.IComparable%601> interface defines the <xref:System.IComparable%601.CompareTo%2A> method, which determines the sort order of instances of the implementing type.</span></span> <span data-ttu-id="5ecdf-106">El <xref:System.IEquatable%601> interfaz define el <xref:System.IEquatable%601.Equals%2A> método, que determina la igualdad de las instancias del tipo de implementación.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-106">The <xref:System.IEquatable%601> interface defines the <xref:System.IEquatable%601.Equals%2A> method, which determines the equality of instances of the implementing type.</span></span>  
  
 <span data-ttu-id="5ecdf-107">El <xref:System.IEquatable%601> interfaz se utiliza como objetos de colección genéricos <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.Generic.List%601>, y <xref:System.Collections.Generic.LinkedList%601> al probar la igualdad en métodos como `Contains`, `IndexOf`, `LastIndexOf`, y `Remove`.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-107">The <xref:System.IEquatable%601> interface is used by generic collection objects such as <xref:System.Collections.Generic.Dictionary%602>, <xref:System.Collections.Generic.List%601>, and <xref:System.Collections.Generic.LinkedList%601> when testing for equality in such methods as `Contains`, `IndexOf`, `LastIndexOf`, and `Remove`.</span></span> <span data-ttu-id="5ecdf-108">Se debe implementar para cualquier objeto que se puede almacenar en una colección genérica.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-108">It should be implemented for any object that might be stored in a generic collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ecdf-109">Vea el ejemplo de la <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-109">See the example for the <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
    </remarks>
    <block subset="none" type="overrides">
      <span data-ttu-id="5ecdf-110">
        <para>Reemplace el parámetro de tipo de la <see cref="T:System.IEquatable`1" /> interfaz con el tipo que implementa esta interfaz.  Si implementa <see cref="T:System.IEquatable`1" />, también debe invalidar las implementaciones de la clase base de <see cref="M:System.Object.Equals(System.Object)" /> y <see cref="M:System.Object.GetHashCode" /> para que su comportamiento es coherente con el de la <see cref="M:System.IEquatable`1.Equals(`0)" /> método. Si invalida <see cref="M:System.Object.Equals(System.Object)" />, también se denomina su implementación invalidada en las llamadas a estático <see langword="Equals(System.Object, System.Object)" /> método en su clase. Además, debería sobrecargar el <see langword="op_Equality" /> y <see langword="op_Inequality" /> operadores. Esto garantiza que todas las pruebas de igualdad devuelven resultados coherentes.  <block subset="none" type="note"><para> Para obtener información sobre cómo reemplazar <see cref="M:System.Object.Equals(System.Object)" />, consulte el <see cref="M:System.Object.Equals(System.Object)" /> artículo.  </para></block>  Para un tipo de valor, siempre debe implementar <see cref="T:System.IEquatable`1" /> e invalidar <see cref="M:System.Object.Equals(System.Object)" /> para mejorar el rendimiento. <see cref="M:System.Object.Equals(System.Object)" /> cuadros de tipos de valor y se basa en la reflexión para comparar dos valores son iguales. Tanto la implementación de <see cref="M:System.IEquatable`1.Equals(`0)" /> y el reemplazo de <see cref="M:System.Object.Equals(System.Object)" /> debe devolver los resultados sean coherentes.  Si implementa <see cref="T:System.IEquatable`1" />, también debe implementar <see cref="T:System.IComparable`1" /> si instancias del tipo se pueden ordenar u ordenadas. Si el tipo implementa <see cref="T:System.IComparable`1" />, casi siempre también implemente <see cref="T:System.IEquatable`1" />.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="5ecdf-110">
          <para>Replace the type parameter of the <see cref="T:System.IEquatable`1" /> interface with the type that is implementing this interface.  If you implement <see cref="T:System.IEquatable`1" />, you should also override the base class implementations of <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> so that their behavior is consistent with that of the <see cref="M:System.IEquatable`1.Equals(`0)" /> method. If you do override <see cref="M:System.Object.Equals(System.Object)" />, your overridden implementation is also called in calls to the static <see langword="Equals(System.Object, System.Object)" /> method on your class. In addition, you should overload the <see langword="op_Equality" /> and <see langword="op_Inequality" /> operators. This ensures that all tests for equality return consistent results.  <block subset="none" type="note"><para> For information on overriding <see cref="M:System.Object.Equals(System.Object)" />, see the <see cref="M:System.Object.Equals(System.Object)" /> article.  </para></block>  For a value type, you should always implement <see cref="T:System.IEquatable`1" /> and override <see cref="M:System.Object.Equals(System.Object)" /> for better performance. <see cref="M:System.Object.Equals(System.Object)" /> boxes value types and relies on reflection to compare two values for equality. Both your implementation of <see cref="M:System.IEquatable`1.Equals(`0)" /> and your override of <see cref="M:System.Object.Equals(System.Object)" /> should return consistent results.  If you implement <see cref="T:System.IEquatable`1" />, you should also implement <see cref="T:System.IComparable`1" /> if instances of your type can be ordered or sorted. If your type implements <see cref="T:System.IComparable`1" />, you almost always also implement <see cref="T:System.IEquatable`1" />.</para>
        </span>
      </span>
      <span data-ttu-id="5ecdf-111">
        <para>Tenga en cuenta que hay algunos diseños que un tipo es compatible con una relación de orden, pero igualdad puede ser distinta de una relación de ordenación. Considere la posibilidad de una clase "Person" donde ordenar alfabéticamente. Ordenación el mismo dos personas con el mismo nombre, pero no son la misma persona.</para>
      </span>
      <span class="sxs-lookup">
        <span data-stu-id="5ecdf-111">
          <para>Note that there are some designs where a type supports an order relation, but equality may be distinct from an ordering relation. Consider a `Person` class where you sort alphabetically. Two people with the same name sort the same, but are not the same person.</para>
        </span>
      </span>
    </block>
    <altmember cref="T:System.IComparable`1" />
    <altmember cref="T:System.IComparable" />
  </Docs>
  <Members>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (T other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(!T other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IEquatable`1.Equals(`0)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As T) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(T other);" />
      <MemberSignature Language="F#" Value="abstract member Equals : 'T -&gt; bool" Usage="iEquatable.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="T" />
      </Parameters>
      <Docs>
        <param name="other">
          <span data-ttu-id="5ecdf-112">Objeto que se va a comparar con este objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ecdf-112">An object to compare with this object.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="5ecdf-113">Indica si el objeto actual es igual que otro objeto del mismo tipo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ecdf-113">Indicates whether the current object is equal to another object of the same type.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="5ecdf-114">
            <see langword="true" /> si el objeto actual es igual al parámetro <paramref name="other" />; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="5ecdf-114">
              <see langword="true" /> if the current object is equal to the <paramref name="other" /> parameter; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="5ecdf-115">La implementación de la <xref:System.IEquatable%601.Equals%2A> método está pensado para realizar una prueba de igualdad con otro objeto del tipo `T`, el mismo tipo que el objeto actual.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-115">The implementation of the <xref:System.IEquatable%601.Equals%2A> method is intended to perform a test for equality with another object of type `T`, the same type as the current object.</span></span> <span data-ttu-id="5ecdf-116">El <xref:System.IEquatable%601.Equals(%600)> se llama al método en las siguientes circunstancias:</span><span class="sxs-lookup"><span data-stu-id="5ecdf-116">The <xref:System.IEquatable%601.Equals(%600)> method is called in the following circumstances:</span></span>  
  
-   <span data-ttu-id="5ecdf-117">Cuando el `Equals` se llama al método y el `other` argumento es un objeto fuertemente tipado de tipo `T`.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-117">When the `Equals` method is called and the `other` argument is a strongly-typed object of type `T`.</span></span> <span data-ttu-id="5ecdf-118">(Si `other` no es de tipo `T`, la base de <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-118">(If `other` is not of type `T`, the base <xref:System.Object.Equals%28System.Object%29?displayProperty=nameWithType> method is called.</span></span> <span data-ttu-id="5ecdf-119">De los dos métodos, <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> ofrece ligeramente mayor rendimiento.)</span><span class="sxs-lookup"><span data-stu-id="5ecdf-119">Of the two methods, <xref:System.IEquatable%601.Equals%2A?displayProperty=nameWithType> offers slightly better performance.)</span></span>  
  
-   <span data-ttu-id="5ecdf-120">Cuando se llama a los métodos de búsqueda de un número de objetos de colección genérica.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-120">When the search methods of a number of generic collection objects are called.</span></span> <span data-ttu-id="5ecdf-121">Algunos de estos tipos y sus métodos incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="5ecdf-121">Some of these types and their methods include the following:</span></span>  
  
    -   <span data-ttu-id="5ecdf-122">Algunas de las sobrecargas genéricas de los <xref:System.Array.BinarySearch%2A> método.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-122">Some of the generic overloads of the <xref:System.Array.BinarySearch%2A> method.</span></span>  
  
    -   <span data-ttu-id="5ecdf-123">Los métodos de búsqueda de la <xref:System.Collections.Generic.List%601> clase, incluidas <xref:System.Collections.Generic.List%601.Contains%28%600%29?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601.IndexOf%2A?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A?displayProperty=nameWithType>, y <xref:System.Collections.Generic.List%601.Remove%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-123">The search methods of the <xref:System.Collections.Generic.List%601> class, including <xref:System.Collections.Generic.List%601.Contains%28%600%29?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601.IndexOf%2A?displayProperty=nameWithType>, <xref:System.Collections.Generic.List%601.LastIndexOf%2A?displayProperty=nameWithType>, and <xref:System.Collections.Generic.List%601.Remove%2A?displayProperty=nameWithType>.</span></span>  
  
    -   <span data-ttu-id="5ecdf-124">Los métodos de búsqueda de la <xref:System.Collections.Generic.Dictionary%602> clase, incluidas <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> y <xref:System.Collections.Generic.IDictionary%602.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-124">The search methods of the <xref:System.Collections.Generic.Dictionary%602> class, including <xref:System.Collections.Generic.Dictionary%602.ContainsKey%2A> and <xref:System.Collections.Generic.IDictionary%602.Remove%2A>.</span></span>  
  
    -   <span data-ttu-id="5ecdf-125">Los métodos de búsqueda de la clase genérica <xref:System.Collections.Generic.LinkedList%601> clase, incluidas <xref:System.Collections.Generic.LinkedList%601.Contains%2A?displayProperty=nameWithType> y <xref:System.Collections.Generic.LinkedList%601.Remove%2A>.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-125">The search methods of the generic <xref:System.Collections.Generic.LinkedList%601> class, including <xref:System.Collections.Generic.LinkedList%601.Contains%2A?displayProperty=nameWithType> and <xref:System.Collections.Generic.LinkedList%601.Remove%2A>.</span></span>  
  
 <span data-ttu-id="5ecdf-126">En otras palabras, para controlar la posibilidad de que los objetos de una clase se almacenarán en una matriz o un objeto de colección genérica, es una buena idea implementar <xref:System.IEquatable%601> para que el objeto se puede identificar y manipular con facilidad.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-126">In other words, to handle the possibility that objects of a class will be stored in an array or a generic collection object, it is a good idea to implement <xref:System.IEquatable%601> so that the object can be easily identified and manipulated.</span></span>  
  
 <span data-ttu-id="5ecdf-127">Al implementar el <xref:System.IEquatable%601.Equals%2A> método, definir la igualdad de forma adecuada para el tipo especificado por el argumento de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-127">When implementing the <xref:System.IEquatable%601.Equals%2A> method, define equality appropriately for the type specified by the generic type argument.</span></span> <span data-ttu-id="5ecdf-128">Por ejemplo, si el argumento de tipo es <xref:System.Int32>, definir la igualdad de forma apropiada para la comparación de dos enteros de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-128">For example, if the type argument is <xref:System.Int32>, define equality appropriately for the comparison of two 32-bit signed integers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="5ecdf-129">El ejemplo siguiente muestra la implementación parcial de un `Person` clase que implementa <xref:System.IEquatable%601> y tiene dos propiedades, `LastName` y `SSN`.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-129">The following example shows the partial implementation of a `Person` class that implements <xref:System.IEquatable%601> and has two properties, `LastName` and `SSN`.</span></span> <span data-ttu-id="5ecdf-130">El <xref:System.IEquatable%601.Equals%2A> devuelve del método `True` si el `SSN` propiedad de dos `Person` objetos es idéntico; en caso contrario, devuelve `False`.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-130">The <xref:System.IEquatable%601.Equals%2A> method returns `True` if the `SSN` property of two `Person` objects is identical; otherwise, it returns `False`.</span></span>  
  
 [!code-csharp[System.GenericIEquatable.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GenericIEquatable.Equals/cs/EqualsEx2.cs#3)]
 [!code-vb[System.GenericIEquatable.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GenericIEquatable.Equals/vb/EqualsEx2.vb#3)]  
  
 <span data-ttu-id="5ecdf-131">`Person` a continuación, se pueden almacenar objetos en un <xref:System.Collections.Generic.List%601> object y pueden identificarse mediante el `Contains` método, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="5ecdf-131">`Person` objects can then be stored in a <xref:System.Collections.Generic.List%601> object and can be identified by the `Contains` method, as the following example shows.</span></span>  
  
 [!code-csharp[System.GenericIEquatable.Equals#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GenericIEquatable.Equals/cs/Snippet12.cs#12)]
 [!code-vb[System.GenericIEquatable.Equals#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GenericIEquatable.Equals/vb/Snippet12.vb#12)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <span data-ttu-id="5ecdf-132">
            <para>Si implementa <see cref="M:System.IEquatable`1.Equals(`0)" />, también debe invalidar las implementaciones de la clase base de <see cref="M:System.Object.Equals(System.Object)" /> y <see cref="M:System.Object.GetHashCode" /> para que su comportamiento es coherente con el de la <see cref="M:System.IEquatable`1.Equals(`0)" /> método. Si invalida <see cref="M:System.Object.Equals(System.Object)" />, también se denomina su implementación invalidada en las llamadas a estático <see langword="Equals(System.Object, System.Object)" /> método en su clase. Además, debería sobrecargar el <see langword="op_Equality" /> y <see langword="op_Inequality" /> operadores. Esto garantiza que todas las pruebas de igualdad devuelven resultados coherentes, que se muestra en el ejemplo.</para>
          </span>
          <span class="sxs-lookup">
            <span data-stu-id="5ecdf-132">
              <para>If you implement <see cref="M:System.IEquatable`1.Equals(`0)" />, you should also override the base class implementations of <see cref="M:System.Object.Equals(System.Object)" /> and <see cref="M:System.Object.GetHashCode" /> so that their behavior is consistent with that of the <see cref="M:System.IEquatable`1.Equals(`0)" /> method. If you do override <see cref="M:System.Object.Equals(System.Object)" />, your overridden implementation is also called in calls to the static <see langword="Equals(System.Object, System.Object)" /> method on your class. In addition, you should overload the <see langword="op_Equality" /> and <see langword="op_Inequality" /> operators. This ensures that all tests for equality return consistent results, which the example illustrates.</para>
            </span>
          </span>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>