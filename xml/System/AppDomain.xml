<Type Name="AppDomain" FullName="System.AppDomain">
  <Metadata><Meta Name="ms.openlocfilehash" Value="40ea79988bc31dd09a52c0a55c2ef2c71dcc4eb7" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53231916" /></Metadata><TypeSignature Language="C#" Value="public sealed class AppDomain : MarshalByRefObject, _AppDomain, System.Security.IEvidenceFactory" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit AppDomain extends System.MarshalByRefObject implements class System._AppDomain, class System.Security.IEvidenceFactory" />
  <TypeSignature Language="DocId" Value="T:System.AppDomain" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class AppDomain&#xA;Inherits MarshalByRefObject&#xA;Implements _AppDomain, IEvidenceFactory" />
  <TypeSignature Language="C++ CLI" Value="public ref class AppDomain sealed : MarshalByRefObject, _AppDomain, System::Security::IEvidenceFactory" />
  <TypeSignature Language="F#" Value="type AppDomain = class&#xA;    inherit MarshalByRefObject&#xA;    interface _AppDomain&#xA;    interface IEvidenceFactory" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Extensions</AssemblyName>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.MarshalByRefObject</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System._AppDomain</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Security.IEvidenceFactory</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System._AppDomain))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="c0a0d-101">Representa un dominio de aplicación, que es un entorno aislado donde se ejecutan las aplicaciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-101">Represents an application domain, which is an isolated environment where applications execute.</span></span> <span data-ttu-id="c0a0d-102">Esta clase no puede heredarse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-102">This class cannot be inherited.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-103">Dominios de aplicación, que están representados por <xref:System.AppDomain> objetos, ayudan a proporcionar aislamiento, descarga y límites de seguridad para ejecutar código administrado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-103">Application domains, which are represented by <xref:System.AppDomain> objects, help provide isolation, unloading, and security boundaries for executing managed code.</span></span>  
  
-   <span data-ttu-id="c0a0d-104">Utilizar dominios de aplicación para aislar las tareas que es posible que derrumbar un proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-104">Use application domains to isolate tasks that might bring down a process.</span></span> <span data-ttu-id="c0a0d-105">Si el estado de la <xref:System.AppDomain> que está ejecutando una tarea se vuelve inestable, el <xref:System.AppDomain> puede descargarse sin afectar al proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-105">If the state of the <xref:System.AppDomain> that's executing a task becomes unstable, the <xref:System.AppDomain> can be unloaded without affecting the process.</span></span> <span data-ttu-id="c0a0d-106">Esto es importante cuando un proceso debe ejecutarse durante largos períodos sin necesidad de reiniciar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-106">This is important when a process must run for long periods without restarting.</span></span> <span data-ttu-id="c0a0d-107">También puede usar dominios de aplicación para aislar las tareas que no deben compartir los datos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-107">You can also use application domains to isolate tasks that should not share data.</span></span>  
  
-   <span data-ttu-id="c0a0d-108">Si un ensamblado se carga en el dominio de aplicación predeterminado, no se puede descargar de la memoria mientras se ejecuta el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-108">If an assembly is loaded into the default application domain, it cannot be unloaded from memory while the process is running.</span></span> <span data-ttu-id="c0a0d-109">Sin embargo, si abre un segundo dominio de aplicación para cargar y ejecutar el ensamblado, se descarga el ensamblado cuando se descarga ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-109">However, if you open a second application domain to load and execute the assembly, the assembly is unloaded when that application domain is unloaded.</span></span> <span data-ttu-id="c0a0d-110">Use esta técnica para minimizar el espacio de trabajo de procesos de larga ejecución que en ocasiones se utilizan grandes archivos DLL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-110">Use this technique to minimize the working set of long-running processes that occasionally use large DLLs.</span></span>  
  
 <span data-ttu-id="c0a0d-111">Pueden ejecutar varios dominios de aplicación en un único proceso; Sin embargo, no hay una correlación uno a uno entre los dominios de aplicación y los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-111">Multiple application domains can run in a single process; however, there is not a one-to-one correlation between application domains and threads.</span></span> <span data-ttu-id="c0a0d-112">Varios subprocesos pueden pertenecer a un dominio de aplicación único y, mientras que un subproceso determinado no se limita a un único dominio de aplicación, en un momento dado, un subproceso se ejecuta en un único dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-112">Several threads can belong to a single application domain, and while a given thread is not confined to a single application domain, at any given time, a thread executes in a single application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-113">Dominios de aplicación se crean mediante el <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-113">Application domains are created using the <xref:System.AppDomain.CreateDomain%2A> method.</span></span> <span data-ttu-id="c0a0d-114"><xref:System.AppDomain> las instancias se usan para cargar y ejecutar ensamblados (<xref:System.Reflection.Assembly>).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-114"><xref:System.AppDomain> instances are used to load and execute assemblies (<xref:System.Reflection.Assembly>).</span></span> <span data-ttu-id="c0a0d-115">Cuando un <xref:System.AppDomain> es ya no está en uso, se puede descargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-115">When an <xref:System.AppDomain> is no longer in use, it can be unloaded.</span></span>  
  
 <span data-ttu-id="c0a0d-116">La <xref:System.AppDomain> clase implementa un conjunto de eventos que las aplicaciones puedan responder cuando se carga un ensamblado al que se va a descargar un dominio de aplicación, o cuando se produce una excepción no controlada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-116">The <xref:System.AppDomain> class implements a set of events that enable applications to respond when an assembly is loaded, when an application domain will be unloaded, or when an unhandled exception is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-117">Para obtener más información sobre el uso de dominios de aplicación, consulte [dominios de aplicación](~/docs/framework/app-domains/application-domains.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-117">For more information on using application domains, see [Application Domains](~/docs/framework/app-domains/application-domains.md).</span></span>  
  
 <span data-ttu-id="c0a0d-118">Esta clase implementa la <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, y <xref:System.Security.IEvidenceFactory> interfaces.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-118">This class implements the <xref:System.MarshalByRefObject>, <xref:System._AppDomain>, and <xref:System.Security.IEvidenceFactory> interfaces.</span></span>  
  
 <span data-ttu-id="c0a0d-119">Nunca se debe crear un contenedor utilizable de forma remota para un <xref:System.AppDomain> objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-119">You should never create a remotable wrapper for an <xref:System.AppDomain> object.</span></span> <span data-ttu-id="c0a0d-120">Si lo hace, puede publicar una referencia remota a la que <xref:System.AppDomain>, exponer métodos, como <xref:System.AppDomain.CreateInstance%2A> para acceso remoto y destruyendo la seguridad de acceso del código para que <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-120">Doing so could publish a remote reference to that <xref:System.AppDomain>, exposing methods such as <xref:System.AppDomain.CreateInstance%2A> to remote access and effectively destroying code access security for that <xref:System.AppDomain>.</span></span> <span data-ttu-id="c0a0d-121">Los clientes malintencionados que se conectan a la remoto <xref:System.AppDomain> se puede obtener acceso a cualquier recurso el <xref:System.AppDomain> sí tiene acceso a.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-121">Malicious clients connecting to the remoted <xref:System.AppDomain> could obtain access to any resource the <xref:System.AppDomain> itself has access to.</span></span> <span data-ttu-id="c0a0d-122">No cree contenedores utilizables de forma remota para cualquier tipo que extiende <xref:System.MarshalByRefObject> y que implemente métodos que podrían ser usados por los clientes malintencionados para omitir el sistema de seguridad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-122">Do not create remotable wrappers for any type that extends <xref:System.MarshalByRefObject> and that implements methods that could be used by malicious clients to bypass the security system.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="c0a0d-123">El valor predeterminado para el <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> propiedad es `false`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-123">The default value for the <xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType> property is `false`.</span></span> <span data-ttu-id="c0a0d-124">Esta configuración no es segura para los servicios.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-124">This setting is unsafe for services.</span></span> <span data-ttu-id="c0a0d-125">Para evitar que los servicios de descarga de código de confianza parcial, establezca esta propiedad en `true`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-125">To prevent services from downloading partially trusted code, set this property to `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-126">En este ejemplo se muestra cómo crear un nuevo <xref:System.AppDomain>, crear instancias de un tipo en ese nuevo <xref:System.AppDomain>y comunicarse con el objeto de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-126">This example shows how to create a new <xref:System.AppDomain>, instantiate a type in that new <xref:System.AppDomain>, and communicate with that type's object.</span></span> <span data-ttu-id="c0a0d-127">Además, este ejemplo muestra cómo descargar el <xref:System.AppDomain> provocando el objeto sea recolectado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-127">In addition, this example shows how to unload the <xref:System.AppDomain> causing the object to be garbage collected.</span></span>  
  
 [!code-cpp[AppDomainX#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomainX/cpp/AppDomainX.cpp#1)]
 [!code-csharp[AppDomainX#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomainX/cs/AppDomainX.cs#1)]
 [!code-vb[AppDomainX#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomainX/VB/AppDomainX.vb#1)]  
  
 ]]></format>
    </remarks>
    <related type="Article" href="https://msdn.microsoft.com/library/07ea8438-7a34-49f0-a7e8-3d6ff7e4a482"><span data-ttu-id="c0a0d-128">Cómo Configurar un dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-128">How To: Configure an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/ba1fa43e-49f5-47d9-bd7f-3024af16f4ba"><span data-ttu-id="c0a0d-129">Cómo Crear un dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-129">How To: Create an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/1432aa2d-bd83-4346-bf3b-a1b7920e2aa9"><span data-ttu-id="c0a0d-130">Cómo: Cargar ensamblados en un dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-130">How to: Load Assemblies into an Application Domain</span></span></related>
    <related type="Article" href="https://msdn.microsoft.com/library/f356116d-e415-4f7c-a332-6e6a60227192"><span data-ttu-id="c0a0d-131">Cómo: Descargar un dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-131">How to: Unload an Application Domain</span></span></related>
  </Docs>
  <Members>
    <Member MemberName="ActivationContext">
      <MemberSignature Language="C#" Value="public ActivationContext ActivationContext { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ActivationContext ActivationContext" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ActivationContext" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ActivationContext As ActivationContext" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ActivationContext ^ ActivationContext { ActivationContext ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ActivationContext : ActivationContext" Usage="System.AppDomain.ActivationContext" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ActivationContext</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-132">Obtiene el contexto de activación para el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-132">Gets the activation context for the current application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-133">Objeto que representa el contexto de activación para el dominio de aplicación actual, o <see langword="null" /> si el dominio no tiene ningún contexto de activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-133">An object that represents the activation context for the current application domain, or <see langword="null" /> if the domain has no activation context.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-134">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-134">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-135">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-135">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AppendPrivatePath">
      <MemberSignature Language="C#" Value="public void AppendPrivatePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void AppendPrivatePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.AppendPrivatePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AppendPrivatePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void AppendPrivatePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member AppendPrivatePath : string -&gt; unit&#xA;override this.AppendPrivatePath : string -&gt; unit" Usage="appDomain.AppendPrivatePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.AppendPrivatePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.AppendPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c0a0d-136">Nombre del directorio que hay que agregar a la ruta de acceso privada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-136">The name of the directory to be appended to the private path.</span></span></param>
        <summary><span data-ttu-id="c0a0d-137">Anexa el nombre de directorio especificado a la lista de rutas de acceso privadas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-137">Appends the specified directory name to the private path list.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-138">No se recomienda el uso de esta propiedad, porque podría cambiar la ruta de acceso de sondeo para ensamblados una vez que ya se han cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-138">The use of this property is not recommended, because it might change the probing path for assemblies after they have already been loaded.</span></span> <span data-ttu-id="c0a0d-139">Utilice la propiedad <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-139">Use the <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType> property instead.</span></span>  
  
 <span data-ttu-id="c0a0d-140">La ruta de acceso privado, o la ruta de búsqueda relativa es la ruta de acceso relativa al directorio base donde el interpretador de ensamblados para ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-140">The private path, or relative search path, is the path relative to the base directory where the assembly resolver probes for private assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-141">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-141">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-142">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-142">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-143">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-143">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationIdentity">
      <MemberSignature Language="C#" Value="public ApplicationIdentity ApplicationIdentity { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.ApplicationIdentity ApplicationIdentity" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationIdentity" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationIdentity As ApplicationIdentity" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property ApplicationIdentity ^ ApplicationIdentity { ApplicationIdentity ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationIdentity : ApplicationIdentity" Usage="System.AppDomain.ApplicationIdentity" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ApplicationIdentity</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-144">Obtiene la identidad de la aplicación en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-144">Gets the identity of the application in the application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-145">Objeto que identifica la aplicación en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-145">An object that identifies the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-146">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-146">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-147">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-147">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplicationTrust">
      <MemberSignature Language="C#" Value="public System.Security.Policy.ApplicationTrust ApplicationTrust { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.ApplicationTrust ApplicationTrust" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ApplicationTrust" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ApplicationTrust As ApplicationTrust" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::ApplicationTrust ^ ApplicationTrust { System::Security::Policy::ApplicationTrust ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ApplicationTrust : System.Security.Policy.ApplicationTrust" Usage="System.AppDomain.ApplicationTrust" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.ApplicationTrust</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-148">Obtiene información que describe los permisos concedidos a una aplicación y si la aplicación tiene un nivel de confianza que le permita ejecutarse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-148">Gets information describing permissions granted to an application and whether the application has a trust level that allows it to run.</span></span></summary>
        <value><span data-ttu-id="c0a0d-149">Objeto que encapsula permisos e información de confianza para la aplicación en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-149">An object that encapsulates permission and trust information for the application in the application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-150">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-150">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-151">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ApplyPolicy">
      <MemberSignature Language="C#" Value="public string ApplyPolicy (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ApplyPolicy(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ApplyPolicy(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ApplyPolicy (assemblyName As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ApplyPolicy(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ApplyPolicy : string -&gt; string" Usage="appDomain.ApplyPolicy assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-152">Nombre para mostrar del ensamblado, en el formato que proporciona la propiedad <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-152">The assembly display name, in the form provided by the <see cref="P:System.Reflection.Assembly.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-153">Devuelve el nombre para mostrar del ensamblado después de aplicar la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-153">Returns the assembly display name after policy has been applied.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-154">Cadena que contiene el nombre para mostrar del ensamblado después de aplicar la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-154">A string containing the assembly display name after policy has been applied.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-155">El <xref:System.AppDomain.ApplyPolicy%2A> mostrar el nombre de método toma un ensamblado y devuelve el nombre para mostrar tras aplicar la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-155">The <xref:System.AppDomain.ApplyPolicy%2A> method takes an assembly display name and returns the post-policy display name.</span></span> <span data-ttu-id="c0a0d-156">Esto es útil si tiene que cargar un ensamblado mediante la directiva, porque el contexto de solo reflexión no aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-156">This is useful if you need to load an assembly using policy, because the reflection-only context does not apply policy.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyLoad">
      <MemberSignature Language="C#" Value="public event AssemblyLoadEventHandler AssemblyLoad;" />
      <MemberSignature Language="ILAsm" Value=".event class System.AssemblyLoadEventHandler AssemblyLoad" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyLoad" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyLoad As AssemblyLoadEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event AssemblyLoadEventHandler ^ AssemblyLoad;" />
      <MemberSignature Language="F#" Value="member this.AssemblyLoad : AssemblyLoadEventHandler " Usage="member this.AssemblyLoad : System.AssemblyLoadEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyLoad</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AssemblyLoadEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-157">Se produce cuando se carga un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-157">Occurs when an assembly is loaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-158">El <xref:System.AssemblyLoadEventHandler> delegado para este evento indica qué ensamblado se cargó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-158">The <xref:System.AssemblyLoadEventHandler> delegate for this event indicates what assembly was loaded.</span></span>  
  
 <span data-ttu-id="c0a0d-159">Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-159">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-160">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-160">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-161">El ejemplo siguiente se muestra el <xref:System.AppDomain.AssemblyLoad> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-161">The following sample demonstrates the <xref:System.AppDomain.AssemblyLoad> event.</span></span>  
  
 <span data-ttu-id="c0a0d-162">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-162">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-163">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-163">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_AssemblyLoad#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CPP/assemblyload.cpp#1)]
 [!code-csharp[AppDomain_AssemblyLoad#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_AssemblyLoad/CS/assemblyload.cs#1)]
 [!code-vb[AppDomain_AssemblyLoad#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_AssemblyLoad/VB/assemblyload.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-164">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-164">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-165">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-165">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="AssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler AssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler AssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.AssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event AssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ AssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.AssemblyResolve : ResolveEventHandler " Usage="member this.AssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.AssemblyResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-166">Se produce cuando la resolución de un ensamblado produce errores.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-166">Occurs when the resolution of an assembly fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-167">Es responsabilidad de la <xref:System.ResolveEventHandler> para este evento devolver el ensamblado especificado por el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad, o para devolver null si no se reconoce el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-167">It is the responsibility of the <xref:System.ResolveEventHandler> for this event to return the assembly that is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property, or to return null if the assembly is not recognized.</span></span> <span data-ttu-id="c0a0d-168">El ensamblado deben cargarse en un contexto de ejecución; Si se carga en el contexto de solo reflexión, se produce un error en la carga que provocó este evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-168">The assembly must be loaded into an execution context; if it is loaded into the reflection-only context, the load that caused this event to be raised fails.</span></span>  
  
 <span data-ttu-id="c0a0d-169">Para obtener instrucciones sobre el uso de este evento, vea [resolver cargas de ensamblado](~/docs/framework/app-domains/resolve-assembly-loads.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-169">For guidance on the use of this event, see [Resolving Assembly Loads](~/docs/framework/app-domains/resolve-assembly-loads.md).</span></span>  
  
 <span data-ttu-id="c0a0d-170">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad devuelve el ensamblado que solicitó la carga del ensamblado que no se pudo resolver.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-170">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="c0a0d-171">Por ejemplo, el cargador podría ser no se puede cargar una dependencia del ensamblado que realiza solicitud porque el ensamblado para solicitar y su dependencia no están en la ruta de acceso de sondeo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-171">For example, the loader might be unable to load a dependency of the requesting assembly because the requesting assembly and its dependency are not in the probing path.</span></span> <span data-ttu-id="c0a0d-172">Conocer la identidad del ensamblado que realiza solicitud podría ser útil para localizar la dependencia o identificar la versión correcta, si hay más de una versión de la dependencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-172">Knowing the identity of the requesting assembly might be useful in locating the dependency or in identifying the correct version, if more than one version of the dependency is available.</span></span> <span data-ttu-id="c0a0d-173">Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-173">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-174">A partir del [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], el <xref:System.ResolveEventHandler> evento se desencadena para todos los ensamblados, incluidos los ensamblados de recursos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-174">Beginning with the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)], the <xref:System.ResolveEventHandler> event is raised for all assemblies, including resource assemblies.</span></span> <span data-ttu-id="c0a0d-175">En versiones anteriores, no se generó el evento para los ensamblados de recursos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-175">In earlier versions, the event was not raised for resource assemblies.</span></span> <span data-ttu-id="c0a0d-176">Si se localiza el sistema operativo, el controlador puede llamarse varias veces: una vez para cada referencia cultural de la cadena de reserva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-176">If the operating system is localized, the handler might be called multiple times: once for each culture in the fallback chain.</span></span>  
  
 <span data-ttu-id="c0a0d-177">Para este evento, el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad devuelve el nombre del ensamblado antes de que se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-177">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-178">Si más de un controlador de eventos está registrado para este evento, el evento handlersarecalled en orden hasta que un controlador de eventos devuelve un valor que no es `null`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-178">If more than one event handler is registered for this event, the event handlersarecalled in order until an event handler returns a value that isn't `null`.</span></span> <span data-ttu-id="c0a0d-179">Controladores de eventos posteriores se omiten.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-179">Subsequent event handlers are ignored.</span></span>  
  
 <span data-ttu-id="c0a0d-180">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-180">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-181">El ejemplo siguiente se muestra el <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-181">The following sample demonstrates the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-182">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-182">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-183">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-183">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AssemblyResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AssemblyResolve/CPP/assemblyresolve.cpp#1)]
 [!code-csharp[AssemblyResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AssemblyResolve/CS/assemblyresolve.cs#1)]
 [!code-vb[AssemblyResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AssemblyResolve/VB/assemblyresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-184">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-184">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-185">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-185">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
        <related type="Article" href="https://msdn.microsoft.com/library/5099e549-f4fd-49fb-a290-549edd456c6a"><span data-ttu-id="c0a0d-186">resolver cargas de ensamblado</span><span class="sxs-lookup"><span data-stu-id="c0a0d-186">Resolving Assembly Loads</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BaseDirectory">
      <MemberSignature Language="C#" Value="public string BaseDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string BaseDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.BaseDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BaseDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ BaseDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseDirectory : string" Usage="System.AppDomain.BaseDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.BaseDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-187">Obtiene el directorio base que la resolución de ensamblado usa para buscar ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-187">Gets the base directory that the assembly resolver uses to probe for assemblies.</span></span></summary>
        <value><span data-ttu-id="c0a0d-188">Directorio base que la resolución de ensamblado usa para buscar ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-188">The base directory that the assembly resolver uses to probe for assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-189">Esta propiedad se corresponde con el <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-189">This property corresponds to the <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c0a0d-190">También se puede recuperar utilizando la <xref:System.AppDomain.GetData%2A> método con la cadena "Raíz (appbase)".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-190">It can also be retrieved using the <xref:System.AppDomain.GetData%2A> method with the string "APPBASE".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-191">En el ejemplo de código siguiente se crea un nuevo dominio de aplicación, que especifica un directorio base que se usará al buscar ensamblados para cargar en el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-191">The following code example creates a new application domain, specifying a base directory to use when searching for assemblies to load into the domain.</span></span> <span data-ttu-id="c0a0d-192">El ejemplo se utiliza el <xref:System.AppDomain.BaseDirectory%2A> propiedad para obtener la ruta de acceso del directorio base, para su presentación en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-192">The example then uses the <xref:System.AppDomain.BaseDirectory%2A> property to obtain the base directory path, for display to the console.</span></span>  
  
 [!code-cpp[ADSetup#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetup/CPP/adsetup.cpp#1)]
 [!code-csharp[ADSetup#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetup/CS/adsetup.cs#1)]
 [!code-vb[ADSetup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetup/VB/adsetup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-193">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-193">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-194">Para obtener acceso a la información de la ruta de acceso, incluso si la ruta de acceso tiene el formato "file://" o \\\UNC\dir o "c:\\".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-194">for access to the information in the path itself, including if the path is in the form "file://" or \\\UNC\dir or "c:\\".</span></span> <span data-ttu-id="c0a0d-195">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-195">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.ApplicationBase" />
      </Docs>
    </Member>
    <Member MemberName="ClearPrivatePath">
      <MemberSignature Language="C#" Value="public void ClearPrivatePath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearPrivatePath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearPrivatePath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearPrivatePath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearPrivatePath();" />
      <MemberSignature Language="F#" Value="abstract member ClearPrivatePath : unit -&gt; unit&#xA;override this.ClearPrivatePath : unit -&gt; unit" Usage="appDomain.ClearPrivatePath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearPrivatePath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearPrivatePath has been deprecated. Please investigate the use of AppDomainSetup.PrivateBinPath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-196">Restablece la ruta de acceso que especifica la ubicación de ensamblados privados en la cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="c0a0d-196">Resets the path that specifies the location of private assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-197">La ruta de acceso privada es una ruta de acceso relativa al directorio base que common language runtime busca para buscar ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-197">The private path is a path relative to the base directory that the common language runtime searches to locate private assemblies.</span></span>  
  
 <span data-ttu-id="c0a0d-198">Para obtener más información, vea <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-198">For more information, see <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-199">En el ejemplo de código siguiente se muestra cómo usar el <xref:System.AppDomain.ClearPrivatePath%2A> método para quitar todas las entradas de la lista de rutas de acceso privadas para buscar cuando se cargan los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-199">The following code example demonstrates how to use the <xref:System.AppDomain.ClearPrivatePath%2A> method to remove all entries from the list of private paths to search when assemblies are loaded.</span></span>  
  
 <span data-ttu-id="c0a0d-200">Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-200">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADClearPrivatePath#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADClearPrivatePath/CPP/adclearprivatepath.cpp#1)]
 [!code-csharp[ADClearPrivatePath#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADClearPrivatePath/CS/adclearprivatepath.cs#1)]
 [!code-vb[ADClearPrivatePath#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADClearPrivatePath/VB/adclearprivatepath.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-201">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-201">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-202">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-202">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-203">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-203">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
      </Docs>
    </Member>
    <Member MemberName="ClearShadowCopyPath">
      <MemberSignature Language="C#" Value="public void ClearShadowCopyPath ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ClearShadowCopyPath() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ClearShadowCopyPath" />
      <MemberSignature Language="VB.NET" Value="Public Sub ClearShadowCopyPath ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ClearShadowCopyPath();" />
      <MemberSignature Language="F#" Value="abstract member ClearShadowCopyPath : unit -&gt; unit&#xA;override this.ClearShadowCopyPath : unit -&gt; unit" Usage="appDomain.ClearShadowCopyPath " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ClearShadowCopyPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.ClearShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-204">Restablece la lista de directorios que contienen instantáneas de ensamblados en la cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="c0a0d-204">Resets the list of directories containing shadow copied assemblies to the empty string ("").</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-205">La ruta de acceso de copia sombra es una lista de directorios donde sombra copiadas en los ensamblados se almacenan.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-205">The shadow copy path is a list of directories where shadow copied assemblies are stored.</span></span>  
  
 <span data-ttu-id="c0a0d-206">Para obtener más información, consulte <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-206">For more information, see <xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-207">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-207">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-208">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-208">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-209">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-209">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="F:System.String.Empty" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="c0a0d-210">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="c0a0d-210">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateComInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-211">Crea una nueva instancia de un tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-211">Creates a new instance of a specified COM type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-212">Nombre de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-212">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-213">Nombre del tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-213">The name of the requested type.</span></span></param>
        <summary><span data-ttu-id="c0a0d-214">Crea una nueva instancia de un tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-214">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="c0a0d-215">Los parámetros especifican el nombre de un archivo que contiene un ensamblado con el tipo y el nombre del tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-215">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-216">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-216">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-217">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-217">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-218">Utilice este método para crear objetos de forma remota sin tener que cargar el tipo localmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-218">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="c0a0d-219">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-219">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="c0a0d-220">Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que este método para crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-220">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-221">El ejemplo siguiente se muestra</span><span class="sxs-lookup"><span data-stu-id="c0a0d-221">The following sample demonstrates</span></span>  
  
 [!code-cpp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CPP/createcominstancefrom.cpp#1)]
 [!code-csharp[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/CS/createcominstancefrom.cs#1)]
 [!code-vb[AppDomain_CreateComInstanceFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateComInstanceFrom/VB/createcominstancefrom.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-222">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-222"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-223">No se puede cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-223">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-224">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-224">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-225">No se ha encontrado ningún constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-225">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-226">No se ha encontrado <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-226"><paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="c0a0d-227"><paramref name="typeName" /> es una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-227"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="c0a0d-228">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-228">-or-</span></span> 
<span data-ttu-id="c0a0d-229">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-229">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-230">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-230">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-231"><paramref name="assemblyName" /> es una cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="c0a0d-231"><paramref name="assemblyName" /> is an empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-232"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-232"><paramref name="assemblyName" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-233">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-233">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-234">El objeto COM al que se hace referencia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-234">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-235">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-235">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-236">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-236">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-237">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-237">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateComInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom (string assemblyFile, string typeName, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateComInstanceFrom(string assemblyFile, string typeName, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateComInstanceFrom(System.String,System.String,System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateComInstanceFrom (assemblyFile As String, typeName As String, hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateComInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.CreateComInstanceFrom : string * string * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateComInstanceFrom (assemblyFile, typeName, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-238">Nombre de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-238">The name of a file containing an assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-239">Nombre del tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-239">The name of the requested type.</span></span></param>
        <param name="hashValue"><span data-ttu-id="c0a0d-240">Representa el valor del código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-240">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="c0a0d-241">Representa el algoritmo hash que usa el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-241">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="c0a0d-242">Crea una nueva instancia de un tipo COM especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-242">Creates a new instance of a specified COM type.</span></span> <span data-ttu-id="c0a0d-243">Los parámetros especifican el nombre de un archivo que contiene un ensamblado con el tipo y el nombre del tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-243">Parameters specify the name of a file that contains an assembly containing the type and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-244">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-244">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-245">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-245">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-246">Utilice este método para crear objetos de forma remota sin tener que cargar el tipo localmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-246">Use this method to create objects remotely without having to load the type locally.</span></span>  
  
 <span data-ttu-id="c0a0d-247">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-247">The return value must to be unwrapped to access the real object.</span></span>  
  
 <span data-ttu-id="c0a0d-248">Un <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> atributo con un valor de `true` deben aplicarse explícitamente o de forma predeterminada al tipo COM para que este método para crear una instancia de ese tipo; de lo contrario, <xref:System.TypeLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-248">A <xref:System.Runtime.InteropServices.ComVisibleAttribute?displayProperty=nameWithType> attribute with a value of `true` must be applied either explicitly or by default to the COM type for this method to create an instance of that type; otherwise, <xref:System.TypeLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-249">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-249"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-250">No se puede cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-250">The type cannot be loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-251">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-251">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-252">No se ha encontrado ningún constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-252">No public parameterless constructor was found.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-253">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-253"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.MemberAccessException"><span data-ttu-id="c0a0d-254"><paramref name="typeName" /> es una clase abstracta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-254"><paramref name="typeName" /> is an abstract class.</span></span>  
  
<span data-ttu-id="c0a0d-255">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-255">-or-</span></span> 
<span data-ttu-id="c0a0d-256">Este miembro se invocó con un mecanismo de enlace en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-256">This member was invoked with a late-binding mechanism.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-257">El llamador no puede proporcionar atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-257">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-258"><paramref name="assemblyFile" /> es la cadena vacía ("").</span><span class="sxs-lookup"><span data-stu-id="c0a0d-258"><paramref name="assemblyFile" /> is the empty string ("").</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-259"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-259"><paramref name="assemblyFile" /> is not a valid assembly.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-260">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-260">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-261">El objeto COM al que se hace referencia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-261">The COM object that is being referred to is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-262">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-262">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-263">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-263">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-264">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-264">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateComInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateDomain">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-265">Crea un nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-265">Creates a new application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string -&gt; AppDomain" Usage="System.AppDomain.CreateDomain friendlyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-266">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-266">The friendly name of the domain.</span></span></param>
        <summary><span data-ttu-id="c0a0d-267">Crea un nuevo dominio de aplicación con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-267">Creates a new application domain with the specified name.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-268">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-268">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-269">El `friendlyName` parámetro está pensado para identificar el dominio de manera que sea significativo para los seres humanos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-269">The `friendlyName` parameter is intended to identify the domain in a manner that is meaningful to humans.</span></span> <span data-ttu-id="c0a0d-270">Esta cadena debe ser adecuada para su presentación en interfaces de usuario.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-270">This string should be suitable for display in user interfaces.</span></span>  
  
 <span data-ttu-id="c0a0d-271">Esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-271">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-272">El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-272">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-273">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-273"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-274">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-274">to provide evidence.</span></span> <span data-ttu-id="c0a0d-275">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-275">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="P:System.AppDomain.FriendlyName" />
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-276">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-276">The friendly name of the domain.</span></span> <span data-ttu-id="c0a0d-277">Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-277">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="c0a0d-278">Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-278">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="c0a0d-279">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-279">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="c0a0d-280">Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-280">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <summary><span data-ttu-id="c0a0d-281">Crea un nuevo dominio de aplicación con el nombre especificado mediante la evidencia proporcionada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-281">Creates a new application domain with the given name using the supplied evidence.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-282">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-282">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-283">Esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-283">This method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-284">Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-284">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-285">No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-285">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="c0a0d-286">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-286">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="c0a0d-287">Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-287">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-288">El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-288">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-289">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-289"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-290">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-290">to provide evidence.</span></span> <span data-ttu-id="c0a0d-291">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-291">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-292">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-292">The friendly name of the domain.</span></span> <span data-ttu-id="c0a0d-293">Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-293">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="c0a0d-294">Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-294">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="c0a0d-295">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-295">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="c0a0d-296">Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-296">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="c0a0d-297">Objeto que contiene la información de inicialización del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-297">An object that contains application domain initialization information.</span></span></param>
        <summary><span data-ttu-id="c0a0d-298">Crea un nuevo dominio de aplicación con el nombre especificado, la evidencia indicada y la correspondiente información de configuración.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-298">Creates a new application domain using the specified name, evidence, and application domain setup information.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-299">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-299">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-300">Si `info` no es se proporciona, esta sobrecarga del método usa la <xref:System.AppDomainSetup> información de dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-300">If `info` is not supplied, this method overload uses the <xref:System.AppDomainSetup> information from the default application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-301">Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-301">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-302">No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-302">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="c0a0d-303">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-303">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="c0a0d-304">Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-304">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-305">El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-305">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-306">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-306"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-307">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-307">to provide evidence.</span></span> <span data-ttu-id="c0a0d-308">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-308">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, AppDomainSetup info, System.Security.PermissionSet grantSet, params System.Security.Policy.StrongName[] fullTrustAssemblies);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, class System.AppDomainSetup info, class System.Security.PermissionSet grantSet, class System.Security.Policy.StrongName[] fullTrustAssemblies) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.AppDomainSetup,System.Security.PermissionSet,System.Security.Policy.StrongName[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, info As AppDomainSetup, grantSet As PermissionSet, ParamArray fullTrustAssemblies As StrongName()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, AppDomainSetup ^ info, System::Security::PermissionSet ^ grantSet, ... cli::array &lt;System::Security::Policy::StrongName ^&gt; ^ fullTrustAssemblies);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * AppDomainSetup * System.Security.PermissionSet * System.Security.Policy.StrongName[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, info, grantSet, fullTrustAssemblies)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="info" Type="System.AppDomainSetup" />
        <Parameter Name="grantSet" Type="System.Security.PermissionSet" />
        <Parameter Name="fullTrustAssemblies" Type="System.Security.Policy.StrongName[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-309">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-309">The friendly name of the domain.</span></span> <span data-ttu-id="c0a0d-310">Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-310">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="c0a0d-311">Para obtener más información, vea la descripción de <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-311">For more information, see the description of <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="c0a0d-312">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-312">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="c0a0d-313">Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-313">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="info"><span data-ttu-id="c0a0d-314">Objeto que contiene la información de inicialización del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-314">An object that contains application domain initialization information.</span></span></param>
        <param name="grantSet"><span data-ttu-id="c0a0d-315">Conjunto predeterminado de permisos que se concede a todos los ensamblados cargados en el nuevo dominio de aplicación que no tienen concesiones concretas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-315">A default permission set that is granted to all assemblies loaded into the new application domain that do not have specific grants.</span></span></param>
        <param name="fullTrustAssemblies"><span data-ttu-id="c0a0d-316">Matriz de nombres seguros que representan ensamblados que se van a considerar de plena confianza en el nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-316">An array of strong names representing assemblies to be considered fully trusted in the new application domain.</span></span></param>
        <summary><span data-ttu-id="c0a0d-317">Crea un nuevo dominio de aplicación usando el nombre, la evidencia, la información de configuración del dominio de aplicación, el conjunto predeterminado de permisos y la matriz de ensamblados de plena confianza que se hayan especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-317">Creates a new application domain using the specified name, evidence, application domain setup information, default permission set, and array of fully trusted assemblies.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-318">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-318">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-319">Debe establecer el <xref:System.AppDomainSetup.ApplicationBase%2A> propiedad de la <xref:System.AppDomainSetup> objeto que proporciona para `info`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-319">You must set the <xref:System.AppDomainSetup.ApplicationBase%2A> property of the <xref:System.AppDomainSetup> object that you supply for `info`.</span></span> <span data-ttu-id="c0a0d-320">De lo contrario, se inicia una excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-320">Otherwise, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-321">Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-321">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="c0a0d-322">La información proporcionada para `grantSet` y `fullTrustAssemblies` se utiliza para crear un <xref:System.Security.Policy.ApplicationTrust> objeto para el nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-322">The information provided for `grantSet` and `fullTrustAssemblies` is used to create an <xref:System.Security.Policy.ApplicationTrust> object for the new application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-323">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-323"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-324">El dominio de aplicación es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-324">The application domain is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-325">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-325">-or-</span></span> 
<span data-ttu-id="c0a0d-326">La propiedad <see cref="P:System.AppDomainSetup.ApplicationBase" /> no se establece en el objeto <see cref="T:System.AppDomainSetup" /> que se proporciona para <paramref name="info" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-326">The <see cref="P:System.AppDomainSetup.ApplicationBase" /> property is not set on the <see cref="T:System.AppDomainSetup" /> object that is supplied for <paramref name="info" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-327">Para poder crear y manipular un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-327">for the ability to create and manipulate an application domain.</span></span> <span data-ttu-id="c0a0d-328">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-328">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="c0a0d-329">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-329">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-330">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-330">The friendly name of the domain.</span></span> <span data-ttu-id="c0a0d-331">Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-331">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="c0a0d-332">Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-332">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="c0a0d-333">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-333">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="c0a0d-334">Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-334">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="c0a0d-335">Directorio base que la resolución de ensamblado usa para buscar ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-335">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="c0a0d-336">Para obtener más información, vea <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-336">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="c0a0d-337">Ruta de acceso correspondiente al directorio base donde la resolución de ensamblado debe buscar ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-337">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="c0a0d-338">Para obtener más información, vea <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-338">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="c0a0d-339">Si es <see langword="true" />, se carga una instantánea de un ensamblado en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-339">If <see langword="true" />, a shadow copy of an assembly is loaded into this application domain.</span></span></param>
        <summary><span data-ttu-id="c0a0d-340">Crea un nuevo dominio de aplicación con el nombre especificado usando la evidencia, la ruta de acceso base de la aplicación, la ruta de búsqueda relativa y un parámetro que especifica si debe cargarse una instantánea de un ensamblado en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-340">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-341">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-341">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-342">Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-342">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="c0a0d-343">Para obtener más información acerca de las instantáneas, vea <xref:System.AppDomain.ShadowCopyFiles%2A> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-343">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-344">No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-344">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="c0a0d-345">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-345">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="c0a0d-346">Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-346">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-347">El ejemplo siguiente muestra, en general, cómo crear un dominio mediante uno de los <xref:System.AppDomain.CreateDomain%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-347">The following sample demonstrates, in general, how to create a domain using one of the <xref:System.AppDomain.CreateDomain%2A> overloads.</span></span>  
  
 [!code-cpp[AppDomain_Setup#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_Setup/CPP/setup.cpp#1)]
 [!code-csharp[AppDomain_Setup#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_Setup/CS/setup.cs#1)]
 [!code-vb[AppDomain_Setup#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_Setup/VB/setup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-348">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-348"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-349">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-349">to provide evidence.</span></span> <span data-ttu-id="c0a0d-350">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-350">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="CreateDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CreateDomain (string friendlyName, System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer adInit, string[] adInitArgs);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.AppDomain CreateDomain(string friendlyName, class System.Security.Policy.Evidence securityInfo, string appBasePath, string appRelativeSearchPath, bool shadowCopyFiles, class System.AppDomainInitializer adInit, string[] adInitArgs) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateDomain(System.String,System.Security.Policy.Evidence,System.String,System.String,System.Boolean,System.AppDomainInitializer,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CreateDomain (friendlyName As String, securityInfo As Evidence, appBasePath As String, appRelativeSearchPath As String, shadowCopyFiles As Boolean, adInit As AppDomainInitializer, adInitArgs As String()) As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static AppDomain ^ CreateDomain(System::String ^ friendlyName, System::Security::Policy::Evidence ^ securityInfo, System::String ^ appBasePath, System::String ^ appRelativeSearchPath, bool shadowCopyFiles, AppDomainInitializer ^ adInit, cli::array &lt;System::String ^&gt; ^ adInitArgs);" />
      <MemberSignature Language="F#" Value="static member CreateDomain : string * System.Security.Policy.Evidence * string * string * bool * AppDomainInitializer * string[] -&gt; AppDomain" Usage="System.AppDomain.CreateDomain (friendlyName, securityInfo, appBasePath, appRelativeSearchPath, shadowCopyFiles, adInit, adInitArgs)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="friendlyName" Type="System.String" />
        <Parameter Name="securityInfo" Type="System.Security.Policy.Evidence" />
        <Parameter Name="appBasePath" Type="System.String" />
        <Parameter Name="appRelativeSearchPath" Type="System.String" />
        <Parameter Name="shadowCopyFiles" Type="System.Boolean" />
        <Parameter Name="adInit" Type="System.AppDomainInitializer" />
        <Parameter Name="adInitArgs" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="friendlyName"><span data-ttu-id="c0a0d-351">Nombre descriptivo del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-351">The friendly name of the domain.</span></span> <span data-ttu-id="c0a0d-352">Este nombre descriptivo puede mostrarse en las interfaces de usuario para identificar el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-352">This friendly name can be displayed in user interfaces to identify the domain.</span></span> <span data-ttu-id="c0a0d-353">Para obtener más información, vea <see cref="P:System.AppDomain.FriendlyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-353">For more information, see <see cref="P:System.AppDomain.FriendlyName" />.</span></span></param>
        <param name="securityInfo"><span data-ttu-id="c0a0d-354">Evidencia que establece la identidad del código que se ejecuta en el dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-354">Evidence that establishes the identity of the code that runs in the application domain.</span></span> <span data-ttu-id="c0a0d-355">Pase <see langword="null" /> para que se use la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-355">Pass <see langword="null" /> to use the evidence of the current application domain.</span></span></param>
        <param name="appBasePath"><span data-ttu-id="c0a0d-356">Directorio base que la resolución de ensamblado usa para buscar ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-356">The base directory that the assembly resolver uses to probe for assemblies.</span></span> <span data-ttu-id="c0a0d-357">Para obtener más información, vea <see cref="P:System.AppDomain.BaseDirectory" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-357">For more information, see <see cref="P:System.AppDomain.BaseDirectory" />.</span></span></param>
        <param name="appRelativeSearchPath"><span data-ttu-id="c0a0d-358">Ruta de acceso correspondiente al directorio base donde la resolución de ensamblado debe buscar ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-358">The path relative to the base directory where the assembly resolver should probe for private assemblies.</span></span> <span data-ttu-id="c0a0d-359">Para obtener más información, vea <see cref="P:System.AppDomain.RelativeSearchPath" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-359">For more information, see <see cref="P:System.AppDomain.RelativeSearchPath" />.</span></span></param>
        <param name="shadowCopyFiles"><span data-ttu-id="c0a0d-360">Es <see langword="true" /> para cargar una instantánea de un ensamblado en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-360"><see langword="true" /> to load a shadow copy of an assembly into the application domain.</span></span></param>
        <param name="adInit"><span data-ttu-id="c0a0d-361">Delegado <see cref="T:System.AppDomainInitializer" /> que representa un método de devolución de llamada que se va a invocar cuando se inicialice el nuevo objeto <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-361">An <see cref="T:System.AppDomainInitializer" /> delegate that represents a callback method to invoke when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <param name="adInitArgs"><span data-ttu-id="c0a0d-362">Matriz de argumentos de cadena que se va a pasar a la devolución de llamada que representa <paramref name="adInit" /> cuando se inicialice el nuevo objeto <see cref="T:System.AppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-362">An array of string arguments to be passed to the callback represented by <paramref name="adInit" />, when the new <see cref="T:System.AppDomain" /> object is initialized.</span></span></param>
        <summary><span data-ttu-id="c0a0d-363">Crea un nuevo dominio de aplicación con el nombre especificado usando la evidencia, la ruta de acceso base de la aplicación, la ruta de búsqueda relativa y un parámetro que especifica si debe cargarse una instantánea de un ensamblado en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-363">Creates a new application domain with the given name, using evidence, application base path, relative search path, and a parameter that specifies whether a shadow copy of an assembly is to be loaded into the application domain.</span></span> <span data-ttu-id="c0a0d-364">Especifica un método de devolución de llamada que se invoca cuando se inicializa el dominio de aplicación, así como una matriz de argumentos de cadena para pasar al método de devolución de llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-364">Specifies a callback method that is invoked when the application domain is initialized, and an array of string arguments to pass the callback method.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-365">Dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-365">The newly created application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-366">El método representado por `adInit` se ejecuta en el contexto del dominio de aplicación recién creado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-366">The method represented by `adInit` is executed in the context of the newly created application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-367">Si `securityInfo` no es se proporciona, se utiliza la evidencia del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-367">If `securityInfo` is not supplied, the evidence from the current application domain is used.</span></span>  
  
 <span data-ttu-id="c0a0d-368">Para obtener más información acerca de las instantáneas, vea <xref:System.AppDomain.ShadowCopyFiles%2A> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-368">For more information about shadow copying, see <xref:System.AppDomain.ShadowCopyFiles%2A> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-369">No utilice esta sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-369">Do not use this method overload to create sandboxed application domains.</span></span> <span data-ttu-id="c0a0d-370">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], la evidencia suministrada para `securityInfo` ya no afecta al conjunto de permisos del dominio de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-370">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the evidence that is supplied for `securityInfo` no longer affects the grant set of the application domain.</span></span> <span data-ttu-id="c0a0d-371">Use el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> sobrecarga del método para crear dominios de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-371">Use the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29> method overload to create sandboxed application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-372">El valor de <paramref name="friendlyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-372"><paramref name="friendlyName" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-373">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-373">to provide evidence.</span></span> <span data-ttu-id="c0a0d-374">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-374">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstance">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-375">Crea una nueva instancia de un tipo especificado definido en un ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-375">Creates a new instance of a specified type defined in a specified assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-376">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-376">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-377">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-377">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-378">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-378">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-379">Crea una nueva instancia del tipo especificado definido en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-379">Creates a new instance of the specified type defined in the specified assembly.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-380">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-380">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-381">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-381">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-382">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-382">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-383">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-383">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="c0a0d-384">Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-384">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="c0a0d-385">Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-385">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="c0a0d-386">El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-386">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-387">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-387">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-388">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-388"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-389"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-389"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-390">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-390">-or-</span></span> 
<span data-ttu-id="c0a0d-391">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-391">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-392">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-392">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-393">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-393"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-394">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-394">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-395">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-395">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-396">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-396"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-397">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-397">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-398">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-398">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-399">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-399">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-400">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-400">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-401">Para poder llamar a código no administrado al crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-401">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="c0a0d-402">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-402">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstance (assemblyName As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-403">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-403">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-404">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-404">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-405">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-405">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-406">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-406">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-407">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-407">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-408">Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-408">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-409">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-409">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-410">Crea una nueva instancia del tipo especificado definido en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-410">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="c0a0d-411">Un parámetro especifica una matriz de atributos de activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-411">A parameter specifies an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-412">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-412">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-413">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-413">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-414">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-414">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-415">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-415">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="c0a0d-416">Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-416">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="c0a0d-417">Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-417">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="c0a0d-418">El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-418">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-419">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-419">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-420">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-420"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-421"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-421"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-422">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-422">-or-</span></span> 
<span data-ttu-id="c0a0d-423">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-423">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-424">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-424">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-425">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-425"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-426">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-426">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-427">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-427">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-428">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-428">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-429">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-429"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-430">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-430">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-431">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-431">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-432">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-432">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-433">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-433">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-434">Para poder llamar a código no administrado al crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-434">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="c0a0d-435">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-435">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-436">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-436">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-437">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-437">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-438">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-438">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-439">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-439">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-440">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-440">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-441">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-441">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-442">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-442">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-443">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-443">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-444">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-444">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="c0a0d-445">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-445">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-446">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-446">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-447">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-447">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-448">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-448">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-449">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-449">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-450">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-450">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-451">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-451">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-452">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-452">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-453">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-453">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-454">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-454">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-455">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-455">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-456">Crea una nueva instancia del tipo especificado definido en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-456">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="c0a0d-457">Los parámetros especifican un enlazador, marcas de enlace, argumentos de constructor, información específica de la referencia cultural usada para interpretar argumentos y atributos de activación opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-457">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, and optional activation attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-458">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-458">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-459">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-459">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-460">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-460">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="c0a0d-461">Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-461">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="c0a0d-462">Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-462">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="c0a0d-463">El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-463">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-464">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-464">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-465">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-465"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-466"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-466"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-467">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-467">-or-</span></span> 
 <span data-ttu-id="c0a0d-468"><paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-468"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-469">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-469">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-470">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-470"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-471">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-471">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-472">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-472">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-473">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-473">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-474">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-474"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-475">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-475">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-476">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-476">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-477">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-477">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-478">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-478">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-479">Para poder llamar a código no administrado al crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-479">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="c0a0d-480">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-480">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-481">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-481">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-482">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-482">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstance">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstance (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstance(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstance : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstance (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstance(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstance which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-483">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-483">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-484">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-484">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-485">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-485">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-486">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-486">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-487">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-487">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-488">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-488">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-489">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-489">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="c0a0d-490">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-490">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-491">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-491">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-492">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-492">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-493">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-493">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-494">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-494">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-495">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-495">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-496">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-496">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-497">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-497">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-498">Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-498">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-499">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-499">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="c0a0d-500">Información que se usa para autorizar la creación de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-500">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-501">Crea una nueva instancia del tipo especificado definido en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-501">Creates a new instance of the specified type defined in the specified assembly.</span></span> <span data-ttu-id="c0a0d-502">Los parámetros establecen un enlazador, marcas de enlace, argumentos de constructor, información específica de la referencia cultural usada para interpretar argumentos, atributos de activación y autorización para crear el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-502">Parameters specify a binder, binding flags, constructor arguments, culture-specific information used to interpret arguments, activation attributes, and authorization to create the type.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-503">Objeto contenedor de la nueva instancia especificada por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-503">An object that is a wrapper for the new instance specified by <paramref name="typeName" />.</span></span> <span data-ttu-id="c0a0d-504">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-504">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-505">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-505">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span>  
  
 <span data-ttu-id="c0a0d-506">Un intento de llamar a <xref:System.AppDomain.CreateInstance%2A> en un destino de dominio de aplicación que no sea el dominio de aplicación actual se producirá en una carga correcta del ensamblado en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-506">An attempt to call <xref:System.AppDomain.CreateInstance%2A> on a target application domain that is not the current application domain will result in a successful load of the assembly in the target application domain.</span></span> <span data-ttu-id="c0a0d-507">Puesto que un <xref:System.Reflection.Assembly> no <xref:System.MarshalByRefObject>, cuando este método intente devolver el <xref:System.Reflection.Assembly> para el ensamblado cargado en el dominio de aplicación actual, common language runtime intenta cargar el ensamblado en el dominio de aplicación actual y el puede producir un error de carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-507">Since an <xref:System.Reflection.Assembly> is not <xref:System.MarshalByRefObject>, when this method attempts to return the <xref:System.Reflection.Assembly> for the loaded assembly to the current application domain, the common language runtime will try to load the assembly into the current application domain and the load might fail.</span></span> <span data-ttu-id="c0a0d-508">El ensamblado que se carga en el dominio de aplicación actual podría ser diferente del ensamblado que se cargó en primer lugar si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-508">The assembly that is loaded into the current application domain might be different from the assembly that was loaded first if the path settings for the two application domains are different.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-509">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-509">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-510">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-510"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-511"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-511"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-512">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-512">-or-</span></span> 
<span data-ttu-id="c0a0d-513">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-513">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-514">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-514">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-515">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-515"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-516">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-516">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-517">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-517">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-518">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-518">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="c0a0d-519">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-519">-or-</span></span> 
 <span data-ttu-id="c0a0d-520"><paramref name="securityAttributes" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-520"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-521">Si la directiva CAS heredada no está habilitada, <paramref name="securityAttributes" /> debería ser <see langword="null." /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-521">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null." /></span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-522">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-522"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-523">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-523">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-524">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-524">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-525">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-525">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-526">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-526">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-527">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-527">to provide evidence.</span></span> <span data-ttu-id="c0a0d-528">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-528">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-529">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-529">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-530">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-530">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.Activator.CreateInstance(System.Type,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-531">Crea una nueva instancia del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-531">Creates a new instance of a specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-532">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-532">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-533">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-533">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-534">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-534">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-535">Crea una nueva instancia del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-535">Creates a new instance of the specified type.</span></span> <span data-ttu-id="c0a0d-536">Los parámetros especifican el ensamblado en el que se definen el tipo y el nombre del tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-536">Parameters specify the assembly where the type is defined, and the name of the type.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-537">Instancia del objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-537">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-538">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-538">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c0a0d-539">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-539">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-540">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-540">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="c0a0d-541">Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-541">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-542">Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-542">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="c0a0d-543">Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-543">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="c0a0d-544">Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-544">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="c0a0d-545">Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-545">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-546">El ejemplo de código siguiente muestra la manera más sencilla para ejecutar código en otro dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-546">The following code example shows the simplest way to execute code in another application domain.</span></span> <span data-ttu-id="c0a0d-547">El ejemplo define una clase denominada `Worker` que hereda de <xref:System.MarshalByRefObject>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-547">The example defines a class named `Worker` that inherits from <xref:System.MarshalByRefObject>.</span></span> <span data-ttu-id="c0a0d-548">La `Worker` clase define un método que muestra el nombre del dominio de aplicación en el que se está ejecutando.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-548">The `Worker` class defines a method that displays the name of the application domain in which it is executing.</span></span> <span data-ttu-id="c0a0d-549">El ejemplo crea instancias de `Worker` en el dominio de aplicación predeterminado y en un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-549">The example creates instances of `Worker` in the default application domain and in a new application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-550">El ensamblado que contiene `Worker` deben cargarse en ambos dominios de aplicación, pero se pueden cargar otros ensamblados que solo existen en el nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-550">The assembly that contains `Worker` must be loaded into both application domains, but it can load other assemblies that exist only in the new application domain.</span></span>  
  
 [!code-cpp[CreateInstanceAndUnwrap2#1](~/samples/snippets/cpp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cpp/source.cpp#1)]
 [!code-csharp[CreateInstanceAndUnwrap2#1](~/samples/snippets/csharp/VS_Snippets_CLR/CreateInstanceAndUnwrap2/cs/source.cs#1)]
 [!code-vb[CreateInstanceAndUnwrap2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/CreateInstanceAndUnwrap2/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-551">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-551"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-552">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-552">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-553">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-553"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-554">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-554"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-555">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-555">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-556">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-556">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-557"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-557"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-558">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-558">-or-</span></span> 
<span data-ttu-id="c0a0d-559">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-559">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-560">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-560">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-561">Para poder leer el archivo que contiene el manifiesto del ensamblado, o si va a crear un tipo desde un módulo que no sea el archivo de manifiesto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-561">for the ability to read the file containing the assembly manifest, or if you are creating a type from a module other than the manifest file.</span></span> <span data-ttu-id="c0a0d-562">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-562">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-563">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-563">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-564">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-564">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-565">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-565">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-566">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-566">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-567">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-567">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-568">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-568">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-569">Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-569">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-570">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-570">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-571">Crea una nueva instancia del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-571">Creates a new instance of the specified type.</span></span> <span data-ttu-id="c0a0d-572">Los parámetros especifican el ensamblado en el que se definen el tipo, el nombre del tipo y una matriz de atributos de activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-572">Parameters specify the assembly where the type is defined, the name of the type, and an array of activation attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-573">Instancia del objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-573">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-574">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-574">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c0a0d-575">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-575">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-576">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-576">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="c0a0d-577">Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-577">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-578">Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-578">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="c0a0d-579">Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-579">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="c0a0d-580">Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-580">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="c0a0d-581">Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-581">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 [!code-cpp[ADDyno#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDyno/CPP/addyno.cpp#1)]
 [!code-csharp[ADDyno#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDyno/CS/addyno.cs#1)]
 [!code-vb[ADDyno#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDyno/VB/addyno.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-582">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-582"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-583">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-583">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-584">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-584"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-585">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-585"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-586">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-586">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-587">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-587">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-588">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-588">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-589"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-589"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-590">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-590">-or-</span></span> 
<span data-ttu-id="c0a0d-591">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-591">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-592">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-592">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-593">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-593">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-594">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-594">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-595">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-595">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-596">Para poder llamar a código no administrado al crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-596">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="c0a0d-597">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-597">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-598">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-598">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-599">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-599">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-600">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-600">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-601">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-601">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-602">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-602">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-603">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-603">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-604">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-604">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-605">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-605">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-606">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-606">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="c0a0d-607">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-607">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-608">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-608">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-609">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-609">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-610">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-610">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-611">Objeto específico de la referencia cultural que se usa para regir la conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-611">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="c0a0d-612">Si <paramref name="culture" /> es <see langword="null" />, se usa <see langword="CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-612">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-613">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-613">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-614">Normalmente, una matriz que contiene un solo objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-614">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object.</span></span> <span data-ttu-id="c0a0d-615">que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-615">that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-616">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-616">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-617">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-617">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-618">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-618">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-619">Crea una nueva instancia del tipo especificado definido en el ensamblado indicado, especificando si se pasa por alto el modelo de mayúsculas y minúsculas del nombre de tipo, los atributos de enlace y el enlazador que se usan para seleccionar el tipo que se va a crear, los argumentos del constructor, la referencia cultural y los atributos de activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-619">Creates a new instance of the specified type defined in the specified assembly, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-620">Instancia del objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-620">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-621">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-621">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-622">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-622">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="c0a0d-623">Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-623">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-624">Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-624">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="c0a0d-625">Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-625">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="c0a0d-626">Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-626">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="c0a0d-627">Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-627">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-628">El ejemplo siguiente muestra el uso de la `ignoreCase` parámetro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-628">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-629">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-629"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-630">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-630">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-631">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-631"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-632">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-632"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-633">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-633">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-634">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-634">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-635">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-635">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-636"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-636"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-637">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-637">-or-</span></span> 
 <span data-ttu-id="c0a0d-638"><paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-638"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-639">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-639">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-640">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-640">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-641">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-641">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-642">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-642">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-643">Para poder llamar a código no administrado al crear una instancia de un delegado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-643">for the ability to call unmanaged code when creating an instance of a delegate.</span></span> <span data-ttu-id="c0a0d-644">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-644">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-645">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-645">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-646">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-646">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-647">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-647">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-648">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-648">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-649">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-649">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-650">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-650">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-651">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-651">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-652">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-652">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-653">Objeto que permite el enlace, la conversión de tipos de argumentos, la invocación de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-653">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects using reflection.</span></span> <span data-ttu-id="c0a0d-654">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-654">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-655">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-655">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-656">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-656">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-657">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-657">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-658">Objeto específico de la referencia cultural que se usa para regir la conversión de tipos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-658">A culture-specific object used to govern the coercion of types.</span></span> <span data-ttu-id="c0a0d-659">Si <paramref name="culture" /> es <see langword="null" />, se usa <see langword="CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-659">If <paramref name="culture" /> is <see langword="null" />, the <see langword="CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-660">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-660">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-661">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-661">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-662">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-662">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-663">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-663">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-664">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-664">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="c0a0d-665">Información que se usa para autorizar la creación de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-665">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-666">Crea una nueva instancia del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-666">Creates a new instance of the specified type.</span></span> <span data-ttu-id="c0a0d-667">Los parámetros especifican el nombre del tipo, así como la forma en que se encontró y se creó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-667">Parameters specify the name of the type, and how it is found and created.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-668">Instancia del objeto especificado por <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-668">An instance of the object specified by <paramref name="typeName" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-669">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstance%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-669">This is a convenience method that combines <xref:System.AppDomain.CreateInstance%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-670">Consulte <xref:System.Reflection.AssemblyName> de formato de `assemblyName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-670">See <xref:System.Reflection.AssemblyName> for the format of `assemblyName`.</span></span> <span data-ttu-id="c0a0d-671">Consulte la <xref:System.Type.FullName%2A?displayProperty=nameWithType> propiedad de formato de `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-671">See the <xref:System.Type.FullName%2A?displayProperty=nameWithType> property for the format of `typeName`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-672">Si realiza una llamada enlazada a un método `M` de un objeto de tipo `T1` que devolvió <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, y que el método realiza una llamada enlazada a un método de un objeto de tipo `T2` en un ensamblado `C` distinto el ensamblado actual o el ensamblado que contiene `T1`, ensamblado `C` se carga en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-672">If you make an early-bound call to a method `M` of an object of type `T1` that was returned by <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>, and that method makes an early-bound call to a method of an object of type `T2` in an assembly `C` other than the current assembly or the assembly containing `T1`, assembly `C` is loaded into the current application domain.</span></span> <span data-ttu-id="c0a0d-673">Esta carga se produce incluso si el enlace anticipado llamada a `T1.M()` se realizó en el cuerpo de un <xref:System.Reflection.Emit.DynamicMethod>, o en otro código generado dinámicamente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-673">This loading occurs even if the early-bound call to `T1.M()` was made in the body of a <xref:System.Reflection.Emit.DynamicMethod>, or in other dynamically generated code.</span></span> <span data-ttu-id="c0a0d-674">Si el dominio actual es el dominio predeterminado, el ensamblado `C` no se puede descargar hasta que finaliza el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-674">If the current domain is the default domain, assembly `C` cannot be unloaded until the process ends.</span></span> <span data-ttu-id="c0a0d-675">Si más adelante, el dominio actual intenta cargar el ensamblado `C`, podría producir un error en la carga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-675">If the current domain later attempts to load assembly `C`, the load might fail.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-676">El ejemplo siguiente muestra el uso de la `ignoreCase` parámetro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-676">The following sample demonstrates the use of the `ignoreCase` parameter.</span></span>  
  
 [!code-cpp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CPP/ignorecase.cpp#1)]
 [!code-csharp[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/CS/ignorecase.cs#1)]
 [!code-vb[AppDomain_CreateInstance_IgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_CreateInstance_IgnoreCase/VB/ignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-677">El valor de <paramref name="assemblyName" /> o <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-677"><paramref name="assemblyName" /> or <paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-678">No se encontró ningún constructor coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-678">No matching constructor was found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-679">No se encontró <paramref name="typename" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-679"><paramref name="typename" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-680">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-680"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-681">El llamador no tiene permiso para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-681">The caller does not have permission to call this constructor.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-682">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-682">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-683">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-683">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-684"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-684"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-685">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-685">-or-</span></span> 
<span data-ttu-id="c0a0d-686">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-686">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-687">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-687">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-688">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-688">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-689">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-689">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-690">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-690">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-691">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-691">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-692">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-692">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="c0a0d-693">la capacidad invocar operaciones en todos los miembros de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-693">for the ability to invoke operations on all type members.</span></span> <span data-ttu-id="c0a0d-694">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-694">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <altmember cref="M:System.AppDomain.CreateInstance(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFrom">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-695">Crea una nueva instancia de un tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-695">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-696">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-696">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="c0a0d-697">El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-697">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-698">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-698">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-699">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-699">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-700">Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-700">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="c0a0d-701">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-701">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-702">El constructor predeterminado para `typeName` se invoca.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-702">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="c0a0d-703">Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-703">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c0a0d-704">Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-704">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="c0a0d-705">Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-705">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="c0a0d-706">Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-706">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="c0a0d-707">Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-707">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-708">Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-708">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-709">Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-709">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-710">El ejemplo siguiente muestra cómo usar el <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga del método para crear una instancia de un objeto en un dominio de aplicación de destino y llamar a sus métodos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-710">The following example shows how to use the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to create an instance of an object in a target application domain and call its methods.</span></span>  
  
 <span data-ttu-id="c0a0d-711">El ejemplo se define la `MarshallableExample` (clase), que se puede calcular referencias entre los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-711">The example defines the `MarshallableExample` class, which can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="c0a0d-712">En el ejemplo se crea una ruta de acceso al ensamblado actualmente en ejecución, crea un dominio de aplicación de destino y utiliza el <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> sobrecarga del método para cargar el ensamblado de ejemplo en el dominio de aplicación de destino y crear una instancia de `MarshallableExample`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-712">The example builds a path to the currently executing assembly, creates a target application domain, and uses the <xref:System.AppDomain.CreateInstanceFrom%28System.String%2CSystem.String%29> method overload to load the example assembly into the target application domain and create an instance of `MarshallableExample`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-713">La ruta de acceso es absoluta en este ejemplo, sin embargo, una ruta de acceso relativa también funcionaría porque el <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> método se usa para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-713">The path is absolute in this example, but a relative path would also work because the <xref:System.Reflection.Assembly.LoadFrom%2A?displayProperty=nameWithType> method is used to load the assembly.</span></span>  
  
 <span data-ttu-id="c0a0d-714">Después de la acción de desencapsular el identificador del objeto, el ejemplo demuestra tres formas de usar un objeto en un dominio de aplicación de destino:</span><span class="sxs-lookup"><span data-stu-id="c0a0d-714">After unwrapping the object handle, the example demonstrates three ways to use an object in a target application domain:</span></span>  
  
-   <span data-ttu-id="c0a0d-715">Invocar un método con el enlace en tiempo de ejecución, mediante la reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-715">Invoking a method with late binding, using reflection.</span></span> <span data-ttu-id="c0a0d-716">Esto requiere información de tipo, lo que hace que el ensamblado se cargue en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-716">This requires type information, which causes the assembly to be loaded into the application domain of the caller.</span></span> <span data-ttu-id="c0a0d-717">(En este ejemplo, que ya esté cargado.)</span><span class="sxs-lookup"><span data-stu-id="c0a0d-717">(In this example, it is already loaded.)</span></span>  
  
-   <span data-ttu-id="c0a0d-718">Convierte el objeto en una interfaz conocida para el llamador y destinatario de la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-718">Casting the object to an interface known to both the caller and the callee.</span></span> <span data-ttu-id="c0a0d-719">Si la interfaz se define en el ensamblado de llamada o en un ensamblado terceros al que hace referencia el llamador y destinatario de la llamada, el ensamblado llamado no se carga en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-719">If the interface is defined in the calling assembly or in a third assembly referenced by both the caller and the callee, the called assembly is not loaded into the application domain of the caller.</span></span>  
  
-   <span data-ttu-id="c0a0d-720">Uso del objeto directamente cuando su tipo se conoce el llamador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-720">Using the object directly when its type is known to the caller.</span></span> <span data-ttu-id="c0a0d-721">El ensamblado deben cargarse en el dominio de aplicación del llamador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-721">The assembly must be loaded into the application domain of the caller.</span></span>  
  
 <span data-ttu-id="c0a0d-722">Es otra manera de evitar la carga del ensamblado llamado en el dominio de aplicación del llamador del llamador se derivan de la <xref:System.MarshalByRefObject> clase y definir un método que se puede ejecutar en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-722">Another way to avoid loading the called assembly into the application domain of the caller is for the caller to derive from the <xref:System.MarshalByRefObject> class and to define a method that can be run in the target application domain.</span></span> <span data-ttu-id="c0a0d-723">Ese método puede usar la reflexión para examinar un ensamblado de destino, porque el ensamblado de destino ya está cargado en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-723">That method can use reflection to examine a target assembly, because the target assembly is already loaded into the target application domain.</span></span> <span data-ttu-id="c0a0d-724">Vea el ejemplo de la <xref:System.AppDomain.DynamicDirectory%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-724">See the example for the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cpp/example.cpp#1)]
 [!code-csharp[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/cs/example.cs#1)]
 [!code-vb[System.AppDomain.CreateInstanceFrom_StringString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.createinstancefrom_stringstring/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-725">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-725"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-726">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-726">-or-</span></span> 
 <span data-ttu-id="c0a0d-727">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-727"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-728">No se encontró <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-728"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-729">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-729"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-730">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-730">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-731">No se ha encontrado ningún constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-731">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-732">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-732">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-733"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-733"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-734">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-734">-or-</span></span> 
<span data-ttu-id="c0a0d-735">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-735">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-736">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-736">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-737">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-737">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-738">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-738">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-739">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-739">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-740">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-740">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFrom (assemblyFile As String, typeName As String, activationAttributes As Object()) As ObjectHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-741">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-741">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="c0a0d-742">El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-742">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-743">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-743">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-744">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-744">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-745">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-745">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-746">Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-746">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-747">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-747">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-748">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-748">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-749">Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-749">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="c0a0d-750">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-750">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-751">El constructor predeterminado para `typeName` se invoca.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-751">The default constructor for `typeName` is invoked.</span></span>  
  
 <span data-ttu-id="c0a0d-752">Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-752">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c0a0d-753">Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-753">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="c0a0d-754">Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-754">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="c0a0d-755">Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-755">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="c0a0d-756">Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-756">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-757">Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-757">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-758">Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-758">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-759">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-759"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-760">No se encontró <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-760"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-761">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-761"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-762">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-762">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-763">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-763">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-764">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-764">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-765">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-765">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-766"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-766"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-767">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-767">-or-</span></span> 
<span data-ttu-id="c0a0d-768">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-768">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-769">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-769">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-770">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-770">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-771">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-771">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-772">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-772">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-773">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-773">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-774">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-774">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="c0a0d-775">El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-775">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-776">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-776">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-777">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-777">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-778">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-778">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-779">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-779">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-780">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-780">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="c0a0d-781">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-781">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-782">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-782">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-783">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-783">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-784">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-784">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-785">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-785">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-786">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-786">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-787">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-787">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-788">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-788">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-789">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-789">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-790">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-790">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-791">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-791">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-792">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-792">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-793">Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-793">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="c0a0d-794">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-794">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-795">Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-795">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c0a0d-796">Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-796">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="c0a0d-797">Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-797">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="c0a0d-798">Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-798">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="c0a0d-799">Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-799">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-800">Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-800">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-801">Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-801">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-802">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-802"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-803">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-803">-or-</span></span> 
 <span data-ttu-id="c0a0d-804">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-804"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-805">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-805">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-806">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-806">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-807">No se encontró <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-807"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-808">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-808"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-809">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-809">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-810">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-810">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-811"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-811"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-812">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-812">-or-</span></span> 
 <span data-ttu-id="c0a0d-813"><paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-813"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-814">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-814">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-815">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-815">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-816">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-816">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-817">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-817">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-818">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-818">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFrom">
      <MemberSignature Language="C#" Value="public System.Runtime.Remoting.ObjectHandle CreateInstanceFrom (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Remoting.ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Runtime::Remoting::ObjectHandle ^ CreateInstanceFrom(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="abstract member CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle&#xA;override this.CreateInstanceFrom : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; System.Runtime.Remoting.ObjectHandle" Usage="appDomain.CreateInstanceFrom (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.CreateInstanceFrom(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFrom which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Runtime.Remoting.ObjectHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-819">Nombre, incluida la ruta de acceso, de un archivo que contiene un ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-819">The name, including the path, of a file that contains an assembly that defines the requested type.</span></span> <span data-ttu-id="c0a0d-820">El ensamblado se carga mediante el método <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-820">The assembly is loaded using the <see cref="M:System.Reflection.Assembly.LoadFrom(System.String)" /> method.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-821">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-821">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-822">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-822">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-823">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-823">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-824">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-824">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-825">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-825">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="c0a0d-826">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-826">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-827">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-827">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-828">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-828">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-829">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-829">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-830">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-830">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-831">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-831">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-832">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-832">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-833">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-833">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-834">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-834">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-835">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-835">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-836">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-836">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="c0a0d-837">Información que se usa para autorizar la creación de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-837">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-838">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-838">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-839">Objeto contenedor de la nueva instancia o <see langword="null" />, si no se encuentra el parámetro <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-839">An object that is a wrapper for the new instance, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span> <span data-ttu-id="c0a0d-840">El valor devuelto debe desempaquetarse para obtener acceso al objeto real.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-840">The return value needs to be unwrapped to access the real object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-841">Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-841">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c0a0d-842">Cuando el <xref:System.AppDomain.CreateInstanceFrom%2A> método se utiliza para crear una instancia en un dominio de aplicación de destino que no sea el dominio de aplicación desde el que se realiza la llamada, el ensamblado se carga en el dominio de aplicación de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-842">When the <xref:System.AppDomain.CreateInstanceFrom%2A> method is used to create an instance in a target application domain, other than the application domain from which the call is made, the assembly is loaded in the target application domain.</span></span> <span data-ttu-id="c0a0d-843">Sin embargo, si la instancia está sin ajustar en el dominio de aplicación que realiza la llamada, utilizando la instancia sin ajustar en ciertos aspectos puede provocar que el ensamblado se carga en el dominio de aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-843">However, if the instance is unwrapped in the calling application domain, using the unwrapped instance in certain ways can cause the assembly to be loaded into the calling application domain.</span></span> <span data-ttu-id="c0a0d-844">Por ejemplo, una vez sin ajustar la instancia, se podría solicitar su información de tipo, para poder llamar a sus métodos en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-844">For example, after the instance is unwrapped, its type information might be requested, in order to call its methods late-bound.</span></span> <span data-ttu-id="c0a0d-845">Cuando el ensamblado se carga en el dominio de aplicación que realiza la llamada, se pueden producir excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-845">When the assembly is loaded into the calling application domain, exceptions can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-846">Si previamente se ha cargado otra versión del mismo ensamblado en el dominio de aplicación que realiza la llamada, o si la ruta de acceso de carga del dominio de aplicación que realiza la llamada es diferente del dominio de aplicación de destino, las excepciones, como <xref:System.MissingMethodException> pueden producirse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-846">If another version of the same assembly was previously loaded into the calling application domain, or if the load path of the calling application domain is different from that of the target application domain, exceptions such as <xref:System.MissingMethodException> can occur.</span></span>  
  
-   <span data-ttu-id="c0a0d-847">Si el dominio de aplicación que realiza la llamada realiza las llamadas enlazadas al tipo de instancia, <xref:System.InvalidCastException> se puede producir cuando se realiza un intento para convertir la instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-847">If the calling application domain makes early-bound calls to the instance type, <xref:System.InvalidCastException> can be thrown when an attempt is made to cast the instance.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-848">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-848"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-849">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-849">-or-</span></span> 
 <span data-ttu-id="c0a0d-850">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-850"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-851">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-851">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span>  
  
<span data-ttu-id="c0a0d-852">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-852">-or-</span></span> 
 <span data-ttu-id="c0a0d-853"><paramref name="securityAttributes" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-853"><paramref name="securityAttributes" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-854">Cuando no se habilita la directiva CAS heredada, <paramref name="securityAttributes" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-854">When legacy CAS policy is not enabled, <paramref name="securityAttributes" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-855">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-855">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-856">No se encontró <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-856"><paramref name="assemblyFile" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-857">No se encontró <paramref name="typeName" /> en <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-857"><paramref name="typeName" /> was not found in <paramref name="assemblyFile" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-858">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-858">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-859">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-859">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-860"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-860"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-861">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-861">-or-</span></span> 
<span data-ttu-id="c0a0d-862">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-862">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-863">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-863">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="c0a0d-864">La instancia es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-864">This instance is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-865">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-865">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-866">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-866">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-867">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-867">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-868">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-868">to provide evidence.</span></span> <span data-ttu-id="c0a0d-869">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-869">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CreateInstanceFromAndUnwrap">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-870">Crea una nueva instancia de un tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-870">Creates a new instance of a specified type defined in the specified assembly file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-871">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-871">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-872">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-872">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-873">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-873">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-874">Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-874">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-875">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-875">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c0a0d-876">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-876">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-877">Para obtener más información, vea el método <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-877">For more information, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-878">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-878"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-879">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-879">-or-</span></span> 
 <span data-ttu-id="c0a0d-880">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-880"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-881">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-881">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-882">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-882"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-883">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-883"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-884">No se ha encontrado ningún constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-884">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-885">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-885">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-886"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-886"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-887">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-887">-or-</span></span> 
<span data-ttu-id="c0a0d-888">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-888">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-889">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-889">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-890">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-890">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-891">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-891">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-892">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-892">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Function CreateInstanceFromAndUnwrap (assemblyName As String, typeName As String, activationAttributes As Object()) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-893">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-893">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-894">Nombre completo del tipo solicitado, incluido el espacio de nombres pero no el ensamblado (vea la propiedad <see cref="P:System.Type.FullName" />).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-894">The fully qualified name of the requested type, including the namespace but not the assembly (see the <see cref="P:System.Type.FullName" /> property).</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-895">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-895">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-896">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-896">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-897">Este parámetro está relacionado con los objetos activados por el cliente. La activación por parte del cliente es una tecnología heredada que se conserva para la compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-897">This parameter is related to client-activated objects.Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-898">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-898">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-899">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-899">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-900">Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-900">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-901">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-901">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="c0a0d-902">Este método llama al constructor predeterminado para `typeName`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-902">This method calls the default constructor for `typeName`.</span></span>  
  
 <span data-ttu-id="c0a0d-903">Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-903">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-904">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-904"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-905">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-905">-or-</span></span> 
 <span data-ttu-id="c0a0d-906">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-906"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-907">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-907">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-908">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-908">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-909">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-909"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-910">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-910"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-911">No se ha encontrado ningún constructor público sin parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-911">No parameterless public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-912">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-912">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-913"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-913"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-914">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-914">-or-</span></span> 
<span data-ttu-id="c0a0d-915">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-915">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-916">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-916">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-917">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-917">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-918">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-918">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-919">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-919">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyFile, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyFile, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyFile, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-920">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-920">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-921">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-921">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-922">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-922">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-923">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-923">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-924">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-924">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-925">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-925">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="c0a0d-926">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-926">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-927">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-927">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-928">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-928">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-929">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-929">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-930">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-930">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-931">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-931">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-932">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-932">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-933">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-933">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-934">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-934">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-935">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-935">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-936">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-936">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <summary><span data-ttu-id="c0a0d-937">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado indicado, especificando si se pasa por alto el modelo de mayúsculas y minúsculas del nombre de tipo, los atributos de enlace y el enlazador que se usan para seleccionar el tipo que se va a crear, los argumentos del constructor, la referencia cultural y los atributos de activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-937">Creates a new instance of the specified type defined in the specified assembly file, specifying whether the case of the type name is ignored; the binding attributes and the binder that are used to select the type to be created; the arguments of the constructor; the culture; and the activation attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-938">Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-938">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-939">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-939">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-940">Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-940">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-941">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-941"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-942">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-942">-or-</span></span> 
 <span data-ttu-id="c0a0d-943">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-943"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-944">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-944">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-945">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-945">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-946">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-946"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-947">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-947"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-948">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-948">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-949">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-949">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-950"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-950"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-951">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-951">-or-</span></span> 
 <span data-ttu-id="c0a0d-952"><paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-952"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime that the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-953">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-953">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-954">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-954">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-955">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-955">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-956">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-956">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceFromAndUnwrap">
      <MemberSignature Language="C#" Value="public object CreateInstanceFromAndUnwrap (string assemblyName, string typeName, bool ignoreCase, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, object[] args, System.Globalization.CultureInfo culture, object[] activationAttributes, System.Security.Policy.Evidence securityAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object CreateInstanceFromAndUnwrap(string assemblyName, string typeName, bool ignoreCase, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, object[] args, class System.Globalization.CultureInfo culture, object[] activationAttributes, class System.Security.Policy.Evidence securityAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.CreateInstanceFromAndUnwrap(System.String,System.String,System.Boolean,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object[],System.Globalization.CultureInfo,System.Object[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ CreateInstanceFromAndUnwrap(System::String ^ assemblyName, System::String ^ typeName, bool ignoreCase, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::Object ^&gt; ^ activationAttributes, System::Security::Policy::Evidence ^ securityAttributes);" />
      <MemberSignature Language="F#" Value="member this.CreateInstanceFromAndUnwrap : string * string * bool * System.Reflection.BindingFlags * System.Reflection.Binder * obj[] * System.Globalization.CultureInfo * obj[] * System.Security.Policy.Evidence -&gt; obj" Usage="appDomain.CreateInstanceFromAndUnwrap (assemblyName, typeName, ignoreCase, bindingAttr, binder, args, culture, activationAttributes, securityAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of CreateInstanceFromAndUnwrap which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="activationAttributes" Type="System.Object[]" />
        <Parameter Name="securityAttributes" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-957">Nombre de archivo y ruta de acceso del ensamblado que define el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-957">The file name and path of the assembly that defines the requested type.</span></span></param>
        <param name="typeName"><span data-ttu-id="c0a0d-958">Nombre completo del tipo solicitado, incluido el espacio de nombres, pero no el ensamblado, tal y como lo devuelve la propiedad <see cref="P:System.Type.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-958">The fully qualified name of the requested type, including the namespace but not the assembly, as returned by the <see cref="P:System.Type.FullName" /> property.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="c0a0d-959">Valor booleano que especifica si va a realizarse una búsqueda con distinción de mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-959">A Boolean value specifying whether to perform a case-sensitive search or not.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="c0a0d-960">Combinación de cero o más marcadores de bits que afectan a la búsqueda del constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-960">A combination of zero or more bit flags that affect the search for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-961">Si <paramref name="bindingAttr" /> es cero, se realiza una búsqueda de constructores públicos que distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-961">If <paramref name="bindingAttr" /> is zero, a case-sensitive search for public constructors is conducted.</span></span></param>
        <param name="binder"><span data-ttu-id="c0a0d-962">Objeto que permite el enlace, la conversión de tipos de argumentos, la llamada de miembros y la recuperación de objetos <see cref="T:System.Reflection.MemberInfo" /> mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-962">An object that enables the binding, coercion of argument types, invocation of members, and retrieval of <see cref="T:System.Reflection.MemberInfo" /> objects through reflection.</span></span> <span data-ttu-id="c0a0d-963">Si <paramref name="binder" /> es null, se usará el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-963">If <paramref name="binder" /> is null, the default binder is used.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-964">Argumentos que se van a pasar al constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-964">The arguments to pass to the constructor.</span></span> <span data-ttu-id="c0a0d-965">Esta matriz de argumentos debe coincidir en número, orden y tipo con los parámetros del constructor que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-965">This array of arguments must match in number, order, and type the parameters of the constructor to invoke.</span></span> <span data-ttu-id="c0a0d-966">Si se prefiere usar el constructor predeterminado, <paramref name="args" /> debe ser una matriz vacía o null.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-966">If the default constructor is preferred, <paramref name="args" /> must be an empty array or null.</span></span></param>
        <param name="culture"><span data-ttu-id="c0a0d-967">Información específica de la referencia cultural que controla la conversión de <paramref name="args" /> en los tipos formales declarados para el constructor de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-967">Culture-specific information that governs the coercion of <paramref name="args" /> to the formal types declared for the <paramref name="typeName" /> constructor.</span></span> <span data-ttu-id="c0a0d-968">Si <paramref name="culture" /> es <see langword="null" />, se usa <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-968">If <paramref name="culture" /> is <see langword="null" />, the <see cref="T:System.Globalization.CultureInfo" /> for the current thread is used.</span></span></param>
        <param name="activationAttributes"><span data-ttu-id="c0a0d-969">Matriz de uno o más atributos que puede participar en la activación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-969">An array of one or more attributes that can participate in activation.</span></span> <span data-ttu-id="c0a0d-970">Normalmente, una matriz que contiene un único objeto <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> que especifica la dirección URL necesaria para activar un objeto remoto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-970">Typically, an array that contains a single <see cref="T:System.Runtime.Remoting.Activation.UrlAttribute" /> object that specifies the URL that is required to activate a remote object.</span></span>  
  
<span data-ttu-id="c0a0d-971">Este parámetro está relacionado con los objetos activados por el cliente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-971">This parameter is related to client-activated objects.</span></span> <span data-ttu-id="c0a0d-972">La activación por parte del cliente es una tecnología heredada que se conserva por compatibilidad con versiones anteriores, pero no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-972">Client activation is a legacy technology that is retained for backward compatibility but is not recommended for new development.</span></span> <span data-ttu-id="c0a0d-973">Las aplicaciones distribuidas deberían usar Windows Communication Foundation.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-973">Distributed applications should instead use Windows Communication Foundation.</span></span></param>
        <param name="securityAttributes"><span data-ttu-id="c0a0d-974">Información que se usa para autorizar la creación de <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-974">Information used to authorize creation of <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-975">Crea una nueva instancia del tipo especificado definido en el archivo de ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-975">Creates a new instance of the specified type defined in the specified assembly file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-976">Objeto solicitado o <see langword="null" /> si no se encuentra <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-976">The requested object, or <see langword="null" /> if <paramref name="typeName" /> is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-977">Se trata de un método de conveniencia que combina <xref:System.AppDomain.CreateInstanceFrom%2A> y <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-977">This is a convenience method that combines <xref:System.AppDomain.CreateInstanceFrom%2A> and <xref:System.Runtime.Remoting.ObjectHandle.Unwrap%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-978">Para obtener más información acerca de este método, consulte el <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-978">For more information about this method, see the <xref:System.Activator.CreateInstanceFrom%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-979">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-979"><paramref name="assemblyName" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-980">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-980">-or-</span></span> 
 <span data-ttu-id="c0a0d-981">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-981"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-982">El llamador no puede ofrecer atributos de activación para un objeto que no hereda de <see cref="T:System.MarshalByRefObject" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-982">The caller cannot provide activation attributes for an object that does not inherit from <see cref="T:System.MarshalByRefObject" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-983">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-983">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-984">No se encontró <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-984"><paramref name="assemblyName" /> was not found.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="c0a0d-985">No se encontró <paramref name="typeName" /> en <paramref name="assemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-985"><paramref name="typeName" /> was not found in <paramref name="assemblyName" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-986">No se encontró ningún constructor público coincidente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-986">No matching public constructor was found.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="c0a0d-987">El autor de la llamada no tiene permiso suficiente para llamar a este constructor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-987">The caller does not have sufficient permission to call this constructor.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-988"><paramref name="assemblyName" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-988"><paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-989">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-989">-or-</span></span> 
<span data-ttu-id="c0a0d-990">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-990">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-991">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-991">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermissionAccess"><span data-ttu-id="c0a0d-992">para que poder leer el archivo que contiene el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-992">for the ability to read the file containing the assembly manifest.</span></span> <span data-ttu-id="c0a0d-993">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-993">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" /></span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-994">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-994">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
        <altmember cref="M:System.Activator.CreateInstanceFrom(System.String,System.String)" />
      </Docs>
    </Member>
    <Member MemberName="CurrentDomain">
      <MemberSignature Language="C#" Value="public static AppDomain CurrentDomain { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.AppDomain CurrentDomain" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.CurrentDomain" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property CurrentDomain As AppDomain" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property AppDomain ^ CurrentDomain { AppDomain ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.CurrentDomain : AppDomain" Usage="System.AppDomain.CurrentDomain" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomain</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-995">Obtiene el actual dominio de aplicación del actual <see cref="T:System.Threading.Thread" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-995">Gets the current application domain for the current <see cref="T:System.Threading.Thread" />.</span></span></summary>
        <value><span data-ttu-id="c0a0d-996">Dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-996">The current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c0a0d-997">En el ejemplo de código siguiente se crea un nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-997">The following code example creates a new application domain.</span></span> <span data-ttu-id="c0a0d-998">El <xref:System.AppDomain.CurrentDomain%2A> propiedad se utiliza para obtener un <xref:System.AppDomain> objeto que representa el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-998">The <xref:System.AppDomain.CurrentDomain%2A> property is used to obtain an <xref:System.AppDomain> object that represents the current application domain.</span></span> <span data-ttu-id="c0a0d-999">El <xref:System.AppDomain.FriendlyName%2A> proporciona el nombre de dominio de aplicación actual, que se muestra a continuación, en la línea de comandos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-999">The <xref:System.AppDomain.FriendlyName%2A> property provides the name of the current application domain, which is then displayed at the command line.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="DefineDynamicAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1000">Define un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1000">Defines a dynamic assembly in the current application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1001">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1001">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1002">Modo de acceso del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1002">The access mode for the dynamic assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1003">Define un ensamblado dinámico con el nombre y modo de acceso especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1003">Defines a dynamic assembly with the specified name and access mode.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1004">Un ensamblado dinámico con el nombre y modo de acceso especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1004">A dynamic assembly with the specified name and access mode.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1005">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1005">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1006">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1006">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1007">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1007">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1008">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1008">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1009">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1009">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1010">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1010">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1011">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1011">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1012">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1012">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1013">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1013"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1014">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1014">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1015">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1015">-or-</span></span> 
<span data-ttu-id="c0a0d-1016">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1016">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1017">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1017">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1018">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1018">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1019">Modo de acceso del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1019">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="c0a0d-1020">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1020">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1021">Define un ensamblado dinámico con el nombre especificado, el modo de acceso y los atributos personalizados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1021">Defines a dynamic assembly with the specified name, access mode, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1022">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1022">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1023">Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1023">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="c0a0d-1024">Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1024">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="c0a0d-1025">Este método debe usarse únicamente para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1025">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1026">Para obtener más información acerca de esta restricción, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1026">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 <span data-ttu-id="c0a0d-1027">Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1027">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1028">Ejemplo de código siguiente muestra cómo crear un ensamblado dinámico que tiene el <xref:System.Security.SecurityTransparentAttribute>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1028">The following code sample shows how to create a dynamic assembly that has the <xref:System.Security.SecurityTransparentAttribute>.</span></span> <span data-ttu-id="c0a0d-1029">El atributo debe especificarse como un elemento de una matriz de <xref:System.Reflection.Emit.CustomAttributeBuilder> objetos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1029">The attribute must be specified as an element of an array of <xref:System.Reflection.Emit.CustomAttributeBuilder> objects.</span></span>  
  
 <span data-ttu-id="c0a0d-1030">El primer paso para crear el <xref:System.Reflection.Emit.CustomAttributeBuilder> es obtener un constructor para el atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1030">The first step in creating the <xref:System.Reflection.Emit.CustomAttributeBuilder> is to obtain a constructor for the attribute.</span></span> <span data-ttu-id="c0a0d-1031">El constructor no tiene parámetros, por lo que la <xref:System.Type.GetConstructor%2A> se llama al método con una matriz vacía de <xref:System.Type> objetos que representan los tipos de los parámetros.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1031">The constructor has no parameters, so the <xref:System.Type.GetConstructor%2A> method is called with an empty array of <xref:System.Type> objects to represent the types of the parameters.</span></span> <span data-ttu-id="c0a0d-1032">El segundo paso consiste en pasar resultante <xref:System.Reflection.ConstructorInfo> objeto al constructor para la <xref:System.Reflection.Emit.CustomAttributeBuilder> (clase), junto con una matriz vacía de tipo <xref:System.Object> para representar los argumentos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1032">The second step is to pass the resulting <xref:System.Reflection.ConstructorInfo> object to the constructor for the <xref:System.Reflection.Emit.CustomAttributeBuilder> class, together with an empty array of type <xref:System.Object> to represent the arguments.</span></span>  
  
 <span data-ttu-id="c0a0d-1033">Resultante <xref:System.Reflection.Emit.CustomAttributeBuilder> , a continuación, se pasa a la <xref:System.AppDomain.DefineDynamicAssembly%2A> método como el único elemento de una matriz.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1033">The resulting <xref:System.Reflection.Emit.CustomAttributeBuilder> is then passed to the <xref:System.AppDomain.DefineDynamicAssembly%2A> method as the only element of an array.</span></span>  
  
 <span data-ttu-id="c0a0d-1034">El código de ejemplo define un módulo y un tipo en el nuevo ensamblado dinámico y, a continuación, muestra los atributos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1034">The example code defines a module and a type in the new dynamic assembly, and then displays the assembly's attributes.</span></span>  
  
 [!code-cpp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/cpp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cpp/source.cpp#1)]
 [!code-csharp[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/csharp/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/cs/source.cs#1)]
 [!code-vb[DefineDynamicAssemblyWithAttributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/DefineDynamicAssemblyWithAttributes/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1035">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1035"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1036">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1036">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1037">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1037">-or-</span></span> 
<span data-ttu-id="c0a0d-1038">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1038">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1039">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1039">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1040">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1040">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1041">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1041">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1042">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1042">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1043">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1043">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1044">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1044">Defines a dynamic assembly using the specified name, access mode, and evidence.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1045">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1045">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1046">Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1046">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1047">El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1047">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1048">Los llamadores deben suministrar un valor null de confianza parcial `evidence`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1048">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="c0a0d-1049">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1049">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1050">Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1050">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1051">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1051">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1052">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1052">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1053">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1053">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1054">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1054">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1055">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1055">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1056">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y el <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1056">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and the <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1057">En primer lugar, el ejemplo de código se intenta crear una instancia de `MyDynamicType` mediante una llamada a la <xref:System.AppDomain.CreateInstance%2A> método con un nombre de ensamblado no válido y detecta la excepción resultante.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1057">First, the code example tries to create an instance of `MyDynamicType` by calling the <xref:System.AppDomain.CreateInstance%2A> method with an invalid assembly name, and catches the resulting exception.</span></span>  
  
 <span data-ttu-id="c0a0d-1058">El ejemplo de código, a continuación, agrega un controlador de eventos para el <xref:System.AppDomain.AssemblyResolve> eventos y vuelva a intenta crear una instancia de`MyDynamicType`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1058">The code example then adds an event handler for the <xref:System.AppDomain.AssemblyResolve> event, and again tries to create an instance of`MyDynamicType`.</span></span> <span data-ttu-id="c0a0d-1059">Durante la llamada a <xref:System.AppDomain.CreateInstance%2A>, el <xref:System.AppDomain.AssemblyResolve> evento se desencadena para el ensamblado no válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1059">During the call to <xref:System.AppDomain.CreateInstance%2A>, the <xref:System.AppDomain.AssemblyResolve> event is raised for the invalid assembly.</span></span> <span data-ttu-id="c0a0d-1060">El controlador de eventos crea un ensamblado dinámico que contiene un tipo denominado `MyDynamicType`, proporciona el tipo de un constructor sin parámetros y devuelve el nuevo ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1060">The event handler creates a dynamic assembly that contains a type named `MyDynamicType`, gives the type a parameterless constructor, and returns the new dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1061">La llamada a <xref:System.AppDomain.CreateInstance%2A> , a continuación, finaliza correctamente y el constructor para `MyDynamicType` muestra un mensaje en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1061">The call to <xref:System.AppDomain.CreateInstance%2A> then finishes successfully, and the constructor for `MyDynamicType` displays a message at the console.</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1062">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1062"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1063">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1063">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1064">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1064">-or-</span></span> 
<span data-ttu-id="c0a0d-1065">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1065">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1066">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1066">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1067">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1067">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1068">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1068">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1069">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1069">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1070">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1070">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1071">Nombre del directorio donde se guardará el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1071">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1072">Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1072">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1073">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y el directorio de almacenamiento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1073">Defines a dynamic assembly using the specified name, access mode, and storage directory.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1074">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1074">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1075">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1075">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1076">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1076">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1077">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1077">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1078">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1078">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1079">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1079">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1080">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1080">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1081">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1081">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1082">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1082">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1083">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1083"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1084">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1084">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1085">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1085">-or-</span></span> 
<span data-ttu-id="c0a0d-1086">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1086">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1087">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1087">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, System.Security.SecurityContextSource securityContextSource);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes, valuetype System.Security.SecurityContextSource securityContextSource) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder},System.Security.SecurityContextSource)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes, System::Security::SecurityContextSource securityContextSource);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; * System.Security.SecurityContextSource -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, assemblyAttributes, securityContextSource)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
        <Parameter Name="securityContextSource" Type="System.Security.SecurityContextSource" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1088">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1088">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1089">Modo de acceso del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1089">The access mode for the dynamic assembly.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="c0a0d-1090">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1090">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <param name="securityContextSource"><span data-ttu-id="c0a0d-1091">Origen del contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1091">The source of the security context.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1092">Define un ensamblado dinámico con el nombre, el modo de acceso y los atributos personalizados especificados, y usando el origen indicado para su contexto de seguridad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1092">Defines a dynamic assembly with the specified name, access mode, and custom attributes, and using the specified source for its security context.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1093">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1093">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1094">Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1094">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="c0a0d-1095">Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1095">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="c0a0d-1096">Este método debe usarse únicamente para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1096">This method should be used only to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1097">Para obtener más información acerca de esta restricción, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1097">For more information about this restriction, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1098">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1098"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1099">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1099">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1100">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1100">-or-</span></span> 
<span data-ttu-id="c0a0d-1101">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1101">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1102">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1102">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c0a0d-1103">El valor de <paramref name="securityContextSource" /> no era ninguno de los valores de enumeración.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1103">The value of <paramref name="securityContextSource" /> was not one of the enumeration values.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of DefineDynamicAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1104">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1104">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1105">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1105">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1106">Nombre del directorio donde se guardará el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1106">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1107">Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1107">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1108">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1108">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1109">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1109">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1110">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento y la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1110">Defines a dynamic assembly using the specified name, access mode, storage directory, and evidence.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1111">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1111">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1112">Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1112">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1113">El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1113">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1114">Los llamadores deben suministrar un valor null de confianza parcial `evidence`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1114">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="c0a0d-1115">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1115">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1116">Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1116">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1117">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1117">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1118">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1118">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1119">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1119">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1120">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1120">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1121">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1121">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1122">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1122">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1123">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1123">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1124">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1124">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1125">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1125"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1126">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1126">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1127">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1127">-or-</span></span> 
<span data-ttu-id="c0a0d-1128">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1128">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1129">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1129">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1130">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1130">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1131">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1131">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1132">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1132">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1133">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1133">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1134">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1134">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1135">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1135">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1136">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1136">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1137">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso y las solicitudes de permiso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1137">Defines a dynamic assembly using the specified name, access mode, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1138">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1138">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1139">Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` no se usan a menos que el ensamblado dinámico se ha guardado y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1139">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="c0a0d-1140">Para especificar las solicitudes de permiso para un ensamblado transitorio que nunca se guarda en disco, use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia como solicitado así como los permisos y proporcionar un <xref:System.Security.Policy.Evidence> objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1140">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1141">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1141">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1142">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1142">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1143">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1143">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1144">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1144">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1145">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1145">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload .</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1146">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1146">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1147">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1147">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1148">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1148">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1149">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1149"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1150">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1150">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1151">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1151">-or-</span></span> 
<span data-ttu-id="c0a0d-1152">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1152">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1153">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1153">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, isSynchronized As Boolean, assemblyAttributes As IEnumerable(Of CustomAttributeBuilder)) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1154">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1154">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1155">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1155">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1156">Nombre del directorio donde se guardará el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1156">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1157">Si <paramref name="dir" /> es <see langword="null" />, se usa el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1157">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="c0a0d-1158"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1158"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="c0a0d-1159">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1159">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1160">Define un ensamblado dinámico usando el nombre, el modo de acceso, el directorio de almacenamiento y la opción de sincronización especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1160">Defines a dynamic assembly using the specified name, access mode, storage directory, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1161">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1161">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1162">Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1162">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="c0a0d-1163">Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1163">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="c0a0d-1164">Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1164">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="c0a0d-1165">Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1165">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1166">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1166"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1167">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1167">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1168">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1168">-or-</span></span> 
<span data-ttu-id="c0a0d-1169">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1169">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1170">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1170">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1171">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1171">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1172">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1172">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1173">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1173">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1174">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1174">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1175">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1175">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1176">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1176">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1177">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1177">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1178">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, la evidencia y las solicitudes de permiso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1178">Defines a dynamic assembly using the specified name, access mode, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1179">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1179">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1180">Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1180">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1181">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1181">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1182">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1182">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1183">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1183">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1184">Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1184">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1185">El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1185">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1186">Los llamadores deben suministrar un valor null de confianza parcial `evidence`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1186">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="c0a0d-1187">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1187">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1188">Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1188">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1189">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1189">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1190">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1190">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1191">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1191">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1192">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1192">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1193">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1193">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1194">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1194"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1195">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1195">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1196">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1196">-or-</span></span> 
<span data-ttu-id="c0a0d-1197">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1197">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1198">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1198">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1199">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1199">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1200">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1200">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="VB.NET" Value="Public Function DefineDynamicAssembly (name As AssemblyName, access As AssemblyBuilderAccess, dir As String, requiredPermissions As PermissionSet, optionalPermissions As PermissionSet, refusedPermissions As PermissionSet) As AssemblyBuilder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1201">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1201">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1202">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1202">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1203">Nombre del directorio donde se guardará el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1203">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1204">Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1204">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1205">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1205">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1206">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1206">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1207">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1207">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1208">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento y las solicitudes de permiso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1208">Defines a dynamic assembly using the specified name, access mode, storage directory, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1209">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1209">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1210">Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` no se usan a menos que el ensamblado dinámico se ha guardado y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1210">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are not used unless the dynamic assembly has been saved and reloaded into memory.</span></span> <span data-ttu-id="c0a0d-1211">Para especificar las solicitudes de permiso para un ensamblado transitorio que nunca se guarda en disco, use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia como solicitado así como los permisos y proporcionar un <xref:System.Security.Policy.Evidence> objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1211">To specify permission requests for a transient assembly that is never saved to disk, use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence as well as requested permissions, and supply an <xref:System.Security.Policy.Evidence> object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1212">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que use una sobrecarga de la <xref:System.AppDomain.DefineDynamicAssembly%2A> método que especifica la evidencia y permisos, proporcione la evidencia que desea que el ensamblado dinámico tiene e incluir <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1212">During the development of code that emits dynamic assemblies, it is recommended that you use an overload of the <xref:System.AppDomain.DefineDynamicAssembly%2A> method that specifies evidence and permissions, supply the evidence you want the dynamic assembly to have, and include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1213">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1213">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1214">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1214">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1215">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1215">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1216">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1216">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1217">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1217">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1218">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1218">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1219">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1219">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1220">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1220"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1221">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1221">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1222">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1222">-or-</span></span> 
<span data-ttu-id="c0a0d-1223">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1223">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1224">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1224">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default.  Please see http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1225">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1225">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1226">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1226">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1227">Nombre del directorio donde se guardará el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1227">The name of the directory where the assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1228">Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1228">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1229">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1229">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1230">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1230">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1231">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1231">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1232">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1232">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1233">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1233">The refused permissions request.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1234">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia y las solicitudes de permiso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1234">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, and permission requests.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1235">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1235">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1236">Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1236">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1237">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1237">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1238">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1238">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1239">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1239">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1240">Solo de plena confianza para los llamadores pueden suministrar sus `evidence` al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1240">Only fully trusted callers can supply their `evidence` when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1241">El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1241">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1242">Los llamadores deben suministrar un valor null de confianza parcial `evidence`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1242">Partially trusted callers must supply a null `evidence`.</span></span> <span data-ttu-id="c0a0d-1243">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1243">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1244">Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1244">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1245">Este método solo debe usarse para definir un ensamblado dinámico en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1245">This method should only be used to define a dynamic assembly in the current application domain.</span></span> <span data-ttu-id="c0a0d-1246">Para obtener más información, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1246">For more information, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1247">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1247">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1248">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1248">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1249">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1249">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1250">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1250"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1251">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1251">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1252">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1252">-or-</span></span> 
<span data-ttu-id="c0a0d-1253">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1253">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1254">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1254">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1255">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1255">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1256">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1256">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized);" />
      <MemberSignature Language="F#" Value="abstract member DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder&#xA;override this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1257">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1257">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1258">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1258">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1259">Nombre del directorio donde se guardará el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1259">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1260">Si <paramref name="dir" /> es <see langword="null" />, el directorio predeterminado es el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1260">If <paramref name="dir" /> is <see langword="null" />, the directory defaults to the current directory.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1261">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1261">The evidence supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1262">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1262">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1263">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1263">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1264">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1264">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1265">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1265">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="c0a0d-1266"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1266"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1267">Define un ensamblado dinámico usando el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia, las solicitudes de permiso y la opción de sincronización.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1267">Defines a dynamic assembly using the specified name, access mode, storage directory, evidence, permission requests, and synchronization option.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1268">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1268">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1269">Las solicitudes de permisos especificadas para `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` sólo se utilizan si `evidence` también se proporciona, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1269">The permission requests specified for `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` are used only if `evidence` is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1270">Durante el desarrollo de código que emite ensamblados dinámicos, se recomienda que incluya <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> en `refusedPermissions`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1270">During the development of code that emits dynamic assemblies, it is recommended that you include <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> in `refusedPermissions`.</span></span> <span data-ttu-id="c0a0d-1271">Incluyendo <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> en el `refusedPermissions` parámetro garantiza que se debe comprobar el código MSIL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1271">Including <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification> in the `refusedPermissions` parameter ensures that the MSIL is verified.</span></span> <span data-ttu-id="c0a0d-1272">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se usa con el código que solicita plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1272">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1273">Solo los llamadores de plena confianza pueden suministrar su evidencia al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1273">Only fully trusted callers can supply their evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1274">El tiempo de ejecución se asignará el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1274">The runtime will map the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1275">Deben proporcionar los llamadores de confianza parcial `null` para el `evidence` parámetro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1275">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="c0a0d-1276">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos, es decir, actual otorgar y denegar los conjuntos, desde el llamador <xref:System.Reflection.Assembly> a dinámico <xref:System.Reflection.Assembly> que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1276">If `evidence` is `null`, the runtime copies the permission sets, that is, the current grant and deny sets, from the caller's <xref:System.Reflection.Assembly> to the dynamic <xref:System.Reflection.Assembly> being defined and marks policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1277">Si el dinámico <xref:System.Reflection.Assembly> está guardado en el disco, carga posteriores obtendrán las concesiones en función de las directivas asociadas a la ubicación donde el <xref:System.Reflection.Assembly> se guardó.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1277">If the dynamic <xref:System.Reflection.Assembly> is saved to disk, subsequent loads will get grants based on policies associated with the location where the <xref:System.Reflection.Assembly> was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1278">Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1278">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="c0a0d-1279">Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1279">If two of these methods are called on different threads, one will block until the other completes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1280">El ejemplo siguiente se muestra el <xref:System.AppDomain.DefineDynamicAssembly%2A> método y <xref:System.AppDomain.AssemblyResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1280">The following sample demonstrates the <xref:System.AppDomain.DefineDynamicAssembly%2A> method and <xref:System.AppDomain.AssemblyResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-1281">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1281">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1282">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1282">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CPP/definedynamicassembly.cpp#1)]
 [!code-csharp[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/CS/definedynamicassembly.cs#1)]
 [!code-vb[AppDomain_DefineDynamicAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DefineDynamicAssembly/VB/definedynamicassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1283">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1283"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1284">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1284">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1285">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1285">-or-</span></span> 
<span data-ttu-id="c0a0d-1286">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1286">The <see langword="Name" /> property of <paramref name="name" /> begins with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1287">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1287">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1288">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1288">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1289">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1289">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DefineDynamicAssembly">
      <MemberSignature Language="C#" Value="public System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly (System.Reflection.AssemblyName name, System.Reflection.Emit.AssemblyBuilderAccess access, string dir, System.Security.Policy.Evidence evidence, System.Security.PermissionSet requiredPermissions, System.Security.PermissionSet optionalPermissions, System.Security.PermissionSet refusedPermissions, bool isSynchronized, System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Emit.AssemblyBuilder DefineDynamicAssembly(class System.Reflection.AssemblyName name, valuetype System.Reflection.Emit.AssemblyBuilderAccess access, string dir, class System.Security.Policy.Evidence evidence, class System.Security.PermissionSet requiredPermissions, class System.Security.PermissionSet optionalPermissions, class System.Security.PermissionSet refusedPermissions, bool isSynchronized, class System.Collections.Generic.IEnumerable`1&lt;class System.Reflection.Emit.CustomAttributeBuilder&gt; assemblyAttributes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DefineDynamicAssembly(System.Reflection.AssemblyName,System.Reflection.Emit.AssemblyBuilderAccess,System.String,System.Security.Policy.Evidence,System.Security.PermissionSet,System.Security.PermissionSet,System.Security.PermissionSet,System.Boolean,System.Collections.Generic.IEnumerable{System.Reflection.Emit.CustomAttributeBuilder})" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::Emit::AssemblyBuilder ^ DefineDynamicAssembly(System::Reflection::AssemblyName ^ name, System::Reflection::Emit::AssemblyBuilderAccess access, System::String ^ dir, System::Security::Policy::Evidence ^ evidence, System::Security::PermissionSet ^ requiredPermissions, System::Security::PermissionSet ^ optionalPermissions, System::Security::PermissionSet ^ refusedPermissions, bool isSynchronized, System::Collections::Generic::IEnumerable&lt;System::Reflection::Emit::CustomAttributeBuilder ^&gt; ^ assemblyAttributes);" />
      <MemberSignature Language="F#" Value="member this.DefineDynamicAssembly : System.Reflection.AssemblyName * System.Reflection.Emit.AssemblyBuilderAccess * string * System.Security.Policy.Evidence * System.Security.PermissionSet * System.Security.PermissionSet * System.Security.PermissionSet * bool * seq&lt;System.Reflection.Emit.CustomAttributeBuilder&gt; -&gt; System.Reflection.Emit.AssemblyBuilder" Usage="appDomain.DefineDynamicAssembly (name, access, dir, evidence, requiredPermissions, optionalPermissions, refusedPermissions, isSynchronized, assemblyAttributes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Declarative security for assembly level is no longer enforced")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Assembly level declarative security is obsolete and is no longer enforced by the CLR by default. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Emit.AssemblyBuilder</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.Reflection.AssemblyName" />
        <Parameter Name="access" Type="System.Reflection.Emit.AssemblyBuilderAccess" />
        <Parameter Name="dir" Type="System.String" />
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
        <Parameter Name="requiredPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="optionalPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="refusedPermissions" Type="System.Security.PermissionSet" />
        <Parameter Name="isSynchronized" Type="System.Boolean" />
        <Parameter Name="assemblyAttributes" Type="System.Collections.Generic.IEnumerable&lt;System.Reflection.Emit.CustomAttributeBuilder&gt;" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1290">Identidad única del ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1290">The unique identity of the dynamic assembly.</span></span></param>
        <param name="access"><span data-ttu-id="c0a0d-1291">Modo de acceso al ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1291">The mode in which the dynamic assembly will be accessed.</span></span></param>
        <param name="dir"><span data-ttu-id="c0a0d-1292">Nombre del directorio donde se guardará el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1292">The name of the directory where the dynamic assembly will be saved.</span></span> <span data-ttu-id="c0a0d-1293">Si <paramref name="dir" /> es <see langword="null" />, se usa el directorio actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1293">If <paramref name="dir" /> is <see langword="null" />, the current directory is used.</span></span></param>
        <param name="evidence"><span data-ttu-id="c0a0d-1294">Evidencia suministrada para el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1294">The evidence that is supplied for the dynamic assembly.</span></span> <span data-ttu-id="c0a0d-1295">La evidencia se usa sin modificaciones como conjunto final de evidencia para la resolución de directivas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1295">The evidence is used unaltered as the final set of evidence used for policy resolution.</span></span></param>
        <param name="requiredPermissions"><span data-ttu-id="c0a0d-1296">Solicitud de permisos requeridos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1296">The required permissions request.</span></span></param>
        <param name="optionalPermissions"><span data-ttu-id="c0a0d-1297">Solicitud de permisos opcionales.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1297">The optional permissions request.</span></span></param>
        <param name="refusedPermissions"><span data-ttu-id="c0a0d-1298">Solicitud de permisos rechazados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1298">The refused permissions request.</span></span></param>
        <param name="isSynchronized"><span data-ttu-id="c0a0d-1299"><see langword="true" /> para sincronizar la creación de módulos, tipos y miembros en el ensamblado dinámico; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1299"><see langword="true" /> to synchronize the creation of modules, types, and members in the dynamic assembly; otherwise, <see langword="false" />.</span></span></param>
        <param name="assemblyAttributes"><span data-ttu-id="c0a0d-1300">Lista enumerable de atributos que se va a aplicarse al ensamblado o <see langword="null" /> si no hay ningún atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1300">An enumerable list of attributes to be applied to the assembly, or <see langword="null" /> if there are no attributes.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1301">Define un ensamblado dinámico con el nombre especificado, el modo de acceso, el directorio de almacenamiento, la evidencia, las solicitudes de permiso, la opción de sincronización y los atributos personalizados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1301">Defines a dynamic assembly with the specified name, access mode, storage directory, evidence, permission requests, synchronization option, and custom attributes.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1302">Ensamblado dinámico con el nombre y las características especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1302">A dynamic assembly with the specified name and features.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1303">Utilice esta sobrecarga del método para especificar atributos que no funcionan correctamente a menos que se aplican cuando se crea un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1303">Use this method overload to specify attributes that do not work correctly unless they are applied when a dynamic assembly is created.</span></span> <span data-ttu-id="c0a0d-1304">Por ejemplo, atributos, como seguridad <xref:System.Security.SecurityTransparentAttribute> y <xref:System.Security.SecurityCriticalAttribute> no funcionan correctamente si se agregan una vez creado un ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1304">For example, security attributes such as <xref:System.Security.SecurityTransparentAttribute> and <xref:System.Security.SecurityCriticalAttribute> do not work correctly if they are added after a dynamic assembly has been created.</span></span>  
  
 <span data-ttu-id="c0a0d-1305">Las solicitudes de permisos especificadas para el `requiredPermissions`, `optionalPermissions`, y `refusedPermissions` parámetros se usan solo si el `evidence` también se proporciona el parámetro, o si el ensamblado dinámico se guarda y vuelve a cargar en memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1305">The permission requests specified for the `requiredPermissions`, `optionalPermissions`, and `refusedPermissions` parameters are used only if the `evidence` parameter is also supplied, or if the dynamic assembly is saved and reloaded into memory.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1306">Al desarrollar código que emite ensamblados dinámicos, se recomienda que incluya el <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> marca en el `refusedPermissions` parámetro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1306">When you develop code that emits dynamic assemblies, we recommend that you include the <xref:System.Security.Permissions.SecurityPermissionFlag.SkipVerification?displayProperty=nameWithType> flag in the `refusedPermissions` parameter.</span></span> <span data-ttu-id="c0a0d-1307">La inclusión de esta marca garantiza que se comprobará el lenguaje intermedio (MSIL) de Microsoft.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1307">The inclusion of this flag ensures that the Microsoft intermediate language (MSIL) will be verified.</span></span> <span data-ttu-id="c0a0d-1308">Esta técnica detectará la generación de código no comprobable, que en caso contrario, es muy difícil detectar involuntaria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1308">This technique will detect the unintentional generation of unverifiable code, which otherwise is very difficult to detect.</span></span> <span data-ttu-id="c0a0d-1309">Una limitación de esta técnica es que también hace que <xref:System.Security.SecurityException> se produce cuando se utiliza con código que requiere plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1309">A limitation of this technique is that it also causes <xref:System.Security.SecurityException> to be thrown when it is used with code that demands full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1310">Solo los llamadores de plena confianza pueden suministrar la evidencia al definir un dinámico <xref:System.Reflection.Assembly>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1310">Only fully trusted callers can supply evidence when defining a dynamic <xref:System.Reflection.Assembly>.</span></span> <span data-ttu-id="c0a0d-1311">El tiempo de ejecución asigna el <xref:System.Security.Policy.Evidence> a través de la directiva de seguridad para determinar los permisos concedidos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1311">The runtime maps the <xref:System.Security.Policy.Evidence> through the security policy to determine the granted permissions.</span></span> <span data-ttu-id="c0a0d-1312">Deben proporcionar los llamadores de confianza parcial `null` para el `evidence` parámetro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1312">Partially trusted callers must supply `null` for the `evidence` parameter.</span></span> <span data-ttu-id="c0a0d-1313">Si `evidence` es `null`, el tiempo de ejecución copia los conjuntos de permisos (es decir, la concesión actual y denegar conjuntos) desde el ensamblado del llamador en el ensamblado dinámico que se está definiendo y marca la directiva como resuelta.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1313">If `evidence` is `null`, the runtime copies the permission sets (that is, the current grant and deny sets) from the caller's assembly to the dynamic assembly that is being defined, and marks the policy as resolved.</span></span>  
  
 <span data-ttu-id="c0a0d-1314">Si el ensamblado dinámico se guarda en disco, posteriores cargas obtendrán las concesiones en función de las directivas que están asociadas con la ubicación donde guardó el ensamblado dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1314">If the dynamic assembly is saved to disk, subsequent loads will get grants based on policies that are associated with the location where the dynamic assembly was saved.</span></span>  
  
 <span data-ttu-id="c0a0d-1315">Si `isSynchronized` es `true`, los métodos siguientes de resultante <xref:System.Reflection.Emit.AssemblyBuilder> se sincronizarán: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, y <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1315">If `isSynchronized` is `true`, the following methods of the resulting <xref:System.Reflection.Emit.AssemblyBuilder> will be synchronized: <xref:System.Reflection.Emit.AssemblyBuilder.DefineDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.DefineResource%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.AddResourceFile%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.GetDynamicModule%2A>, <xref:System.Reflection.Emit.AssemblyBuilder.SetEntryPoint%2A>, and <xref:System.Reflection.Emit.AssemblyBuilder.Save%2A>.</span></span> <span data-ttu-id="c0a0d-1316">Si dos de estos métodos se llaman en subprocesos diferentes, uno se bloqueará hasta que se complete la otra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1316">If two of these methods are called on different threads, one will block until the other is completed.</span></span>  
  
 <span data-ttu-id="c0a0d-1317">Esta sobrecarga del método se introdujo en la [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1317">This method overload is introduced in the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)].</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1318">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1318"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-1319">La propiedad <see langword="Name" /> de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1319">The <see langword="Name" /> property of <paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="c0a0d-1320">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1320">-or-</span></span> 
<span data-ttu-id="c0a0d-1321">La propiedad <see langword="Name" /> de <paramref name="name" /> empieza con un espacio en blanco o contiene una barra diagonal o una barra diagonal inversa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1321">The <see langword="Name" /> property of <paramref name="name" /> starts with white space, or contains a forward or backward slash.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1322">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1322">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1323">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1323">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1324">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1324">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <altmember cref="M:System.Reflection.Emit.AssemblyBuilder.SetCustomAttribute(System.Reflection.Emit.CustomAttributeBuilder)" />
      </Docs>
    </Member>
    <Member MemberName="DoCallBack">
      <MemberSignature Language="C#" Value="public void DoCallBack (CrossAppDomainDelegate callBackDelegate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void DoCallBack(class System.CrossAppDomainDelegate callBackDelegate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.DoCallBack(System.CrossAppDomainDelegate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DoCallBack (callBackDelegate As CrossAppDomainDelegate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void DoCallBack(CrossAppDomainDelegate ^ callBackDelegate);" />
      <MemberSignature Language="F#" Value="abstract member DoCallBack : CrossAppDomainDelegate -&gt; unit&#xA;override this.DoCallBack : CrossAppDomainDelegate -&gt; unit" Usage="appDomain.DoCallBack callBackDelegate" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.DoCallBack(System.CrossAppDomainDelegate)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callBackDelegate" Type="System.CrossAppDomainDelegate" />
      </Parameters>
      <Docs>
        <param name="callBackDelegate"><span data-ttu-id="c0a0d-1325">Delegado que especifica un método al que se va a llamar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1325">A delegate that specifies a method to call.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1326">Ejecuta el código en otro dominio de aplicación identificado por el delegado especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1326">Executes the code in another application domain that is identified by the specified delegate.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1327">`callBackDelegate` puede especificar un cálculo de referencias por valor, <xref:System.MarshalByRefObject>, o <xref:System.ContextBoundObject>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1327">`callBackDelegate` can specify a marshal-by-value, <xref:System.MarshalByRefObject>, or <xref:System.ContextBoundObject>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1328">El ejemplo siguiente muestra cómo utilizar una variable static <xref:System.AppDomain.DoCallBack%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1328">The following sample demonstrates using a static <xref:System.AppDomain.DoCallBack%2A> method.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_static.cpp#1)]
 [!code-csharp[AppDomain_DoCallBack#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_static.cs#1)]
 [!code-vb[AppDomain_DoCallBack#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_static.vb#1)]  
  
 <span data-ttu-id="c0a0d-1329">El ejemplo siguiente muestra cómo utilizar el <xref:System.AppDomain.DoCallBack%2A> método por valor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1329">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by value.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#2](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byval.cpp#2)]
 [!code-csharp[AppDomain_DoCallBack#2](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byval.cs#2)]
 [!code-vb[AppDomain_DoCallBack#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byval.vb#2)]  
  
 <span data-ttu-id="c0a0d-1330">El ejemplo siguiente muestra cómo utilizar el <xref:System.AppDomain.DoCallBack%2A> método por referencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1330">The following sample demonstrates using the <xref:System.AppDomain.DoCallBack%2A> method by reference.</span></span>  
  
 [!code-cpp[AppDomain_DoCallBack#3](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_DoCallBack/CPP/docallback_byref.cpp#3)]
 [!code-csharp[AppDomain_DoCallBack#3](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_DoCallBack/CS/docallback_byref.cs#3)]
 [!code-vb[AppDomain_DoCallBack#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_DoCallBack/VB/docallback_byref.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1331">El valor de <paramref name="callBackDelegate" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1331"><paramref name="callBackDelegate" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DomainManager">
      <MemberSignature Language="C#" Value="public AppDomainManager DomainManager { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainManager DomainManager" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DomainManager" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DomainManager As AppDomainManager" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainManager ^ DomainManager { AppDomainManager ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DomainManager : AppDomainManager" Usage="System.AppDomain.DomainManager" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.AppDomainManager</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1332">Obtiene el administrador de dominio que ha proporcionado el host al inicializar el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1332">Gets the domain manager that was provided by the host when the application domain was initialized.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1333">Objeto que representa el administrador de dominio que proporcionó el host al inicializar el dominio de aplicación, o <see langword="null" /> si no se proporcionó un administrador de dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1333">An object that represents the domain manager provided by the host when the application domain was initialized, or <see langword="null" /> if no domain manager was provided.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1334">Un host no administrado de common language runtime (CLR) puede proporcionar un administrador de dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1334">An unmanaged host of the common language runtime (CLR) can provide a domain manager.</span></span> <span data-ttu-id="c0a0d-1335">El Administrador de dominio puede participar en la inicialización del nuevo dominio de aplicación y proporcionar otros administradores, como un <xref:System.Security.HostSecurityManager>, que participen en las operaciones del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1335">The domain manager can participate in initializing the new application domain and supply other managers, such as a <xref:System.Security.HostSecurityManager>, that participate in the operations of the application domain.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-1336">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1336">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-1337">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1337">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="DomainUnload">
      <MemberSignature Language="C#" Value="public event EventHandler DomainUnload;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler DomainUnload" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.DomainUnload" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event DomainUnload As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ DomainUnload;" />
      <MemberSignature Language="F#" Value="member this.DomainUnload : EventHandler " Usage="member this.DomainUnload : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.DomainUnload</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1338">Se produce cuando un <see cref="T:System.AppDomain" /> está a punto de descargarse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1338">Occurs when an <see cref="T:System.AppDomain" /> is about to be unloaded.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1339">El <xref:System.EventHandler> delegado para este evento puede realizar cualquier actividad de finalización antes de que se descarga el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1339">The <xref:System.EventHandler> delegate for this event can perform any termination activities before the application domain is unloaded.</span></span>  
  
 <span data-ttu-id="c0a0d-1340">Cada dominio de aplicación que necesita para realizar el procesamiento cuando se descargue debe registrar un controlador de eventos para este evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1340">Each application domain that needs to perform processing when it is unloaded should register an event handler for this event.</span></span> <span data-ttu-id="c0a0d-1341">Un controlador de eventos compartidos no se debe usar, porque el <xref:System.EventHandler> delegado no identifica el dominio al que se está descargando.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1341">A shared event handler should not be used, because the <xref:System.EventHandler> delegate does not identify the domain that is being unloaded.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1342">Nunca se genera este evento en el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1342">This event is never raised in the default application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1343">No haga suposiciones sobre el subproceso que se genera el evento en.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1343">Do not make assumptions about the thread the event is raised on.</span></span> <span data-ttu-id="c0a0d-1344">El evento puede generarse en un subproceso distinto al que llama el <xref:System.AppDomain.Unload%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1344">The event can be raised on a different thread than the one that called the <xref:System.AppDomain.Unload%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1345">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1345">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DynamicDirectory">
      <MemberSignature Language="C#" Value="public string DynamicDirectory { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string DynamicDirectory" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.DynamicDirectory" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property DynamicDirectory As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ DynamicDirectory { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DynamicDirectory : string" Usage="System.AppDomain.DynamicDirectory" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.DynamicDirectory</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1346">Obtiene el directorio que la resolución de ensamblado usa para buscar ensamblados creados de forma dinámica.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1346">Gets the directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1347">Directorio que la resolución de ensamblado usa para buscar ensamblados creados de forma dinámica.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1347">The directory that the assembly resolver uses to probe for dynamically created assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1348">Para establecer el directorio dinámico, asigne una ruta de acceso del directorio base para el <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad de la <xref:System.AppDomainSetup> objeto que se usará para crear el nuevo dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1348">To set the dynamic directory, assign a base directory path to the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property of the <xref:System.AppDomainSetup> object that will be used to create the new application domain.</span></span> <span data-ttu-id="c0a0d-1349">La ruta de acceso del directorio base asigne a la propiedad se modifica mediante la adición de un subdirectorio cuyo nombre simple es el código hash de la cadena que asigne a la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propiedad, por lo que es el formato del directorio base *ruta de acceso original* \\ *código hash*.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1349">The base directory path you assign to the property is modified by the addition of a subdirectory whose simple name is the hash code of the string you assign to the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so the format of the base directory is *original path*\\*hash code*.</span></span> <span data-ttu-id="c0a0d-1350">El directorio dinámico es un subdirectorio del directorio base.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1350">The dynamic directory is a subdirectory of this base directory.</span></span> <span data-ttu-id="c0a0d-1351">Su nombre simple es el valor de la <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> propiedad, por lo que su formato es *ruta de acceso original*\\*código hash*\\*nombre de la aplicación*.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1351">Its simple name is the value of the <xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType> property, so its format is *original path*\\*hash code*\\*application name*.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1352">El ejemplo siguiente crea un dominio de aplicación con un directorio para los ensamblados dinámicos, emite un ensamblado dinámico y lo almacena en el directorio dinámico y, a continuación, carga el ensamblado en el nuevo dominio de aplicación y lo usa.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1352">The following example creates an application domain with a directory for dynamic assemblies, emits a dynamic assembly and stores it in the dynamic directory, and then loads the assembly into the new application domain and uses it.</span></span>  
  
 <span data-ttu-id="c0a0d-1353">El ejemplo se crea un <xref:System.AppDomainSetup> objeto y establece su <xref:System.AppDomainSetup.ApplicationName%2A> propiedad en "Ejemplo" y su <xref:System.AppDomainSetup.DynamicBase%2A> propiedad en "C:\DynamicAssemblyDir".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1353">The example creates an <xref:System.AppDomainSetup> object and sets its <xref:System.AppDomainSetup.ApplicationName%2A> property to "Example" and its <xref:System.AppDomainSetup.DynamicBase%2A> property to "C:\DynamicAssemblyDir".</span></span> <span data-ttu-id="c0a0d-1354">El ejemplo se muestra a continuación, el <xref:System.AppDomainSetup.DynamicBase%2A> propiedad para mostrar que el código hash del nombre de la aplicación se ha anexado como un subdirectorio de la ruta de acceso que se asignó originalmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1354">The example then displays the <xref:System.AppDomainSetup.DynamicBase%2A> property, to show that the hash code of the application name has been appended as a subdirectory of the path that was originally assigned.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1355">El directorio base en este ejemplo está pensado para estar fuera de la ruta de acceso de sondeo para la aplicación de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1355">The base directory in this example is intended to be outside the probing path for the example application.</span></span> <span data-ttu-id="c0a0d-1356">Asegúrese de compilar el ejemplo en una ubicación diferente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1356">Be sure to compile the example in a different location.</span></span> <span data-ttu-id="c0a0d-1357">Eliminar el directorio base y todos sus subdirectorios cada vez que ejecute el ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1357">Delete the base directory and all its subdirectories each time you run the example.</span></span>  
  
 <span data-ttu-id="c0a0d-1358">El ejemplo crea un nuevo dominio de aplicación, utilizando el <xref:System.AppDomainSetup> objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1358">The example creates a new application domain, using the <xref:System.AppDomainSetup> object.</span></span> <span data-ttu-id="c0a0d-1359">El ejemplo se usa el <xref:System.AppDomain.DynamicDirectory%2A> propiedad que se va a recuperar el nombre del directorio, por lo que puede crear el directorio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1359">The example uses the <xref:System.AppDomain.DynamicDirectory%2A> property to retrieve the name of the directory, so it can create the directory.</span></span> <span data-ttu-id="c0a0d-1360">(En el ejemplo se podría crear fácilmente el directorio con antelación mediante la concatenación de la ruta de acceso original, el código hash del nombre de la aplicación y el nombre de la aplicación.)</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1360">(The example could just as easily create the directory beforehand by concatenating the original path, the hash code of the application name, and the application name.)</span></span>  
  
 <span data-ttu-id="c0a0d-1361">El ejemplo tiene un `GenerateDynamicAssembly` método que emite un ensamblado denominado `DynamicHelloWorld.dll` y lo almacena en el directorio dinámico del dominio de aplicación nuevo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1361">The example has a `GenerateDynamicAssembly` method that emits an assembly named `DynamicHelloWorld.dll` and stores it in the new application domain's dynamic directory.</span></span> <span data-ttu-id="c0a0d-1362">El ensamblado dinámico contiene un solo tipo, `HelloWorld`, que tiene un método estático (`Shared` método en Visual Basic) denominada `HelloFromAD`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1362">The dynamic assembly contains one type, `HelloWorld`, that has a static method (`Shared` method in Visual Basic) named `HelloFromAD`.</span></span> <span data-ttu-id="c0a0d-1363">Llamar a este método muestra el nombre del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1363">Calling this method displays the name of the application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1364">El `Example` clase se deriva de <xref:System.MarshalByRefObject>, por lo que en el ejemplo se puede crear una instancia de la clase en el nuevo dominio de aplicación y llamar a su `Test` método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1364">The `Example` class derives from <xref:System.MarshalByRefObject>, so the example can create an instance of the class in the new application domain and call its `Test` method.</span></span> <span data-ttu-id="c0a0d-1365">El `Test` método carga el ensamblado dinámico por su nombre para mostrar y llama a estático `HelloFromAD` método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1365">The `Test` method loads the dynamic assembly by its display name and calls the static `HelloFromAD` method.</span></span>  
  
 <span data-ttu-id="c0a0d-1366">Puede mostrar que se busca en el directorio dinámico después de las rutas de acceso de sondeo normales al escribir código para un ensamblado denominado `DynamicHelloWorld.dll` y compilarlo en el mismo directorio que este ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1366">You can show that the dynamic directory is searched after the normal probing paths by writing code for an assembly named `DynamicHelloWorld.dll` and compiling it in the same directory as this example.</span></span> <span data-ttu-id="c0a0d-1367">El ensamblado debe tener una clase denominada `HelloWorld` con un método estático denominado `HelloFromAD`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1367">The assembly must have a class named `HelloWorld` with a static method named `HelloFromAD`.</span></span> <span data-ttu-id="c0a0d-1368">Este método no tiene que tienen la misma funcionalidad que aparece en el ejemplo; simplemente puede mostrar una cadena en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1368">This method does not have to have the same functionality as the one in the example; it can simply display a string to the console.</span></span> <span data-ttu-id="c0a0d-1369">El ensamblado debe tener también un <xref:System.Reflection.AssemblyVersionAttribute> atributo que se establece su versión a 1.0.0.0.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1369">The assembly must also have an <xref:System.Reflection.AssemblyVersionAttribute> attribute that sets its version to 1.0.0.0.</span></span> <span data-ttu-id="c0a0d-1370">Al ejecutar el ejemplo, se encuentra el ensamblado que se ha compilado en el directorio actual antes de que se busca en el directorio dinámico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1370">When you run the example, the assembly you compiled in the current directory is found before the dynamic directory is searched.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1371">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1371">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1372">Para obtener acceso a la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1372">for access to the path information.</span></span> <span data-ttu-id="c0a0d-1373">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1373">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Evidence">
      <MemberSignature Language="C#" Value="public System.Security.Policy.Evidence Evidence { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.Policy.Evidence Evidence" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Evidence" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Evidence As Evidence" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::Policy::Evidence ^ Evidence { System::Security::Policy::Evidence ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Evidence : System.Security.Policy.Evidence" Usage="System.AppDomain.Evidence" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Security.IEvidenceFactory.Evidence</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.Policy.Evidence</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1374">Obtiene el objeto <see cref="T:System.Security.Policy.Evidence" /> asociado a este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1374">Gets the <see cref="T:System.Security.Policy.Evidence" /> associated with this application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1375">Evidencia asociada a este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1375">The evidence associated with this application domain.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1376">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1376">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1377">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1377">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1378">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1378">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="c0a0d-1379">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1379">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssembly">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1380">Ejecuta el ensamblado que contiene el archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1380">Executes the assembly contained in the specified file.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string -&gt; int&#xA;override this.ExecuteAssembly : string -&gt; int" Usage="appDomain.ExecuteAssembly assemblyFile" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1381">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1381">The name of the file that contains the assembly to execute.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1382">Ejecuta el ensamblado que contiene el archivo especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1382">Executes the assembly contained in the specified file.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1383">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1383">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1384">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1384">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1385">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1385">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1386">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1386">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1387">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1387">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1388">Para crear el <xref:System.AppDomain> para cargar y ejecutar, utilice el <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1388">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1389">El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1389">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1390">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1390"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1391">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1391"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1392"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1392"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1393">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1393">-or-</span></span> 
<span data-ttu-id="c0a0d-1394">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1394">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1395">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1395">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1396">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1396">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1397">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1397">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1398">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1398">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1399">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1399">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1400">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1400">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1401">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1401">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1402">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1402">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1403">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1403">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1404">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1404">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1405">Ejecuta el ensamblado que contiene el archivo especificado, usando la evidencia especificada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1405">Executes the assembly contained in the specified file, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1406">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1406">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1407">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1407">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1408">El <xref:System.AppDomain.ExecuteAssembly%2A> método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1408">The <xref:System.AppDomain.ExecuteAssembly%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1409">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1409">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1410">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1410">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1411">El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1411">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1412">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1412"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1413">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1413"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1414"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1414"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1415">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1415">-or-</span></span> 
<span data-ttu-id="c0a0d-1416">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1416">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1417">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1417">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1418">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1418">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1419">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1419">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1420">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1420">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1421">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1421">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1422">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1422">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1423">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1423">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1424">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1424">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1425">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1425">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1426">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1426">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1427">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1427">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1428">Argumentos del punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1428">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1429">Ejecuta el ensamblado contenido en el archivo especificado, usando los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1429">Executes the assembly contained in the specified file, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1430">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1430">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1431">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1431">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1432">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1432">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1433">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1433">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1434">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1434">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1435">El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1435">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1436">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1436"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1437">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1437"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1438"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1438"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1439">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1439">-or-</span></span> 
 <span data-ttu-id="c0a0d-1440"><paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1440"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1441">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1441">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1442">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1442">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1443">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1443">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1444">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1444">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1445">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1445">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1446">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1446">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1447">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1447">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1448">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1448">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int&#xA;override this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1449">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1449">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1450">Evidencia suministrada para el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1450">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1451">Argumentos del punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1451">The arguments to the entry point of the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1452">Ejecuta el ensamblado que contiene el archivo especificado, usando la evidencia y los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1452">Executes the assembly contained in the specified file, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1453">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1453">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1454">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1454">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1455">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1455">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1456">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1456">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1457">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1457">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1458">El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1458">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1459">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1459"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1460">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1460"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1461"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1461"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1462">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1462">-or-</span></span> 
<span data-ttu-id="c0a0d-1463">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1463">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1464">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1464">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1465">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1465">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-1466"><paramref name="assemblySecurity" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1466"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-1467">Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1467">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1468">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1468">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1469">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1469">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1470">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1470">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1471">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1471">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1472">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1472">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1473">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1473">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1474">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1474">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1475">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1475">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1476">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1476">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1477">Argumentos del punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1477">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="c0a0d-1478">Representa el valor del código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1478">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="c0a0d-1479">Representa el algoritmo hash que usa el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1479">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1480">Ejecuta el ensamblado contenido en el archivo especificado, usando los argumentos, el valor hash y el algoritmo hash especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1480">Executes the assembly contained in the specified file, using the specified arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1481">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1481">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1482">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1482">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1483">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1483">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1484">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1484">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1485">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1485">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1486">El ejemplo siguiente muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1486">The following sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1487">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1487"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1488">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1488"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1489"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1489"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1490">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1490">-or-</span></span> 
 <span data-ttu-id="c0a0d-1491"><paramref name="assemblyFile" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1491"><paramref name="assemblyFile" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1492">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1492">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1493">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1493">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1494">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1494">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1495">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1495">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1496">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1496">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1497">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1497">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1498">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1498">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1499">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1499">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssembly">
      <MemberSignature Language="C#" Value="public int ExecuteAssembly (string assemblyFile, System.Security.Policy.Evidence assemblySecurity, string[] args, byte[] hashValue, System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssembly(string assemblyFile, class System.Security.Policy.Evidence assemblySecurity, string[] args, unsigned int8[] hashValue, valuetype System.Configuration.Assemblies.AssemblyHashAlgorithm hashAlgorithm) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssembly(System.String,System.Security.Policy.Evidence,System.String[],System.Byte[],System.Configuration.Assemblies.AssemblyHashAlgorithm)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssembly (assemblyFile As String, assemblySecurity As Evidence, args As String(), hashValue As Byte(), hashAlgorithm As AssemblyHashAlgorithm) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssembly(System::String ^ assemblyFile, System::Security::Policy::Evidence ^ assemblySecurity, cli::array &lt;System::String ^&gt; ^ args, cli::array &lt;System::Byte&gt; ^ hashValue, System::Configuration::Assemblies::AssemblyHashAlgorithm hashAlgorithm);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssembly : string * System.Security.Policy.Evidence * string[] * byte[] * System.Configuration.Assemblies.AssemblyHashAlgorithm -&gt; int" Usage="appDomain.ExecuteAssembly (assemblyFile, assemblySecurity, args, hashValue, hashAlgorithm)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssembly which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyFile" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]" />
        <Parameter Name="hashValue" Type="System.Byte[]" />
        <Parameter Name="hashAlgorithm" Type="System.Configuration.Assemblies.AssemblyHashAlgorithm" />
      </Parameters>
      <Docs>
        <param name="assemblyFile"><span data-ttu-id="c0a0d-1500">Nombre del archivo que contiene el ensamblado que se va a ejecutar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1500">The name of the file that contains the assembly to execute.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1501">Evidencia suministrada para el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1501">The supplied evidence for the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1502">Argumentos del punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1502">The arguments to the entry point of the assembly.</span></span></param>
        <param name="hashValue"><span data-ttu-id="c0a0d-1503">Representa el valor del código hash calculado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1503">Represents the value of the computed hash code.</span></span></param>
        <param name="hashAlgorithm"><span data-ttu-id="c0a0d-1504">Representa el algoritmo hash que usa el manifiesto del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1504">Represents the hash algorithm used by the assembly manifest.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1505">Ejecuta el ensamblado contenido en el archivo especificado, usando la evidencia, los argumentos, el valor hash y el algoritmo hash especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1505">Executes the assembly contained in the specified file, using the specified evidence, arguments, hash value, and hash algorithm.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1506">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1506">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1507">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1507">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1508">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1508">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1509">Este método carga ensamblados utilizando la <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1509">This method loads assemblies using the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span> <span data-ttu-id="c0a0d-1510">También puede ejecutar ensamblados mediante la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método, que carga los ensamblados que utilizan el <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1510">You can also execute assemblies using the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method, which loads assemblies using the <xref:System.Reflection.Assembly.Load%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1511">Ejemplo de Thefollowing muestra cómo utilizar una de las sobrecargas de <xref:System.AppDomain.ExecuteAssembly%2A> en dos dominios diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1511">Thefollowing sample demonstrates using one of the overloads of <xref:System.AppDomain.ExecuteAssembly%2A> on two different domains.</span></span>  
  
 [!code-cpp[AppDomain_ExecuteAssembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CPP/executeassembly.cpp#1)]
 [!code-csharp[AppDomain_ExecuteAssembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_ExecuteAssembly/CS/executeassembly.cs#1)]
 [!code-vb[AppDomain_ExecuteAssembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_ExecuteAssembly/VB/executeassembly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1512">El valor de <paramref name="assemblyFile" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1512"><paramref name="assemblyFile" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1513">No se ha encontrado <paramref name="assemblyFile" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1513"><paramref name="assemblyFile" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1514"><paramref name="assemblyFile" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1514"><paramref name="assemblyFile" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1515">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1515">-or-</span></span> 
<span data-ttu-id="c0a0d-1516">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyFile" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1516">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyFile" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1517">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1517">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1518">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1518">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-1519"><paramref name="assemblySecurity" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1519"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-1520">Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1520">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1521">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1521">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1522">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1522">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1523">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1523">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1524">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1524">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1525">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1525">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1526">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1526">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1527">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1527">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1528">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1528">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <MemberGroup MemberName="ExecuteAssemblyByName">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1529">Ejecuta un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1529">Executes an assembly.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string -&gt; int" Usage="appDomain.ExecuteAssemblyByName assemblyName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1530">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1530">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1531">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1531">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1532">Ejecuta un ensamblado a partir de su nombre para mostrar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1532">Executes an assembly given its display name.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1533">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1533">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1534">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1534">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1535">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1535">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1536">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1536">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1537">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1537">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 <span data-ttu-id="c0a0d-1538">Para crear el <xref:System.AppDomain> para cargar y ejecutar, utilice el <xref:System.AppDomain.CreateDomain%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1538">To create the <xref:System.AppDomain> to load and execute, use the <xref:System.AppDomain.CreateDomain%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1539">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1539"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1540">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1540">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1541">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1541">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1542">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1542">-or-</span></span> 
<span data-ttu-id="c0a0d-1543">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1543">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1544">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1544">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1545">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1545">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1546">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1546">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1547">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1547">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1548">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1548">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1549">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1549">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1550">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1550">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1551">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1551">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Reflection.AssemblyName" />
        <altmember cref="M:System.Reflection.Assembly.Load(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1552">Objeto <see cref="T:System.Reflection.AssemblyName" /> que representa el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1552">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1553">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1553">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1554">Ejecuta el ensamblado a partir de un objeto <see cref="T:System.Reflection.AssemblyName" />, usando los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1554">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1555">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1555">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1556">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1556">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1557">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1557">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1558">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1558">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1559">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1559">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1560">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1560">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1561">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1561">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1562">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1562">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1563">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1563">-or-</span></span> 
 <span data-ttu-id="c0a0d-1564"><paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1564"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1565">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1565">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1566">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1566">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1567">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1567">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1568">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1568">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1569">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1569">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1570">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1570">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1571">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1571">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1572">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1572">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1573">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1573">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1574">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1574">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1575">Ejecuta un ensamblado a partir de su nombre para mostrar, usando la evidencia especificada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1575">Executes an assembly given its display name, using the specified evidence.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1576">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1576">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1577">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1577">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1578">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1578">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1579">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1579">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1580">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1580">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1581">Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1581">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="c0a0d-1582">Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1582">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1583">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1583"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1584">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1584">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1585">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1585">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1586">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1586">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1587">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1587">-or-</span></span> 
<span data-ttu-id="c0a0d-1588">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1588">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1589">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1589">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1590">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1590">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1591">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1591">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1592">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1592">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1593">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1593">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1594">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1594">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1595">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1595">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1596">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1596">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1597">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1597">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1598">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1598">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1599">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1599">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1600">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1600">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1601">Ejecuta el ensamblado a partir de su nombre para mostrar, usando los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1601">Executes the assembly given its display name, using the specified arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1602">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1602">The value that is returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1603">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1603">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1604">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1604">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1605">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1605">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1606">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1606">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1607">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1607"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1608">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1608">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1609">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1609">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1610">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1610">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1611">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1611">-or-</span></span> 
 <span data-ttu-id="c0a0d-1612"><paramref name="assemblyName" /> se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1612"><paramref name="assemblyName" /> was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1613">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1613">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1614">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1614">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1615">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1615">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1616">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1616">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1617">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1617">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1618">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1618">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1619">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1619">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (System.Reflection.AssemblyName assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(class System.Reflection.AssemblyName assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.Reflection.AssemblyName,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::Reflection::AssemblyName ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : System.Reflection.AssemblyName * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1620">Objeto <see cref="T:System.Reflection.AssemblyName" /> que representa el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1620">An <see cref="T:System.Reflection.AssemblyName" /> object representing the name of the assembly.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1621">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1621">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1622">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1622">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1623">Ejecuta el ensamblado a partir de un objeto <see cref="T:System.Reflection.AssemblyName" />, usando la evidencia y los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1623">Executes the assembly given an <see cref="T:System.Reflection.AssemblyName" />, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1624">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1624">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1625">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1625">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1626">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1626">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1627">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1627">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1628">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1628">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1629">Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1629">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="c0a0d-1630">Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1630">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1631">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1631">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1632">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1632">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1633">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1633">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1634">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1634">-or-</span></span> 
<span data-ttu-id="c0a0d-1635">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1635">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1636">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1636">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-1637"><paramref name="assemblySecurity" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1637"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-1638">Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1638">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1639">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1639">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1640">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1640">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1641">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1641">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1642">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1642">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1643">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1643">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1644">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1644">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1645">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1645">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1646">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1646">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="ExecuteAssemblyByName">
      <MemberSignature Language="C#" Value="public int ExecuteAssemblyByName (string assemblyName, System.Security.Policy.Evidence assemblySecurity, params string[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ExecuteAssemblyByName(string assemblyName, class System.Security.Policy.Evidence assemblySecurity, string[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ExecuteAssemblyByName(System.String,System.Security.Policy.Evidence,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Function ExecuteAssemblyByName (assemblyName As String, assemblySecurity As Evidence, ParamArray args As String()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ExecuteAssemblyByName(System::String ^ assemblyName, System::Security::Policy::Evidence ^ assemblySecurity, ... cli::array &lt;System::String ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="member this.ExecuteAssemblyByName : string * System.Security.Policy.Evidence * string[] -&gt; int" Usage="appDomain.ExecuteAssemblyByName (assemblyName, assemblySecurity, args)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of ExecuteAssemblyByName which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyName" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
        <Parameter Name="args" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="assemblyName"><span data-ttu-id="c0a0d-1647">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1647">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1648">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1648">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1649">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1649">Evidence for loading the assembly.</span></span></param>
        <param name="args"><span data-ttu-id="c0a0d-1650">Argumentos de línea de comandos que se van a pasar al iniciar el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1650">Command-line arguments to pass when starting the process.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1651">Ejecuta el ensamblado a partir de su nombre para mostrar, usando la evidencia y argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1651">Executes the assembly given its display name, using the specified evidence and arguments.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1652">Valor devuelto por el punto de entrada del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1652">The value returned by the entry point of the assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1653">El <xref:System.AppDomain.ExecuteAssemblyByName%2A> método proporciona una funcionalidad similar a la <xref:System.AppDomain.ExecuteAssembly%2A> método, pero especifica el ensamblado por nombre para mostrar o <xref:System.Reflection.AssemblyName> en lugar de por la ubicación del archivo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1653">The <xref:System.AppDomain.ExecuteAssemblyByName%2A> method provides similar functionality to the <xref:System.AppDomain.ExecuteAssembly%2A> method, but specifies the assembly by display name or <xref:System.Reflection.AssemblyName> rather than by file location.</span></span> <span data-ttu-id="c0a0d-1654">Por lo tanto, <xref:System.AppDomain.ExecuteAssemblyByName%2A> carga ensamblados con el <xref:System.Reflection.Assembly.Load%2A> método en lugar de con el <xref:System.Reflection.Assembly.LoadFile%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1654">Therefore, <xref:System.AppDomain.ExecuteAssemblyByName%2A> loads assemblies with the <xref:System.Reflection.Assembly.Load%2A> method rather than with the <xref:System.Reflection.Assembly.LoadFile%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1655">El ensamblado comienza a ejecutarse en el punto de entrada especificado en el encabezado de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1655">The assembly begins executing at the entry point specified in the .NET Framework header.</span></span>  
  
 <span data-ttu-id="c0a0d-1656">Este método no crea un nuevo proceso o un dominio de aplicación y no se ejecuta el método de punto de entrada en un nuevo subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1656">This method does not create a new process or application domain, and it does not execute the entry point method on a new thread.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1657">Cuando se usa el <xref:System.AppDomain.ExecuteAssemblyByName%2A> método con un <xref:System.Security.Policy.Evidence> parámetro, evidencias se combinan.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1657">When you use the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method with an <xref:System.Security.Policy.Evidence> parameter, pieces of evidence are merged.</span></span> <span data-ttu-id="c0a0d-1658">Evidencias proporcionada como argumento a la <xref:System.AppDomain.ExecuteAssemblyByName%2A> método sustituyen a los elementos de la evidencia proporcionada por el cargador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1658">Pieces of evidence supplied as an argument to the <xref:System.AppDomain.ExecuteAssemblyByName%2A> method supersede pieces of evidence supplied by the loader.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1659">El valor de <paramref name="assemblyName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1659"><paramref name="assemblyName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1660">El ensamblado especificado por <paramref name="assemblyName" /> no se encuentra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1660">The assembly specified by <paramref name="assemblyName" /> is not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1661">El ensamblado especificado por <paramref name="assemblyName" /> se encontró, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1661">The assembly specified by <paramref name="assemblyName" /> was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1662">El ensamblado especificado por <paramref name="assemblyName" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1662">The assembly specified by <paramref name="assemblyName" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1663">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1663">-or-</span></span> 
<span data-ttu-id="c0a0d-1664">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyName" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1664">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyName" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1665">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1665">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-1666"><paramref name="assemblySecurity" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1666"><paramref name="assemblySecurity" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-1667">Cuando no se habilita la directiva CAS heredada, <paramref name="assemblySecurity" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1667">When legacy CAS policy is not enabled, <paramref name="assemblySecurity" /> should be <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="c0a0d-1668">El ensamblado especificado no tiene ningún punto de entrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1668">The specified assembly has no entry point.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1669">Para obtener acceso leer de un archivo o directorio para el acceso a la información de la ruta de acceso y para redirigir un nombre para mostrar a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1669">for access to read from a file or directory, for access to the information in the path itself, and for redirecting a display name to a path.</span></span> <span data-ttu-id="c0a0d-1670">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1670">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1671">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1671">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1672">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1672">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1673">Para obtener acceso a un sitio Web, cuando un nombre para mostrar se redirige a una dirección URL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1673">for access to a Web site, when a display name is redirected to a URL.</span></span></permission>
        <permission cref="T:System.Security.Permissions.UIPermission"><span data-ttu-id="c0a0d-1674">Para ejecutar una aplicación de consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1674">to execute a console application.</span></span> <span data-ttu-id="c0a0d-1675">Enumeración asociada: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1675">Associated enumeration: <see cref="F:System.Security.Permissions.PermissionState.Unrestricted" />.</span></span></permission>
        <altmember cref="T:System.Security.Policy.Evidence" />
      </Docs>
    </Member>
    <Member MemberName="FirstChanceException">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; FirstChanceException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.FirstChanceException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event FirstChanceException As EventHandler(Of FirstChanceExceptionEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Runtime::ExceptionServices::FirstChanceExceptionEventArgs ^&gt; ^ FirstChanceException;" />
      <MemberSignature Language="F#" Value="member this.FirstChanceException : EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " Usage="member this.FirstChanceException : System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1676">Ocurre cuando se produce una excepción en código administrado, antes de que el runtime busque un controlador de excepciones en la pila de llamadas del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1676">Occurs when an exception is thrown in managed code, before the runtime searches the call stack for an exception handler in the application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1677">Este evento es sólo una notificación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1677">This event is only a notification.</span></span> <span data-ttu-id="c0a0d-1678">Controle este evento no controla la excepción ni afectan de ninguna forma de control de excepciones posteriores.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1678">Handling this event does not handle the exception or affect subsequent exception handling in any way.</span></span> <span data-ttu-id="c0a0d-1679">Después de que se ha provocado el evento y se han invocado los controladores de eventos, common language runtime (CLR) comienza a buscar un controlador para la excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1679">After the event has been raised and event handlers have been invoked, the common language runtime (CLR) begins to search for a handler for the exception.</span></span> <span data-ttu-id="c0a0d-1680"><xref:System.AppDomain.FirstChanceException> proporciona el dominio de aplicación con la primera oportunidad de examinar cualquier excepción administrada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1680"><xref:System.AppDomain.FirstChanceException> provides the application domain with a first chance to examine any managed exception.</span></span>  
  
 <span data-ttu-id="c0a0d-1681">El evento se puede controlar por dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1681">The event can be handled per application domain.</span></span> <span data-ttu-id="c0a0d-1682">Si un subproceso pasa a través de varios dominios de aplicación mientras se ejecuta una llamada, el evento se produce en cada dominio de aplicación que ha registrado un controlador de eventos, antes de que el CLR comienza a buscar un controlador de excepciones coincidente en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1682">If a thread passes through multiple application domains while executing a call, the event is raised in each application domain that has registered an event handler, before the CLR begins searching for a matching exception handler in that application domain.</span></span> <span data-ttu-id="c0a0d-1683">Después de que se ha controlado el evento, se realizará una búsqueda de un controlador de excepciones coincidente en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1683">After the event has been handled, a search is made for a matching exception handler in that application domain.</span></span> <span data-ttu-id="c0a0d-1684">Si se encuentra ninguno, se produce el evento en el siguiente dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1684">If none is found, the event is raised in the next application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1685">Debe controlar todas las excepciones que se producen en el evento del controlador para el <xref:System.AppDomain.FirstChanceException> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1685">You must handle all exceptions that occur in the event handler for the <xref:System.AppDomain.FirstChanceException> event.</span></span> <span data-ttu-id="c0a0d-1686">En caso contrario, <xref:System.AppDomain.FirstChanceException> es generada de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1686">Otherwise, <xref:System.AppDomain.FirstChanceException> is raised recursively.</span></span> <span data-ttu-id="c0a0d-1687">Esto podría producir un desbordamiento de pila y la finalización de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1687">This could result in a stack overflow and termination of the application.</span></span> <span data-ttu-id="c0a0d-1688">Se recomienda implementar controladores de eventos para este evento como regiones de ejecución restringida (CER), para evitar que las excepciones relacionadas con la infraestructura como de memoria insuficiente o desbordamiento de pila que afectan a la máquina virtual mientras la notificación de excepción es se está procesando.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1688">We recommend that you implement event handlers for this event as constrained execution regions (CERs), to keep infrastructure-related exceptions such as out-of-memory or stack overflow from affecting the virtual machine while the exception notification is being processed.</span></span>  
  
 <span data-ttu-id="c0a0d-1689">Este evento no se genera para las excepciones que indican los daños de estado del proceso, como las infracciones de acceso, a menos que el controlador de eventos es crítico para la seguridad y tiene el <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1689">This event is not raised for exceptions that indicate corruption of process state, such as access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="c0a0d-1690">Common language runtime suspende las anulaciones de subprocesos mientras se controla este evento de notificación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1690">The common language runtime suspends thread aborts while this notification event is being handled.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1691">En el ejemplo siguiente se crea una serie de dominios de aplicación denominada `AD0` a través de `AD3`, con un `Worker` objeto en cada dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1691">The following example creates a series of application domains named `AD0` through `AD3`, with a `Worker` object in each application domain.</span></span> <span data-ttu-id="c0a0d-1692">Cada `Worker` objeto tiene una referencia a la `Worker` objeto en el siguiente dominio de aplicación, excepto para el `Worker` en el último dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1692">Each `Worker` object has a reference to the `Worker` object in the next application domain, except for the `Worker` in the last application domain.</span></span> <span data-ttu-id="c0a0d-1693">El <xref:System.AppDomain.FirstChanceException> evento se controla en todos los dominios de aplicación, excepto `AD1`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1693">The <xref:System.AppDomain.FirstChanceException> event is handled in all application domains except `AD1`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1694">Además de este ejemplo, que muestra las notificaciones de excepciones de primera oportunidad en varios dominios de aplicación, puede encontrar casos de uso sencillos de [Cómo: Recibir notificaciones de excepciones de primera oportunidad](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1694">In addition to this example, which demonstrates first-chance exception notifications in multiple application domains, you can find simple use cases in [How to: Receive First-Chance Exception Notifications](~/docs/framework/app-domains/how-to-receive-first-chance-exception-notifications.md).</span></span>  
  
 <span data-ttu-id="c0a0d-1695">Cuando se han creado los dominios de aplicación, el dominio de aplicación predeterminado llama el `TestException` método para el primer dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1695">When the application domains have been created, the default application domain calls the `TestException` method for the first application domain.</span></span> <span data-ttu-id="c0a0d-1696">Cada `Worker` de objeto llama el `TestException` método del siguiente dominio de aplicación, hasta el último `Worker` produce una excepción que es controlada o no.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1696">Each `Worker` object calls the `TestException` method for the next application domain, until the last `Worker` throws an exception that is either handled or unhandled.</span></span> <span data-ttu-id="c0a0d-1697">Por lo tanto, el subproceso actual se pasa a través de todos los dominios de aplicación, y `TestException` se agrega a la pila en cada dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1697">Thus, the current thread passes through all the application domains, and `TestException` is added to the stack in each application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1698">Cuando el último `Worker` objeto controla la excepción, el <xref:System.AppDomain.FirstChanceException> evento se produce solo en el último dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1698">When the last `Worker` object handles the exception, the <xref:System.AppDomain.FirstChanceException> event is raised only in the last application domain.</span></span> <span data-ttu-id="c0a0d-1699">Los demás dominios de aplicación nunca tienen la oportunidad para controlar la excepción, por lo que no se genera el evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1699">The other application domains never get a chance to handle the exception, so the event is not raised.</span></span>  
  
 <span data-ttu-id="c0a0d-1700">Cuando el último `Worker` objeto no controla la excepción, el <xref:System.AppDomain.FirstChanceException> evento se genera en cada dominio de aplicación que tiene un controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1700">When the last `Worker` object does not handle the exception, the <xref:System.AppDomain.FirstChanceException> event is raised in each application domain that has an event handler.</span></span> <span data-ttu-id="c0a0d-1701">Una vez terminada cada controlador de eventos, la pila continúa desenredar hasta que la excepción ha sido detectada por el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1701">After each event handler has finished, the stack continues to unwind until the exception is caught by the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1702">Para ver cómo la presentación de la pila crece a medida que se genera el evento más cercanos y cuanto más se acerque al dominio de aplicación predeterminado, cambie `e.Exception.Message` a `e.Exception` en el `FirstChanceHandler` controladores de eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1702">To see how the stack display grows as the event is raised closer and closer to the default application domain, change `e.Exception.Message` to `e.Exception` in the `FirstChanceHandler` event handlers.</span></span> <span data-ttu-id="c0a0d-1703">Tenga en cuenta que, cuando `TestException` se llama a través de los límites del dominio de aplicación, aparece dos veces: una vez para el proxy y otra para el código auxiliar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1703">Notice that when `TestException` is called across application domain boundaries, it appears twice: once for the proxy and once for the stub.</span></span>  
  
 [!code-csharp[System.AppDomain.FirstChanceException#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/cs/example.cs#1)]
 [!code-vb[System.AppDomain.FirstChanceException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.firstchanceexception/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-1704">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1704">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-1705">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1705">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs" />
        <altmember cref="E:System.AppDomain.UnhandledException" />
        <related type="Article" href="https://msdn.microsoft.com/library/66f002b8-a97d-4a6e-a503-2cec01689113"><span data-ttu-id="c0a0d-1706">Cómo: Recibir notificaciones de excepciones de primera oportunidad</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1706">How to: Receive First-Chance Exception Notifications</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="FriendlyName">
      <MemberSignature Language="C#" Value="public string FriendlyName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FriendlyName" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.FriendlyName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FriendlyName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FriendlyName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FriendlyName : string" Usage="System.AppDomain.FriendlyName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.FriendlyName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1707">Obtiene el nombre descriptivo de este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1707">Gets the friendly name of this application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1708">Nombre descriptivo de este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1708">The friendly name of this application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1709">El nombre descriptivo del dominio de aplicación predeterminado es el nombre de archivo del proceso ejecutable.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1709">The friendly name of the default application domain is the file name of the process executable.</span></span> <span data-ttu-id="c0a0d-1710">Por ejemplo, si usa el archivo ejecutable para iniciar el proceso es `"c:\MyAppDirectory\MyAssembly.exe"`, es el nombre descriptivo del dominio de aplicación predeterminado `"MyAssembly.exe"`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1710">For example, if the executable used to start the process is `"c:\MyAppDirectory\MyAssembly.exe"`, the friendly name of the default application domain is `"MyAssembly.exe"`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1711">El siguiente ejemplo de código utiliza el <xref:System.AppDomain.FriendlyName%2A> propiedad va a obtener el nombre descriptivo del dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1711">The following code example uses the <xref:System.AppDomain.FriendlyName%2A> property to get the friendly name of the current application domain.</span></span> <span data-ttu-id="c0a0d-1712">Para el dominio de aplicación predeterminado, el nombre descriptivo es el nombre del archivo ejecutable de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1712">For the default application domain, the friendly name is the name of the application's executable file.</span></span> <span data-ttu-id="c0a0d-1713">El ejemplo de código también muestra información adicional sobre el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1713">The code example also displays additional information about the application domain.</span></span>  
  
 [!code-cpp[ADApplicationBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADApplicationBase/CPP/adapplicationbase.cpp#1)]
 [!code-csharp[ADApplicationBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADApplicationBase/CS/adapplicationbase.cs#1)]
 [!code-vb[ADApplicationBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADApplicationBase/VB/adapplicationbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1714">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1714">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] GetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly[] GetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::Assembly ^&gt; ^ GetAssemblies();" />
      <MemberSignature Language="F#" Value="abstract member GetAssemblies : unit -&gt; System.Reflection.Assembly[]&#xA;override this.GetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.GetAssemblies " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetAssemblies</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1715">Obtiene los ensamblados que se han cargado en el contexto de ejecución de este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1715">Gets the assemblies that have been loaded into the execution context of this application domain.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1716">Matriz de ensamblados de este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1716">An array of assemblies in this application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c0a0d-1717">El siguiente ejemplo de código utiliza el <xref:System.AppDomain.GetAssemblies%2A> método para obtener una lista de todos los ensamblados que se han cargado en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1717">The following code example uses the <xref:System.AppDomain.GetAssemblies%2A> method to get a list of all assemblies that have been loaded into the application domain.</span></span> <span data-ttu-id="c0a0d-1718">Los ensamblados, a continuación, se muestran en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1718">The assemblies are then displayed to the console.</span></span>  
  
 <span data-ttu-id="c0a0d-1719">Para ejecutar este ejemplo de código, deberá crear un ensamblado denominado `CustomLibrary.dll`, o cambiar el nombre del ensamblado que se pasa a la <xref:System.AppDomain.GetAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1719">To run this code example, you need to create an assembly named `CustomLibrary.dll`, or change the assembly name that is passed to the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
 [!code-cpp[ADGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetAssemblies/CPP/adgetassemblies.cpp#1)]
 [!code-csharp[ADGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetAssemblies/CS/adgetassemblies.cs#1)]
 [!code-vb[ADGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetAssemblies/VB/adgetassemblies.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1720">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1720">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentThreadId">
      <MemberSignature Language="C#" Value="public static int GetCurrentThreadId ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetCurrentThreadId() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetCurrentThreadId" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetCurrentThreadId () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetCurrentThreadId();" />
      <MemberSignature Language="F#" Value="static member GetCurrentThreadId : unit -&gt; int" Usage="System.AppDomain.GetCurrentThreadId " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.'")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread.  http://go.microsoft.com/fwlink/?linkid=14202", false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1721">Obtiene el identificador del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1721">Gets the current thread identifier.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1722">Entero de 32 bits con signo que representa el identificador del actual subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1722">A 32-bit signed integer that is the identifier of the current thread.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1723">Use el <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> propiedad, que es estable incluso cuando .NET Framework está hospedada en un entorno que admite fibras (es decir, subprocesos pequeños).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1723">Use the <xref:System.Threading.Thread.ManagedThreadId%2A?displayProperty=nameWithType> property, which is stable even when the .NET Framework is hosted by an environment that supports fibers (that is, lightweight threads).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1724">llamar a este método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1724">to call this method.</span></span> <span data-ttu-id="c0a0d-1725">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1725">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" />.</span></span> <span data-ttu-id="c0a0d-1726">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1726">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <altmember cref="T:System.Int32" />
        <altmember cref="P:System.Threading.Thread.ManagedThreadId" />
      </Docs>
    </Member>
    <Member MemberName="GetData">
      <MemberSignature Language="C#" Value="public object GetData (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetData(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetData(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetData (name As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetData(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetData : string -&gt; obj&#xA;override this.GetData : string -&gt; obj" Usage="appDomain.GetData name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetData(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-1727">Nombre de una propiedad de dominio de aplicación predefinida o nombre de una propiedad de dominio de aplicación que se haya definido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1727">The name of a predefined application domain property, or the name of an application domain property you have defined.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1728">Obtiene el valor almacenado en el dominio de aplicación actual para el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1728">Gets the value stored in the current application domain for the specified name.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1729">El valor de la propiedad o <paramref name="name" /> o <see langword="null" /> si la propiedad no existe.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1729">The value of the <paramref name="name" /> property, or <see langword="null" /> if the property does not exist.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1730">Use este método para recuperar el valor de una entrada en una memoria caché interna de pares de nombre y datos que describen las propiedades de esta instancia de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1730">Use this method to retrieve the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span> <span data-ttu-id="c0a0d-1731">Tenga en cuenta que la comparación de `name` con el nombre de pares de clave y valor distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1731">Note that the comparison of `name` with the name of key-value pairs is case-sensitive.</span></span>  
  
 <span data-ttu-id="c0a0d-1732">La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1732">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="c0a0d-1733">Puede examinar sus valores con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> propiedades.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1733">You can inspect their values with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties.</span></span>  
  
 <span data-ttu-id="c0a0d-1734">Puede insertar o modificar sus propios pares de nombre y datos definidos por el usuario con el <xref:System.AppDomain.SetData%2A> método y examinar sus valores con el <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1734">You can insert or modify your own user defined name-data pairs with the <xref:System.AppDomain.SetData%2A> method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 <span data-ttu-id="c0a0d-1735">La tabla siguiente se describen los `name` de cada entrada de sistema y su correspondiente predefinidos <xref:System.AppDomainSetup> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1735">The following table describes the `name` of each predefined system entry and its corresponding <xref:System.AppDomainSetup> property.</span></span>  
  
|<span data-ttu-id="c0a0d-1736">Valor de 'name'</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1736">Value of 'name'</span></span>|<span data-ttu-id="c0a0d-1737">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1737">Property</span></span>|  
|---------------------|--------------|  
|<span data-ttu-id="c0a0d-1738">"RAÍZ (APPBASE)"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1738">"APPBASE"</span></span>|<xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1739">"APP_CONFIG_FILE"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1739">"APP_CONFIG_FILE"</span></span>|<xref:System.AppDomainSetup.ConfigurationFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1740">"APP_LAUNCH_URL"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1740">"APP_LAUNCH_URL"</span></span>|<span data-ttu-id="c0a0d-1741">(ninguna propiedad)</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1741">(no property)</span></span><br /><br /> <span data-ttu-id="c0a0d-1742">"APP_LAUNCH_URL" representa la dirección URL solicitada originalmente por el usuario, antes de cualquier redirección.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1742">"APP_LAUNCH_URL" represents the URL originally requested by the user, before any redirection.</span></span> <span data-ttu-id="c0a0d-1743">Está disponible solo cuando la aplicación se ha iniciado con un explorador como Internet Explorer.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1743">It is available only when the application has been launched with a browser such as Internet Explorer.</span></span> <span data-ttu-id="c0a0d-1744">No todos los exploradores proporcionan este valor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1744">Not all browsers provide this value.</span></span>|  
|<span data-ttu-id="c0a0d-1745">"APP_NAME"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1745">"APP_NAME"</span></span>|<xref:System.AppDomainSetup.ApplicationName%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1746">"BINPATH_PROBE_ONLY"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1746">"BINPATH_PROBE_ONLY"</span></span>|<xref:System.AppDomainSetup.PrivateBinPathProbe%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1747">"CACHE_BASE"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1747">"CACHE_BASE"</span></span>|<xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1748">"CODE_DOWNLOAD_DISABLED"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1748">"CODE_DOWNLOAD_DISABLED"</span></span>|<xref:System.AppDomainSetup.DisallowCodeDownload%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1749">"DEV_PATH"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1749">"DEV_PATH"</span></span>|<span data-ttu-id="c0a0d-1750">(ninguna propiedad)</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1750">(no property)</span></span>|  
|<span data-ttu-id="c0a0d-1751">"DISALLOW_APP"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1751">"DISALLOW_APP"</span></span>|<xref:System.AppDomainSetup.DisallowPublisherPolicy%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1752">"DISALLOW_APP_BASE_PROBING"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1752">"DISALLOW_APP_BASE_PROBING"</span></span>|<xref:System.AppDomainSetup.DisallowApplicationBaseProbing%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1753">"DISALLOW_APP_REDIRECTS"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1753">"DISALLOW_APP_REDIRECTS"</span></span>|<xref:System.AppDomainSetup.DisallowBindingRedirects%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1754">"DYNAMIC_BASE"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1754">"DYNAMIC_BASE"</span></span>|<xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1755">"FORCE_CACHE_INSTALL"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1755">"FORCE_CACHE_INSTALL"</span></span>|<xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1756">"LICENSE_FILE" o una cadena específica de la aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1756">"LICENSE_FILE", or an application-specific string</span></span>|<xref:System.AppDomainSetup.LicenseFile%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1757">"LOADER_OPTIMIZATION"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1757">"LOADER_OPTIMIZATION"</span></span>|<xref:System.AppDomainSetup.LoaderOptimization%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1758">"LOCATION_URI"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1758">"LOCATION_URI"</span></span>|<span data-ttu-id="c0a0d-1759">(ninguna propiedad)</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1759">(no property)</span></span>|  
|<span data-ttu-id="c0a0d-1760">"PRIVATE_BINPATH"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1760">"PRIVATE_BINPATH"</span></span>|<xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>|  
|<span data-ttu-id="c0a0d-1761">"REGEX_DEFAULT_MATCH_TIMEOUT"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1761">"REGEX_DEFAULT_MATCH_TIMEOUT"</span></span>|<xref:System.Text.RegularExpressions.Regex.MatchTimeout%2A?displayProperty=nameWithType><br /><br /> <span data-ttu-id="c0a0d-1762">"REGEX_DEFAULT_MATCH_TIMEOUT" no es una entrada de sistema y su valor se puede establecer mediante una llamada a la <xref:System.AppDomain.SetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1762">"REGEX_DEFAULT_MATCH_TIMEOUT" is not a system entry, and its value can be set by calling the <xref:System.AppDomain.SetData%2A> method.</span></span>|  
|<span data-ttu-id="c0a0d-1763">"SHADOW_COPY_DIRS"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1763">"SHADOW_COPY_DIRS"</span></span>|<xref:System.AppDomainSetup.ShadowCopyDirectories%2A?displayProperty=nameWithType>|  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1764">El ejemplo siguiente crea un nuevo dominio de aplicación, establece un valor proporcionado por el sistema para el dominio y agrega un nuevo par de valor para el dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1764">The following example creates a new application domain, sets a system-provided value for the domain, and adds a new value pair for the domain.</span></span> <span data-ttu-id="c0a0d-1765">El ejemplo, a continuación, muestra cómo usar el <xref:System.AppDomain.GetData%2A> método para recuperar los datos de estos pares de valor y mostrarlos en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1765">The example then demonstrates how to use the <xref:System.AppDomain.GetData%2A> method to retrieve the data from these value pairs and display them to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1766">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1766"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1767">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1767">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1768">Para obtener acceso a la información de la ruta de acceso, si la propiedad se aplica a una ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1768">for access to the information in the path itself, if the property applies to a path.</span></span> <span data-ttu-id="c0a0d-1769">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1769">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="M:System.AppDomain.SetData(System.String,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="appDomain.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1770">Obtiene el tipo de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1770">Gets the type of the current instance.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1771">Tipo de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1771">The type of the current instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Id">
      <MemberSignature Language="C#" Value="public int Id { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Id" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.Id" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Id As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Id { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Id : int" Usage="System.AppDomain.Id" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1772">Obtiene un entero que identifica únicamente el dominio de aplicación en el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1772">Gets an integer that uniquely identifies the application domain within the process.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1773">Entero que identifica el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1773">An integer that identifies the application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c0a0d-1774">En el ejemplo de código siguiente se crea un segundo dominio de aplicación y muestra información sobre el dominio predeterminado y el nuevo dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1774">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="InitializeLifetimeService">
      <MemberSignature Language="C#" Value="public override object InitializeLifetimeService ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object InitializeLifetimeService() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.InitializeLifetimeService" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function InitializeLifetimeService () As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Object ^ InitializeLifetimeService();" />
      <MemberSignature Language="F#" Value="override this.InitializeLifetimeService : unit -&gt; obj" Usage="appDomain.InitializeLifetimeService " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.InitializeLifetimeService</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1775">Concede al <see cref="T:System.AppDomain" /> una duración infinita, ya que impide que se genere una concesión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1775">Gives the <see cref="T:System.AppDomain" /> an infinite lifetime by preventing a lease from being created.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1776">Siempre es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1776">Always <see langword="null" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1777">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1777">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-1778">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1778">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-1779">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1779">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="IsCompatibilitySwitchSet">
      <MemberSignature Language="C#" Value="public Nullable&lt;bool&gt; IsCompatibilitySwitchSet (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;bool&gt; IsCompatibilitySwitchSet(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsCompatibilitySwitchSet(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function IsCompatibilitySwitchSet (value As String) As Nullable(Of Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;bool&gt; IsCompatibilitySwitchSet(System::String ^ value);" />
      <MemberSignature Language="F#" Value="member this.IsCompatibilitySwitchSet : string -&gt; Nullable&lt;bool&gt;" Usage="appDomain.IsCompatibilitySwitchSet value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Boolean&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="c0a0d-1780">Modificador de compatibilidad que se va a comprobar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1780">The compatibility switch to test.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1781">Obtiene un valor booleano que acepta valores NULL que indica si se ha establecido algún modificador de compatibilidad y, en ese caso, si se ha establecido el modificador de compatibilidad especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1781">Gets a nullable Boolean value that indicates whether any compatibility switches are set, and if so, whether the specified compatibility switch is set.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1782">Una referencia nula (<see langword="Nothing" /> en Visual Basic) si no se estableció ningún modificador de compatibilidad; de lo contrario, es un valor booleano que indica si se estableció el modificador de compatibilidad especificado por <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1782">A null reference (<see langword="Nothing" /> in Visual Basic) if no compatibility switches are set; otherwise, a Boolean value that indicates whether the compatibility switch that is specified by <paramref name="value" /> is set.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1783">Este método comprueba si se ha establecido el modificador de compatibilidad especificado para el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1783">This method tests whether the specified compatibility switch has been set for the current application domain.</span></span> <span data-ttu-id="c0a0d-1784">Modificadores de compatibilidad normalmente restauración un comportamiento (por ejemplo, las cadenas de manera se ordenan) que se ha cambiado entre las versiones de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1784">Compatibility switches typically restore a behavior (such as the way strings are sorted) that was changed between versions of the .NET Framework.</span></span>  <span data-ttu-id="c0a0d-1785">Se establecen mediante una llamada a la <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> método antes de crear un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1785">They are set by calling the <xref:System.AppDomainSetup.SetCompatibilitySwitches%2A?displayProperty=nameWithType> method before creating an application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1786">En la tabla siguiente se proporciona ejemplos de modificadores de compatibilidad que se pueden establecer para restaurar el comportamiento de versiones anteriores de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1786">The following table provides examples of compatibility switches that can be set to restore the behavior of earlier versions of the .NET Framework.</span></span>  
  
|<span data-ttu-id="c0a0d-1787">Modificador</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1787">Switch</span></span>|<span data-ttu-id="c0a0d-1788">Significado</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1788">Meaning</span></span>|  
|------------|-------------|  
|<span data-ttu-id="c0a0d-1789">"NetFx40_LegacySecurityPolicy"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1789">"NetFx40_LegacySecurityPolicy"</span></span>|<span data-ttu-id="c0a0d-1790">Acceso del código (CAS) para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1790">Code access security (CAS) for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span> <span data-ttu-id="c0a0d-1791">Consulte [ &lt;NetFx40_LegacySecurityPolicy&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1791">See [&lt;NetFx40_LegacySecurityPolicy&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/netfx40-legacysecuritypolicy-element.md).</span></span>|  
|<span data-ttu-id="c0a0d-1792">"NetFx40_Legacy20SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1792">"NetFx40_Legacy20SortingBehavior"</span></span>|<span data-ttu-id="c0a0d-1793">Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] están habilitados en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1793">String sorting defaults for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] are enabled in this application domain.</span></span> <span data-ttu-id="c0a0d-1794">Su éxito requiere sort00001000.dll para instalarse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1794">Its success requires sort00001000.dll to be installed.</span></span> <span data-ttu-id="c0a0d-1795">Consulte [ &lt;CompatSortNLSVersion&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1795">See [&lt;CompatSortNLSVersion&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/compatsortnlsversion-element.md).</span></span>|  
|<span data-ttu-id="c0a0d-1796">"NetFx40_Legacy40SortingBehavior"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1796">"NetFx40_Legacy40SortingBehavior"</span></span>|<span data-ttu-id="c0a0d-1797">Cadena de ordenación de los valores predeterminados para el [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]y Unicode 5.0 están habilitadas en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1797">String sorting defaults for the [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)]and Unicode 5.0 are enabled in this application domain.</span></span> <span data-ttu-id="c0a0d-1798">Su éxito requiere sort00060101.dll para instalarse.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1798">Its success requires sort00060101.dll to be installed.</span></span>|  
|<span data-ttu-id="c0a0d-1799">"NetFx40_TimeSpanLegacyFormatMode"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1799">"NetFx40_TimeSpanLegacyFormatMode"</span></span>|<span data-ttu-id="c0a0d-1800"><xref:System.TimeSpan> formato de comportamiento para el [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] está habilitada en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1800"><xref:System.TimeSpan> formatting behavior for the [!INCLUDE[net_v35_short](~/includes/net-v35-short-md.md)] is enabled in this application domain.</span></span>  <span data-ttu-id="c0a0d-1801">Consulte [ &lt;TimeSpan_LegacyFormatMode&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) y la sección "Restauración de formato de TimeSpan de heredado" de la <xref:System.TimeSpan> tema.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1801">See [&lt;TimeSpan_LegacyFormatMode&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/timespan-legacyformatmode-element.md) and the "Restoring Legacy TimeSpan Formatting" section of the <xref:System.TimeSpan> topic.</span></span>|  
|<span data-ttu-id="c0a0d-1802">"UseRandomizedStringHashAlgorithm"</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1802">"UseRandomizedStringHashAlgorithm"</span></span>|<span data-ttu-id="c0a0d-1803">El runtime calcula los códigos hash para cadenas en una por cada dominio de aplicación en lugar de usar un solo algoritmo hash que genera un código hash coherente entre dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1803">The runtime calculates hash codes for strings on a per application domain basis instead of using a single hashing algorithm that produces a consistent hash code across application domains.</span></span> <span data-ttu-id="c0a0d-1804">Consulte [ &lt;UseRandomizedStringHashAlgorithm&gt; elemento](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1804">See [&lt;UseRandomizedStringHashAlgorithm&gt; Element](~/docs/framework/configure-apps/file-schema/runtime/userandomizedstringhashalgorithm-element.md).</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.AppDomainSetup.SetCompatibilitySwitches(System.Collections.Generic.IEnumerable{System.String})" />
      </Docs>
    </Member>
    <Member MemberName="IsDefaultAppDomain">
      <MemberSignature Language="C#" Value="public bool IsDefaultAppDomain ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsDefaultAppDomain() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsDefaultAppDomain" />
      <MemberSignature Language="VB.NET" Value="Public Function IsDefaultAppDomain () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsDefaultAppDomain();" />
      <MemberSignature Language="F#" Value="member this.IsDefaultAppDomain : unit -&gt; bool" Usage="appDomain.IsDefaultAppDomain " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1805">Devuelve un valor que indica si el dominio de aplicación es el dominio de aplicación predeterminado para el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1805">Returns a value that indicates whether the application domain is the default application domain for the process.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1806"><see langword="true" /> si el objeto <see cref="T:System.AppDomain" /> actual representa el dominio de aplicación predeterminado para el proceso; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1806"><see langword="true" /> if the current <see cref="T:System.AppDomain" /> object represents the default application domain for the process; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1807">Cada proceso administrado tiene un dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1807">Every managed process has a default application domain.</span></span> <span data-ttu-id="c0a0d-1808">La ejecución comienza en el dominio predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1808">Execution begins in the default domain.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1809">En el ejemplo de código siguiente se crea un segundo dominio de aplicación y muestra información sobre el dominio predeterminado y el nuevo dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1809">The following code example creates a second application domain and displays information about the default domain and the new domain.</span></span>  
  
 [!code-cpp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CPP/System.AppDomain.IsDefaultAppDomain.cpp#1)]
 [!code-csharp[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/CS/source.cs#1)]
 [!code-vb[System.AppDomain.IsDefaultAppDomain#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.AppDomain.IsDefaultAppDomain/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinalizingForUnload">
      <MemberSignature Language="C#" Value="public bool IsFinalizingForUnload ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool IsFinalizingForUnload() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.IsFinalizingForUnload" />
      <MemberSignature Language="VB.NET" Value="Public Function IsFinalizingForUnload () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool IsFinalizingForUnload();" />
      <MemberSignature Language="F#" Value="member this.IsFinalizingForUnload : unit -&gt; bool" Usage="appDomain.IsFinalizingForUnload " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-1810">Indica si se está descargando este dominio de aplicación y si Common Language Runtime está finalizando los objetos que contiene.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1810">Indicates whether this application domain is unloading, and the objects it contains are being finalized by the common language runtime.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1811">Es <see langword="true" /> si se está descargando este dominio de aplicación y si Common Language Runtime comenzó el proceso de invocación de los finalizadores; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1811"><see langword="true" /> if this application domain is unloading and the common language runtime has started invoking finalizers; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1812">El método de finalización de un objeto proporciona una oportunidad para realizar cualquier operación de limpieza necesaria antes de que el objeto se recopila.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1812">The finalization method for an object provides you an opportunity to perform any necessary cleanup operations before the object is garbage collected.</span></span> <span data-ttu-id="c0a0d-1813">Después de la finalización, el objeto es accesible, pero en un estado no válido y, por tanto, no utilizable.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1813">After finalization, the object is accessible but in an invalid state and therefore unusable.</span></span> <span data-ttu-id="c0a0d-1814">Finalmente, colección de elementos no utilizados completa y reclama el objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1814">Eventually, garbage collection completes and reclaims the object.</span></span>  
  
 <span data-ttu-id="c0a0d-1815">Se llama el método de finalización de un objeto en una de las siguientes situaciones: durante la recolección de elementos no utilizados, cuando common language runtime se está cerrando, o cuando se descarga el dominio de aplicación que contiene el objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1815">An object's finalization method is called in one of the following situations: during garbage collection, when the common language runtime is shutting down, or when the application domain that contains the object is unloaded.</span></span> <span data-ttu-id="c0a0d-1816">El <xref:System.AppDomain.IsFinalizingForUnload%2A> devuelve del método `true` sólo en el último caso; no devolver `true` si da como resultado de finalización de la rutina de recolección o de apagado CLR.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1816">The <xref:System.AppDomain.IsFinalizingForUnload%2A> method returns `true` only in the last case; it does not return `true` if finalization results from routine garbage collection or from CLR shutdown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1817">Para determinar si la finalización es debido al cierre del CLR, use el <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1817">To determine whether finalization is due to CLR shutdown, use the <xref:System.Environment.HasShutdownStarted%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c0a0d-1818">Devuelve `true` si tiene lugar la finalización es debido a un dominio de aplicación que se está descargando o al CLR que se va a cerrar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1818">It returns `true` if finalization is due to an application domain being unloaded or to the CLR shutting down.</span></span>  
  
 <span data-ttu-id="c0a0d-1819">Mientras se ejecutan en el método de finalización durante la descarga del dominio, puede tener acceso a otro objeto que se hace referencia a un campo estático y tiene un método de finalización.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1819">While executing in your finalization method during domain unloading, you might want to access another object that is referenced by a static field and has a finalization method.</span></span> <span data-ttu-id="c0a0d-1820">Sin embargo, no puede confiable hacerlo porque el objeto que se accede podría haber finalizado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1820">However, you cannot reliably do so because the accessed object might already have been finalized.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1821">Una excepción a esta regla es la <xref:System.Console> (clase), que contiene los campos estáticos que hacen referencia a objetos de secuencia, pero se implementa especialmente por lo que siempre puede escribir en la consola del sistema, incluso durante el cierre del dominio de descarga o el sistema.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1821">An exception to this rule is the <xref:System.Console> class, which contains static fields that reference stream objects, but is implemented specially so you can always write to the system console, even during domain unloading or system shutdown.</span></span>  
  
 <span data-ttu-id="c0a0d-1822">Utilice este método en el método de finalización de un objeto para determinar si se está descargando el dominio de aplicación que contiene el objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1822">Use this method in an object's finalization method to determine whether the application domain that contains the object is unloading.</span></span> <span data-ttu-id="c0a0d-1823">Si es así, no se puede tener acceso a cualquier objeto que tiene un método de finalización y se hace referencia a un campo estático confiable.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1823">If that is the case, you cannot reliably access any object that has a finalization method and is referenced by a static field.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Environment.HasShutdownStarted" />
      </Docs>
    </Member>
    <Member MemberName="IsFullyTrusted">
      <MemberSignature Language="C#" Value="public bool IsFullyTrusted { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsFullyTrusted" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsFullyTrusted" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsFullyTrusted As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsFullyTrusted { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsFullyTrusted : bool" Usage="System.AppDomain.IsFullyTrusted" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1824">Obtiene un valor que indica si los ensamblados que se cargan en el dominio de aplicación actual se ejecutan con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1824">Gets a value that indicates whether assemblies that are loaded into the current application domain execute with full trust.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1825">Es <see langword="true" /> si los ensamblados que se cargan en el dominio de aplicación actual se ejecutan con plena confianza; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1825"><see langword="true" /> if assemblies that are loaded into the current application domain execute with full trust; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1826">Este método siempre devuelve `true` para el dominio de aplicación predeterminado de una aplicación que se ejecuta en el escritorio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1826">This method always returns `true` for the default application domain of an application that runs on the desktop.</span></span> <span data-ttu-id="c0a0d-1827">Devuelve `false` para un dominio de aplicación en espacio aislado que se creó mediante el <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método, a menos que los permisos que se conceden al dominio de aplicación son equivalentes a plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1827">It returns `false` for a sandboxed application domain that was created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload, unless the permissions that are granted to the application domain are equivalent to full trust.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1828">En el ejemplo siguiente se muestra el <xref:System.AppDomain.IsFullyTrusted%2A> propiedad y el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> propiedad con dominios de aplicación de plena confianza y confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1828">The following example demonstrates the <xref:System.AppDomain.IsFullyTrusted%2A> property and the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> property with fully trusted and partially trusted application domains.</span></span> <span data-ttu-id="c0a0d-1829">El dominio de aplicación de plena confianza es el dominio de aplicación predeterminado para la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1829">The fully trusted application domain is the default application domain for the application.</span></span> <span data-ttu-id="c0a0d-1830">Se crea el dominio de aplicación de confianza parcial mediante la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1830">The partially trusted application domain is created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span>  
  
 <span data-ttu-id="c0a0d-1831">El ejemplo se usa un `Worker` clase que derive de <xref:System.MarshalByRefObject>, por lo que se pueden calcular las referencias entre los límites del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1831">The example uses a `Worker` class that derives from <xref:System.MarshalByRefObject>, so it can be marshaled across application domain boundaries.</span></span> <span data-ttu-id="c0a0d-1832">El ejemplo se crea un `Worker` objeto en el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1832">The example creates a `Worker` object in the default application domain.</span></span> <span data-ttu-id="c0a0d-1833">A continuación, llama el `TestIsFullyTrusted` método para mostrar el valor de propiedad del dominio de aplicación y de dos ensamblados que se cargan en el dominio de aplicación: mscorlib, que forma parte de .NET Framework y el ensamblado de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1833">It then calls the `TestIsFullyTrusted` method to display the property value for the application domain and for two assemblies that are loaded into the application domain: mscorlib, which is part of the .NET Framework, and the example assembly.</span></span> <span data-ttu-id="c0a0d-1834">El dominio de aplicación es de plena confianza, por lo que ambos ensamblados son de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1834">The application domain is fully trusted, so both assemblies are fully trusted.</span></span>  
  
 <span data-ttu-id="c0a0d-1835">En el ejemplo se crea otro `Worker` objeto en un dominio de aplicación en espacio aislado y llama de nuevo el `TestIsFullyTrusted` método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1835">The example creates another `Worker` object in a sandboxed application domain and again calls the `TestIsFullyTrusted` method.</span></span> <span data-ttu-id="c0a0d-1836">Mscorlib siempre es de confianza, incluso en un dominio de aplicación de confianza parcial, pero el ensamblado de ejemplo es de confianza parcial.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1836">Mscorlib is always trusted, even in a partially trusted application domain, but the example assembly is partially trusted.</span></span>  
  
 [!code-csharp[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/cs/example.cs#1)]
 [!code-vb[System.AppDomain.IsFullyTrusted#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.isfullytrusted/vb/example.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsHomogenous">
      <MemberSignature Language="C#" Value="public bool IsHomogenous { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsHomogenous" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.IsHomogenous" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsHomogenous As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsHomogenous { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsHomogenous : bool" Usage="System.AppDomain.IsHomogenous" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1837">Obtiene un valor que indica si el dominio de aplicación actual tiene un conjunto de permisos concedido a todos los ensamblados que se cargan en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1837">Gets a value that indicates whether the current application domain has a set of permissions that is granted to all assemblies that are loaded into the application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-1838">Es <see langword="true" /> si el dominio de aplicación actual tiene un conjunto homogéneo de permisos; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1838"><see langword="true" /> if the current application domain has a homogenous set of permissions; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1839">Esta propiedad devuelve `true` para dominios de aplicación en espacio aislado que se crearon con la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1839">This property returns `true` for sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="c0a0d-1840">Dominios de aplicación en espacio aislado tienen un conjunto homogéneo de permisos; es decir, el mismo conjunto de permisos se concede a todos los ensamblados de confianza parcial que se cargan en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1840">Sandboxed application domains have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="c0a0d-1841">Un dominio de aplicación en espacio aislado, opcionalmente, tiene una lista de ensamblados con nombre seguro que están exentos de este conjunto de permisos y en su lugar se ejecute con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1841">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 <span data-ttu-id="c0a0d-1842">Plena confianza para el código puede utilizar el <xref:System.AppDomain.PermissionSet%2A> propiedad para determinar el conjunto de permisos homogéneo de un dominio de aplicación en espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1842">Fully trusted code can use the <xref:System.AppDomain.PermissionSet%2A> property to determine the homogenous grant set of a sandboxed application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1843">Esta propiedad devuelve también `true` para el dominio de aplicación predeterminado de una aplicación de escritorio, porque ese dominio de aplicación concede plena confianza a todos los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1843">This property also returns `true` for the default application domain of a desktop application, because that application domain grants full trust to all assemblies.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.AppDomain.PermissionSet" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Load">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-1844">Carga un <see cref="T:System.Reflection.Assembly" /> en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1844">Loads an <see cref="T:System.Reflection.Assembly" /> into this application domain.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load rawAssembly" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="c0a0d-1845">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1845">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1846">Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1846">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1847">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1847">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1848">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1848">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1849">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1849">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1850">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1850">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1851">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1851">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1852">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1852">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1853">El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1853">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="c0a0d-1854">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1854">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1855">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1855">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1856">El valor de <paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1856"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1857"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1857"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1858">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1858">-or-</span></span> 
<span data-ttu-id="c0a0d-1859">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1859">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1860">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1860">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1861">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1861">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1862">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1862">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1863">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1863">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyRef" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="c0a0d-1864">Objeto que describe el ensamblado que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1864">An object that describes the assembly to load.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1865">Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1865">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1866">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1866">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1867">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1867">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1868">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1868">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1869">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1869">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1870">Si ya se ha cargado una versión del ensamblado solicitado, este método devuelve el ensamblado cargado, incluso si se solicita una versión diferente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1870">If a version of the requested assembly is already loaded, this method returns the loaded assembly, even if a different version is requested.</span></span>  
  
 <span data-ttu-id="c0a0d-1871">Proporcionar un nombre de ensamblado parciales para `assemblyRef` no se recomienda.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1871">Supplying a partial assembly name for `assemblyRef` is not recommended.</span></span> <span data-ttu-id="c0a0d-1872">(Un nombre parcial omite uno o varios de la referencia cultural, versión o token de clave pública.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1872">(A partial name omits one or more of culture, version, or public key token.</span></span> <span data-ttu-id="c0a0d-1873">Para las sobrecargas que toman una cadena en lugar de un <xref:System.Reflection.AssemblyName> objeto, "MyAssembly, Version = 1.0.0.0" es un ejemplo de un nombre parcial y "MyAssembly, Version = 1.0.0.0, Culture = neutral, PublicKeyToken = 18ab3442da84b47" es un ejemplo de un nombre completo.) Uso de nombres parciales tiene un efecto negativo en el rendimiento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1873">For overloads that take a string instead of an <xref:System.Reflection.AssemblyName> object, "MyAssembly, Version=1.0.0.0" is an example of a partial name and "MyAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=18ab3442da84b47" is an example of a full name.) Using partial names has a negative effect on performance.</span></span> <span data-ttu-id="c0a0d-1874">Además, un nombre de ensamblado parcial puede cargar un ensamblado de la caché global de ensamblados solo si hay una copia exacta del ensamblado en el directorio de base de la aplicación (<xref:System.AppDomain.BaseDirectory%2A> o <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1874">In addition, a partial assembly name can load an assembly from the global assembly cache only if there is an exact copy of the assembly in the application base directory (<xref:System.AppDomain.BaseDirectory%2A> or <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>).</span></span>  
  
 <span data-ttu-id="c0a0d-1875">Si el actual <xref:System.AppDomain> objeto representa el dominio de aplicación `A`y el <xref:System.AppDomain.Load%2A> se llama al método desde el dominio de aplicación `B`, el ensamblado se carga en ambos dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1875">If the current <xref:System.AppDomain> object represents application domain `A`, and the <xref:System.AppDomain.Load%2A> method is called from application domain `B`, the assembly is loaded into both application domains.</span></span> <span data-ttu-id="c0a0d-1876">Por ejemplo, el siguiente código carga `MyAssembly` en el nuevo dominio de aplicación `ChildDomain` y también en el dominio de aplicación donde se ejecuta el código:</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1876">For example, the following code loads `MyAssembly` into the new application domain `ChildDomain` and also into the application domain where the code executes:</span></span>  
  
 [!code-cpp[System.AppDomain.Load#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.appdomain.load/cpp/source.cpp#1)]
 [!code-csharp[System.AppDomain.Load#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.appdomain.load/cs/source.cs#1)]
 [!code-vb[System.AppDomain.Load#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.appdomain.load/vb/source.vb#1)]  
  
 <span data-ttu-id="c0a0d-1877">El ensamblado se carga en ambos dominios porque <xref:System.Reflection.Assembly> no se deriva de <xref:System.MarshalByRefObject>y por lo tanto, el valor devuelto de la <xref:System.AppDomain.Load%2A> método no se pueden serializar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1877">The assembly is loaded into both domains because <xref:System.Reflection.Assembly> does not derive from <xref:System.MarshalByRefObject>, and therefore the return value of the <xref:System.AppDomain.Load%2A> method cannot be marshaled.</span></span> <span data-ttu-id="c0a0d-1878">En su lugar, common language runtime intenta cargar el ensamblado en el dominio de aplicación que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1878">Instead, the common language runtime tries to load the assembly into the calling application domain.</span></span> <span data-ttu-id="c0a0d-1879">Los ensamblados que se cargan en los dos dominios de aplicación pueden ser diferentes si los valores de ruta de acceso para los dos dominios de aplicación son diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1879">The assemblies that are loaded into the two application domains might be different if the path settings for the two application domains are different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-1880">Si tanto el <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> propiedad y el <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> propiedad se establece, el primer intento de cargar el ensamblado utiliza el nombre para mostrar (incluida la versión, referencia cultural y así sucesivamente, tal como lo devuelve el <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1880">If both the <xref:System.Reflection.AssemblyName.Name%2A?displayProperty=nameWithType> property and the <xref:System.Reflection.AssemblyName.CodeBase%2A?displayProperty=nameWithType> property are set, the first attempt to load the assembly uses the display name (including version, culture, and so on, as returned by the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property).</span></span> <span data-ttu-id="c0a0d-1881">Si no se encuentra el archivo, el <xref:System.Reflection.AssemblyName.CodeBase%2A> propiedad se utiliza para buscar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1881">If the file is not found, the <xref:System.Reflection.AssemblyName.CodeBase%2A> property is used to search for the assembly.</span></span> <span data-ttu-id="c0a0d-1882">Si se encuentra el ensamblado mediante <xref:System.Reflection.AssemblyName.CodeBase%2A>, el nombre para mostrar se compara con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1882">If the assembly is found using <xref:System.Reflection.AssemblyName.CodeBase%2A>, the display name is matched against the assembly.</span></span> <span data-ttu-id="c0a0d-1883">Si se produce un error en la coincidencia, un <xref:System.IO.FileLoadException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1883">If the match fails, a <xref:System.IO.FileLoadException> is thrown.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1884">El valor de <paramref name="assemblyRef" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1884"><paramref name="assemblyRef" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1885">No se ha encontrado <paramref name="assemblyRef" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1885"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1886"><paramref name="assemblyRef" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1886"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1887">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1887">-or-</span></span> 
<span data-ttu-id="c0a0d-1888">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1888">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1889">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1889">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1890">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1890">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1891">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1891">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1892">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1892">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString);" />
      <MemberSignature Language="F#" Value="abstract member Load : string -&gt; System.Reflection.Assembly&#xA;override this.Load : string -&gt; System.Reflection.Assembly" Usage="appDomain.Load assemblyString" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="c0a0d-1893">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1893">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1894">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1894">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1895">Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su nombre de presentación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1895">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1896">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1896">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1897">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1897">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1898">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1898">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1899">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1899">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1900">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1900">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1901"><paramref name="assemblyString" /> es <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-1901"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1902">No se ha encontrado <paramref name="assemblyString" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1902"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1903"><paramref name="assemblyString" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1903"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1904">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1904">-or-</span></span> 
<span data-ttu-id="c0a0d-1905">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1905">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1906">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1906">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1907">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1907">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1908">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1908">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1909">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1909">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1910">Para poder acceder a la ubicación del ensamblado si el ensamblado no es local.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1910">for the ability to access the location of the assembly if the assembly is not local.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte()) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="c0a0d-1911">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1911">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="c0a0d-1912">Matriz de tipo <see langword="byte" /> que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1912">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1913">Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1913">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="c0a0d-1914">También se cargan los bytes sin formato que representan los símbolos del <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1914">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1915">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1915">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1916">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1916">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1917">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1917">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1918">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1918">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1919">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1919">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1920">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1920">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1921">El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1921">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="c0a0d-1922">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1922">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1923">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1923">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1924">El valor de <paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1924"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1925"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1925"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1926">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1926">-or-</span></span> 
<span data-ttu-id="c0a0d-1927">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1927">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1928">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1928">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1929">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1929">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1930">para leer un URI que no comienzan con "file://".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1930">for reading a URI that does not begin with "file://".</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1931">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1931">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1932">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1932">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (System.Reflection.AssemblyName assemblyRef, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(class System.Reflection.AssemblyName assemblyRef, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyRef As AssemblyName, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::Reflection::AssemblyName ^ assemblyRef, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : System.Reflection.AssemblyName * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyRef, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Reflection.AssemblyName,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyRef" Type="System.Reflection.AssemblyName" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyRef"><span data-ttu-id="c0a0d-1933">Objeto que describe el ensamblado que se va a cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1933">An object that describes the assembly to load.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1934">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1934">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1935">Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1935">Loads an <see cref="T:System.Reflection.Assembly" /> given its <see cref="T:System.Reflection.AssemblyName" />.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1936">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1936">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1937">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1937">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1938">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1938">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1939">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1939">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1940">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1940">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1941"><paramref name="assemblyRef" /> es <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-1941"><paramref name="assemblyRef" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1942">No se ha encontrado <paramref name="assemblyRef" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1942"><paramref name="assemblyRef" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1943"><paramref name="assemblyRef" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1943"><paramref name="assemblyRef" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1944">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1944">-or-</span></span> 
<span data-ttu-id="c0a0d-1945">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyRef" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1945">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyRef" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1946">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1946">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1947">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1947">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1948">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1948">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1949">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1949">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1950">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1950">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1951">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1951">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1952">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1952">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (string assemblyString, System.Security.Policy.Evidence assemblySecurity);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(string assemblyString, class System.Security.Policy.Evidence assemblySecurity) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.String,System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (assemblyString As String, assemblySecurity As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(System::String ^ assemblyString, System::Security::Policy::Evidence ^ assemblySecurity);" />
      <MemberSignature Language="F#" Value="abstract member Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : string * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (assemblyString, assemblySecurity)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.String,System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="assemblyString" Type="System.String" />
        <Parameter Name="assemblySecurity" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="assemblyString"><span data-ttu-id="c0a0d-1953">Nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1953">The display name of the assembly.</span></span> <span data-ttu-id="c0a0d-1954">Vea <see cref="P:System.Reflection.Assembly.FullName" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1954">See <see cref="P:System.Reflection.Assembly.FullName" />.</span></span></param>
        <param name="assemblySecurity"><span data-ttu-id="c0a0d-1955">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1955">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1956">Carga un <see cref="T:System.Reflection.Assembly" /> a partir de su nombre de presentación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1956">Loads an <see cref="T:System.Reflection.Assembly" /> given its display name.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1957">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1957">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1958">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1958">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1959">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1959">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1960">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1960">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1961">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1961">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1962"><paramref name="assemblyString" /> es <see langword="null" /></span><span class="sxs-lookup"><span data-stu-id="c0a0d-1962"><paramref name="assemblyString" /> is <see langword="null" /></span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="c0a0d-1963">No se ha encontrado <paramref name="assemblyString" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1963"><paramref name="assemblyString" /> is not found.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1964"><paramref name="assemblyString" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1964"><paramref name="assemblyString" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1965">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1965">-or-</span></span> 
<span data-ttu-id="c0a0d-1966">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="assemblyString" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1966">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="assemblyString" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1967">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1967">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1968">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1968">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1969">para cargar un ensamblado con la evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1969">to load an assembly with evidence.</span></span> <span data-ttu-id="c0a0d-1970">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1970">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1971">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1971">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-1972">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1972">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-1973">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1973">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Load">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly Load (byte[] rawAssembly, byte[] rawSymbolStore, System.Security.Policy.Evidence securityEvidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.Assembly Load(unsigned int8[] rawAssembly, unsigned int8[] rawSymbolStore, class System.Security.Policy.Evidence securityEvidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)" />
      <MemberSignature Language="VB.NET" Value="Public Function Load (rawAssembly As Byte(), rawSymbolStore As Byte(), securityEvidence As Evidence) As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::Assembly ^ Load(cli::array &lt;System::Byte&gt; ^ rawAssembly, cli::array &lt;System::Byte&gt; ^ rawSymbolStore, System::Security::Policy::Evidence ^ securityEvidence);" />
      <MemberSignature Language="F#" Value="abstract member Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly&#xA;override this.Load : byte[] * byte[] * System.Security.Policy.Evidence -&gt; System.Reflection.Assembly" Usage="appDomain.Load (rawAssembly, rawSymbolStore, securityEvidence)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Load(System.Byte[],System.Byte[],System.Security.Policy.Evidence)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use an overload that does not take an Evidence parameter")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("Methods which use evidence to sandbox are obsolete and will be removed in a future release of the .NET Framework. Please use an overload of Load which does not take an Evidence parameter. See http://go.microsoft.com/fwlink/?LinkId=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rawAssembly" Type="System.Byte[]" />
        <Parameter Name="rawSymbolStore" Type="System.Byte[]" />
        <Parameter Name="securityEvidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="rawAssembly"><span data-ttu-id="c0a0d-1974">Matriz de tipo <see langword="byte" /> que es una imagen basada en COFF que contiene un ensamblado emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1974">An array of type <see langword="byte" /> that is a COFF-based image containing an emitted assembly.</span></span></param>
        <param name="rawSymbolStore"><span data-ttu-id="c0a0d-1975">Matriz de tipo <see langword="byte" /> que contiene los bytes sin formato que representan los símbolos del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1975">An array of type <see langword="byte" /> containing the raw bytes representing the symbols for the assembly.</span></span></param>
        <param name="securityEvidence"><span data-ttu-id="c0a0d-1976">Evidencia para cargar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1976">Evidence for loading the assembly.</span></span></param>
        <summary><span data-ttu-id="c0a0d-1977">Carga el <see cref="T:System.Reflection.Assembly" /> con una imagen basada en el formato COFF (Common Object File Format) que contiene un <see cref="T:System.Reflection.Assembly" /> emitido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1977">Loads the <see cref="T:System.Reflection.Assembly" /> with a common object file format (COFF) based image containing an emitted <see cref="T:System.Reflection.Assembly" />.</span></span> <span data-ttu-id="c0a0d-1978">También se cargan los bytes sin formato que representan los símbolos del <see cref="T:System.Reflection.Assembly" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1978">The raw bytes representing the symbols for the <see cref="T:System.Reflection.Assembly" /> are also loaded.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-1979">Ensamblado cargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1979">The loaded assembly.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-1980">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el nivel de confianza de un ensamblado que se carga mediante el uso de este método es el mismo que el nivel de confianza del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1980">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the trust level of an assembly that is loaded by using this method is the same as the trust level of the application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-1981">Este método debe usarse solo para cargar un ensamblado en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1981">This method should be used only to load an assembly into the current application domain.</span></span> <span data-ttu-id="c0a0d-1982">Este método se proporciona como una comodidad para los llamadores de interoperabilidad que no se pueden llamar a estático <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1982">This method is provided as a convenience for interoperability callers who cannot call the static <xref:System.Reflection.Assembly.Load%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c0a0d-1983">Para cargar ensamblados en otros dominios de aplicación, use un método como <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1983">To load assemblies into other application domains, use a method such as <xref:System.AppDomain.CreateInstanceAndUnwrap%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-1984">Para obtener información que es común a todas las sobrecargas de este método, consulte el <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1984">For information that is common to all overloads of this method, see the <xref:System.AppDomain.Load%28System.Reflection.AssemblyName%29> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-1985">El ejemplo siguiente muestra el uso de la carga de un ensamblado sin procesar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1985">The following sample demonstrates the use of loading a raw assembly.</span></span>  
  
 <span data-ttu-id="c0a0d-1986">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1986">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-1987">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1987">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_LoadRaw#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_LoadRaw/CPP/loadraw.cpp#1)]
 [!code-csharp[AppDomain_LoadRaw#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_LoadRaw/CS/loadraw.cs#1)]
 [!code-vb[AppDomain_LoadRaw#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_LoadRaw/VB/loadraw.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-1988">El valor de <paramref name="rawAssembly" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1988"><paramref name="rawAssembly" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="c0a0d-1989"><paramref name="rawAssembly" /> no es un ensamblado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1989"><paramref name="rawAssembly" /> is not a valid assembly.</span></span>  
  
<span data-ttu-id="c0a0d-1990">O bien</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1990">-or-</span></span> 
<span data-ttu-id="c0a0d-1991">La versión 2.0 u otra posterior de Common Language Runtime está cargada actualmente y <paramref name="rawAssembly" /> se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1991">Version 2.0 or later of the common language runtime is currently loaded and <paramref name="rawAssembly" /> was compiled with a later version.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-1992">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1992">The operation is attempted on an unloaded application domain.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="c0a0d-1993">Se cargó un ensamblado o módulo dos veces con dos evidencias diferentes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1993">An assembly or module was loaded twice with two different evidences.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c0a0d-1994"><paramref name="securityEvidence" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1994"><paramref name="securityEvidence" /> is not <see langword="null" />.</span></span> <span data-ttu-id="c0a0d-1995">Cuando no se habilita la directiva CAS heredada, <paramref name="securityEvidence" /> debe ser <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1995">When legacy CAS policy is not enabled, <paramref name="securityEvidence" /> should be <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-1996">para proporcionar evidencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1996">to provide evidence.</span></span> <span data-ttu-id="c0a0d-1997">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1997">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlEvidence" />.</span></span> <span data-ttu-id="c0a0d-1998">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1998">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-1999">Para obtener acceso desde un archivo o directorio y para tener acceso a la información de la ruta de acceso de lectura.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-1999">for access to read from a file or directory, and for access to the information in the path itself.</span></span> <span data-ttu-id="c0a0d-2000">Enumeraciones asociadas: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2000">Associated enumerations: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.Read" />, <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <permission cref="T:System.Net.WebPermission"><span data-ttu-id="c0a0d-2001">para leer una ruta de acceso que no está en el formulario "file://" o "\\\UNC\dir\\" o "c:\\".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2001">for reading a path that is not in the form "file://" or "\\\UNC\dir\\" or "c:\\".</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="MonitoringIsEnabled">
      <MemberSignature Language="C#" Value="public static bool MonitoringIsEnabled { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property bool MonitoringIsEnabled" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringIsEnabled" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property MonitoringIsEnabled As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool MonitoringIsEnabled { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringIsEnabled : bool with get, set" Usage="System.AppDomain.MonitoringIsEnabled" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2002">Obtiene o establece un valor que indica si la supervisión de la CPU y de la memoria del dominio de aplicación está habilitada para el proceso actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2002">Gets or sets a value that indicates whether CPU and memory monitoring of application domains is enabled for the current process.</span></span> <span data-ttu-id="c0a0d-2003">Una vez que se habilita la supervisión para un proceso, no se puede deshabilitar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2003">Once monitoring is enabled for a process, it cannot be disabled.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2004">Es <see langword="true" /> si la supervisión está habilitada; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2004"><see langword="true" /> if monitoring is enabled; otherwise <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2005">Esto `static` propiedad (`Shared` propiedad en Visual Basic) controla la CPU y memoria de supervisión de todos los dominios de aplicación en el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2005">This `static` property (`Shared` property in Visual Basic) controls CPU and memory monitoring of all the application domains in the process.</span></span>  
  
 <span data-ttu-id="c0a0d-2006">Si se intenta establecer esta propiedad en `false`, un <xref:System.ArgumentException> se produce la excepción, incluso si el valor actual de la propiedad es `false`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2006">If you attempt to set this property to `false`, a <xref:System.ArgumentException> exception is thrown, even if the current value of the property is `false`.</span></span>  
  
 <span data-ttu-id="c0a0d-2007">Una vez habilitada la supervisión, puede usar el <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, y <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> propiedades para supervisar el uso de CPU y memoria de dominios de aplicación individuales de la instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2007">Once monitoring is enabled, you can use the <xref:System.AppDomain.MonitoringSurvivedMemorySize%2A>, <xref:System.AppDomain.MonitoringSurvivedProcessMemorySize%2A>, <xref:System.AppDomain.MonitoringTotalAllocatedMemorySize%2A>, and <xref:System.AppDomain.MonitoringTotalProcessorTime%2A> instance properties to monitor CPU and memory use of individual application domains.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c0a0d-2008">El proceso actual ha intentado asignar el valor <see langword="false" /> a esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2008">The current process attempted to assign the value <see langword="false" /> to this property.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2009">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2009">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2010">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2010">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="c0a0d-2011">Supervisión de recursos de dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2011">Application Domain Resource Monitoring</span></span></related>
        <related type="Article" href="https://msdn.microsoft.com/library/02119ab6-1e91-448e-97ad-e7b2e5c4bbbd"><span data-ttu-id="c0a0d-2012">&lt;appdomainResourceMonitoring&gt; elemento</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2012">&lt;appdomainResourceMonitoring&gt; Element</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringSurvivedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringSurvivedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringSurvivedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringSurvivedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2013">Obtiene el número de bytes que sobrevivieron a la última recolección y a la que se sabe que hace referencia el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2013">Gets the number of bytes that survived the last collection and that are known to be referenced by the current application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2014">Número de bytes supervivientes.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2014">The number of surviving bytes.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2015">Las estadísticas se actualizan con cada recolección de elementos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2015">The statistics are updated with each garbage collection.</span></span> <span data-ttu-id="c0a0d-2016">Sin embargo, se garantiza que sea precisa solo después de una recolección completa de bloqueo; es decir, se produce una colección que incluye todas las generaciones y que detiene la aplicación mientras la colección.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2016">However, they are guaranteed to be accurate only after a full, blocking collection; that is, a collection that includes all generations and that stops the application while collection occurs.</span></span> <span data-ttu-id="c0a0d-2017">Por ejemplo, el <xref:System.GC.Collect?displayProperty=nameWithType> sobrecarga del método realiza una recolección completa de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2017">For example, the <xref:System.GC.Collect?displayProperty=nameWithType> method overload performs a full, blocking collection.</span></span> <span data-ttu-id="c0a0d-2018">(Colección simultánea se produce en segundo plano y no bloquea la aplicación).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2018">(Concurrent collection occurs in the background and does not block the application.)</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-2019">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2019">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2020">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2020">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2021">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2021">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="c0a0d-2022">Supervisión de recursos de dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2022">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringSurvivedProcessMemorySize">
      <MemberSignature Language="C#" Value="public static long MonitoringSurvivedProcessMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int64 MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MonitoringSurvivedProcessMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property long MonitoringSurvivedProcessMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringSurvivedProcessMemorySize : int64" Usage="System.AppDomain.MonitoringSurvivedProcessMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2023">Obtiene los bytes totales que sobrevivieron a la última recolección para todos los dominios de aplicación del proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2023">Gets the total bytes that survived from the last collection for all application domains in the process.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2024">Número total de bytes supervivientes para el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2024">The total number of surviving bytes for the process.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2025">Después de una recolección completa, bloquea, este número representa el número de bytes actualmente mantienen activos en administra montones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2025">After a full, blocking collection, this number represents the number of bytes currently held live on managed heaps.</span></span> <span data-ttu-id="c0a0d-2026">Debe ser casi el número notificado por el <xref:System.GC.GetTotalMemory%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2026">It should be close to the number reported by the <xref:System.GC.GetTotalMemory%2A> method.</span></span> <span data-ttu-id="c0a0d-2027">Después de una recolección efímera, este número representa el número de bytes actualmente mantiene activo en generaciones efímeras.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2027">After an ephemeral collection, this number represents the number of bytes currently held live in ephemeral generations.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-2028">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2028">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2029">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2029">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2030">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2030">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="c0a0d-2031">Supervisión de recursos de dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2031">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalAllocatedMemorySize">
      <MemberSignature Language="C#" Value="public long MonitoringTotalAllocatedMemorySize { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalAllocatedMemorySize As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long MonitoringTotalAllocatedMemorySize { long get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalAllocatedMemorySize : int64" Usage="System.AppDomain.MonitoringTotalAllocatedMemorySize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2032">Obtiene el tamaño total, en bytes, de todas las asignaciones de memoria realizadas por el dominio de aplicación desde que se creó, sin restar la memoria recopilada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2032">Gets the total size, in bytes, of all memory allocations that have been made by the application domain since it was created, without subtracting memory that has been collected.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2033">Tamaño total de todas las asignaciones de memoria.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2033">The total size of all memory allocations.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-2034">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2034">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2035">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2035">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2036">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2036">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="c0a0d-2037">Supervisión de recursos de dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2037">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MonitoringTotalProcessorTime">
      <MemberSignature Language="C#" Value="public TimeSpan MonitoringTotalProcessorTime { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan MonitoringTotalProcessorTime" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MonitoringTotalProcessorTime As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan MonitoringTotalProcessorTime { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.MonitoringTotalProcessorTime : TimeSpan" Usage="System.AppDomain.MonitoringTotalProcessorTime" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2038">Obtiene el tiempo total de procesador usado por todos los subprocesos mientras se ejecutaban en el dominio de aplicación actual, desde que el proceso se inició.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2038">Gets the total processor time that has been used by all threads while executing in the current application domain, since the process started.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2039">Tiempo total de procesador para el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2039">Total processor time for the current application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2040">El tiempo total que se notifica para un dominio de aplicación incluye el tiempo dedicado a cada subproceso en el proceso de ejecutar en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2040">The total time that is reported for an application domain includes the time each thread in the process spent executing in that application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-2041">Un subproceso que llama a código no administrado aún está asociado a un dominio de aplicación y el tiempo de procesador dedicado a ejecutar que el código no administrado se notifica para el dominio de aplicación donde se realizó la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2041">A thread that calls into unmanaged code is still associated with an application domain, and the processor time spent executing the unmanaged code is reported for the application domain where the call was made.</span></span>  
  
 <span data-ttu-id="c0a0d-2042">Cuando un subproceso está bloqueado o en modo de suspensión, no consume tiempo de procesador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2042">When a thread is blocked or sleeping, it does not consume processor time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-2043">La propiedad <see langword="static" /> (<see langword="Shared" /> en Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> propiedad está establecida en <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2043">The <see langword="static" /> (<see langword="Shared" /> in Visual Basic) <see cref="P:System.AppDomain.MonitoringIsEnabled" /> property is set to <see langword="false" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2044">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2044">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2045">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2045">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="https://msdn.microsoft.com/library/318bedf8-7f35-4f00-b34a-2b7b8e3fa315"><span data-ttu-id="c0a0d-2046">Supervisión de recursos de dominio de aplicación</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2046">Application Domain Resource Monitoring</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="PermissionSet">
      <MemberSignature Language="C#" Value="public System.Security.PermissionSet PermissionSet { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Security.PermissionSet PermissionSet" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.PermissionSet" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PermissionSet As PermissionSet" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Security::PermissionSet ^ PermissionSet { System::Security::PermissionSet ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.PermissionSet : System.Security.PermissionSet" Usage="System.AppDomain.PermissionSet" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Security.PermissionSet</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2047">Obtiene el conjunto de permisos de un dominio de aplicación en un espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2047">Gets the permission set of a sandboxed application domain.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2048">Conjunto de permisos del dominio de aplicación en un espacio aislado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2048">The permission set of the sandboxed application domain.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2049">Dominios de aplicación en espacio aislado que se crearon con la <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> sobrecarga del método tienen un conjunto homogéneo de permisos; es decir, el mismo conjunto de permisos se concede a todos los ensamblados de confianza parcial que se cargan en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2049">Sandboxed application domains that were created by using the <xref:System.AppDomain.CreateDomain%28System.String%2CSystem.Security.Policy.Evidence%2CSystem.AppDomainSetup%2CSystem.Security.PermissionSet%2CSystem.Security.Policy.StrongName%5B%5D%29?displayProperty=nameWithType> method overload have a homogenous set of permissions; that is, the same set of permissions is granted to all partially trusted assemblies that are loaded into the application domain.</span></span> <span data-ttu-id="c0a0d-2050">Un dominio de aplicación en espacio aislado, opcionalmente, tiene una lista de ensamblados con nombre seguro que están exentos de este conjunto de permisos y en su lugar se ejecute con plena confianza.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2050">A sandboxed application domain optionally has a list of strong-named assemblies that are exempt from this permission set, and instead run with full trust.</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2051">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2051">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2052">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2052">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomain.IsHomogenous" />
      </Docs>
    </Member>
    <Member MemberName="ProcessExit">
      <MemberSignature Language="C#" Value="public event EventHandler ProcessExit;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler ProcessExit" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ProcessExit" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ProcessExit As EventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event EventHandler ^ ProcessExit;" />
      <MemberSignature Language="F#" Value="member this.ProcessExit : EventHandler " Usage="member this.ProcessExit : System.EventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ProcessExit</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>remove: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.EventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2053">Se produce al salir del proceso primario del dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2053">Occurs when the default application domain's parent process exits.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2054">El <xref:System.EventHandler> de este evento puede realizar actividades de terminación, como cerrar archivos, liberar almacenamiento, y así sucesivamente, antes de que finalice el proceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2054">The <xref:System.EventHandler> for this event can perform termination activities, such as closing files, releasing storage and so on, before the process ends.</span></span>  
  
 <span data-ttu-id="c0a0d-2055">A partir de la versión 2.0 de .NET Framework, este evento se produce en cada dominio de aplicación que registra un controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2055">Beginning with the .NET Framework version 2.0, this event is raised in each application domain that registers an event handler.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-2056">El tiempo de ejecución total de todos los <xref:System.AppDomain.ProcessExit> controladores de eventos es limitada, tal como el tiempo de ejecución total de todos los finalizadores se limita al proceso de cierre.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2056">The total execution time of all <xref:System.AppDomain.ProcessExit> event handlers is limited, just as the total execution time of all finalizers is limited at process shutdown.</span></span> <span data-ttu-id="c0a0d-2057">El valor predeterminado es de dos segundos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2057">The default is two seconds.</span></span> <span data-ttu-id="c0a0d-2058">Un host no administrado puede cambiar este tiempo de ejecución mediante una llamada a la [ICLRPolicyManager:: SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) método con el [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) valor de enumeración.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2058">An unmanaged host can change this execution time by calling the [ICLRPolicyManager::SetTimeout](~/docs/framework/unmanaged-api/hosting/iclrpolicymanager-settimeout-method.md) method with the [OPR_ProcessExit](~/docs/framework/unmanaged-api/hosting/eclroperation-enumeration.md) enumeration value.</span></span>  
  
 <span data-ttu-id="c0a0d-2059">En las versiones 1.0 y 1.1 de .NET Framework, este evento es sólo se desencadena en el dominio de aplicación predeterminado y solo si un controlador de eventos está registrado en el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2059">In the .NET Framework versions 1.0 and 1.1, this event is raised only in the default application domain, and only if an event handler is registered in the default application domain.</span></span>  
  
 <span data-ttu-id="c0a0d-2060">Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2060">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-2061">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2061">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyAssemblyResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ReflectionOnlyAssemblyResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ReflectionOnlyAssemblyResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event ResolveEventHandler ^ ReflectionOnlyAssemblyResolve;" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyAssemblyResolve : ResolveEventHandler " Usage="member this.ReflectionOnlyAssemblyResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2062">Aparece cuando se produce un error en la resolución de un ensamblado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2062">Occurs when the resolution of an assembly fails in the reflection-only context.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2063">En el contexto de solo reflexión, no se resuelven automáticamente las dependencias.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2063">In the reflection-only context, dependencies are not resolved automatically.</span></span> <span data-ttu-id="c0a0d-2064">Debe cargar previamente o devuelto por el controlador para este evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2064">They must be preloaded or returned by the handler for this event.</span></span> <span data-ttu-id="c0a0d-2065">Este evento se desencadena cuando un ensamblado tiene una dependencia que ya no está cargada en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2065">This event is raised when an assembly has a dependency that is not already loaded into the reflection-only context.</span></span> <span data-ttu-id="c0a0d-2066">La falta de dependencia especificado por el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2066">The missing dependency is specified by the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c0a0d-2067">El <xref:System.ResolveEventHandler> para este evento debe devolver un ensamblado que cumpla la dependencia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2067">The <xref:System.ResolveEventHandler> for this event must return an assembly that satisfies the dependency.</span></span> <span data-ttu-id="c0a0d-2068">El ensamblado que se devuelve se debe cargar en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2068">The assembly that is returned must be loaded into the reflection-only context.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-2069">Este evento se genera solo para las dependencias que faltan del ensamblado que se va a cargar en el contexto de solo reflexión (por ejemplo, mediante el <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> método).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2069">This event is raised only for missing dependencies of the assembly that you are loading into the reflection-only context (for example, by using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A?displayProperty=nameWithType> method).</span></span> <span data-ttu-id="c0a0d-2070">No se genera si no se encuentra el ensamblado que va a cargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2070">It is not raised if the assembly that you are loading cannot be found.</span></span>  
  
 <span data-ttu-id="c0a0d-2071">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad devuelve el ensamblado que solicitó la carga del ensamblado que no se pudo resolver.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2071">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property returns the assembly that requested the assembly load that could not be resolved.</span></span> <span data-ttu-id="c0a0d-2072">Conocer la identidad del ensamblado que realiza solicitud podría ser útil para identificar la versión correcta de la dependencia, si más de una versión está disponible.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2072">Knowing the identity of the requesting assembly might be useful in identifying the correct version of the dependency, if more than one version is available.</span></span> <span data-ttu-id="c0a0d-2073">Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2073">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-2074">Para este evento, el <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> propiedad devuelve el nombre del ensamblado antes de que se aplica la directiva.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2074">For this event, the <xref:System.ResolveEventArgs.Name%2A?displayProperty=nameWithType> property returns the assembly name before policy is applied.</span></span>  
  
 <span data-ttu-id="c0a0d-2075">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2075">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2076">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2076">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2077">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2077">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetAssemblies">
      <MemberSignature Language="C#" Value="public System.Reflection.Assembly[] ReflectionOnlyGetAssemblies ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.Assembly[] ReflectionOnlyGetAssemblies() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ReflectionOnlyGetAssemblies" />
      <MemberSignature Language="VB.NET" Value="Public Function ReflectionOnlyGetAssemblies () As Assembly()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Reflection::Assembly ^&gt; ^ ReflectionOnlyGetAssemblies();" />
      <MemberSignature Language="F#" Value="member this.ReflectionOnlyGetAssemblies : unit -&gt; System.Reflection.Assembly[]" Usage="appDomain.ReflectionOnlyGetAssemblies " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-2078">Devuelve los ensamblados que se han cargado en el contexto de solo reflexión del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2078">Returns the assemblies that have been loaded into the reflection-only context of the application domain.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-2079">Matriz de objetos <see cref="T:System.Reflection.Assembly" /> que representan los ensamblados cargados en el contexto de solo reflexión del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2079">An array of <see cref="T:System.Reflection.Assembly" /> objects that represent the assemblies loaded into the reflection-only context of the application domain.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2080">Este método devuelve los ensamblados que se han cargado en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2080">This method returns the assemblies that have been loaded into the reflection-only context.</span></span> <span data-ttu-id="c0a0d-2081">Para obtener los ensamblados que se han cargado para la ejecución, use el <xref:System.AppDomain.GetAssemblies%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2081">To get the assemblies that have been loaded for execution, use the <xref:System.AppDomain.GetAssemblies%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2082">En el ejemplo de código siguiente se carga el ensamblado System.dll en el contexto de ejecución y, a continuación, en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2082">The following code example loads the System.dll assembly into the execution context and then into the reflection-only context.</span></span> <span data-ttu-id="c0a0d-2083">El <xref:System.AppDomain.GetAssemblies%2A> y <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> métodos se usan para mostrar los ensamblados cargados en cada contexto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2083">The <xref:System.AppDomain.GetAssemblies%2A> and <xref:System.AppDomain.ReflectionOnlyGetAssemblies%2A> methods are used to display the assemblies loaded into each context.</span></span>  
  
 [!code-cpp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CPP/reflectiononly.cpp#1)]
 [!code-csharp[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/CS/reflectiononly.cs#1)]
 [!code-vb[AppDomain.ReflectionOnlyGetAssemblies#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain.ReflectionOnlyGetAssemblies/VB/reflectiononly.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2084">Se ha intentado realizar una operación en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2084">An operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="M:System.AppDomain.GetAssemblies" />
      </Docs>
    </Member>
    <Member MemberName="RelativeSearchPath">
      <MemberSignature Language="C#" Value="public string RelativeSearchPath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string RelativeSearchPath" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.RelativeSearchPath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RelativeSearchPath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ RelativeSearchPath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RelativeSearchPath : string" Usage="System.AppDomain.RelativeSearchPath" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.RelativeSearchPath</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2085">Obtiene la ruta de acceso del directorio base en que la resolución de ensamblado debe buscar ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2085">Gets the path under the base directory where the assembly resolver should probe for private assemblies.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2086">La ruta de acceso del directorio base en que la resolución de ensamblado debe buscar ensamblados privados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2086">The path under the base directory where the assembly resolver should probe for private assemblies.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2087">Los ensamblados privados se implementan en la misma estructura de directorio que la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2087">Private assemblies are deployed in the same directory structure as the application.</span></span> <span data-ttu-id="c0a0d-2088">Si la ruta de acceso especificada por el <xref:System.AppDomain.RelativeSearchPath%2A> propiedad no está bajo <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, se omite.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2088">If the path specified by the <xref:System.AppDomain.RelativeSearchPath%2A> property is not under <xref:System.AppDomainSetup.ApplicationBase%2A?displayProperty=nameWithType>, it is ignored.</span></span>  
  
 <span data-ttu-id="c0a0d-2089">Esta propiedad devuelve el valor establecido mediante <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2089">This property returns the value set using <xref:System.AppDomainSetup.PrivateBinPath%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2090">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2090">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.FileIOPermission"><span data-ttu-id="c0a0d-2091">Para obtener acceso a la información de ruta de acceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2091">for access to the path information.</span></span> <span data-ttu-id="c0a0d-2092">Enumeración asociada: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2092">Associated enumeration: <see cref="F:System.Security.Permissions.FileIOPermissionAccess.PathDiscovery" />.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.PrivateBinPath" />
      </Docs>
    </Member>
    <Member MemberName="ResourceResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler ResourceResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler ResourceResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.ResourceResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event ResourceResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ ResourceResolve;" />
      <MemberSignature Language="F#" Value="member this.ResourceResolve : ResolveEventHandler " Usage="member this.ResourceResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.ResourceResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2093">Aparece cuando se produce un error en la resolución de un recurso porque éste no es un recurso vinculado válido o incrustado en el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2093">Occurs when the resolution of a resource fails because the resource is not a valid linked or embedded resource in the assembly.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2094">El <xref:System.ResolveEventHandler> de este evento puede intentar localizar el ensamblado que contiene el recurso y devolverlo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2094">The <xref:System.ResolveEventHandler> for this event can attempt to locate the assembly containing the resource and return it.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="c0a0d-2095">Este evento no se produce si se produce un error en la resolución porque no se encuentra ningún archivo para un recurso vinculado válido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2095">This event is not raised if resolution fails because no file can be found for a valid linked resource.</span></span> <span data-ttu-id="c0a0d-2096">Se produce si no se encuentra una secuencia de recurso del manifiesto, pero no se genera si no se encuentra una clave de recurso individual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2096">It is raised if a manifest resource stream cannot be found, but it is not raised if an individual resource key cannot be found.</span></span>  
  
 <span data-ttu-id="c0a0d-2097">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad contiene el ensamblado que el recurso solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2097">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the resource.</span></span> <span data-ttu-id="c0a0d-2098">Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2098">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-2099">Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2099">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-2100">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2100">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2101">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2101">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2102">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2102">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="SetAppDomainPolicy">
      <MemberSignature Language="C#" Value="public void SetAppDomainPolicy (System.Security.Policy.PolicyLevel domainPolicy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetAppDomainPolicy(class System.Security.Policy.PolicyLevel domainPolicy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetAppDomainPolicy(System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetAppDomainPolicy (domainPolicy As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetAppDomainPolicy(System::Security::Policy::PolicyLevel ^ domainPolicy);" />
      <MemberSignature Language="F#" Value="member this.SetAppDomainPolicy : System.Security.Policy.PolicyLevel -&gt; unit" Usage="appDomain.SetAppDomainPolicy domainPolicy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("AppDomain policy levels are obsolete and will be removed in a future release of the .NET Framework. See http://go.microsoft.com/fwlink/?LinkID=155570 for more information.")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domainPolicy" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="domainPolicy"><span data-ttu-id="c0a0d-2103">Nivel de directiva de seguridad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2103">The security policy level.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2104">Establece el nivel de directiva de seguridad para este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2104">Establishes the security policy level for this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2105">Llame a este método antes de que un ensamblado se carga en el <xref:System.AppDomain> en orden para la directiva de seguridad que tienen efecto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2105">Call this method before an assembly is loaded into the <xref:System.AppDomain> in order for the security policy to have effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2106">En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomain.SetAppDomainPolicy%2A> método para establecer el nivel de directiva de seguridad de un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2106">The following example demonstrates how to use the <xref:System.AppDomain.SetAppDomainPolicy%2A> method to set the security policy level of an application domain.</span></span>  
  
 [!code-cpp[ADSetAppDomainPolicy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADSetAppDomainPolicy/CPP/adsetappdomainpolicy.cpp#1)]
 [!code-csharp[ADSetAppDomainPolicy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADSetAppDomainPolicy/CS/adsetappdomainpolicy.cs#1)]
 [!code-vb[ADSetAppDomainPolicy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADSetAppDomainPolicy/VB/adsetappdomainpolicy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-2107">El valor de <paramref name="domainPolicy" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2107"><paramref name="domainPolicy" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="c0a0d-2108">Ya se ha establecido el nivel de directiva de seguridad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2108">The security policy level has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2109">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2109">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2110">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2110">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2111">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2111">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetCachePath">
      <MemberSignature Language="C#" Value="public void SetCachePath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetCachePath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetCachePath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetCachePath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetCachePath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetCachePath : string -&gt; unit&#xA;override this.SetCachePath : string -&gt; unit" Usage="appDomain.SetCachePath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetCachePath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.SetCachePath")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetCachePath has been deprecated. Please investigate the use of AppDomainSetup.CachePath instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c0a0d-2112">Ruta de acceso completa a la ubicación de la instantánea.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2112">The fully qualified path to the shadow copy location.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2113">Establece la ruta de acceso al directorio especificado como la ubicación donde se almacenan las instantáneas de los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2113">Establishes the specified directory path as the location where assemblies are shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2114">La ruta de acceso de la memoria caché se omite si el <xref:System.AppDomainSetup.ApplicationName%2A> no se establece la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2114">The cache path is ignored if the <xref:System.AppDomainSetup.ApplicationName%2A> property is not set.</span></span> <span data-ttu-id="c0a0d-2115">Vea la propiedad <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2115">See the <xref:System.AppDomainSetup.CachePath%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="c0a0d-2116">Para obtener más información sobre la copia sombra vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2116">For more information on shadow copying see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2117">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2117">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2118">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2118">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2119">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2119">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.CachePath" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="c0a0d-2120">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2120">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetData">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2121">Asigna un valor a una propiedad de dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2121">Assigns a value to an application domain property.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetData(string name, object data) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetData(System::String ^ name, System::Object ^ data);" />
      <MemberSignature Language="F#" Value="abstract member SetData : string * obj -&gt; unit&#xA;override this.SetData : string * obj -&gt; unit" Usage="appDomain.SetData (name, data)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetData(System.String,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-2122">Nombre de una propiedad de dominio de aplicación definida por el usuario que se va a crear o cambiar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2122">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="c0a0d-2123">El valor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2123">The value of the property.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2124">Asigna el valor especificado a la propiedad especificada del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2124">Assigns the specified value to the specified application domain property.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2125">Use este método para insertar una entrada o modificar el valor de una entrada en una memoria caché interna de pares de nombre y datos que describen las propiedades de esta instancia de <xref:System.AppDomain>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2125">Use this method to insert an entry, or modify the value of an entry in an internal cache of name-data pairs that describe properties of this instance of <xref:System.AppDomain>.</span></span>  
  
 <span data-ttu-id="c0a0d-2126">La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2126">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="c0a0d-2127">No se puede insertar o modificar las entradas del sistema con este método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2127">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="c0a0d-2128">Una llamada al método que intenta modificar una entrada de sistema no tiene ningún efecto; el método no produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2128">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="c0a0d-2129">Puede inspeccionar los valores de las entradas del sistema con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> describen las propiedades en <xref:System.AppDomain.GetData%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2129">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method, or the equivalent <xref:System.AppDomainSetup> properties described in <xref:System.AppDomain.GetData%2A>.</span></span>  
  
 <span data-ttu-id="c0a0d-2130">Puede llamar a este método para establecer el valor del intervalo de tiempo de espera predeterminado para evaluar patrones de expresiones regulares mediante la fuente de alimentación "REGEX_DEFAULT_MATCH_TIMEOUT" como valor de la `name` argumento y un <xref:System.TimeSpan> valor que representa el tiempo de espera intervalo como el valor de la `data` argumento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2130">You can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span> <span data-ttu-id="c0a0d-2131">También puede insertar o modificar sus propios pares de nombre y datos definidos por el usuario con este método y examinar sus valores con el <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2131">You can also insert or modify your own user defined name-data pairs with this method and inspect their values with the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2132">En el ejemplo siguiente se muestra cómo usar el <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> método para crear un nuevo par de valor.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2132">The following example demonstrates how to use the <xref:System.AppDomain.SetData%28System.String%2CSystem.Object%29> method to create a new value pair.</span></span> <span data-ttu-id="c0a0d-2133">El ejemplo se utiliza el <xref:System.AppDomain.GetData%2A> método para recuperar el valor y se muestra en la consola.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2133">The example then uses the <xref:System.AppDomain.GetData%2A> method to retrieve the value, and displays it to the console.</span></span>  
  
 [!code-cpp[ADGetData#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADGetData/CPP/adgetdata.cpp#1)]
 [!code-csharp[ADGetData#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADGetData/CS/adgetdata.cs#1)]
 [!code-vb[ADGetData#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADGetData/VB/adgetdata.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2134">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2134">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2135">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2135">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2136">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2136">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.AppDomain.GetData(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="SetData">
      <MemberSignature Language="C#" Value="public void SetData (string name, object data, System.Security.IPermission permission);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetData(string name, object data, class System.Security.IPermission permission) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetData(System.String,System.Object,System.Security.IPermission)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetData (name As String, data As Object, permission As IPermission)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetData(System::String ^ name, System::Object ^ data, System::Security::IPermission ^ permission);" />
      <MemberSignature Language="F#" Value="member this.SetData : string * obj * System.Security.IPermission -&gt; unit" Usage="appDomain.SetData (name, data, permission)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="data" Type="System.Object" />
        <Parameter Name="permission" Type="System.Security.IPermission" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="c0a0d-2137">Nombre de una propiedad de dominio de aplicación definida por el usuario que se va a crear o cambiar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2137">The name of a user-defined application domain property to create or change.</span></span></param>
        <param name="data"><span data-ttu-id="c0a0d-2138">El valor de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2138">The value of the property.</span></span></param>
        <param name="permission"><span data-ttu-id="c0a0d-2139">Permiso que se va a exigir al llamador cuando se recupere la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2139">The permission to demand of the caller when the property is retrieved.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2140">Asigna el valor especificado a la propiedad de dominio de aplicación indicada, con un permiso especificado que se exige al llamador cuando se recupera la propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2140">Assigns the specified value to the specified application domain property, with a specified permission to demand of the caller when the property is retrieved.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2141">Utilice este método para insertar o modificar sus propias entradas definidas por el usuario en una memoria caché interna de pares de nombre/datos que describen las propiedades del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2141">Use this method to insert or modify your own user-defined entries in an internal cache of name/data pairs that describe properties of the application domain.</span></span> <span data-ttu-id="c0a0d-2142">Cuando se inserta una entrada, puede especificar una demanda de permiso para aplicar cuando se recupera la entrada. Además, puede llamar a este método para establecer el valor del intervalo de tiempo de espera predeterminado para evaluar patrones de expresiones regulares mediante la fuente de alimentación "REGEX_DEFAULT_MATCH_TIMEOUT" como el valor de la `name` argumento y un <xref:System.TimeSpan> valor que representa el intervalo de tiempo de espera que el valor de la `data` argumento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2142">When you insert an entry, you can specify a permission demand to enforce when the entry is retrieved.In addition, you can call this method to set the value of the default timeout interval for evaluating regular expression patterns by supply "REGEX_DEFAULT_MATCH_TIMEOUT" as the value of the `name` argument and a <xref:System.TimeSpan> value that represents the timeout interval as the value of the `data` argument.</span></span>  
  
 <span data-ttu-id="c0a0d-2143">No se puede usar este método para asignar una petición de seguridad a una cadena de propiedad definido por el sistema.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2143">You cannot use this method to assign a security demand to a system-defined property string.</span></span>  
  
 <span data-ttu-id="c0a0d-2144">La memoria caché contiene automáticamente las entradas del sistema predefinidos que se insertan cuando se crea el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2144">The cache automatically contains predefined system entries that are inserted when the application domain is created.</span></span> <span data-ttu-id="c0a0d-2145">No se puede insertar o modificar las entradas del sistema con este método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2145">You cannot insert or modify system entries with this method.</span></span> <span data-ttu-id="c0a0d-2146">Una llamada al método que intenta modificar una entrada de sistema no tiene ningún efecto; el método no produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2146">A method call that attempts to modify a system entry has no effect; the method does not throw an exception.</span></span> <span data-ttu-id="c0a0d-2147">Puede inspeccionar los valores de las entradas del sistema con el <xref:System.AppDomain.GetData%2A> método o el equivalente <xref:System.AppDomainSetup> las propiedades descritas en la sección Comentarios para el <xref:System.AppDomain.GetData%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2147">You can inspect the values of system entries with the <xref:System.AppDomain.GetData%2A> method or the equivalent <xref:System.AppDomainSetup> properties described in the Remarks section for the <xref:System.AppDomain.GetData%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-2148">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2148"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="c0a0d-2149"><paramref name="name" /> especifica una cadena de propiedad definida por el sistema y <paramref name="permission" /> no es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2149"><paramref name="name" /> specifies a system-defined property string and <paramref name="permission" /> is not <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2150">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2150">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2151">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2151">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetDynamicBase">
      <MemberSignature Language="C#" Value="public void SetDynamicBase (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetDynamicBase(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetDynamicBase(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetDynamicBase (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetDynamicBase(System::String ^ path);" />
      <MemberSignature Language="F#" Value="member this.SetDynamicBase : string -&gt; unit" Usage="appDomain.SetDynamicBase path" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.DynamicBase")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetDynamicBase has been deprecated. Please investigate the use of AppDomainSetup.DynamicBase instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c0a0d-2152">Ruta de acceso completa que es el directorio base de los subdirectorios donde se almacenan los ensamblados dinámicos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2152">The fully qualified path that is the base directory for subdirectories where dynamic assemblies are stored.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2153">Establece la ruta de acceso al directorio especificado como directorio base de los subdirectorios donde se almacenan los archivos generados de forma dinámica y se obtiene acceso a ellos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2153">Establishes the specified directory path as the base directory for subdirectories where dynamically generated files are stored and accessed.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2154">Este método establece el <xref:System.AppDomainSetup.DynamicBase%2A> propiedad de interno <xref:System.AppDomainSetup> asociado con esta instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2154">This method sets the <xref:System.AppDomainSetup.DynamicBase%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2155">Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2155">This method is now obsolete, and should not be used for new development.</span></span> <span data-ttu-id="c0a0d-2156">El ejemplo siguiente muestra cómo usar la alternativa no obsoleta, la <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2156">The following example shows how to use the non-obsolete alternative, the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c0a0d-2157">Para obtener una explicación de este ejemplo, vea el <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> propiedad o el <xref:System.AppDomain.DynamicDirectory%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2157">For an explanation of this example, see the <xref:System.AppDomainSetup.DynamicBase%2A?displayProperty=nameWithType> property or the <xref:System.AppDomain.DynamicDirectory%2A> property.</span></span>  
  
 [!code-cpp[ADDynamicBase#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADDynamicBase/CPP/addynamicbase.cpp#1)]
 [!code-csharp[ADDynamicBase#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADDynamicBase/CS/addynamicbase.cs#1)]
 [!code-vb[ADDynamicBase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADDynamicBase/VB/addynamicbase.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2158">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2158">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2159">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2159">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2160">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2160">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.AppDomainSetup.DynamicBase" />
      </Docs>
    </Member>
    <Member MemberName="SetPrincipalPolicy">
      <MemberSignature Language="C#" Value="public void SetPrincipalPolicy (System.Security.Principal.PrincipalPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetPrincipalPolicy(valuetype System.Security.Principal.PrincipalPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetPrincipalPolicy(System.Security.Principal.PrincipalPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetPrincipalPolicy (policy As PrincipalPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetPrincipalPolicy(System::Security::Principal::PrincipalPolicy policy);" />
      <MemberSignature Language="F#" Value="member this.SetPrincipalPolicy : System.Security.Principal.PrincipalPolicy -&gt; unit" Usage="appDomain.SetPrincipalPolicy policy" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="policy" Type="System.Security.Principal.PrincipalPolicy" />
      </Parameters>
      <Docs>
        <param name="policy"><span data-ttu-id="c0a0d-2161">Uno de los valores de <see cref="T:System.Security.Principal.PrincipalPolicy" /> que especifica el tipo del objeto principal que se va a asociar a los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2161">One of the <see cref="T:System.Security.Principal.PrincipalPolicy" /> values that specifies the type of the principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2162">Especifica la forma en que los objetos principales y de identidad deben asociarse a un subproceso si éste intenta enlazarse a un principal mientas se ejecuta en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2162">Specifies how principal and identity objects should be attached to a thread if the thread attempts to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2163">Al establecer este valor sólo serán efectivo si se establece antes de usar el <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2163">Setting this value will only be effective if you set it before using the <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c0a0d-2164">Por ejemplo, si establece <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> a una entidad determinada (por ejemplo, una entidad de seguridad genérico) y, después, use el <xref:System.AppDomain.SetPrincipalPolicy%2A> método para establecer el <xref:System.Security.Principal.PrincipalPolicy> a <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, la entidad de seguridad actual seguirá siendo la entidad de seguridad genérico.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2164">For example, if you set <xref:System.Threading.Thread.CurrentPrincipal%2A?displayProperty=nameWithType> to a given principal (for example, a generic principal) and then use the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to set the <xref:System.Security.Principal.PrincipalPolicy> to <xref:System.Security.Principal.PrincipalPolicy.WindowsPrincipal>, the current principal will remain the generic principal.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2165">El ejemplo siguiente muestra el efecto en los subprocesos del uso de la <xref:System.AppDomain.SetPrincipalPolicy%2A> método para cambiar la directiva de entidad del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2165">The following example shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span> <span data-ttu-id="c0a0d-2166">También se muestra el efecto de usar el <xref:System.AppDomain.SetThreadPrincipal%2A> método para cambiar la entidad de seguridad que está disponible para asociar a los subprocesos en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2166">It also shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads in the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2167">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2167">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-2168">Para poder manipular el objeto principal.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2168">for ability to manipulate the principal object.</span></span> <span data-ttu-id="c0a0d-2169">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2169">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="c0a0d-2170">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2170">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyFiles">
      <MemberSignature Language="C#" Value="public void SetShadowCopyFiles ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetShadowCopyFiles() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyFiles ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetShadowCopyFiles();" />
      <MemberSignature Language="F#" Value="member this.SetShadowCopyFiles : unit -&gt; unit" Usage="appDomain.SetShadowCopyFiles " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyFiles")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyFiles has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyFiles instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-2171">Activa la creación de instantáneas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2171">Turns on shadow copying.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2172">Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2172">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2173">Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2173">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[adproperties#1](~/samples/snippets/cpp/VS_Snippets_CLR/adproperties/CPP/adproperties.cpp#1)]
 [!code-csharp[adproperties#1](~/samples/snippets/csharp/VS_Snippets_CLR/adproperties/CS/adproperties.cs#1)]
 [!code-vb[adproperties#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/adproperties/VB/adproperties.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2174">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2174">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2175">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2175">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2176">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2176">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="c0a0d-2177">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2177">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetShadowCopyPath">
      <MemberSignature Language="C#" Value="public void SetShadowCopyPath (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void SetShadowCopyPath(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetShadowCopyPath(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetShadowCopyPath (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void SetShadowCopyPath(System::String ^ path);" />
      <MemberSignature Language="F#" Value="abstract member SetShadowCopyPath : string -&gt; unit&#xA;override this.SetShadowCopyPath : string -&gt; unit" Usage="appDomain.SetShadowCopyPath path" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.SetShadowCopyPath(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use AppDomainSetup.ShadowCopyDirectories")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("AppDomain.SetShadowCopyPath has been deprecated. Please investigate the use of AppDomainSetup.ShadowCopyDirectories instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path"><span data-ttu-id="c0a0d-2178">Lista de nombres de directorio separados por puntos y comas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2178">A list of directory names, where each name is separated by a semicolon.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2179">Establece la ruta de acceso al directorio especificado como la ubicación de las instantáneas de los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2179">Establishes the specified directory path as the location of assemblies to be shadow copied.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2180">De forma predeterminada, una copia sombra incluye todos los ensamblados que se encuentran a través de sondeo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2180">By default, a shadow copy includes all assemblies found through probing.</span></span> <span data-ttu-id="c0a0d-2181">El <xref:System.AppDomain.SetShadowCopyPath%2A> método restringe la instantánea a los ensamblados en los directorios especificados por `path`.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2181">The <xref:System.AppDomain.SetShadowCopyPath%2A> method restricts the shadow copy to the assemblies in the directories specified by `path`.</span></span>  
  
 <span data-ttu-id="c0a0d-2182">El <xref:System.AppDomain.SetShadowCopyPath%2A> método no especificar directorios adicionales que se buscarán los ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2182">The <xref:System.AppDomain.SetShadowCopyPath%2A> method does not specify additional directories to be searched for assemblies.</span></span> <span data-ttu-id="c0a0d-2183">Los ensamblados se hiciera deben estar ubicados en la ruta de búsqueda, por ejemplo en <xref:System.AppDomain.BaseDirectory%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2183">Assemblies to be shadow-copied must already be located in the search path, for example under <xref:System.AppDomain.BaseDirectory%2A>.</span></span> <span data-ttu-id="c0a0d-2184">El <xref:System.AppDomain.SetShadowCopyPath%2A> método especifica qué rutas de acceso de búsqueda son aptas para realizar una copia sombra.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2184">The <xref:System.AppDomain.SetShadowCopyPath%2A> method specifies which search paths are eligible to be shadow-copied.</span></span>  
  
 <span data-ttu-id="c0a0d-2185">Este método establece el <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> propiedad de interno <xref:System.AppDomainSetup> asociado con esta instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2185">This method sets the <xref:System.AppDomainSetup.ShadowCopyDirectories%2A> property of the internal <xref:System.AppDomainSetup> associated with this instance.</span></span>  
  
 <span data-ttu-id="c0a0d-2186">Para obtener más información sobre las instantáneas, vea [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2186">For more information on shadow copying, see [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2187">Este método ahora está obsoleto y no se recomienda para nuevo desarrollo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2187">This method is now obsolete, and should not be used for new development.</span></span>  
  
 [!code-cpp[ADShadowCopy#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADShadowCopy/CPP/adshadowcopy.cpp#1)]
 [!code-csharp[ADShadowCopy#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADShadowCopy/CS/adshadowcopy.cs#1)]
 [!code-vb[ADShadowCopy#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADShadowCopy/VB/adshadowcopy.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2188">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2188">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2189">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2189">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2190">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2190">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="c0a0d-2191">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2191">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="SetThreadPrincipal">
      <MemberSignature Language="C#" Value="public void SetThreadPrincipal (System.Security.Principal.IPrincipal principal);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetThreadPrincipal(class System.Security.Principal.IPrincipal principal) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.SetThreadPrincipal(System.Security.Principal.IPrincipal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetThreadPrincipal (principal As IPrincipal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetThreadPrincipal(System::Security::Principal::IPrincipal ^ principal);" />
      <MemberSignature Language="F#" Value="member this.SetThreadPrincipal : System.Security.Principal.IPrincipal -&gt; unit" Usage="appDomain.SetThreadPrincipal principal" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="principal" Type="System.Security.Principal.IPrincipal" />
      </Parameters>
      <Docs>
        <param name="principal"><span data-ttu-id="c0a0d-2192">Objeto principal que se va a asociar a los subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2192">The principal object to attach to threads.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2193">Establece el objeto principal predeterminado que se va a asociar a los subprocesos si éstos intentan enlazarse a un principal mientras se ejecutan en este dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2193">Sets the default principal object to be attached to threads if they attempt to bind to a principal while executing in this application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c0a0d-2194">El ejemplo siguiente muestra el efecto de usar el <xref:System.AppDomain.SetThreadPrincipal%2A> método para cambiar la entidad de seguridad que está disponible para asociar a los subprocesos que se ejecutan en el dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2194">The following example shows the effect of using the <xref:System.AppDomain.SetThreadPrincipal%2A> method to change the principal that is available for attaching to threads that are executing in the application domain.</span></span> <span data-ttu-id="c0a0d-2195">También se muestra el efecto en los subprocesos del uso de la <xref:System.AppDomain.SetPrincipalPolicy%2A> método para cambiar la directiva de entidad del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2195">It also shows the effect on threads of using the <xref:System.AppDomain.SetPrincipalPolicy%2A> method to change the principal policy of the application domain.</span></span>  
  
 [!code-cpp[ADPrincipal#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADPrincipal/CPP/adprincipal.cpp#1)]
 [!code-csharp[ADPrincipal#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADPrincipal/CS/adprincipal.cs#1)]
 [!code-vb[ADPrincipal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADPrincipal/VB/adprincipal.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-2196">El valor de <paramref name="principal" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2196"><paramref name="principal" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Security.Policy.PolicyException"><span data-ttu-id="c0a0d-2197">Ya se ha establecido la entidad de seguridad del subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2197">The thread principal has already been set.</span></span></exception>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2198">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2198">The operation is attempted on an unloaded application domain.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-2199">Para poder manipular el objeto principal.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2199">for ability to manipulate the principal object.</span></span> <span data-ttu-id="c0a0d-2200">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2200">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlPrincipal" />.</span></span> <span data-ttu-id="c0a0d-2201">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2201">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="SetupInformation">
      <MemberSignature Language="C#" Value="public AppDomainSetup SetupInformation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.AppDomainSetup SetupInformation" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.SetupInformation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SetupInformation As AppDomainSetup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property AppDomainSetup ^ SetupInformation { AppDomainSetup ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SetupInformation : AppDomainSetup" Usage="System.AppDomain.SetupInformation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.AppDomainSetup</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2202">Obtiene la información de configuración del dominio de aplicación correspondiente a esta instancia.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2202">Gets the application domain configuration information for this instance.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2203">Información de inicialización del dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2203">The application domain initialization information.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2204">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2204">The operation is attempted on an unloaded application domain.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ShadowCopyFiles">
      <MemberSignature Language="C#" Value="public bool ShadowCopyFiles { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ShadowCopyFiles" />
      <MemberSignature Language="DocId" Value="P:System.AppDomain.ShadowCopyFiles" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ShadowCopyFiles As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ShadowCopyFiles { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ShadowCopyFiles : bool" Usage="System.AppDomain.ShadowCopyFiles" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System._AppDomain.ShadowCopyFiles</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2205">Obtiene una indicación si el dominio de aplicación se configura para archivos de instantánea.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2205">Gets an indication whether the application domain is configured to shadow copy files.</span></span></summary>
        <value><span data-ttu-id="c0a0d-2206"><see langword="true" /> si el dominio de aplicación se configura para archivos de instantánea; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2206"><see langword="true" /> if the application domain is configured to shadow copy files; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2207">Para obtener más información, consulte <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> y [copias sombra de ensamblados](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2207">For more information, see <xref:System.AppDomainSetup.ShadowCopyFiles%2A?displayProperty=nameWithType> and [Shadow Copying Assemblies](~/docs/framework/app-domains/shadow-copy-assemblies.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2208">La operación se intenta en un dominio de aplicación descargado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2208">The operation is attempted on an unloaded application domain.</span></span></exception>
        <altmember cref="P:System.AppDomainSetup.ShadowCopyFiles" />
        <related type="Article" href="~/docs/framework/app-domains/shadow-copy-assemblies.md"><span data-ttu-id="c0a0d-2209">Copias sombra de ensamblados</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2209">Shadow Copying Assemblies</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _AppDomain.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _AppDomain.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = _AppDomain::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="c0a0d-2210">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2210">Reserved for future use.</span></span> <span data-ttu-id="c0a0d-2211">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2211">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="c0a0d-2212">Matriz que se pasa con los nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2212">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="c0a0d-2213">Número de nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2213">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="c0a0d-2214">Contexto de configuración regional en el que se van a interpretar los nombres.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2214">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="c0a0d-2215">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2215">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2216">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2216">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2217">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2217">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="c0a0d-2218">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2218">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="c0a0d-2219">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2219">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _AppDomain.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = _AppDomain::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="c0a0d-2220">Información de tipos que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2220">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="c0a0d-2221">Identificador de la configuración regional de la información de tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2221">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="c0a0d-2222">Recibe un puntero al objeto de información de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2222">Receives a pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2223">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2223">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2224">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2224">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="c0a0d-2225">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2225">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="c0a0d-2226">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2226">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _AppDomain.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _AppDomain.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = _AppDomain::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="c0a0d-2227">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2227">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2228">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2228">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2229">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2229">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="c0a0d-2230">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2230">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="c0a0d-2231">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2231">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System._AppDomain.Invoke">
      <MemberSignature Language="C#" Value="void _AppDomain.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System._AppDomain.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.System#_AppDomain#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _AppDomain.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System._AppDomain.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = _AppDomain::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="c0a0d-2232">Identifica el miembro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2232">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="c0a0d-2233">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2233">Reserved for future use.</span></span> <span data-ttu-id="c0a0d-2234">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2234">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="c0a0d-2235">Contexto de la configuración regional en que se interpretan los argumentos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2235">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="c0a0d-2236">Marcas que describen el contexto de la llamada.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2236">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="c0a0d-2237">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2237">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="c0a0d-2238">Puntero a la ubicación donde se va a almacenar el resultado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2238">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="c0a0d-2239">Puntero a una estructura que contiene información de excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2239">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="c0a0d-2240">Índice del primer argumento que tiene un error.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2240">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2241">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2241">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2242">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2242">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="c0a0d-2243">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2243">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="c0a0d-2244">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2244">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="appDomain.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System._AppDomain.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c0a0d-2245">Obtiene una representación en forma de cadena que incluye el nombre descriptivo del dominio de aplicación y cualquier directiva del contexto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2245">Obtains a string representation that includes the friendly name of the application domain and any context policies.</span></span></summary>
        <returns><span data-ttu-id="c0a0d-2246">Cadena formada al concatenar la cadena literal "Nombre:", el nombre descriptivo del dominio de aplicación y las representaciones en forma de cadena de las directivas de contexto o la cadena "No hay directivas de contexto".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2246">A string formed by concatenating the literal string "Name:", the friendly name of the application domain, and either string representations of the context policies or the string "There are no context policies."</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="c0a0d-2247">En el ejemplo de código siguiente se muestra el valor devuelto de la <xref:System.AppDomain.ToString%2A> método.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2247">The following code example displays the return value of the <xref:System.AppDomain.ToString%2A> method.</span></span>  
  
 [!code-cpp[ADToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADToString/CPP/adtostring.cpp#1)]
 [!code-csharp[ADToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADToString/CS/adtostring.cs#1)]
 [!code-vb[ADToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADToString/VB/adtostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.AppDomainUnloadedException"><span data-ttu-id="c0a0d-2248">Se ha descargado el dominio de aplicación que representa el objeto <see cref="T:System.AppDomain" /> actual.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2248">The application domain represented by the current <see cref="T:System.AppDomain" /> has been unloaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="TypeResolve">
      <MemberSignature Language="C#" Value="public event ResolveEventHandler TypeResolve;" />
      <MemberSignature Language="ILAsm" Value=".event class System.ResolveEventHandler TypeResolve" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.TypeResolve" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event TypeResolve As ResolveEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event ResolveEventHandler ^ TypeResolve;" />
      <MemberSignature Language="F#" Value="member this.TypeResolve : ResolveEventHandler " Usage="member this.TypeResolve : System.ResolveEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.TypeResolve</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.ResolveEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2249">Se produce cuando la resolución de un tipo produce errores.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2249">Occurs when the resolution of a type fails.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2250">El <xref:System.AppDomain.TypeResolve> evento se produce cuando common language runtime no puede determinar el ensamblado que se puede crear el tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2250">The <xref:System.AppDomain.TypeResolve> event occurs when the common language runtime is unable to determine the assembly that can create the requested type.</span></span> <span data-ttu-id="c0a0d-2251">Esto puede ocurrir si el tipo está definido en un ensamblado dinámico, o el tipo no está definido en un ensamblado dinámico, pero el tiempo de ejecución no sabe qué ensamblado está definido el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2251">This can occur if the type is defined in a dynamic assembly, or the type is not defined in a dynamic assembly but the runtime does not know which assembly the type is defined in.</span></span> <span data-ttu-id="c0a0d-2252">La última situación puede producirse cuando <xref:System.Type.GetType%2A?displayProperty=nameWithType> se denomina con un nombre de tipo que no está calificado con el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2252">The latter situation can occur when <xref:System.Type.GetType%2A?displayProperty=nameWithType> is called with a type name that is not qualified with the assembly name.</span></span>  
  
 <span data-ttu-id="c0a0d-2253">El <xref:System.ResolveEventHandler> de este evento puede intentar localizar y crear el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2253">The <xref:System.ResolveEventHandler> for this event can attempt to locate and create the type.</span></span>  
  
 <span data-ttu-id="c0a0d-2254">Sin embargo, el <xref:System.AppDomain.TypeResolve> evento no se produce si el tiempo de ejecución sabe que no es posible encontrar un tipo en determinados ensamblados.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2254">However, the <xref:System.AppDomain.TypeResolve> event does not occur if the runtime knows it is not possible to find a type in certain assemblies.</span></span> <span data-ttu-id="c0a0d-2255">Por ejemplo, este evento no se produce si el tipo no se encuentra en un ensamblado estático porque el tiempo de ejecución sepa tipos no se puede agregar dinámicamente a los ensamblados estáticos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2255">For example, this event does not occur if the type is not found in a static assembly because the runtime knows types cannot be added dynamically to static assemblies.</span></span>  
  
 <span data-ttu-id="c0a0d-2256">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], el <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> propiedad contiene el ensamblado que solicitó el tipo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2256">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType> property contains the assembly that requested the type.</span></span> <span data-ttu-id="c0a0d-2257">Para obtener más información, vea <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2257">For more information, see <xref:System.ResolveEventArgs.RequestingAssembly%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="c0a0d-2258">Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2258">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-2259">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2259">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2260">El ejemplo siguiente se muestra el <xref:System.AppDomain.TypeResolve> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2260">The following sample demonstrates the <xref:System.AppDomain.TypeResolve> event.</span></span>  
  
 <span data-ttu-id="c0a0d-2261">Para que poder ejecutar este ejemplo de código, debe proporcionar el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2261">For this code example to run, you must provide the fully qualified assembly name.</span></span> <span data-ttu-id="c0a0d-2262">Para obtener información acerca de cómo obtener el nombre completo del ensamblado, vea [nombres de ensamblado](~/docs/framework/app-domains/assembly-names.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2262">For information about how to obtain the fully qualified assembly name, see [Assembly Names](~/docs/framework/app-domains/assembly-names.md).</span></span>  
  
 [!code-cpp[AppDomain_TypeResolve#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_TypeResolve/CPP/typeresolve.cpp#1)]
 [!code-csharp[AppDomain_TypeResolve#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_TypeResolve/CS/typeresolve.cs#1)]
 [!code-vb[AppDomain_TypeResolve#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_TypeResolve/VB/typeresolve.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2263">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2263">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2264">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2264">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="P:System.ResolveEventArgs.RequestingAssembly" />
      </Docs>
    </Member>
    <Member MemberName="UnhandledException">
      <MemberSignature Language="C#" Value="public event UnhandledExceptionEventHandler UnhandledException;" />
      <MemberSignature Language="ILAsm" Value=".event class System.UnhandledExceptionEventHandler UnhandledException" />
      <MemberSignature Language="DocId" Value="E:System.AppDomain.UnhandledException" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event UnhandledException As UnhandledExceptionEventHandler " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual event UnhandledExceptionEventHandler ^ UnhandledException;" />
      <MemberSignature Language="F#" Value="member this.UnhandledException : UnhandledExceptionEventHandler " Usage="member this.UnhandledException : System.UnhandledExceptionEventHandler " />
      <MemberType>Event</MemberType>
      <Implements>
        <InterfaceMember>E:System._AppDomain.UnhandledException</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>add: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>remove: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UnhandledExceptionEventHandler</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c0a0d-2265">Se produce cuando no se detecta una excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2265">Occurs when an exception is not caught.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2266">Este evento proporciona una notificación de excepciones no detectadas.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2266">This event provides notification of uncaught exceptions.</span></span> <span data-ttu-id="c0a0d-2267">Permite que la aplicación registrar información sobre la excepción antes de que el controlador predeterminado del sistema notifica la excepción al usuario y finaliza la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2267">It allows the application to log information about the exception before the system default handler reports the exception to the user and terminates the application.</span></span> <span data-ttu-id="c0a0d-2268">Si hay suficiente información sobre el estado de la aplicación de acciones disponibles, otras pueden emprenderse - por ejemplo, guardar los datos de programa para su posterior recuperación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2268">If sufficient information about the state of the application is available, other actions may be undertaken - such as saving program data for later recovery.</span></span> <span data-ttu-id="c0a0d-2269">Precaución, porque los datos de programa pueden dañarse cuando no se controlan las excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2269">Caution is advised, because program data can become corrupted when exceptions are not handled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-2270">En las versiones 1.0 y 1.1 de .NET Framework, opciones de depuración y de finalización de la aplicación se notifican al usuario antes de que se genera este evento, en lugar de después.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2270">In the .NET Framework versions 1.0 and 1.1, application termination and debugging options are reported to the user before this event is raised, rather than after.</span></span>  
  
 <span data-ttu-id="c0a0d-2271">Este evento se puede controlar en cualquier dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2271">This event can be handled in any application domain.</span></span> <span data-ttu-id="c0a0d-2272">Sin embargo, el evento no se genera necesariamente en el dominio de aplicación donde se produjo la excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2272">However, the event is not necessarily raised in the application domain where the exception occurred.</span></span> <span data-ttu-id="c0a0d-2273">Una excepción es no controlada solo si se ha quitado toda la pila del subproceso sin encontrar un controlador de excepciones es aplicable, por lo que es el primer lugar que el evento puede generarse en el dominio de aplicación donde se originó el subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2273">An exception is unhandled only if the entire stack for the thread has been unwound without finding an applicable exception handler, so the first place the event can be raised is in the application domain where the thread originated.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-2274">En las versiones 1.0 y 1.1 de .NET Framework, este evento se produce solo en el dominio de aplicación predeterminado creado por el sistema cuando se inicia una aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2274">In the .NET Framework versions 1.0 and 1.1, this event occurs only for the default application domain that is created by the system when an application is started.</span></span> <span data-ttu-id="c0a0d-2275">Si una aplicación crea dominios de aplicación adicionales, especificando a un delegado para este evento en dichos dominios de aplicación no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2275">If an application creates additional application domains, specifying a delegate for this event in those applications domains has no effect.</span></span>  
  
 <span data-ttu-id="c0a0d-2276">Si el <xref:System.AppDomain.UnhandledException> evento se controla en el dominio de aplicación predeterminado, se producirá allí para cualquier excepción no controlada en cualquier subproceso, independientemente de qué dominio de aplicación la ha iniciado el subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2276">If the <xref:System.AppDomain.UnhandledException> event is handled in the default application domain, it is raised there for any unhandled exception in any thread, no matter what application domain the thread started in.</span></span> <span data-ttu-id="c0a0d-2277">Si se ha iniciado el subproceso en un dominio de aplicación que tiene un controlador de eventos <xref:System.AppDomain.UnhandledException>, se genera el evento en ese dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2277">If the thread started in an application domain that has an event handler for <xref:System.AppDomain.UnhandledException>, the event is raised in that application domain.</span></span> <span data-ttu-id="c0a0d-2278">Si ese dominio de aplicación no es el dominio de aplicación predeterminado, y también hay un controlador de eventos en el dominio de aplicación predeterminado, el evento se produce en dos dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2278">If that application domain is not the default application domain, and there is also an event handler in the default application domain, the event is raised in both application domains.</span></span>  
  
 <span data-ttu-id="c0a0d-2279">Por ejemplo, supongamos que un subproceso se inicia en el dominio de aplicación "AD1", llama a un método en el dominio de aplicación "AD2" y, a partir de ahí llama a un método en el dominio de aplicación "AD3", donde produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2279">For example, suppose a thread starts in application domain "AD1", calls a method in application domain "AD2", and from there calls a method in application domain "AD3", where it throws an exception.</span></span> <span data-ttu-id="c0a0d-2280">El primer dominio de aplicación en el que el <xref:System.AppDomain.UnhandledException> puede generarse el evento es "AD1".</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2280">The first application domain in which the <xref:System.AppDomain.UnhandledException> event can be raised is "AD1".</span></span> <span data-ttu-id="c0a0d-2281">Si ese dominio de aplicación no es el dominio de aplicación predeterminado, también se provoca el evento en el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2281">If that application domain is not the default application domain, the event can also be raised in the default application domain.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-2282">Common language runtime suspende las anulaciones de subproceso mientras los controladores de eventos para el <xref:System.AppDomain.UnhandledException> eventos se ejecutan.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2282">The common language runtime suspends thread aborts while event handlers for the <xref:System.AppDomain.UnhandledException> event are executing.</span></span>  
  
 <span data-ttu-id="c0a0d-2283">Si el controlador de eventos tiene un <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> atributo con las marcas apropiadas, el controlador de eventos se trata como una región de ejecución restringida.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2283">If the event handler has a <xref:System.Runtime.ConstrainedExecution.ReliabilityContractAttribute> attribute with the appropriate flags, the event handler is treated as a constrained execution region.</span></span>  
  
 <span data-ttu-id="c0a0d-2284">A partir de la [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], no se provoca este evento para las excepciones que se dañan el estado del proceso, como desbordamientos de pila o infracciones de acceso, a menos que el controlador de eventos es crítico para la seguridad y tiene el <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2284">Starting with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], this event is not raised for exceptions that corrupt the state of the process, such as stack overflows or access violations, unless the event handler is security-critical and has the <xref:System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute> attribute.</span></span>  
  
 <span data-ttu-id="c0a0d-2285">En las versiones 1.0 y 1.1 de .NET Framework, una excepción no controlada que se produce en un subproceso distinto del subproceso principal de la aplicación ha sido detectada por el tiempo de ejecución y, por tanto, no hace que la aplicación finalice.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2285">In the .NET Framework versions 1.0 and 1.1, an unhandled exception that occurs in a thread other than the main application thread is caught by the runtime and therefore does not cause the application to terminate.</span></span> <span data-ttu-id="c0a0d-2286">Por lo tanto, es posible que el <xref:System.AppDomain.UnhandledException> evento sin la terminación de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2286">Thus, it is possible for the <xref:System.AppDomain.UnhandledException> event to be raised without the application terminating.</span></span> <span data-ttu-id="c0a0d-2287">A partir de la versión 2.0 de .NET Framework, este mecanismo de seguridad para las excepciones no controladas en subprocesos secundarios se ha quitado, puesto que el efecto acumulativo de errores sin incluido una degradación del rendimiento, datos dañados y bloqueos, que eran difíciles depurar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2287">Starting with the .NET Framework version 2.0, this backstop for unhandled exceptions in child threads was removed, because the cumulative effect of such silent failures included performance degradation, corrupted data, and lockups, all of which were difficult to debug.</span></span> <span data-ttu-id="c0a0d-2288">Para obtener más información, incluida una lista de los casos en los que no finaliza el tiempo de ejecución, consulte [excepciones en subprocesos administrados](~/docs/standard/threading/exceptions-in-managed-threads.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2288">For more information, including a list of cases in which the runtime does not terminate, see [Exceptions in Managed Threads](~/docs/standard/threading/exceptions-in-managed-threads.md).</span></span>  
  
 <span data-ttu-id="c0a0d-2289">Para registrar un controlador de eventos para este evento, debe tener los permisos necesarios, o un <xref:System.Security.SecurityException> se produce.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2289">To register an event handler for this event, you must have the required permissions, or a <xref:System.Security.SecurityException> is thrown.</span></span>  
  
 <span data-ttu-id="c0a0d-2290">Para obtener más información sobre el manejo de eventos, consulte [controlar y provocar eventos](~/docs/standard/events/index.md).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2290">For more information about handling events, see [Handling and Raising Events](~/docs/standard/events/index.md).</span></span>  
  
## <a name="other-events-for-unhandled-exceptions"></a><span data-ttu-id="c0a0d-2291">Otros eventos para las excepciones no controladas</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2291">Other Events for Unhandled Exceptions</span></span>  
 <span data-ttu-id="c0a0d-2292">Para determinados modelos de aplicación, el <xref:System.AppDomain.UnhandledException> evento puede ser adelantado por otros eventos si se produce la excepción no controlada en el subproceso principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2292">For certain application models, the <xref:System.AppDomain.UnhandledException> event can be preempted by other events if the unhandled exception occurs in the main application thread.</span></span>  
  
 <span data-ttu-id="c0a0d-2293">En las aplicaciones que usan Windows Forms, excepciones no controladas en la causa del subproceso principal de la aplicación la <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2293">In applications that use Windows Forms, unhandled exceptions in the main application thread cause the <xref:System.Windows.Forms.Application.ThreadException?displayProperty=nameWithType> event to be raised.</span></span> <span data-ttu-id="c0a0d-2294">Si se controla este evento, el comportamiento predeterminado es que la excepción no controlada finaliza la aplicación, aunque la aplicación se queda en un estado desconocido.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2294">If this event is handled, the default behavior is that the unhandled exception does not terminate the application, although the application is left in an unknown state.</span></span> <span data-ttu-id="c0a0d-2295">En ese caso, el <xref:System.AppDomain.UnhandledException> no se produce el evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2295">In that case, the <xref:System.AppDomain.UnhandledException> event is not raised.</span></span> <span data-ttu-id="c0a0d-2296">Este comportamiento puede modificarse mediante el archivo de configuración de aplicación, o mediante el uso de la <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> método para cambiar el modo a <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> antes el <xref:System.Windows.Forms.Application.ThreadException> se enlazó el controlador de eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2296">This behavior can be changed by using the application configuration file, or by using the <xref:System.Windows.Forms.Application.SetUnhandledExceptionMode%2A?displayProperty=nameWithType> method to change the mode to <xref:System.Windows.Forms.UnhandledExceptionMode.ThrowException?displayProperty=nameWithType> before the <xref:System.Windows.Forms.Application.ThreadException> event handler is hooked up.</span></span> <span data-ttu-id="c0a0d-2297">Esto se aplica sólo al subproceso principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2297">This applies only to the main application thread.</span></span> <span data-ttu-id="c0a0d-2298">El <xref:System.AppDomain.UnhandledException> evento se desencadena para excepciones no controladas producidas en otros subprocesos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2298">The <xref:System.AppDomain.UnhandledException> event is raised for unhandled exceptions thrown in other threads.</span></span>  
  
 <span data-ttu-id="c0a0d-2299">A partir de Microsoft Visual Studio 2005, el marco de aplicación de Visual Basic proporciona otro evento para las excepciones no controladas en el subproceso principal de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2299">Starting with Microsoft Visual Studio 2005, the Visual Basic application framework provides another event for unhandled exceptions in the main application thread.</span></span> <span data-ttu-id="c0a0d-2300">Consulte la <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2300">See the <xref:Microsoft.VisualBasic.ApplicationServices.WindowsFormsApplicationBase.UnhandledException?displayProperty=nameWithType> event.</span></span> <span data-ttu-id="c0a0d-2301">Este evento tiene un objeto de argumentos de evento con el mismo nombre que el objeto de argumentos de evento utilizado por <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, pero con diferentes propiedades.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2301">This event has an event arguments object with the same name as the event arguments object used by <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType>, but with different properties.</span></span> <span data-ttu-id="c0a0d-2302">En concreto, este objeto de argumentos de evento tiene un <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> propiedad que permite que la aplicación continuar la ejecución, se omitirá la excepción no controlada (y dejar la aplicación en un estado desconocido).</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2302">In particular, this event arguments object has an <xref:Microsoft.VisualBasic.ApplicationServices.UnhandledExceptionEventArgs.ExitApplication%2A> property that allows the application to continue running, ignoring the unhandled exception (and leaving the application in an unknown state).</span></span> <span data-ttu-id="c0a0d-2303">En ese caso, el <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> no se produce el evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2303">In that case, the <xref:System.AppDomain.UnhandledException?displayProperty=nameWithType> event is not raised.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2304">El siguiente ejemplo se muestra el <xref:System.AppDomain.UnhandledException> eventos.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2304">The followingexample demonstrates the <xref:System.AppDomain.UnhandledException> event.</span></span> <span data-ttu-id="c0a0d-2305">Define un controlador de eventos, `MyHandler`, que se invoca cuando se produce una excepción no controlada en el dominio de aplicación predeterminado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2305">It defines an event handler, `MyHandler`, that is invoked whenever an unhandled exception is thrown in the default application domain.</span></span> <span data-ttu-id="c0a0d-2306">A continuación, se produce dos excepciones.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2306">It then throws two exceptions.</span></span> <span data-ttu-id="c0a0d-2307">La primera se controla mediante un **try/catch** bloque.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2307">The first is handled by a **try/catch** block.</span></span> <span data-ttu-id="c0a0d-2308">El segundo es controlado y se invoca el `MyHandle` rutina antes de que termine la aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2308">The second is unhandled and invokes the `MyHandle` routine before the application terminates.</span></span>  
  
 [!code-cpp[AppDomain_UnhandledException#1](~/samples/snippets/cpp/VS_Snippets_CLR/AppDomain_UnhandledException/CPP/unhandledexception.cpp#1)]
 [!code-csharp[AppDomain_UnhandledException#1](~/samples/snippets/csharp/VS_Snippets_CLR/AppDomain_UnhandledException/CS/unhandledexception.cs#1)]
 [!code-vb[AppDomain_UnhandledException#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/AppDomain_UnhandledException/VB/unhandledexception.vb#1)]  
  
 ]]></format>
        </remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="c0a0d-2309">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2309">requires full trust for the immediate caller.</span></span> <span data-ttu-id="c0a0d-2310">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2310">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="Unload">
      <MemberSignature Language="C#" Value="public static void Unload (AppDomain domain);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Unload(class System.AppDomain domain) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.AppDomain.Unload(System.AppDomain)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Unload (domain As AppDomain)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Unload(AppDomain ^ domain);" />
      <MemberSignature Language="F#" Value="static member Unload : AppDomain -&gt; unit" Usage="System.AppDomain.Unload domain" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Extensions</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptAppDomain, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="domain" Type="System.AppDomain" />
      </Parameters>
      <Docs>
        <param name="domain"><span data-ttu-id="c0a0d-2311">Dominio de aplicación que se va a descargar.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2311">An application domain to unload.</span></span></param>
        <summary><span data-ttu-id="c0a0d-2312">Descarga el dominio de aplicación especificado.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2312">Unloads the specified application domain.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c0a0d-2313">En la versión 2.0 de .NET Framework, hay un subproceso dedicado para descargar dominios de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2313">In the .NET Framework version 2.0 there is a thread dedicated to unloading application domains.</span></span> <span data-ttu-id="c0a0d-2314">Esto mejora la confiabilidad, especialmente cuando se hospeda .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2314">This improves reliability, especially when the .NET Framework is hosted.</span></span> <span data-ttu-id="c0a0d-2315">Cuando un subproceso llama <xref:System.AppDomain.Unload%2A>, el dominio de destino se ha marcado para descarga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2315">When a thread calls <xref:System.AppDomain.Unload%2A>, the target domain is marked for unloading.</span></span> <span data-ttu-id="c0a0d-2316">El subproceso dedicado intenta descargar el dominio, y anulan todos los subprocesos del dominio.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2316">The dedicated thread attempts to unload the domain, and all threads in the domain are aborted.</span></span> <span data-ttu-id="c0a0d-2317">Si un subproceso no anula, por ejemplo porque se está ejecutando código no administrado, o porque se está ejecutando un `finally` bloque, a continuación, tras un período de tiempo un <xref:System.CannotUnloadAppDomainException> se produce en el subproceso que llamó originalmente <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2317">If a thread does not abort, for example because it is executing unmanaged code, or because it is executing a `finally` block, then after a period of time a <xref:System.CannotUnloadAppDomainException> is thrown in the thread that originally called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="c0a0d-2318">Si el subproceso que no se pudo anular finalmente finaliza, no se descarga el dominio de destino.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2318">If the thread that could not be aborted eventually ends, the target domain is not unloaded.</span></span> <span data-ttu-id="c0a0d-2319">Por lo tanto, en la versión 2.0 de .NET Framework `domain` no se garantiza que se descargue porque podría no ser posible terminar subprocesos en ejecución.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2319">Thus, in the .NET Framework version 2.0 `domain` is not guaranteed to unload, because it might not be possible to terminate executing threads.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c0a0d-2320">En algunos casos, una llamada a <xref:System.AppDomain.Unload%2A> hace inmediato <xref:System.CannotUnloadAppDomainException>, por ejemplo si se llama en un finalizador.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2320">In some cases, calling <xref:System.AppDomain.Unload%2A> causes an immediate <xref:System.CannotUnloadAppDomainException>, for example if it is called in a finalizer.</span></span>  
  
 <span data-ttu-id="c0a0d-2321">Los subprocesos en `domain` se terminan con el <xref:System.Threading.Thread.Abort%2A> método que inicia un <xref:System.Threading.ThreadAbortException> en el subproceso.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2321">The threads in `domain` are terminated using the <xref:System.Threading.Thread.Abort%2A> method, which throws a <xref:System.Threading.ThreadAbortException> in the thread.</span></span> <span data-ttu-id="c0a0d-2322">Aunque el subproceso debe terminar rápidamente, puede seguir ejecutándose durante un período de tiempo en impredecibles un `finally` cláusula.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2322">Although the thread should terminate promptly, it can continue executing for an unpredictable amount of time in a `finally` clause.</span></span>  
  
## <a name="version-compatibility"></a><span data-ttu-id="c0a0d-2323">Compatibilidad de versiones</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2323">Version Compatibility</span></span>  
 <span data-ttu-id="c0a0d-2324">En .NET Framework versiones 1.0 y 1.1, si el subproceso que llama a <xref:System.AppDomain.Unload%2A> se está ejecutando en `domain`, se inicia otro subproceso para realizar la operación de descarga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2324">In the .NET Framework version 1.0 and 1.1 if the thread that calls <xref:System.AppDomain.Unload%2A> is running in `domain`, another thread is started to perform the unload operation.</span></span> <span data-ttu-id="c0a0d-2325">Si `domain` no se puede descargar, un <xref:System.CannotUnloadAppDomainException> se produce en ese subproceso, no en el subproceso original que llamó a <xref:System.AppDomain.Unload%2A>.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2325">If `domain` cannot be unloaded, a <xref:System.CannotUnloadAppDomainException> is thrown in that thread, not in the original thread that called <xref:System.AppDomain.Unload%2A>.</span></span> <span data-ttu-id="c0a0d-2326">Sin embargo, si el subproceso que llama a <xref:System.AppDomain.Unload%2A> se está ejecutando fuera `domain`, que el subproceso recibe la excepción.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2326">However, if the thread that calls <xref:System.AppDomain.Unload%2A> is running outside `domain`, that thread receives the exception.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c0a0d-2327">El ejemplo de código siguiente muestra cómo descargar un dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2327">The following code example shows how to unload an application domain.</span></span>  
  
 [!code-cpp[ADUnload#1](~/samples/snippets/cpp/VS_Snippets_CLR/ADUnload/CPP/adunload.cpp#1)]
 [!code-csharp[ADUnload#1](~/samples/snippets/csharp/VS_Snippets_CLR/ADUnload/CS/adunload.cs#1)]
 [!code-vb[ADUnload#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/ADUnload/VB/adunload.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="c0a0d-2328">El valor de <paramref name="domain" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2328"><paramref name="domain" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.CannotUnloadAppDomainException"><span data-ttu-id="c0a0d-2329">No se pudo descargar <paramref name="domain" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2329"><paramref name="domain" /> could not be unloaded.</span></span></exception>
        <exception cref="T:System.Exception"><span data-ttu-id="c0a0d-2330">Error durante el proceso de descarga.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2330">An error occurred during the unload process.</span></span></exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="c0a0d-2331">Para agregar un controlador de eventos para este evento.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2331">to add an event handler for this event.</span></span> <span data-ttu-id="c0a0d-2332">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2332">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.ControlAppDomain" />.</span></span> <span data-ttu-id="c0a0d-2333">Acción de seguridad: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span><span class="sxs-lookup"><span data-stu-id="c0a0d-2333">Security action: <see cref="F:System.Security.Permissions.SecurityAction.Demand" />.</span></span></permission>
      </Docs>
    </Member>
  </Members>
</Type>