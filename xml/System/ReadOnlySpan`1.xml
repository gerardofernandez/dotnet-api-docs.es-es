<Type Name="ReadOnlySpan&lt;T&gt;" FullName="System.ReadOnlySpan&lt;T&gt;">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d9a6096f593f5262be925b5e430936ef154f819b" /><Meta Name="ms.sourcegitcommit" Value="d8bd5d494445ce3fcad1321267cb87548d23a45b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/15/2018" /><Meta Name="ms.locfileid" Value="53448142" /></Metadata><TypeSignature Language="C#" Value="public struct ReadOnlySpan&lt;T&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit ReadOnlySpan`1&lt;T&gt; extends System.ValueType" />
  <TypeSignature Language="DocId" Value="T:System.ReadOnlySpan`1" />
  <TypeSignature Language="VB.NET" Value="Public Structure ReadOnlySpan(Of T)" />
  <TypeSignature Language="C++ CLI" Value="generic &lt;typename T&gt;&#xA;public value class ReadOnlySpan" />
  <TypeSignature Language="F#" Value="type ReadOnlySpan&lt;'T&gt; = struct" />
  <AssemblyInfo>
    <AssemblyName>System.Memory</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeParameters>
    <TypeParameter Name="T" />
  </TypeParameters>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsByRefLike</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <typeparam name="T"><span data-ttu-id="55e66-101">El tipo de elementos en el <see cref="System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-101">The type of items in the <see cref="System.ReadOnlySpan`1" />.</span></span></typeparam>
    <summary><span data-ttu-id="55e66-102">Proporciona una representación de solo lectura con seguridad de tipos y memoria de una región contigua de memoria arbitraria.</span><span class="sxs-lookup"><span data-stu-id="55e66-102">Provides a type-safe and memory-safe read-only representation of a contiguous region of arbitrary memory.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-103">`ReadOnlySpan<T>` es un [ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) que se asigna en la pila y nunca puede escape al montón administrado.</span><span class="sxs-lookup"><span data-stu-id="55e66-103">`ReadOnlySpan<T>` is a [ref struct](~/docs/csharp/language-reference/keywords/ref.md#ref-struct-types) that is allocated on the stack and can never escape to the managed heap.</span></span> <span data-ttu-id="55e66-104">Tipos de struct ref tienen un número de restricciones para asegurarse de que no se puede promocionar al montón administrado, incluidos los que no se puede realizar la conversión boxing, capturados en las expresiones lambda, asignadas a variables de tipo <xref:System.Object>, asignado a `dynamic` variables, y no pueden implementar cualquier tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="55e66-104">Ref struct types have a number of restrictions to ensure that they cannot be promoted to the managed heap, including that they can't be boxed, captured in lambda expressions, assigned to variables of type <xref:System.Object>, assigned to `dynamic` variables, and they cannot implement any interface type.</span></span>

<span data-ttu-id="55e66-105">Un `ReadOnlySpan<T>` instancia a menudo se usa para hacer referencia a los elementos de una matriz o una parte de una matriz.</span><span class="sxs-lookup"><span data-stu-id="55e66-105">A `ReadOnlySpan<T>` instance is often used to reference the elements of an array or a portion of an array.</span></span> <span data-ttu-id="55e66-106">A diferencia de una matriz, sin embargo, un `ReadOnlySpan<T>` instancia puede apuntar a la memoria administrada, memoria nativa, o memoria administrada en la pila.</span><span class="sxs-lookup"><span data-stu-id="55e66-106">Unlike an array, however, a `ReadOnlySpan<T>` instance can point to managed memory, native memory, or memory managed on the stack.</span></span>]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlySpan (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.#ctor(`0[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="new ReadOnlySpan&lt;'T&gt; : 'T[] -&gt; ReadOnlySpan&lt;'T&gt;" Usage="new System.ReadOnlySpan&lt;'T&gt; array" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="55e66-107">Matriz desde la que se va a crear <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-107">The array from which to create the <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="55e66-108">Crea un objeto <see cref="T:System.ReadOnlySpan`1" /> con la totalidad de una matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="55e66-108">Creates a new <see cref="T:System.ReadOnlySpan`1" /> over the entirety of a specified array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-109">Si la matriz es null, este constructor devuelve un valor null `ReadOnlySpan<T>`.</span><span class="sxs-lookup"><span data-stu-id="55e66-109">If the array is null, this constructor returns a null `ReadOnlySpan<T>`.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlySpan (void* pointer, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* pointer, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.#ctor(System.Void*,System.Int32)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan(void* pointer, int length);" />
      <MemberSignature Language="F#" Value="new ReadOnlySpan&lt;'T&gt; : nativeptr&lt;unit&gt; * int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="new System.ReadOnlySpan&lt;'T&gt; (pointer, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="pointer" Type="System.Void*" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="55e66-110">Un puntero a la dirección inicial de un número especificado de objetos <paramref name="T" /> en memoria.</span><span class="sxs-lookup"><span data-stu-id="55e66-110">A pointer to the starting address of a specified number of <paramref name="T" /> objects in memory.</span></span></param>
        <param name="length"><span data-ttu-id="55e66-111">Número de objetos <paramref name="T" /> que se van a incluir.</span><span class="sxs-lookup"><span data-stu-id="55e66-111">The number of <paramref name="T" /> objects to be included.</span></span></param>
        <summary><span data-ttu-id="55e66-112">Crea un objeto <see cref="T:System.ReadOnlySpan`1" /> a partir de un número especificado de bytes desde una dirección de memoria especificada.</span><span class="sxs-lookup"><span data-stu-id="55e66-112">Creates a new <see cref="T:System.ReadOnlySpan`1" /> from a specified number of bytes starting at a specified memory address.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-113">Este constructor debe usarse con cuidado, porque crea de forma arbitraria con tipo `T`s desde un bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="55e66-113">This constructor should be used with care, since it creates arbitrarily typed `T`s from a block of memory.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="55e66-114"><paramref name="T" /> es un tipo de referencia o contiene referencias y, por tanto, no se puede almacenar en memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="55e66-114"><paramref name="T" /> is a reference type or contains references and therefore cannot be stored in unmanaged memory.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="55e66-115"><paramref name="length" /> es negativo.</span><span class="sxs-lookup"><span data-stu-id="55e66-115"><paramref name="length" /> is negative.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public ReadOnlySpan (T[] array, int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(!T[] array, int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.#ctor(`0[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (array As T(), start As Integer, length As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan(cli::array &lt;T&gt; ^ array, int start, int length);" />
      <MemberSignature Language="F#" Value="new ReadOnlySpan&lt;'T&gt; : 'T[] * int * int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="new System.ReadOnlySpan&lt;'T&gt; (array, start, length)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="55e66-116">Matriz desde la que se va a crear <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-116">The array from which to create the <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <param name="start"><span data-ttu-id="55e66-117">Índice del primer elemento que se va a incluir.</span><span class="sxs-lookup"><span data-stu-id="55e66-117">The index of the first element to include.</span></span></param>
        <param name="length"><span data-ttu-id="55e66-118">Número de elementos que se van a incluir.</span><span class="sxs-lookup"><span data-stu-id="55e66-118">The number of elements to include.</span></span></param>
        <summary><span data-ttu-id="55e66-119">Crea un objeto <see cref="T:System.ReadOnlySpan`1" /> que incluye un número especificado de elementos de una matriz a partir de un índice especificado.</span><span class="sxs-lookup"><span data-stu-id="55e66-119">Creates a new <see cref="T:System.ReadOnlySpan`1" /> that includes a specified number of elements of an array starting at a specified index.</span></span></summary>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="55e66-120"><paramref name="array" /> es <see langword="null" />, pero <paramref name="start" /> o <paramref name="length" /> es distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="55e66-120"><paramref name="array" /> is <see langword="null" />, but <paramref name="start" /> or <paramref name="length" /> is non-zero.</span></span>

<span data-ttu-id="55e66-121">O bien</span><span class="sxs-lookup"><span data-stu-id="55e66-121">-or-</span></span>

<span data-ttu-id="55e66-122"><paramref name="start" /> está fuera de los límites de la matriz.</span><span class="sxs-lookup"><span data-stu-id="55e66-122"><paramref name="start" /> is outside the bounds of the array.</span></span>

<span data-ttu-id="55e66-123">O bien</span><span class="sxs-lookup"><span data-stu-id="55e66-123">-or-</span></span>

<span data-ttu-id="55e66-124"><paramref name="start" /> y <paramref name="length" /> superan el número de elementos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="55e66-124"><paramref name="start" /> and <paramref name="length" /> exceeds the number of elements in the array.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CopyTo">
      <MemberSignature Language="C#" Value="public void CopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.CopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Sub CopyTo (destination As Span(Of T))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.CopyTo : Span&lt;'T&gt; -&gt; unit" Usage="readOnlySpan.CopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="55e66-125">El intervalo en el que copiar los elementos.</span><span class="sxs-lookup"><span data-stu-id="55e66-125">The span to copy items into.</span></span></param>
        <summary><span data-ttu-id="55e66-126">Copia el contenido de este elemento <see cref="System.ReadOnlySpan`1" /> en un elemento <see cref="System.Span`1" /> de destino.</span><span class="sxs-lookup"><span data-stu-id="55e66-126">Copies the contents of this <see cref="System.ReadOnlySpan`1" /> into a destination <see cref="System.Span`1" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-127">Si el `source` y `destination` se superponen, la totalidad de `source` se tratará como si se ha copiado en una ubicación temporal antes de copiarlos a `destination`.</span><span class="sxs-lookup"><span data-stu-id="55e66-127">If the `source` and `destination` overlap, the entirety of `source` is handled as if it was copied to a temporary location before it is copied to `destination`.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="55e66-128"><paramref name="destination" /> es más corto que el origen <see cref="System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-128"><paramref name="destination" /> is shorter than the source <see cref="System.ReadOnlySpan`1" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Empty">
      <MemberSignature Language="C#" Value="public static ReadOnlySpan&lt;T&gt; Empty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.ReadOnlySpan`1&lt;!T&gt; Empty" />
      <MemberSignature Language="DocId" Value="P:System.ReadOnlySpan`1.Empty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Empty As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property ReadOnlySpan&lt;T&gt; Empty { ReadOnlySpan&lt;T&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.Empty : ReadOnlySpan&lt;'T&gt;" Usage="System.ReadOnlySpan&lt;'T&gt;.Empty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="55e66-129">Devuelve una <see cref="T:System.ReadOnlySpan`1" /> vacía.</span><span class="sxs-lookup"><span data-stu-id="55e66-129">Returns an empty <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <value><span data-ttu-id="55e66-130">Objeto <see cref="T:System.ReadOnlySpan`1" /> vacío.</span><span class="sxs-lookup"><span data-stu-id="55e66-130">An empty <see cref="T:System.ReadOnlySpan`1" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="readOnlySpan.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("Equals() on ReadOnlySpan will always throw an exception. Use == instead.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="55e66-131">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-131">Not supported.</span></span></param>
        <summary><span data-ttu-id="55e66-132">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-132">Not supported.</span></span> <span data-ttu-id="55e66-133">Produce una excepción <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-133">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-134">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-134">Not supported.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-135">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-135">Not supported.</span></span>]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="55e66-136">Este método siempre realiza el inicio.</span><span class="sxs-lookup"><span data-stu-id="55e66-136">Always thrown by this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;T&gt;.Enumerator GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlySpan`1/Enumerator&lt;!T&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEnumerator () As ReadOnlySpan(Of T).Enumerator" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan&lt;T&gt;::Enumerator GetEnumerator();" />
      <MemberSignature Language="F#" Value="member this.GetEnumerator : unit -&gt; ReadOnlySpan&lt;'T&gt;.Enumerator" Usage="readOnlySpan.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;+Enumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55e66-137">Devuelve un enumerador para este elemento <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-137">Returns an enumerator for this <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-138">Un enumerador para este intervalo de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55e66-138">An enumerator for this read-only span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-139">En lugar de llamar el <xref:System.ReadOnlySpan%601.GetEnumerator%2A> método directamente, puede utilizar el C# `foreach` instrucción y Visual Basic `For Each`... `Next` construcción para enumerar un <xref:System.ReadOnlySpan%601>.</span><span class="sxs-lookup"><span data-stu-id="55e66-139">Instead of calling the <xref:System.ReadOnlySpan%601.GetEnumerator%2A> method directly, you can use the C# `foreach` statement and the Visual Basic `For Each`...`Next` construct to enumerate a <xref:System.ReadOnlySpan%601>.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="readOnlySpan.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2">
          <AttributeName>System.Obsolete("GetHashCode() on ReadOnlySpan will always throw an exception.")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55e66-140">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-140">Not supported.</span></span> <span data-ttu-id="55e66-141">Produce una excepción <see cref="T:System.NotSupportedException" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-141">Throws a <see cref="T:System.NotSupportedException" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-142">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-142">Not supported.</span></span></returns>
        <remarks><span data-ttu-id="55e66-143">No se admite.</span><span class="sxs-lookup"><span data-stu-id="55e66-143">Not supported.</span></span></remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="55e66-144">Este método siempre realiza el inicio.</span><span class="sxs-lookup"><span data-stu-id="55e66-144">Always thrown by this method.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEmpty">
      <MemberSignature Language="C#" Value="public bool IsEmpty { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEmpty" />
      <MemberSignature Language="DocId" Value="P:System.ReadOnlySpan`1.IsEmpty" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEmpty As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEmpty { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEmpty : bool" Usage="System.ReadOnlySpan&lt;'T&gt;.IsEmpty" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="55e66-145">Devuelve un valor que indica que el intervalo actual de solo lectura está vacío.</span><span class="sxs-lookup"><span data-stu-id="55e66-145">Returns a value that indicates the current read-only span is empty.</span></span></summary>
        <value><span data-ttu-id="55e66-146"><see langword="true" /> Cuando el intervalo actual está vacío; en caso contrario <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-146"><see langword="true" /> when the current span is empty; otherwise <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public T&amp; this[int index] { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance T&amp; modreq(System.Runtime.InteropServices.InAttribute) Item(int32)" />
      <MemberSignature Language="DocId" Value="P:System.ReadOnlySpan`1.Item(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Default Public ReadOnly Property Item(index As Integer) As T&amp;" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property T&amp; ^ default[int] { T&amp; ^ get(int index); };" />
      <MemberSignature Language="F#" Value="member this.Item(int) : T&amp;" Usage="System.ReadOnlySpan&lt;'T&gt;.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2">
          <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>T&amp;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="index" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="index"><span data-ttu-id="55e66-147">Índice de base cero del elemento que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="55e66-147">The zero-based index of the element to get.</span></span></param>
        <summary><span data-ttu-id="55e66-148">Obtiene un elemento del intervalo de solo lectura en el índice de base cero especificado.</span><span class="sxs-lookup"><span data-stu-id="55e66-148">Gets an item from the read-only span at the specified zero-based index.</span></span></summary>
        <value><span data-ttu-id="55e66-149">Elemento del intervalo de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55e66-149">The element from the read-only span.</span></span></value>
        <remarks>To be added.</remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="55e66-150"><paramref name="index" /> es menor que cero o mayor o igual a <see cref="P:System.ReadOnlySpan`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-150"><paramref name="index" /> is less then zero or greater than or equal to <see cref="P:System.ReadOnlySpan`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Length">
      <MemberSignature Language="C#" Value="public int Length { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Length" />
      <MemberSignature Language="DocId" Value="P:System.ReadOnlySpan`1.Length" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Length As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Length { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Length : int" Usage="System.ReadOnlySpan&lt;'T&gt;.Length" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="55e66-151">El número de elementos del intervalo de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55e66-151">The number of items in the read-only span.</span></span></summary>
        <value><span data-ttu-id="55e66-152">Número de elementos.</span><span class="sxs-lookup"><span data-stu-id="55e66-152">The number of items.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ReadOnlySpan&lt;T&gt; left, ReadOnlySpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.ReadOnlySpan`1&lt;!T&gt; left, valuetype System.ReadOnlySpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.op_Equality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ReadOnlySpan(Of T), right As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(ReadOnlySpan&lt;T&gt; left, ReadOnlySpan&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="right" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="55e66-153">Primer intervalo que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="55e66-153">The first span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="55e66-154">Segundo intervalo que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="55e66-154">The second span to compare.</span></span></param>
        <summary><span data-ttu-id="55e66-155">Devuelve un valor que indica si dos instancias de <see cref="T:System.ReadOnlySpan`1" /> son iguales.</span><span class="sxs-lookup"><span data-stu-id="55e66-155">Returns a value that indicates whether two <see cref="T:System.ReadOnlySpan`1" /> instances are equal.</span></span></summary>
        <returns><span data-ttu-id="55e66-156">Es <see langword="true" /> si las dos instancias <see cref="T:System.ReadOnlySpan`1" /> son iguales; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-156"><see langword="true" /> if the two <see cref="T:System.ReadOnlySpan`1" /> instances are equal; otherwise, <see langword="false" /></span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-157">Esto comprueba si dos <xref:System.ReadOnlySpan`1> instancias apunte a la misma ubicación de memoria inicial y tienen el mismo <xref:System.ReadOnlySpan`1.Length> valores.</span><span class="sxs-lookup"><span data-stu-id="55e66-157">This tests if two <xref:System.ReadOnlySpan`1> instances point to the same starting memory location, and have the same <xref:System.ReadOnlySpan`1.Length> values.</span></span> <span data-ttu-id="55e66-158">No se compara el contenido de dos <xref:System.ReadOnlySpan`1> instancias.</span><span class="sxs-lookup"><span data-stu-id="55e66-158">This does not compare the contents of two <xref:System.ReadOnlySpan`1> instances.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (T[] array);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(!T[] array) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.op_Implicit(`0[])~System.ReadOnlySpan{`0}" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (array As T()) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(cli::array &lt;T&gt; ^ array);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : 'T[] -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.ReadOnlySpan&lt;'T&gt;.op_Implicit array" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="array" Type="T[]" />
      </Parameters>
      <Docs>
        <param name="array"><span data-ttu-id="55e66-159">Matriz que se va a convertir en <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-159">The array to convert to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="55e66-160">Define una conversión implícita de una matriz en <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-160">Defines an implicit conversion of an array to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-161">Intervalo de solo lectura que se corresponde con <paramref name="array" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-161">The read-only span that corresponds to <paramref name="array" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; arraySegment) cil managed" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (arraySegment As ArraySegment(Of T)) As ReadOnlySpan(Of T)" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(ArraySegment&lt;T&gt; arraySegment);" FrameworkAlternate="netcore-2.0" />
      <MemberSignature Language="C#" Value="public static implicit operator ReadOnlySpan&lt;T&gt; (ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.ReadOnlySpan`1&lt;!T&gt; op_Implicit(valuetype System.ArraySegment`1&lt;!T&gt; segment) cil managed" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.op_Implicit(System.ArraySegment{`0})~System.ReadOnlySpan{`0}" FrameworkAlternate="netcore-2.1;netcore-2.0;netcore-2.2" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (segment As ArraySegment(Of T)) As ReadOnlySpan(Of T)" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator ReadOnlySpan&lt;T&gt;(ArraySegment&lt;T&gt; segment);" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      <MemberSignature Language="F#" Value="static member op_Implicit : ArraySegment&lt;'T&gt; -&gt; ReadOnlySpan&lt;'T&gt;" Usage="System.ReadOnlySpan&lt;'T&gt;.op_Implicit segment" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="arraySegment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.0" />
        <Parameter Name="segment" Type="System.ArraySegment&lt;T&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2" />
      </Parameters>
      <Docs>
        <param name="arraySegment"><span data-ttu-id="55e66-162">Segmento de la matriz que se va a convertir en <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-162">The array segment to be converted to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <param name="segment"><span data-ttu-id="55e66-163">Segmento de la matriz que se va a convertir en <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-163">The array segment to be converted to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></param>
        <summary><span data-ttu-id="55e66-164">Define una conversión implícita de un elemento <see cref="T:System.ArraySegment`1" /> en <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-164">Defines an implicit conversion of an <see cref="T:System.ArraySegment`1" /> to a <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-165">Intervalo de solo lectura que se corresponde con el segmento de la matriz.</span><span class="sxs-lookup"><span data-stu-id="55e66-165">A read-only span that corresponds to the array segment.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ReadOnlySpan&lt;T&gt; left, ReadOnlySpan&lt;T&gt; right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.ReadOnlySpan`1&lt;!T&gt; left, valuetype System.ReadOnlySpan`1&lt;!T&gt; right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.op_Inequality(System.ReadOnlySpan{`0},System.ReadOnlySpan{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ReadOnlySpan(Of T), right As ReadOnlySpan(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(ReadOnlySpan&lt;T&gt; left, ReadOnlySpan&lt;T&gt; right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : ReadOnlySpan&lt;'T&gt; * ReadOnlySpan&lt;'T&gt; -&gt; bool" Usage="System.ReadOnlySpan&lt;'T&gt;.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.ReadOnlySpan&lt;T&gt;" />
        <Parameter Name="right" Type="System.ReadOnlySpan&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="55e66-166">El primer intervalo de solo lectura para comparar.</span><span class="sxs-lookup"><span data-stu-id="55e66-166">The first read-only span to compare.</span></span></param>
        <param name="right"><span data-ttu-id="55e66-167">El segundo intervalo de solo lectura para comparar.</span><span class="sxs-lookup"><span data-stu-id="55e66-167">The second read-only span to compare.</span></span></param>
        <summary><span data-ttu-id="55e66-168">Devuelve un valor que indica si dos instancias de <see cref="T:System.ReadOnlySpan`1" /> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="55e66-168">Returns a value that indicates whether two <see cref="T:System.ReadOnlySpan`1" /> instances are not equal.</span></span></summary>
        <returns><span data-ttu-id="55e66-169">Es <see langword="true" /> si las dos instancias de <see cref="T:System.ReadOnlySpan`1" /> no son iguales; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-169"><see langword="true" /> if the two <see cref="T:System.ReadOnlySpan`1" /> instances are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-170">Dos <xref:System.ReadOnlySpan%601> instancias no son iguales si tienen longitudes diferentes o si los elementos correspondientes de `left` y `right` señalan a ubicaciones de memoria diferente.</span><span class="sxs-lookup"><span data-stu-id="55e66-170">Two <xref:System.ReadOnlySpan%601> instances are not equal if they have different lengths or if the corresponding elements of `left` and `right` point to different memory locations.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;T&gt; Slice (int start);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlySpan`1&lt;!T&gt; Slice(int32 start) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.Slice(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan&lt;T&gt; Slice(int start);" />
      <MemberSignature Language="F#" Value="member this.Slice : int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="readOnlySpan.Slice start" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="55e66-171">Índice en el que va a comenzar el segmento.</span><span class="sxs-lookup"><span data-stu-id="55e66-171">The index at which to begin the slice.</span></span></param>
        <summary><span data-ttu-id="55e66-172">Forma un segmento fuera del intervalo actual de solo lectura que comienza en un índice especificado.</span><span class="sxs-lookup"><span data-stu-id="55e66-172">Forms a slice out of the current read-only span that begins at a specified index.</span></span></summary>
        <returns><span data-ttu-id="55e66-173">Intervalo que consta de todos los elementos del intervalo actual desde <paramref name="index" /> hasta el final del intervalo.</span><span class="sxs-lookup"><span data-stu-id="55e66-173">A span that consists of all elements of the current span from <paramref name="index" /> to the end of the span.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="55e66-174"><paramref name="start" /> es mayor que el número de elementos del intervalo de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="55e66-174"><paramref name="start" /> is greater than the number of items in the read-only span.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Slice">
      <MemberSignature Language="C#" Value="public ReadOnlySpan&lt;T&gt; Slice (int start, int length);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.ReadOnlySpan`1&lt;!T&gt; Slice(int32 start, int32 length) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.Slice(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Slice (start As Integer, length As Integer) As ReadOnlySpan(Of T)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; ReadOnlySpan&lt;T&gt; Slice(int start, int length);" />
      <MemberSignature Language="F#" Value="member this.Slice : int * int -&gt; ReadOnlySpan&lt;'T&gt;" Usage="readOnlySpan.Slice (start, length)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.ReadOnlySpan&lt;T&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="start" Type="System.Int32" />
        <Parameter Name="length" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="start"><span data-ttu-id="55e66-175">Índice en el que va a comenzar este segmento.</span><span class="sxs-lookup"><span data-stu-id="55e66-175">The index at which to begin this slice.</span></span></param>
        <param name="length"><span data-ttu-id="55e66-176">Longitud deseada del segmento.</span><span class="sxs-lookup"><span data-stu-id="55e66-176">The desired length for the slice.</span></span></param>
        <summary><span data-ttu-id="55e66-177">Forma un segmento fuera del intervalo actual de solo lectura a partir de un índice especificado durante una longitud determinada.</span><span class="sxs-lookup"><span data-stu-id="55e66-177">Forms a slice out of the current read-only span starting at a specified index for a specified length.</span></span></summary>
        <returns><span data-ttu-id="55e66-178">Intervalo de solo lectura que consta de elementos <paramref name="length" /> desde el intervalo actual a partir de <paramref name="index" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-178">A read-only span that consists of <paramref name="length" /> elements from the current span starting at <paramref name="index" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="55e66-179"><paramref name="start" /> es menor que cero o mayor o igual a <see cref="T:System.Span`1.Length" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-179"><paramref name="start" /> is less than zero or greater than or equal to <see cref="T:System.Span`1.Length" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToArray">
      <MemberSignature Language="C#" Value="public T[] ToArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance !T[] ToArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.ToArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToArray () As T()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;T&gt; ^ ToArray();" />
      <MemberSignature Language="F#" Value="member this.ToArray : unit -&gt; 'T[]" Usage="readOnlySpan.ToArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>T[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55e66-180">Copia el contenido de este intervalo de solo lectura en una nueva matriz.</span><span class="sxs-lookup"><span data-stu-id="55e66-180">Copies the contents of this read-only span into a new array.</span></span></summary>
        <returns><span data-ttu-id="55e66-181">Matriz que contiene los datos del intervalo actual.</span><span class="sxs-lookup"><span data-stu-id="55e66-181">An array containing the data in the current span.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-182">Este método realiza una copia de datos y de asignación del montón y, por lo tanto, debe evitarse si es posible.</span><span class="sxs-lookup"><span data-stu-id="55e66-182">This method performs a heap allocation and data copy, and therefore, should be avoided if possible.</span></span> <span data-ttu-id="55e66-183">Lo que a veces es necesario cuando las API que admiten <xref:System.ReadOnlySpan%601> no están disponibles, pero las API que funcionan con matrices.</span><span class="sxs-lookup"><span data-stu-id="55e66-183">It it sometimes necessary when APIs that support <xref:System.ReadOnlySpan%601> are not available, but APIs that work with arrays are.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="readOnlySpan.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="55e66-184">Devuelve la representación de <see cref="T:System.ReadOnlySpan`1" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-184">Returns the string representation of this <see cref="T:System.ReadOnlySpan`1" />.</span></span></summary>
        <returns><span data-ttu-id="55e66-185">Representación de cadena de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="55e66-185">The string representation of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-186">Para un `ReadOnlySpan<Char>`, `ToString` método devuelve un <xref:System.String> que contiene los caracteres que apunta el intervalo.</span><span class="sxs-lookup"><span data-stu-id="55e66-186">For a `ReadOnlySpan<Char>`, the `ToString` method returns a <xref:System.String> that contains the characters pointed to by the span.</span></span> <span data-ttu-id="55e66-187">De lo contrario, devuelve un <xref:System.String> con el nombre del tipo y el número de elementos que contiene el intervalo.</span><span class="sxs-lookup"><span data-stu-id="55e66-187">Otherwise, it returns a <xref:System.String> with the name of the type and the number of elements that the span contains.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TryCopyTo">
      <MemberSignature Language="C#" Value="public bool TryCopyTo (Span&lt;T&gt; destination);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryCopyTo(valuetype System.Span`1&lt;!T&gt; destination) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.ReadOnlySpan`1.TryCopyTo(System.Span{`0})" />
      <MemberSignature Language="VB.NET" Value="Public Function TryCopyTo (destination As Span(Of T)) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool TryCopyTo(Span&lt;T&gt; destination);" />
      <MemberSignature Language="F#" Value="member this.TryCopyTo : Span&lt;'T&gt; -&gt; bool" Usage="readOnlySpan.TryCopyTo destination" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Memory</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;T&gt;" />
      </Parameters>
      <Docs>
        <param name="destination"><span data-ttu-id="55e66-188">Destino de la operación de copia.</span><span class="sxs-lookup"><span data-stu-id="55e66-188">The target of the copy operation.</span></span></param>
        <summary><span data-ttu-id="55e66-189">Intenta copiar el contenido de <see cref="System.ReadOnlySpan`1" /> en <see cref="System.Span`1" /> y devuelve un valor para indicar si la operación se ha realizado correctamente o no.</span><span class="sxs-lookup"><span data-stu-id="55e66-189">Attempts to copy the contents of this <see cref="System.ReadOnlySpan`1" /> into a <see cref="System.Span`1" /> and returns a value to indicate whether or not the operation succeeded.</span></span></summary>
        <returns><span data-ttu-id="55e66-190"><see langword="true" /> si la operación de copia se ha realizado correctamente; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="55e66-190"><see langword="true" /> if the copy operation succeeded; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="55e66-191">Si el `source` y `destination` se superponen, la totalidad de `source` se tratará como si se ha copiado en una ubicación temporal antes de copiarlos a `destination`.</span><span class="sxs-lookup"><span data-stu-id="55e66-191">If the `source` and `destination` overlap, the entirety of `source` is handled as if it was copied to a temporary location before it is copied to `destination`.</span></span>

<span data-ttu-id="55e66-192">Si el `destination` longitud es menor que `source`, no hay elementos se copian y el método devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="55e66-192">If the `destination` length is shorter than `source`, no items are copied and the method returns `false`.</span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>