<Type Name="GC" FullName="System.GC">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="49d7f123c5b7e13096e48237964ba4928d5d2ae9" />
    <Meta Name="ms.sourcegitcommit" Value="9e06b87bcfa4347dbbaaa4b3cc36b43b93b5badb" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="es-ES" />
    <Meta Name="ms.lasthandoff" Value="11/20/2018" />
    <Meta Name="ms.locfileid" Value="52244374" />
  </Metadata>
  <TypeSignature Language="C#" Value="public static class GC" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract sealed beforefieldinit GC extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.GC" />
  <TypeSignature Language="VB.NET" Value="Public Class GC" />
  <TypeSignature Language="C++ CLI" Value="public ref class GC abstract sealed" />
  <TypeSignature Language="F#" Value="type GC = class" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>
      <span data-ttu-id="20d1b-101">Controla el recolector de elementos no utilizados del sistema, un servicio que recupera de forma automática la memoria que no se utiliza.</span>
      <span class="sxs-lookup">
        <span data-stu-id="20d1b-101">Controls the system garbage collector, a service that automatically reclaims unused memory.</span>
      </span>
    </summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-102">El recolector de elementos no utilizados es un componente de common language runtime que controla la asignación y liberación de memoria administrada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-102">The garbage collector is a common language runtime component that controls the allocation and release of managed memory.</span></span> <span data-ttu-id="20d1b-103">Influir en los métodos de esta clase cuando se realiza la recolección de elementos en un objeto y, cuando se liberan los recursos asignados por un objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-103">The methods in this class influence when garbage collection is performed on an object and when resources allocated by an object are released.</span></span> <span data-ttu-id="20d1b-104">Propiedades de esta clase proporcionan información acerca de la cantidad total de memoria disponible en el sistema y la categoría de edad o la generación de memoria asignada a un objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-104">Properties in this class provide information about the total amount of memory available in the system and the age category, or generation, of memory allocated to an object.</span></span>  
  
 <span data-ttu-id="20d1b-105">El recolector de elementos no utilizados realiza un seguimiento y reclama los objetos asignados en memoria administrada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-105">The garbage collector tracks and reclaims objects allocated in managed memory.</span></span> <span data-ttu-id="20d1b-106">Periódicamente, el recolector de elementos no utilizados realiza la recolección para liberar memoria asignada a objetos para los que no hay ninguna referencia válida.</span><span class="sxs-lookup"><span data-stu-id="20d1b-106">Periodically, the garbage collector performs garbage collection to reclaim memory allocated to objects for which there are no valid references.</span></span> <span data-ttu-id="20d1b-107">Colección de elementos no utilizados se produce automáticamente cuando no se puede satisfacer una solicitud de memoria utilizando la memoria libre disponible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-107">Garbage collection happens automatically when a request for memory cannot be satisfied using available free memory.</span></span> <span data-ttu-id="20d1b-108">O bien, una aplicación puede forzar la colección de elementos no utilizados mediante la <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-108">Alternatively, an application can force garbage collection using the <xref:System.GC.Collect%2A> method.</span></span>  
  
 <span data-ttu-id="20d1b-109">Recolección de elementos consta de los pasos siguientes:</span><span class="sxs-lookup"><span data-stu-id="20d1b-109">Garbage collection consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="20d1b-110">El recolector de elementos no utilizados busca los objetos administrados que se hace referencia en código administrado.</span><span class="sxs-lookup"><span data-stu-id="20d1b-110">The garbage collector searches for managed objects that are referenced in managed code.</span></span>  
  
2.  <span data-ttu-id="20d1b-111">El recolector de elementos no utilizados intenta finalizar los objetos que no se hace referencia.</span><span class="sxs-lookup"><span data-stu-id="20d1b-111">The garbage collector tries to finalize objects that are not referenced.</span></span>  
  
3.  <span data-ttu-id="20d1b-112">El recolector de elementos no utilizados libera los objetos que no se hace referencia y reclama su memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-112">The garbage collector frees objects that are not referenced and reclaims their memory.</span></span>  
  
 <span data-ttu-id="20d1b-113">En este tema, se incluyen las siguientes secciones:</span><span class="sxs-lookup"><span data-stu-id="20d1b-113">This topic includes the following sections:</span></span>  
  
 <span data-ttu-id="20d1b-114">[El recolector de elementos no utilizados y los recursos no administrados](#unmanaged) </span><span class="sxs-lookup"><span data-stu-id="20d1b-114">[The garbage collector and unmanaged resources](#unmanaged) </span></span>  
 <span data-ttu-id="20d1b-115">[Generaciones y caducidad de objetos](#generations) </span><span class="sxs-lookup"><span data-stu-id="20d1b-115">[Object aging and generations](#generations) </span></span>  
 [<span data-ttu-id="20d1b-116">Impedir la recolección de elementos</span><span class="sxs-lookup"><span data-stu-id="20d1b-116">Disallowing garbage collection</span></span>](#NoGCRegion)  
  
<a name="unmanaged"></a>   
## <a name="the-garbage-collector-and-unmanaged-resources"></a><span data-ttu-id="20d1b-117">El recolector de elementos no utilizados y los recursos no administrados</span><span class="sxs-lookup"><span data-stu-id="20d1b-117">The garbage collector and unmanaged resources</span></span>  
 <span data-ttu-id="20d1b-118">Durante una recolección, el recolector de elementos no utilizados no liberar un objeto si encuentra una o varias referencias al objeto en el código administrado.</span><span class="sxs-lookup"><span data-stu-id="20d1b-118">During a collection, the garbage collector will not free an object if it finds one or more references to the object in managed code.</span></span> <span data-ttu-id="20d1b-119">Sin embargo, el recolector de elementos no utilizados no reconoce las referencias a un objeto desde código no administrado y puede liberar objetos que se utilizan exclusivamente en código no administrado, a menos que explícitamente no hacerlo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-119">However, the garbage collector does not recognize references to an object from unmanaged code, and might free objects that are being used exclusively in unmanaged code unless explicitly prevented from doing so.</span></span> <span data-ttu-id="20d1b-120">El <xref:System.GC.KeepAlive%2A> método proporciona un mecanismo que impide que el recolector de elementos de recopilación de objetos que están en uso en código no administrado.</span><span class="sxs-lookup"><span data-stu-id="20d1b-120">The <xref:System.GC.KeepAlive%2A> method provides a mechanism that prevents the garbage collector from collecting objects that are still in use in unmanaged code.</span></span>  
  
 <span data-ttu-id="20d1b-121">Aparte de las asignaciones de memoria administrada, las implementaciones del recolector de elementos no utilizados no mantienen información acerca de los recursos mantenidos por un objeto, como identificadores de archivos o las conexiones de base de datos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-121">Aside from managed memory allocations, implementations of the garbage collector do not maintain information about resources held by an object, such as file handles or database connections.</span></span> <span data-ttu-id="20d1b-122">Cuando un tipo utiliza recursos no administrados que deben liberarse antes de que se recuperan instancias del tipo, el tipo puede implementar un finalizador.</span><span class="sxs-lookup"><span data-stu-id="20d1b-122">When a type uses unmanaged resources that must be released before instances of the type are reclaimed, the type can implement a finalizer.</span></span>  
  
 <span data-ttu-id="20d1b-123">En la mayoría de los casos, los finalizadores se implementan mediante la invalidación de la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método; sin embargo, los tipos escritos en C# o C++ implementan destructores, que los compiladores se convierten en un reemplazo de <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-123">In most cases, finalizers are implemented by overriding the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method; however, types written in C# or C++ implement destructors, which compilers turn into an override of <xref:System.Object.Finalize%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20d1b-124">En la mayoría de los casos, si un objeto tiene un finalizador, el recolector de elementos no utilizados lo llama antes de liberar el objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-124">In most cases, if an object has a finalizer, the garbage collector calls it prior to freeing the object.</span></span> <span data-ttu-id="20d1b-125">Sin embargo, el recolector de elementos no utilizados no es necesario para llamar a los finalizadores en todas las situaciones; Por ejemplo, el <xref:System.GC.SuppressFinalize%2A> método explícitamente impide que un finalizador del objeto que se llama.</span><span class="sxs-lookup"><span data-stu-id="20d1b-125">However, the garbage collector is not required to call finalizers in all situations; for example, the <xref:System.GC.SuppressFinalize%2A> method explicitly prevents an object's finalizer from being called.</span></span> <span data-ttu-id="20d1b-126">Además, el recolector de elementos no utilizados no tiene que usar un subproceso específico para finalizar los objetos o garantiza el orden en el que se llama a los finalizadores para objetos que hacen referencia entre sí, pero están disponibles para la recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-126">Also, the garbage collector is not required to use a specific thread to finalize objects, or guarantee the order in which finalizers are called for objects that reference each other but are otherwise available for garbage collection.</span></span>  
  
 <span data-ttu-id="20d1b-127">En escenarios donde se deben liberar los recursos en un momento determinado, las clases pueden implementar la <xref:System.IDisposable> interfaz, que contiene el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> método que realiza las tareas de administración y limpieza de recursos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-127">In scenarios where resources must be released at a specific time, classes can implement the <xref:System.IDisposable> interface, which contains the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> method that performs resource management and cleanup tasks.</span></span> <span data-ttu-id="20d1b-128">Las clases que implementan <xref:System.IDisposable.Dispose%2A> especifique, como parte de su contrato de clase, cuando los consumidores de la clase llama al método para limpiar el objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-128">Classes that implement <xref:System.IDisposable.Dispose%2A> must specify, as part of their class contract, if and when class consumers call the method to clean up the object.</span></span> <span data-ttu-id="20d1b-129">El recolector de elementos no utilizados no, de forma predeterminada, llama a la <xref:System.IDisposable.Dispose%2A> método; sin embargo, las implementaciones de la <xref:System.IDisposable.Dispose%2A> método puede llamar a métodos el <xref:System.GC> clase para personalizar el comportamiento de finalización del recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-129">The garbage collector does not, by default, call the <xref:System.IDisposable.Dispose%2A> method; however, implementations of the <xref:System.IDisposable.Dispose%2A> method can call methods in the <xref:System.GC> class to customize the finalization behavior of the garbage collector.</span></span>  
  
 <span data-ttu-id="20d1b-130">Para obtener más información sobre la finalización del objeto y el patrón de dispose, vea [limpiar recursos no administrados](~/docs/standard/garbage-collection/unmanaged.md).</span><span class="sxs-lookup"><span data-stu-id="20d1b-130">For more information on object finalization and the dispose pattern, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md).</span></span>  
  
<a name="generations"></a>   
## <a name="object-aging-and-generations"></a><span data-ttu-id="20d1b-131">Generaciones y caducidad de objetos</span><span class="sxs-lookup"><span data-stu-id="20d1b-131">Object aging and generations</span></span>  
 <span data-ttu-id="20d1b-132">El recolector de elementos no utilizados de common language runtime admite la edad de los objetos mediante las generaciones.</span><span class="sxs-lookup"><span data-stu-id="20d1b-132">The garbage collector in the common language runtime supports object aging using generations.</span></span> <span data-ttu-id="20d1b-133">Una generación es una unidad de medida de la antigüedad relativa de los objetos en memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-133">A generation is a unit of measure of the relative age of objects in memory.</span></span> <span data-ttu-id="20d1b-134">El número de generación o la edad de un objeto indica la generación a la que pertenece un objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-134">The generation number, or age, of an object indicates the generation to which an object belongs.</span></span> <span data-ttu-id="20d1b-135">Los objetos creados más recientemente forman parte de las generaciones más recientes y tienen los números más bajos de generación de ciclo de los objetos creados anteriormente en la vida de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-135">Objects created more recently are part of newer generations, and have lower generation numbers than objects created earlier in the application life cycle.</span></span> <span data-ttu-id="20d1b-136">Son objetos de la generación más reciente en la generación 0.</span><span class="sxs-lookup"><span data-stu-id="20d1b-136">Objects in the most recent generation are in generation 0.</span></span> <span data-ttu-id="20d1b-137">Esta implementación del recolector de elementos no utilizados admite tres generaciones de objetos, las generaciones 0, 1 y 2.</span><span class="sxs-lookup"><span data-stu-id="20d1b-137">This implementation of the garbage collector supports three generations of objects, generations 0, 1, and 2.</span></span> <span data-ttu-id="20d1b-138">Puede recuperar el valor de la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el número de generación máximo admitido por el sistema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-138">You can retrieve the value of the <xref:System.GC.MaxGeneration%2A> property to determine the maximum generation number supported by the system.</span></span>  
  
 <span data-ttu-id="20d1b-139">Caducidad de objetos permite que las aplicaciones dirijan la recolección en un conjunto específico de generaciones en lugar de requerir el recolector de elementos no utilizados evaluar todas las generaciones.</span><span class="sxs-lookup"><span data-stu-id="20d1b-139">Object aging allows applications to target garbage collection at a specific set of generations rather than requiring the garbage collector to evaluate all generations.</span></span> <span data-ttu-id="20d1b-140">Las sobrecargas de los <xref:System.GC.Collect%2A> método que incluyen un `generation` parámetro le permiten especificar la generación más antigua se recolecte.</span><span class="sxs-lookup"><span data-stu-id="20d1b-140">Overloads of the <xref:System.GC.Collect%2A> method that include a `generation` parameter allow you to specify the oldest generation to be garbage collected.</span></span>  
  
<a name="NoGCRegion"></a>   
## <a name="disallowing-garbage-collection"></a><span data-ttu-id="20d1b-141">Impedir la recolección de elementos</span><span class="sxs-lookup"><span data-stu-id="20d1b-141">Disallowing garbage collection</span></span>  
 <span data-ttu-id="20d1b-142">A partir de la [!INCLUDE[net_v46](~/includes/net-v46-md.md)], el recolector de elementos no utilizados es compatible con un GC región modo de no latencia que se puede usar durante la ejecución de las rutas críticas en qué elementos no utilizados colección puede afectar al rendimiento de una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-142">Starting with the [!INCLUDE[net_v46](~/includes/net-v46-md.md)], the garbage collector supports a no GC region latency mode that can be used during the execution of critical paths in which garbage collection can adversely affect an app's performance.</span></span> <span data-ttu-id="20d1b-143">El modo de latencia ninguna región de GC requiere que especifique una cantidad de memoria que se puede asignar sin interferencias del recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-143">The no GC region latency mode requires that you specify an amount of memory that can be allocated without interference from the garbage collector.</span></span> <span data-ttu-id="20d1b-144">Si el tiempo de ejecución puede asignar memoria, el tiempo de ejecución no realizará una colección de elementos no utilizados mientras se está ejecutando código en la ruta crítica.</span><span class="sxs-lookup"><span data-stu-id="20d1b-144">If the runtime can allocate that memory, the runtime will not perform a garbage collection while code in the critical path is executing.</span></span>  
  
 <span data-ttu-id="20d1b-145">Definir el principio de la ruta crítica de la región de GC no mediante una llamada a una de las sobrecargas de los <xref:System.GC.TryStartNoGCRegion%2A>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-145">You define the beginning of the critical path of the no GC region by calling one of the overloads of the <xref:System.GC.TryStartNoGCRegion%2A>.</span></span> <span data-ttu-id="20d1b-146">Especifique el final de su ruta de acceso crítica mediante una llamada a la <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-146">You specify the end of its critical path by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 <span data-ttu-id="20d1b-147">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-147">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-148">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-148">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-149">El ejemplo siguiente usa varios métodos de GC para obtener información de memoria sobre un bloque de objetos no utilizados y la generación e imprimirlo en la consola.</span><span class="sxs-lookup"><span data-stu-id="20d1b-149">The following example uses several GC methods to get generation and memory information about a block of unused objects and print it to the console.</span></span> <span data-ttu-id="20d1b-150">Los objetos no utilizados, a continuación, se recopilan y se muestran los totales de memoria resultantes.</span><span class="sxs-lookup"><span data-stu-id="20d1b-150">The unused objects are then collected, and the resulting memory totals are displayed.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Runtime.GCSettings" />
    <related type="Article" href="~/docs/standard/garbage-collection/index.md">
      <span data-ttu-id="20d1b-151">recolección de elementos no utilizados</span>
      <span class="sxs-lookup">
        <span data-stu-id="20d1b-151">Garbage Collection</span>
      </span>
    </related>
    <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
      <span data-ttu-id="20d1b-152">Fundamentos de la recolección de elementos no utilizados</span>
      <span class="sxs-lookup">
        <span data-stu-id="20d1b-152">Fundamentals of Garbage Collection</span>
      </span>
    </related>
  </Docs>
  <Members>
    <Member MemberName="AddMemoryPressure">
      <MemberSignature Language="C#" Value="public static void AddMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void AddMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.AddMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub AddMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void AddMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member AddMemoryPressure : int64 -&gt; unit" Usage="System.GC.AddMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="20d1b-153">Cantidad incremental de memoria no administrada que se ha asignado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-153">The incremental amount of unmanaged memory that has been allocated.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-154">Informa al tiempo de ejecución de una asignación grande de memoria no administrada que se debe tener en cuenta al programar la recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-154">Informs the runtime of a large allocation of unmanaged memory that should be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-155">Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada está asignada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-155">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="20d1b-156">Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta que sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-156">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="20d1b-157">El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-157">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory.</span></span>  
  
 <span data-ttu-id="20d1b-158">En el patrón de uso más simple, un objeto administrado asigna memoria no administrada en el constructor y lo libera en la `Dispose` o `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-158">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="20d1b-159">Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.</span><span class="sxs-lookup"><span data-stu-id="20d1b-159">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="20d1b-160">En escenarios más complicados, donde la asignación de memoria no administrada cambia considerablemente durante la vigencia del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos de comunicación de estos cambios incrementales en el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20d1b-160">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="20d1b-161">Debe asegurarse de que quita exactamente la cantidad de presión que agrega.</span><span class="sxs-lookup"><span data-stu-id="20d1b-161">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="20d1b-162">Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-162">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-163">
            <paramref name="bytesAllocated" /> es menor o igual que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-163">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="20d1b-164">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-164">-or-</span>
          </span>
          <span data-ttu-id="20d1b-165">En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-165">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="20d1b-166">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-166">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="20d1b-167">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-167">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-168">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-168">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-169">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-169">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="CancelFullGCNotification">
      <MemberSignature Language="C#" Value="public static void CancelFullGCNotification ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelFullGCNotification() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CancelFullGCNotification" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelFullGCNotification ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelFullGCNotification();" />
      <MemberSignature Language="F#" Value="static member CancelFullGCNotification : unit -&gt; unit" Usage="System.GC.CancelFullGCNotification " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-170">Cancela el registro de una notificación de recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-170">Cancels the registration of a garbage collection notification.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-171">Este método cancela una notificación de recolección que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-171">This method cancels a garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="20d1b-172">No es necesario llamar a este método antes de ajustar los valores de parámetro de umbral en llamadas posteriores a la <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-172">You do not have to call this method before adjusting threshold parameter values in subsequent calls to the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-173">El ejemplo siguiente cancela un registro de la colección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-173">The following example cancels a garbage collection registration.</span></span> <span data-ttu-id="20d1b-174">Este ejemplo forma parte de un ejemplo más extenso proporcionado para el [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-174">This example is part of a larger example provided for the [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#7](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#7)]
 [!code-csharp[GCNotification#7](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#7)]
 [!code-vb[GCNotification#7](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-175">Este miembro no está disponible cuando la recolección de elementos no utilizados simultánea está habilitada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-175">This member is not available when concurrent garbage collection is enabled.</span>
          </span>
          <span data-ttu-id="20d1b-176">Vea la configuración en tiempo de ejecución [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) para obtener información sobre cómo deshabilitar la recolección de elementos no utilizados simultánea.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-176">See the [&lt;gcConcurrent&gt;](~/docs/framework/configure-apps/file-schema/runtime/gcconcurrent-element.md) runtime setting for information about how to disable concurrent garbage collection.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-177">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-177">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-178">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-178">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-179">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-179">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-180">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-180">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-181">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-181">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Collect">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-182">Fuerza a que se lleve a cabo la recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-182">Forces garbage collection.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect();" />
      <MemberSignature Language="F#" Value="static member Collect : unit -&gt; unit" Usage="System.GC.Collect " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-183">Fuerza a que se lleve a cabo una recolección de elementos no utilizados de todas las generaciones.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-183">Forces an immediate garbage collection of all generations.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-184">Utilice este método para intentar reclamar toda la memoria que no es accesible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-184">Use this method to try to reclaim all memory that is inaccessible.</span></span> <span data-ttu-id="20d1b-185">Realiza una recolección de elementos no utilizados de bloqueo de todas las generaciones.</span><span class="sxs-lookup"><span data-stu-id="20d1b-185">It performs a blocking garbage collection of all generations.</span></span>  
  
 <span data-ttu-id="20d1b-186">Todos los objetos, independientemente de cuánto tiempo llevan en memoria, se consideran para la colección; Sin embargo, no se recopilan los objetos que se hace referencia en código administrado.</span><span class="sxs-lookup"><span data-stu-id="20d1b-186">All objects, regardless of how long they have been in memory, are considered for collection; however, objects that are referenced in managed code are not collected.</span></span> <span data-ttu-id="20d1b-187">Utilice este método para forzar al sistema para intentar reclamar la cantidad máxima de memoria disponible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-187">Use this method to force the system to try to reclaim the maximum amount of available memory.</span></span>  
  
 <span data-ttu-id="20d1b-188">A partir de la [!INCLUDE[net_v451](~/includes/net-v451-md.md)], puede compactar el montón de objetos grandes (LOH) estableciendo el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método, como en el ejemplo siguiente se muestra.</span><span class="sxs-lookup"><span data-stu-id="20d1b-188">Starting with the [!INCLUDE[net_v451](~/includes/net-v451-md.md)], you can compact the large object heap (LOH) by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Runtime.GCSettings#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.runtime.gcsettings/cs/lohcompactionmode1.cs#1)]
 [!code-vb[System.Runtime.GCSettings#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.runtime.gcsettings/vb/lohcompactionmode1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-189">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.Collect%2A> método para realizar una recolección en todas las generaciones de memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-189">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on all generations of memory.</span></span> <span data-ttu-id="20d1b-190">El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-190">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.Collect Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.Collect Example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.Collect Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="20d1b-191">Colecciones inducidas</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-191">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation);" />
      <MemberSignature Language="F#" Value="static member Collect : int -&gt; unit" Usage="System.GC.Collect generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="20d1b-192">El número de la generación más antigua de elementos no usados para recolectar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-192">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-193">Fuerza a que se lleve a cabo inmediatamente la recolección de elementos no utilizados desde la generación 0 hasta la generación especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-193">Forces an immediate garbage collection from generation 0 through a specified generation.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-194">Utilice este método para intentar reclamar la memoria que no es accesible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-194">Use this method to try to reclaim memory that is inaccessible.</span></span> <span data-ttu-id="20d1b-195">Sin embargo, con este método no garantiza que se reclame toda la memoria accesible en la generación especificada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-195">However, using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="20d1b-196">Si se implementa la edad de los objetos, el recolector de elementos no utilizados no recopila los objetos con un número de generación que es mayor que la generación especificada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-196">If object aging is implemented, the garbage collector does not collect objects with a generation number that is higher than the specified generation.</span></span> <span data-ttu-id="20d1b-197">Si no se implementa la edad de los objetos, el recolector de elementos no utilizados considera que todos los objetos durante la recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-197">If object aging is not implemented, the garbage collector considers all objects during the garbage collection.</span></span>  
  
 <span data-ttu-id="20d1b-198">Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de la `generation` parámetro.</span><span class="sxs-lookup"><span data-stu-id="20d1b-198">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of the `generation` parameter.</span></span>  
  
 <span data-ttu-id="20d1b-199">Para que el recolector de elementos no utilizados que considere la posibilidad de todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="20d1b-199">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span> <span data-ttu-id="20d1b-200">Para que el recolector de elementos reclamar objetos en función de un <xref:System.GCCollectionMode> establecer, use el <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-200">To have the garbage collector reclaim objects based on a <xref:System.GCCollectionMode> setting, use the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%29?displayProperty=nameWithType> method overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-201">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.Collect%2A> método para realizar una recolección en capas individuales de memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-201">The following example demonstrates how to use the <xref:System.GC.Collect%2A> method to perform a collection on individual layers of memory.</span></span> <span data-ttu-id="20d1b-202">El código genera un número de objetos no utilizados y, a continuación, llama a la <xref:System.GC.Collect%2A> método para limpiarlos de la memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-202">The code generates a number of unused objects, and then calls the <xref:System.GC.Collect%2A> method to clean them from memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-203">
            <paramref name="generation" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-203">
              <paramref name="generation" /> is not valid.</span>
          </span>
        </exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="20d1b-204">Colecciones inducidas</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-204">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode -&gt; unit" Usage="System.GC.Collect (generation, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="20d1b-205">El número de la generación más antigua de elementos no usados para recolectar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-205">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="20d1b-206">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-206">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-207">Fuerza una recolección de elementos no utilizados desde la generación 0 hasta la generación especificada, en el momento especificado por el valor <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-207">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-208">Use el `mode` parámetro para especificar si la colección de elementos no utilizados debería producirse inmediatamente o solo si el tiempo es adecuado para reclamar objetos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-208">Use the `mode` parameter to specify whether garbage collection should occur immediately or only if the time is optimal to reclaim objects.</span></span> <span data-ttu-id="20d1b-209">Con este método no garantiza que se reclame toda la memoria accesible en la generación especificada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-209">Using this method does not guarantee that all inaccessible memory in the specified generation is reclaimed.</span></span>  
  
 <span data-ttu-id="20d1b-210">Para ajustar la tendencia a la intrusión de elementos no utilizados durante los períodos críticos en la aplicación, establezca el <xref:System.Runtime.GCSettings.LatencyMode%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="20d1b-210">To adjust the intrusiveness of garbage collection during critical periods in your application, set the <xref:System.Runtime.GCSettings.LatencyMode%2A> property.</span></span>  
  
 <span data-ttu-id="20d1b-211">El recolector de elementos no utilizados no recopila los objetos con un número de generación superior al especificado por el `generation` parámetro.</span><span class="sxs-lookup"><span data-stu-id="20d1b-211">The garbage collector does not collect objects with a generation number higher than specified by the `generation` parameter.</span></span> <span data-ttu-id="20d1b-212">Use la <xref:System.GC.MaxGeneration%2A> propiedad para determinar el máximo valor válido de `generation`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-212">Use the <xref:System.GC.MaxGeneration%2A> property to determine the maximum valid value of `generation`.</span></span>  
  
 <span data-ttu-id="20d1b-213">Para que el recolector de elementos no utilizados que considere la posibilidad de todos los objetos independientemente de su generación, utilice la versión de este método que no toma ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="20d1b-213">To have the garbage collector consider all objects regardless of their generation, use the version of this method that takes no parameters.</span></span>  
  
 <span data-ttu-id="20d1b-214">Para que el recolector de elementos no utilizados recupera los objetos hasta una generación especificada de objetos, use el <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-214">To have the garbage collector reclaim objects up to a specified generation of objects, use the <xref:System.GC.Collect%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="20d1b-215">Al especificar la generación máxima, se recopilan todos los objetos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-215">When you specify the maximum generation, all objects are collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-216">En el ejemplo siguiente se fuerza una recolección de elementos para los objetos de generación 2 con la <xref:System.GCCollectionMode.Optimized> configuración.</span><span class="sxs-lookup"><span data-stu-id="20d1b-216">The following example forces a garbage collection for generation 2 objects with the <xref:System.GCCollectionMode.Optimized> setting.</span></span>  
  
 [!code-csharp[System.GC.GCCollectionMode#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GCCollectionMode/cs/Program.cs#1)]
 [!code-vb[System.GC.GCCollectionMode#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GCCollectionMode/vb/program.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-217">
            <paramref name="generation" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-217">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="20d1b-218">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-218">-or-</span>
          </span>
          <span data-ttu-id="20d1b-219">
            <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-219">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
        <related type="Article" href="https://msdn.microsoft.com/library/019008fe-4708-4e65-bebf-04fd9941e149">
          <span data-ttu-id="20d1b-220">Colecciones inducidas</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-220">Induced Collections</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="20d1b-221">El número de la generación más antigua de elementos no usados para recolectar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-221">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="20d1b-222">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-222">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="20d1b-223">
            <see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-223">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-224">Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con un valor que especifica si la recolección debe ser de bloqueo.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-224">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with a value specifying whether the collection should be blocking.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-225">En la tabla siguiente se resume la interacción de la `mode` y `blocking` parámetros:</span><span class="sxs-lookup"><span data-stu-id="20d1b-225">The following table summarizes the interaction of the `mode` and `blocking` parameters:</span></span>  
  
|`mode`|<span data-ttu-id="20d1b-226">`blocking` es `true`</span><span class="sxs-lookup"><span data-stu-id="20d1b-226">`blocking` is `true`</span></span>|<span data-ttu-id="20d1b-227">`blocking` es `false`</span><span class="sxs-lookup"><span data-stu-id="20d1b-227">`blocking` is `false`</span></span>|  
|-|-|-|  
|<span data-ttu-id="20d1b-228"><xref:System.GCCollectionMode.Forced> o <xref:System.GCCollectionMode.Default></span><span class="sxs-lookup"><span data-stu-id="20d1b-228"><xref:System.GCCollectionMode.Forced> or <xref:System.GCCollectionMode.Default></span></span>|<span data-ttu-id="20d1b-229">Se realiza una recolección de bloqueo lo antes posible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-229">A blocking collection is performed as soon as possible.</span></span> <span data-ttu-id="20d1b-230">Si una recolección en segundo plano está en curso y `generation` es 0 o 1, el <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método inmediatamente desencadena una recolección de bloqueo y vuelve cuando finaliza la colección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-230">If a background collection is in progress and `generation` is 0 or 1, the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method immediately triggers a blocking collection and returns when the collection is finished.</span></span> <span data-ttu-id="20d1b-231">Si una recolección en segundo plano está en curso y `generation` es 2, el método espera hasta que finalice la recolección en segundo plano, desencadena una recolección de generación 2 de bloqueo y, a continuación, se devuelve.</span><span class="sxs-lookup"><span data-stu-id="20d1b-231">If a background collection is in progress and `generation` is 2, the method waits until the background collection is finished, triggers a blocking generation 2 collection, and then returns.</span></span>|<span data-ttu-id="20d1b-232">Se realiza una recolección lo antes posible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-232">A collection is performed as soon as possible.</span></span> <span data-ttu-id="20d1b-233">El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias.</span><span class="sxs-lookup"><span data-stu-id="20d1b-233">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="20d1b-234">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-234">If a background collection is already in progress, the method returns immediately.</span></span>|  
|<xref:System.GCCollectionMode.Optimized>|<span data-ttu-id="20d1b-235">Se puede realizar una recolección de bloqueo, dependiendo del estado del recolector de elementos no utilizados y del parámetro `generation`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-235">A blocking collection may be performed, depending on the state of the garbage collector and the `generation` parameter.</span></span> <span data-ttu-id="20d1b-236">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-236">The garbage collector tries to provide optimal performance.</span></span>|<span data-ttu-id="20d1b-237">Se puede realizar una recolección, según el estado del recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-237">A collection may be performed, depending on the state of the garbage collector.</span></span> <span data-ttu-id="20d1b-238">El método <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> solicita una colección en segundo plano, pero esto no se garantiza; puede que aún se realice una colección de bloqueo, dependiendo de las circunstancias.</span><span class="sxs-lookup"><span data-stu-id="20d1b-238">The <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method requests a background collection, but this is not guaranteed; depending on the circumstances, a blocking collection may still be performed.</span></span> <span data-ttu-id="20d1b-239">El recolector de elementos no utilizados intenta proporcionar un rendimiento óptimo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-239">The garbage collector tries to provide optimal performance.</span></span> <span data-ttu-id="20d1b-240">Si una colección en segundo plano ya está en curso, el método vuelve inmediatamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-240">If a background collection is already in progress, the method returns immediately.</span></span>|  
  
 <span data-ttu-id="20d1b-241">Si una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> método realiza una recolección de elementos no utilizados de bloqueo completa, también puede compactar el montón de objeto grande estableciendo la <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> antes de llamar a la <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-241">If a call to the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%29> method performs a full blocking garbage collection, you can also compact the large object heap by setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> before calling the <xref:System.GC.Collect%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-242">
            <paramref name="generation" /> no es válido.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-242">
              <paramref name="generation" /> is not valid.</span>
          </span>
          <span data-ttu-id="20d1b-243">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-243">-or-</span>
          </span>
          <span data-ttu-id="20d1b-244">
            <paramref name="mode" /> no es uno de los valores de <see cref="T:System.GCCollectionMode" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-244">
              <paramref name="mode" /> is not one of the <see cref="T:System.GCCollectionMode" /> values.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="Collect">
      <MemberSignature Language="C#" Value="public static void Collect (int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Collect(int32 generation, valuetype System.GCCollectionMode mode, bool blocking, bool compacting) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.Collect(System.Int32,System.GCCollectionMode,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Collect (generation As Integer, mode As GCCollectionMode, blocking As Boolean, compacting As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);" />
      <MemberSignature Language="F#" Value="static member Collect : int * GCCollectionMode * bool * bool -&gt; unit" Usage="System.GC.Collect (generation, mode, blocking, compacting)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
        <Parameter Name="mode" Type="System.GCCollectionMode" />
        <Parameter Name="blocking" Type="System.Boolean" />
        <Parameter Name="compacting" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="20d1b-245">El número de la generación más antigua de elementos no usados para recolectar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-245">The number of the oldest generation to be garbage collected.</span>
          </span>
        </param>
        <param name="mode">
          <span data-ttu-id="20d1b-246">Un valor de enumeración que especifica si se fuerza la recolección de elementos (<see cref="F:System.GCCollectionMode.Default" /> o <see cref="F:System.GCCollectionMode.Forced" />) o si será optimizada (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-246">An enumeration value that specifies whether the garbage collection is forced (<see cref="F:System.GCCollectionMode.Default" /> or <see cref="F:System.GCCollectionMode.Forced" />) or optimized (<see cref="F:System.GCCollectionMode.Optimized" />).</span>
          </span>
        </param>
        <param name="blocking">
          <span data-ttu-id="20d1b-247">
            <see langword="true" /> para realizar una recolección de elementos no utilizados de bloqueo; <see langword="false" /> para realizar una recolección de elementos no utilizados en segundo plano cuando sea posible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-247">
              <see langword="true" /> to perform a blocking garbage collection; <see langword="false" /> to perform a background garbage collection where possible.</span>
          </span>
        </param>
        <param name="compacting">
          <span data-ttu-id="20d1b-248">
            <see langword="true" /> para compactar el montón de objetos pequeños; <see langword="false" /> solo para limpiar.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-248">
              <see langword="true" /> to compact the small object heap; <see langword="false" /> to sweep only.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-249">Fuerza una recolección de elementos no utilizados de generación 0 en una generación especificada, en un momento especificado por un valor de <see cref="T:System.GCCollectionMode" />, con valores que especifican si la recolección debe ser de bloqueo y compactante.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-249">Forces a garbage collection from generation 0 through a specified generation, at a time specified by a <see cref="T:System.GCCollectionMode" /> value, with values that specify whether the collection should be blocking and compacting.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-250">Si `blocking` es `false`, el GC decide si debe realizar una recolección de elementos no utilizados de bloqueo o de un fondo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-250">If `blocking` is `false`, the GC decides whether to perform a background or a blocking garbage collection.</span></span> <span data-ttu-id="20d1b-251">Si `compacting` es `true`, realiza una recolección de elementos no utilizados de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-251">If `compacting` is `true`, it performs a blocking garbage collection.</span></span>  
  
 <span data-ttu-id="20d1b-252">Si `compacting` es `true`, el tiempo de ejecución compacta el montón de objetos pequeños (SOH).</span><span class="sxs-lookup"><span data-stu-id="20d1b-252">If `compacting` is `true`, the runtime compacts the small object heap (SOH).</span></span> <span data-ttu-id="20d1b-253">No se compacta el montón de objetos grandes (LOH) a menos que el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad está establecida en <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-253">The large object heap (LOH) is not compacted unless the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property is set to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType>.</span></span> <span data-ttu-id="20d1b-254">Tenga en cuenta que esto incluye todos los elementos no utilizados colecciones de bloqueo, no solo de forma completa las colecciones de elementos no utilizados de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-254">Note that this includes all blocking garbage collections, not just full blocking garbage collections.</span></span>  
  
 <span data-ttu-id="20d1b-255">Puede llamar a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método para reducir el montón administrado para el menor tamaño posible, como se muestra en el siguiente fragmento de código.</span><span class="sxs-lookup"><span data-stu-id="20d1b-255">You can call the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method to reduce the managed heap to the smallest size possible, as the following code fragment illustrates.</span></span>  
  
 [!code-csharp[System.GC.Collect#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect/cs/collect4.cs#1)]
 [!code-vb[System.GC.Collect#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect/vb/collect4.vb#1)]  
  
 <span data-ttu-id="20d1b-256">Especificar `true` para el `compacting` argumento garantiza una recolección de elementos no utilizados de bloqueo completa, con compactación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-256">Specifying `true` for the `compacting` argument guarantees a compacting, full blocking garbage collection.</span></span> <span data-ttu-id="20d1b-257">Establecer el <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> propiedad <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> garantiza que el montón de objeto grande y el SOH se compactan.</span><span class="sxs-lookup"><span data-stu-id="20d1b-257">Setting the <xref:System.Runtime.GCSettings.LargeObjectHeapCompactionMode%2A?displayProperty=nameWithType> property to <xref:System.Runtime.GCLargeObjectHeapCompactionMode.CompactOnce?displayProperty=nameWithType> ensures that both the LOH and SOH are compacted.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CollectionCount">
      <MemberSignature Language="C#" Value="public static int CollectionCount (int generation);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 CollectionCount(int32 generation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.CollectionCount(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function CollectionCount (generation As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int CollectionCount(int generation);" />
      <MemberSignature Language="F#" Value="static member CollectionCount : int -&gt; int" Usage="System.GC.CollectionCount generation" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="generation" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="generation">
          <span data-ttu-id="20d1b-258">La generación de objetos para la que se va a determinar el número de recolecciones de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-258">The generation of objects for which the garbage collection count is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-259">Devuelve el número de veces que se ha producido la recolección de elementos no utilizados para la generación de objetos especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-259">Returns the number of times garbage collection has occurred for the specified generation of objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-260">El número de veces que se ha realizado la recolección de elementos no utilizados para la generación especificada desde que se inició el proceso.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-260">The number of times garbage collection has occurred for the specified generation since the process was started.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-261">Si implementa su propia administración de recursos, es posible que deba forzar la recolección periódicamente mediante una llamada a la <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-261">If you implement your own resource management, you might need to force garbage collection periodically by calling the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="20d1b-262">Se trata de una operación costosa, puede mejorar el rendimiento omitiendo la llamada cuando se ha producido recientemente a una colección de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-262">Because this is an expensive operation, you can improve performance by skipping the call when a garbage collection has occurred recently.</span></span> <span data-ttu-id="20d1b-263">Guarde el valor devuelto por <xref:System.GC.CollectionCount%2A> inmediatamente después de llamar a <xref:System.GC.Collect%2A>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-263">Save the value returned by <xref:System.GC.CollectionCount%2A> immediately after calling <xref:System.GC.Collect%2A>.</span></span> <span data-ttu-id="20d1b-264">La próxima vez que se debe llamar a <xref:System.GC.Collect%2A>, compare el valor actual devuelto por <xref:System.GC.CollectionCount%2A> en el valor guardado.</span><span class="sxs-lookup"><span data-stu-id="20d1b-264">The next time you need to call <xref:System.GC.Collect%2A>, compare the current value returned by <xref:System.GC.CollectionCount%2A> to the saved value.</span></span> <span data-ttu-id="20d1b-265">Si los dos valores son iguales, no se ha producido ninguna recolección provisional y resulta razonable llamar a <xref:System.GC.Collect%2A> nuevo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-265">If the two values are equal, no collection has occurred in the interim and it is reasonable to call <xref:System.GC.Collect%2A> again.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-266">
            <paramref name="generation" /> es menor que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-266">
              <paramref name="generation" /> is less than 0.</span>
          </span>
        </exception>
      </Docs>
    </Member>
    <Member MemberName="EndNoGCRegion">
      <MemberSignature Language="C#" Value="public static void EndNoGCRegion ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void EndNoGCRegion() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.EndNoGCRegion" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub EndNoGCRegion ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void EndNoGCRegion();" />
      <MemberSignature Language="F#" Value="static member EndNoGCRegion : unit -&gt; unit" Usage="System.GC.EndNoGCRegion " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-267">Finaliza el modo de no latencia en la región GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-267">Ends the no GC region latency mode.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-268">El <xref:System.GC.EndNoGCRegion%2A> método produce una <xref:System.InvalidOperationException> si el recolector de elementos no utilizados no está en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-268">The <xref:System.GC.EndNoGCRegion%2A> method throws an <xref:System.InvalidOperationException> if the garbage collector is not in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-269">Esto se produce en cualquiera de las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="20d1b-269">This occurs under any of the following conditions:</span></span>  
  
-   <span data-ttu-id="20d1b-270">El <xref:System.GC.TryStartNoGCRegion%2A> no llamó al método anteriormente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-270">The <xref:System.GC.TryStartNoGCRegion%2A> method was not called previously.</span></span>  
  
-   <span data-ttu-id="20d1b-271">La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> devuelto del método `false`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-271">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method returned `false`.</span></span>  
  
-   <span data-ttu-id="20d1b-272">La llamada a la <xref:System.GC.TryStartNoGCRegion%2A> método producía una excepción.</span><span class="sxs-lookup"><span data-stu-id="20d1b-272">The call to the <xref:System.GC.TryStartNoGCRegion%2A> method threw an exception.</span></span>  
  
 <span data-ttu-id="20d1b-273">Puede evitar una excepción para cualquiera de estos motivos mediante código como el siguiente:</span><span class="sxs-lookup"><span data-stu-id="20d1b-273">You can prevent an exception for any of these reasons by using code such as the following:</span></span>  
  
 [!code-csharp[System.GC.EndNoGCRegion#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.endnogcregion/cs/endnogcregion1.cs#1)]
 [!code-vb[System.GC.EndNoGCRegion#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.endnogcregion/vb/endnogcregion1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-274">El recolector de elementos no utilizados no está en modo de no latencia en la región GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-274">The garbage collector is not in no GC region latency mode.</span>
          </span>
          <span data-ttu-id="20d1b-275">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-275">-or-</span>
          </span>
          <span data-ttu-id="20d1b-276">El modo de no latencia en la región GC se terminó prematuramente porque se indujo una recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-276">The no GC region latency mode was ended previously because a garbage collection was induced.</span>
          </span>
          <span data-ttu-id="20d1b-277">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-277">-or-</span>
          </span>
          <span data-ttu-id="20d1b-278">Una asignación de memoria superó la cantidad especificada en la llamada al método <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-278">A memory allocation exceeded the amount specified in the call to the <see cref="M:System.GC.TryStartNoGCRegion(System.Int64)" /> method.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.TryStartNoGCRegion(System.Int64)" />
        <altmember cref="P:System.Runtime.GCSettings.LatencyMode" />
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="20d1b-279">Modos de latencia</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-279">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="GetAllocatedBytesForCurrentThread">
      <MemberSignature Language="C#" Value="public static long GetAllocatedBytesForCurrentThread ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetAllocatedBytesForCurrentThread() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetAllocatedBytesForCurrentThread" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetAllocatedBytesForCurrentThread () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetAllocatedBytesForCurrentThread();" />
      <MemberSignature Language="F#" Value="static member GetAllocatedBytesForCurrentThread : unit -&gt; int64" Usage="System.GC.GetAllocatedBytesForCurrentThread " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-280">Obtiene el número total de bytes asignados al subproceso actual desde el principio de su duración.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-280">Gets the total number of bytes allocated to the current thread since the beginning of its lifetime.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-281">Número total de bytes asignados al subproceso actual desde el principio de su duración.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-281">The total number of bytes allocated to the current thread since the beginning of its lifetime.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  

<span data-ttu-id="20d1b-282">El `GetAllocatedBytesForCurrentThread` método devuelve el número total de bytes asignados en el montón administrado durante la vigencia de un subproceso, no el número total de bytes que han sobrevivido a la recolección de elementos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-282">The `GetAllocatedBytesForCurrentThread` method returns the total number of bytes allocated on the managed heap during the lifetime of a thread, not the total number of bytes that have survived garbage collection.</span></span> <span data-ttu-id="20d1b-283">El valor devuelto no incluye también las asignaciones nativas.</span><span class="sxs-lookup"><span data-stu-id="20d1b-283">The returned value also does not include any native allocations.</span></span>

<span data-ttu-id="20d1b-284">Este método resulta útil principalmente en scenarious para medir la diferencia en la asignación de memoria entre intervalos de tiempo o los eventos de supervisión.</span><span class="sxs-lookup"><span data-stu-id="20d1b-284">This method is most useful in monitoring scenarious for measuring the difference in memory allocation between time intervals or events.</span></span>

       ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetGeneration">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-285">Devuelve el número de generación actual de un objeto.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-285">Returns the current generation number of an object.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : obj -&gt; int" Usage="System.GC.GetGeneration obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="20d1b-286">El objeto cuya información sobre generación se recupera.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-286">The object that generation information is retrieved for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-287">Devuelve el número de generación actual del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-287">Returns the current generation number of the specified object.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-288">El número de generación actual de <paramref name="obj" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-288">The current generation number of <paramref name="obj" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-289">Use este método para determinar la edad de un objeto y, a continuación, usar esa información con el <xref:System.GC.Collect%2A> método para obligar al recolector de elementos no utilizados para recopilar objetos de la misma generación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-289">Use this method to determine the age of an object, and then use that information with the <xref:System.GC.Collect%2A> method to force the garbage collector to collect objects in the same generation.</span></span> <span data-ttu-id="20d1b-290">Por ejemplo, puede usar este método cuando tenga un conjunto de objetos que se crean como un grupo y que dejan de estar accesibles al mismo tiempo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-290">For example, use this method when you have a set of objects that are created as a group and that become inaccessible at the same time.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-291">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.GetGeneration%2A> método para determinar la edad de un objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-291">The following example demonstrates how to use the <xref:System.GC.GetGeneration%2A> method to determine the age of an object.</span></span> <span data-ttu-id="20d1b-292">El ejemplo, a continuación, realiza recolecciones de elementos para limpiar la memoria y comparar el pre y post colección totales de memoria en la consola de.</span><span class="sxs-lookup"><span data-stu-id="20d1b-292">The example then performs garbage collections to clean up memory and compare the pre and post collection memory totals in the console.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetGeneration">
      <MemberSignature Language="C#" Value="public static int GetGeneration (WeakReference wo);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 GetGeneration(class System.WeakReference wo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetGeneration(System.WeakReference)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetGeneration (wo As WeakReference) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int GetGeneration(WeakReference ^ wo);" />
      <MemberSignature Language="F#" Value="static member GetGeneration : WeakReference -&gt; int" Usage="System.GC.GetGeneration wo" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="wo" Type="System.WeakReference" />
      </Parameters>
      <Docs>
        <param name="wo">
          <span data-ttu-id="20d1b-293">Un <see cref="T:System.WeakReference" /> que hace referencia al objeto de destino cuyo número de generación debe determinarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-293">A <see cref="T:System.WeakReference" /> that refers to the target object whose generation number is to be determined.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-294">Devuelve el número de generación actual del destino de una referencia débil especificada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-294">Returns the current generation number of the target of a specified weak reference.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-295">El número de generación actual del destino de <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-295">The current generation number of the target of <paramref name="wo" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="20d1b-296">En el ejemplo siguiente se muestra el uso de la <xref:System.GC.GetGeneration%2A> método para determinar la edad de un objeto de referencia débil.</span><span class="sxs-lookup"><span data-stu-id="20d1b-296">The following example demonstrates the use of the <xref:System.GC.GetGeneration%2A> method to determine the age of a weak reference object.</span></span>  
  
 [!code-cpp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CPP/systemgcgetgenerationweak.cpp#1)]
 [!code-csharp[System.GC.GetGenerationWeak Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/CS/systemgcgetgenerationweak.cs#1)]
 [!code-vb[System.GC.GetGenerationWeak Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.GetGenerationWeak Example/VB/systemgcgetgenerationweak.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <span data-ttu-id="20d1b-297">Ya se ha realizado la recolección de elementos no utilizados en <paramref name="wo" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-297">Garbage collection has already been performed on <paramref name="wo" />.</span>
          </span>
        </exception>
        <altmember cref="P:System.GC.MaxGeneration" />
      </Docs>
    </Member>
    <Member MemberName="GetTotalMemory">
      <MemberSignature Language="C#" Value="public static long GetTotalMemory (bool forceFullCollection);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int64 GetTotalMemory(bool forceFullCollection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.GetTotalMemory(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTotalMemory (forceFullCollection As Boolean) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static long GetTotalMemory(bool forceFullCollection);" />
      <MemberSignature Language="F#" Value="static member GetTotalMemory : bool -&gt; int64" Usage="System.GC.GetTotalMemory forceFullCollection" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="forceFullCollection" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="forceFullCollection">
          <span data-ttu-id="20d1b-298">
            <see langword="true" /> para indicar que este método puede esperar a que se produzca la recolección de elementos no utilizados antes de regresar; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-298">
              <see langword="true" /> to indicate that this method can wait for garbage collection to occur before returning; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-299">Recupera el número de bytes que se considera que están asignados en la actualidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-299">Retrieves the number of bytes currently thought to be allocated.</span>
          </span>
          <span data-ttu-id="20d1b-300">Un parámetro indica si este método puede esperar un breve intervalo de tiempo antes de regresar, para permitir que el sistema recoja los elementos no utilizados y finalice los objetos.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-300">A parameter indicates whether this method can wait a short interval before returning, to allow the system to collect garbage and finalize objects.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-301">Número que representa la aproximación más exacta disponible del número de bytes actualmente asignados en la memoria administrada.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-301">A number that is the best available approximation of the number of bytes currently allocated in managed memory.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-302">Si el `forceFullCollection` parámetro es `true`, este método espera un breve intervalo antes de devolver mientras el sistema recopila elementos no utilizados y finaliza los objetos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-302">If the `forceFullCollection` parameter is `true`, this method waits a short interval before returning while the system collects garbage and finalizes objects.</span></span> <span data-ttu-id="20d1b-303">La duración del intervalo es un límite especificado internamente determinado por el número de ciclos de colección de elementos no utilizados completa y el cambio en la cantidad de memoria recuperada entre los ciclos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-303">The duration of the interval is an internally specified limit determined by the number of garbage collection cycles completed and the change in the amount of memory recovered between cycles.</span></span> <span data-ttu-id="20d1b-304">El recolector de elementos no utilizados no garantiza que se recopila toda la memoria accesible.</span><span class="sxs-lookup"><span data-stu-id="20d1b-304">The garbage collector does not guarantee that all inaccessible memory is collected.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-305">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.GetTotalMemory%2A> método para obtener y mostrar el número de bytes actualmente asignados en memoria administrada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-305">The following example demonstrates how to use the <xref:System.GC.GetTotalMemory%2A> method to get and display the number of bytes currently allocated in managed memory.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="KeepAlive">
      <MemberSignature Language="C#" Value="public static void KeepAlive (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void KeepAlive(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.KeepAlive(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub KeepAlive (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void KeepAlive(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member KeepAlive : obj -&gt; unit" Usage="System.GC.KeepAlive obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="20d1b-306">El objeto al que se va a hacer referencia.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-306">The object to reference.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-307">Hace referencia al objeto especificado, convirtiéndolo en un objeto no válido para la recolección de elementos no utilizados desde el principio de la rutina actual hasta el momento en que se llamó a este método.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-307">References the specified object, which makes it ineligible for garbage collection from the start of the current routine to the point where this method is called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-308">El propósito de la <xref:System.GC.KeepAlive%2A> método consiste en garantizar la existencia de una referencia a un objeto que está en riesgo de ser reclamado prematuramente por el recolector de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-308">The purpose of the <xref:System.GC.KeepAlive%2A> method is to ensure the existence of a reference to an object that is at risk of being prematurely reclaimed by the garbage collector.</span></span> <span data-ttu-id="20d1b-309">Un escenario común donde esto puede ocurrir es cuando no hay ninguna referencia al objeto en código administrado o datos, pero el objeto todavía está en uso en código no administrado, como las API de Win32, archivos DLL no administrados, o métodos que utilizan COM.</span><span class="sxs-lookup"><span data-stu-id="20d1b-309">A common scenario where this might happen is when there are no references to the object in managed code or data, but the object is still in use in unmanaged code such as Win32 APIs, unmanaged DLLs, or methods using COM.</span></span>  
  
 <span data-ttu-id="20d1b-310">Este método hace referencia a la `obj` parámetro, convirtiéndolo ese objeto no válido para la recolección de elementos desde el principio de la rutina hasta el punto en el orden de ejecución, donde se llama a este método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-310">This method references the `obj` parameter, making that object ineligible for garbage collection from the start of the routine to the point, in execution order, where this method is called.</span></span> <span data-ttu-id="20d1b-311">Este método al final, no al principio del intervalo de instrucciones de código donde `obj` deben estar disponibles.</span><span class="sxs-lookup"><span data-stu-id="20d1b-311">Code this method at the end, not the beginning, of the range of instructions where `obj` must be available.</span></span>  
  
 <span data-ttu-id="20d1b-312">El <xref:System.GC.KeepAlive%2A> método no realiza ninguna operación y no produce efectos aparte de ampliar la duración del objeto pasado como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="20d1b-312">The <xref:System.GC.KeepAlive%2A> method performs no operation and produces no side effects other than extending the lifetime of the object passed in as a parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-313">En el ejemplo de código siguiente se crea un objeto al principio de su `Main` método y no hace referencia al objeto nuevamente hasta el final, cuando el <xref:System.GC.KeepAlive%2A> se llama al método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-313">The following code example creates an object at the beginning of its `Main` method and does not refer to the object again until the end, when the <xref:System.GC.KeepAlive%2A> method is called.</span></span> <span data-ttu-id="20d1b-314">El objeto se mantiene durante 30 segundos de la `Main` método, a pesar de las llamadas a la <xref:System.GC.Collect%2A> y <xref:System.GC.WaitForPendingFinalizers%2A> métodos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-314">The object persists for the 30-second duration of the `Main` method, despite calls to the <xref:System.GC.Collect%2A> and <xref:System.GC.WaitForPendingFinalizers%2A> methods.</span></span>  
  
 [!code-cpp[System.GC.KeepAlive Example2#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CPP/gckeepalive.cpp#1)]
 [!code-csharp[System.GC.KeepAlive Example2#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/CS/gckeepalive.cs#1)]
 [!code-vb[System.GC.KeepAlive Example2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.KeepAlive Example2/VB/gckeepalive.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="MaxGeneration">
      <MemberSignature Language="C#" Value="public static int MaxGeneration { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 MaxGeneration" />
      <MemberSignature Language="DocId" Value="P:System.GC.MaxGeneration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MaxGeneration As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int MaxGeneration { int get(); };" />
      <MemberSignature Language="F#" Value="member this.MaxGeneration : int" Usage="System.GC.MaxGeneration" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-315">Obtiene el número máximo de generaciones que el sistema admite en la actualidad.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-315">Gets the maximum number of generations that the system currently supports.</span>
          </span>
        </summary>
        <value>
          <span data-ttu-id="20d1b-316">Un valor comprendido entre cero y el número máximo de generaciones admitidas.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-316">A value that ranges from zero to the maximum number of supported generations.</span>
          </span>
        </value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-317">El número de generación o la edad de un objeto es una medida relativa de la duración de un objeto definido por la implementación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-317">The generation number, or age, of an object is an implementation-defined relative measure of an object's lifespan.</span></span> <span data-ttu-id="20d1b-318">Son los objetos creados más recientemente en la generación 0 y los objetos más antiguos están en una generación menor o igual a la generación devuelta por la <xref:System.GC.MaxGeneration%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="20d1b-318">The most recently created objects are in generation 0 and the oldest objects are in a generation less than or equal to the generation returned by the <xref:System.GC.MaxGeneration%2A> property.</span></span>  
  
 <span data-ttu-id="20d1b-319">El recolector de elementos no utilizados se da por supuesto que la memoria más reciente es más probable que sea apto para la recolección de memoria anterior.</span><span class="sxs-lookup"><span data-stu-id="20d1b-319">The garbage collector assumes that newer memory is more likely to be eligible for garbage collection than older memory.</span></span> <span data-ttu-id="20d1b-320">Por lo tanto, el recolector de elementos no utilizados mejora su rendimiento ajustando los números de generación cada vez que reclama memoria, y el <xref:System.GC.MaxGeneration%2A> puede alcanzar el valor de propiedad con el tiempo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-320">Therefore, the garbage collector improves its performance by adjusting generation numbers each time it reclaims memory, and the <xref:System.GC.MaxGeneration%2A> property value can grow over time.</span></span>  
  
 <span data-ttu-id="20d1b-321">Si se implementa la edad de los objetos, el <xref:System.GC.MaxGeneration%2A> propiedad devuelve el número de generación máximo utilizado por el sistema; en caso contrario, esta propiedad devuelve cero.</span><span class="sxs-lookup"><span data-stu-id="20d1b-321">If object aging is implemented, the <xref:System.GC.MaxGeneration%2A> property returns the maximum generation number used by the system; otherwise, this property returns zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-322">El ejemplo siguiente muestra cómo usar la propiedad MaxGeneration para mostrar el mayor número de generación actualmente en uso.</span><span class="sxs-lookup"><span data-stu-id="20d1b-322">The following example demonstrates how to use the MaxGeneration property to display the largest generation number currently in use.</span></span>  
  
 [!code-cpp[System.GC.Collect Int Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.gc.collect int example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.Collect Int Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.collect int example/CS/class1.cs#1)]
 [!code-vb[System.GC.Collect Int Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.collect int example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>
            <span data-ttu-id="20d1b-323">Para esta implementación, el valor devuelto por la <see cref="P:System.GC.MaxGeneration" /> se garantiza que la propiedad permanece constante para la duración de una aplicación en ejecución.</span>
            <span class="sxs-lookup">
              <span data-stu-id="20d1b-323">For this implementation, the value returned by the <see cref="P:System.GC.MaxGeneration" /> property is guaranteed to remain constant for the lifetime of an executing application.</span>
            </span>
            <span data-ttu-id="20d1b-324">Use la <see cref="P:System.GC.MaxGeneration" /> propiedad para determinar el valor máximo que puede especificar cuando se llama a la <see cref="M:System.GC.Collect(System.Int32)" /> método que toma un parámetro de generación.</span>
            <span class="sxs-lookup">
              <span data-stu-id="20d1b-324">Use the <see cref="P:System.GC.MaxGeneration" /> property to determine the maximum value you can specify when calling the <see cref="M:System.GC.Collect(System.Int32)" /> method that takes a generation parameter.</span>
            </span>
          </para>
        </block>
        <altmember cref="M:System.GC.GetGeneration(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="RegisterForFullGCNotification">
      <MemberSignature Language="C#" Value="public static void RegisterForFullGCNotification (int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RegisterForFullGCNotification(int32 maxGenerationThreshold, int32 largeObjectHeapThreshold) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RegisterForFullGCNotification(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RegisterForFullGCNotification (maxGenerationThreshold As Integer, largeObjectHeapThreshold As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);" />
      <MemberSignature Language="F#" Value="static member RegisterForFullGCNotification : int * int -&gt; unit" Usage="System.GC.RegisterForFullGCNotification (maxGenerationThreshold, largeObjectHeapThreshold)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="maxGenerationThreshold" Type="System.Int32" />
        <Parameter Name="largeObjectHeapThreshold" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="maxGenerationThreshold">
          <span data-ttu-id="20d1b-325">Número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en la generación 2.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-325">A number between 1 and 99 that specifies when the notification should be raised based on the objects allocated in generation 2.</span>
          </span>
        </param>
        <param name="largeObjectHeapThreshold">
          <span data-ttu-id="20d1b-326">Un número comprendido entre 1 y 99 que especifica cuándo debe emitirse la notificación basándose en los objetos asignados en el montón de objetos grandes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-326">A number between 1 and 99 that specifies when the notification should be raised based on objects allocated in the large object heap.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-327">Especifica que debe emitirse una notificación de recolección de elementos no utilizados cuando las condiciones favorecen la recolección completa de elementos no utilizados y cuando se ha completado la recolección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-327">Specifies that a garbage collection notification should be raised when conditions favor full garbage collection and when the collection has been completed.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-328">Por cada generación, el recolector de elementos no utilizados establece un umbral para las asignaciones en dicha generación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-328">For each generation, the garbage collector sets a threshold for allocations into that generation.</span></span> <span data-ttu-id="20d1b-329">Cuando el tamaño de las asignaciones supera este umbral, se desencadena una recolección en dicha generación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-329">When the size of allocations exceeds this threshold, a garbage collection is triggered on that generation.</span></span> <span data-ttu-id="20d1b-330">De ejemplo, si el umbral de generación 2 es 20MB (lo que significa que 20MB sobrevive a las recolecciones de generación 1 y se promueven a la generación 2) y más de 20MB sobrevivió a la generación 1 y se pide a la generación 2, se volverá a intentar la siguiente recolección de elementos no utilizados como una recolección de generación 2.</span><span class="sxs-lookup"><span data-stu-id="20d1b-330">For example, if generation 2’s threshold is 20MB (which means that 20MB survives generation 1 collections and is promoted into generation 2), and more than 20MB has survived generation 1 and is prompted into generation 2, the next garbage collection will be attempted as a generation 2 collection.</span></span> <span data-ttu-id="20d1b-331">De forma similar, si el montón de objetos grandes (LOH) Value de umbral es de 20MB y la aplicación ha asignado más de 20MB de objetos grandes, la siguiente recolección de elementos no utilizados también se volverá a intentar como una recolección de generación 2 (ya que el montón de objeto grande solo se recopila en las colecciones de elementos no utilizados de gen2).</span><span class="sxs-lookup"><span data-stu-id="20d1b-331">Similarly, if the large object heap's (LOH's) threshold is 20MB and your app has allocated more than 20MB of large objects, the next garbage collection will also be attempted as a generation 2 collection (since the LOH is only collected in gen2 garbage collections).</span></span>  
  
 <span data-ttu-id="20d1b-332">El `maxGenerationThreshold` y `largeObjectHeapThreshold` umbrales controlan cuánto de antemano se le notificará antes de que se produce una colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-332">The `maxGenerationThreshold` and `largeObjectHeapThreshold` thresholds control how much in advance you are notified before a full garbage collection occurs.</span></span> <span data-ttu-id="20d1b-333">Cuanto mayor sea el umbral, las asignaciones más que pueden producirse entre la notificación y la siguiente recolección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-333">The greater the threshold, the more allocations that can occur between notification and the next full garbage collection.</span></span>  
  
 <span data-ttu-id="20d1b-334">Si dispone de las situaciones en que una colección de elementos no utilizados completa por common language runtime negativamente afectaría al rendimiento de la aplicación, puede pedir que se le notifique cuando el tiempo de ejecución se va a realizar una recolección de elementos no utilizados completa y eludir esa recolección por inducción de una colección por su cuenta (mediante el <xref:System.GC.Collect%2A> método) cuando las condiciones son todavía favorables.</span><span class="sxs-lookup"><span data-stu-id="20d1b-334">If you have situations in which a full garbage collection by the common language runtime would adversely affect your application's performance, you can ask to be notified when the runtime is about to do a full garbage collection and circumvent that collection by inducing a collection yourself (using the <xref:System.GC.Collect%2A> method) when conditions are still favorable.</span></span> <span data-ttu-id="20d1b-335">Además de cambiar la programación de la colección de elementos no utilizados, notificación de GC completo es útil en los escenarios siguientes:</span><span class="sxs-lookup"><span data-stu-id="20d1b-335">In addition to changing the garbage collection schedule yourself, full GC notification is useful in following the scenarios:</span></span>  
  
-   <span data-ttu-id="20d1b-336">Supervisión de la estrategia de una colección de elementos no utilizados completa y, cuando se le notifique que uno se aproxima, reducir el tamaño de los datos en directo (por ejemplo, al liberar algunas entradas de caché).</span><span class="sxs-lookup"><span data-stu-id="20d1b-336">You monitor for the approach of a full garbage collection and, when you are notified that one is approaching, you reduce live data size (for example, by releasing some cache entries).</span></span> <span data-ttu-id="20d1b-337">Como resultado, cuando se produce la recolección de elementos, es capaz de liberar más memoria.</span><span class="sxs-lookup"><span data-stu-id="20d1b-337">As a result, when the garbage collection occurs, it is able to reclaim more memory.</span></span>  
  
-   <span data-ttu-id="20d1b-338">Supervisar la finalización de una colección de elementos no utilizados completa para que pueda recopilar algunas estadísticas.</span><span class="sxs-lookup"><span data-stu-id="20d1b-338">You monitor for the completion of a full garbage collection so that you can collect some statistics.</span></span>  <span data-ttu-id="20d1b-339">Por ejemplo, es posible que desee medir el tamaño del montón al finalizar el GC para que sepa el tamaño de los datos en directo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-339">For example, you might want to measure the size of the heap at GC completion so that you know the size of live data.</span></span> <span data-ttu-id="20d1b-340">(Después de un GC completo, el montón es con su tamaño más pequeño).</span><span class="sxs-lookup"><span data-stu-id="20d1b-340">(After a full GC, the heap is at its smallest size.)</span></span>  
  
 <span data-ttu-id="20d1b-341">Para obtener más información sobre lo que representa una colección de elementos no utilizados completa, consulte [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md).</span><span class="sxs-lookup"><span data-stu-id="20d1b-341">For more information about what represents a full garbage collection, see [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md).</span></span>  
  
 <span data-ttu-id="20d1b-342">Cuando se registra para una notificación de recolección, puede recibir notificaciones cuando una recolección de elementos no utilizados completa está próxima y cuando se complete.</span><span class="sxs-lookup"><span data-stu-id="20d1b-342">When you register for a garbage collection notification, you can be notified when a full garbage collection is approaching and when it is completed.</span></span> <span data-ttu-id="20d1b-343">Este patrón es similar a cómo se supervisa el sistema operativo para las notificaciones de memoria baja.</span><span class="sxs-lookup"><span data-stu-id="20d1b-343">This pattern resembles how the operating system monitors for low memory notifications.</span></span>  
  
 <span data-ttu-id="20d1b-344">Utilice las instrucciones siguientes para especificar el `maxGenerationThreshold` y `largeObjectHeapThreshold` parámetros:</span><span class="sxs-lookup"><span data-stu-id="20d1b-344">Use the following guidelines for specifying the `maxGenerationThreshold` and `largeObjectHeapThreshold` parameters:</span></span>  
  
-   <span data-ttu-id="20d1b-345">Cuanto mayor sea el valor de umbral, se producen la más asignaciones entre la notificación y la colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-345">The larger the threshold value, the more allocations will occur between the notification and the full garbage collection.</span></span>  
  
     <span data-ttu-id="20d1b-346">Un valor de umbral mayor proporciona más oportunidades para el tiempo de ejecución comprobar si una recolección próxima.</span><span class="sxs-lookup"><span data-stu-id="20d1b-346">A larger threshold value provides more opportunities for the runtime to check for an approaching collection.</span></span> <span data-ttu-id="20d1b-347">Esto aumenta la probabilidad de que se le notificará.</span><span class="sxs-lookup"><span data-stu-id="20d1b-347">This increases the likelihood that you will be notified.</span></span> <span data-ttu-id="20d1b-348">Sin embargo, no debe establecer el umbral demasiado alto, ya da lugar a una más asignaciones antes de que el tiempo de ejecución induce la recolección siguiente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-348">However, you should not set the threshold too high because that results in a more allocations before the runtime induces the next collection.</span></span>  
  
     <span data-ttu-id="20d1b-349">Cuando se induce una recolección tras la notificación con un valor de umbral alto, menos objetos se reclaman que reclamarían colección siguiente del tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20d1b-349">When you induce a collection yourself upon notification using a high threshold value, fewer objects are reclaimed than would be reclaimed by the runtime's next collection.</span></span>  
  
-   <span data-ttu-id="20d1b-350">Cuanto menor sea el valor de umbral, menos las asignaciones entre la notificación y la colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-350">The smaller the threshold value, the fewer the allocations between notification and the full garbage collection.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-351">El ejemplo siguiente muestra cómo registrar una notificación de recolección e iniciar un subproceso para supervisar el estado de la notificación de recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-351">The following example shows how to register a garbage collection notification and start a thread to monitor the status of the garbage collection notification.</span></span> <span data-ttu-id="20d1b-352">Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-352">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#2](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#2)]
 [!code-csharp[GCNotification#2](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#2)]
 [!code-vb[GCNotification#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-353">
            <paramref name="maxGenerationThreshold" /> o <paramref name="largeObjectHeapThreshold" /> no está entre 1 y 99.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-353">
              <paramref name="maxGenerationThreshold" /> or <paramref name="largeObjectHeapThreshold" /> is not between 1 and 99.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-354">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-354">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-355">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-355">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-356">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-356">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-357">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-357">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-358">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-358">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="RemoveMemoryPressure">
      <MemberSignature Language="C#" Value="public static void RemoveMemoryPressure (long bytesAllocated);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void RemoveMemoryPressure(int64 bytesAllocated) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.RemoveMemoryPressure(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub RemoveMemoryPressure (bytesAllocated As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void RemoveMemoryPressure(long bytesAllocated);" />
      <MemberSignature Language="F#" Value="static member RemoveMemoryPressure : int64 -&gt; unit" Usage="System.GC.RemoveMemoryPressure bytesAllocated" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bytesAllocated" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bytesAllocated">
          <span data-ttu-id="20d1b-359">Cantidad de memoria no administrada que se ha liberado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-359">The amount of unmanaged memory that has been released.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-360">Informa al tiempo de ejecución de que se ha liberado la memoria no administrada y ya no se necesita tener en cuenta al programar la recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-360">Informs the runtime that unmanaged memory has been released and no longer needs to be taken into account when scheduling garbage collection.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-361">Para determinar cuándo se debe programar la recopilación de elementos no utilizados, el tiempo de ejecución tiene en cuenta la cantidad de memoria administrada está asignada.</span><span class="sxs-lookup"><span data-stu-id="20d1b-361">In determining when to schedule garbage collection, the runtime takes into account how much managed memory is allocated.</span></span> <span data-ttu-id="20d1b-362">Si un objeto administrado pequeño asigna una gran cantidad de memoria no administrada, el tiempo de ejecución tiene en cuenta que sólo la memoria administrada y, por tanto, subestima la urgencia de programar la recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-362">If a small managed object allocates a large amount of unmanaged memory, the runtime takes into account only the managed memory, and thus underestimates the urgency of scheduling garbage collection.</span></span> <span data-ttu-id="20d1b-363">El <xref:System.GC.AddMemoryPressure%2A> método informa el tiempo de ejecución de esta necesidad adicional de memoria del sistema y el <xref:System.GC.RemoveMemoryPressure%2A> método informa al tiempo de ejecución que se ha liberado la presión adicional.</span><span class="sxs-lookup"><span data-stu-id="20d1b-363">The <xref:System.GC.AddMemoryPressure%2A> method informs the runtime of this additional pressure on system memory, and the <xref:System.GC.RemoveMemoryPressure%2A> method informs the runtime that the additional pressure has been released.</span></span>  
  
 <span data-ttu-id="20d1b-364">En el patrón de uso más simple, un objeto administrado asigna memoria no administrada en el constructor y lo libera en la `Dispose` o `Finalize` método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-364">In the simplest usage pattern, a managed object allocates unmanaged memory in the constructor and releases it in the `Dispose` or `Finalize` method.</span></span> <span data-ttu-id="20d1b-365">Llame a la <xref:System.GC.AddMemoryPressure%2A> método después de asignar la memoria no administrada y llamar a la <xref:System.GC.RemoveMemoryPressure%2A> método después de liberarla.</span><span class="sxs-lookup"><span data-stu-id="20d1b-365">Call the <xref:System.GC.AddMemoryPressure%2A> method after allocating the unmanaged memory, and call the <xref:System.GC.RemoveMemoryPressure%2A> method after releasing it.</span></span>  
  
 <span data-ttu-id="20d1b-366">En escenarios más complicados, donde la asignación de memoria no administrada cambia considerablemente durante la vigencia del objeto administrado, puede llamar a la <xref:System.GC.AddMemoryPressure%2A> y <xref:System.GC.RemoveMemoryPressure%2A> métodos de comunicación de estos cambios incrementales en el tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="20d1b-366">In more complicated scenarios, where the unmanaged memory allocation changes substantially during the lifetime of the managed object, you can call the <xref:System.GC.AddMemoryPressure%2A> and <xref:System.GC.RemoveMemoryPressure%2A> methods to communicate these incremental changes to the runtime.</span></span>  
  
> [!CAUTION]
>  <span data-ttu-id="20d1b-367">Debe asegurarse de que quita exactamente la cantidad de presión que agrega.</span><span class="sxs-lookup"><span data-stu-id="20d1b-367">You must ensure that you remove exactly the amount of pressure you add.</span></span> <span data-ttu-id="20d1b-368">Si no lo puede afectar negativamente el rendimiento del sistema en las aplicaciones que se ejecutan durante largos períodos de tiempo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-368">Failing to do so can adversely affect the performance of the system in applications that run for long periods of time.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-369">
            <paramref name="bytesAllocated" /> es menor o igual que 0.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-369">
              <paramref name="bytesAllocated" /> is less than or equal to 0.</span>
          </span>
          <span data-ttu-id="20d1b-370">O bien</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-370">-or-</span>
          </span>
          <span data-ttu-id="20d1b-371">En un equipo de 32 bits, <paramref name="bytesAllocated" /> es mayor que <see cref="F:System.Int32.MaxValue" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-371">On a 32-bit computer, <paramref name="bytesAllocated" /> is larger than <see cref="F:System.Int32.MaxValue" />.</span>
          </span>
        </exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">
          <span data-ttu-id="20d1b-372">Para poder llamar a código no administrado al manipular la prioridad de la colección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-372">for the ability to call unmanaged code when manipulating garbage-collection priority.</span>
          </span>
          <span data-ttu-id="20d1b-373">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-373">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-374">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-374">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-375">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-375">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
      </Docs>
    </Member>
    <Member MemberName="ReRegisterForFinalize">
      <MemberSignature Language="C#" Value="public static void ReRegisterForFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void ReRegisterForFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.ReRegisterForFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub ReRegisterForFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void ReRegisterForFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member ReRegisterForFinalize : obj -&gt; unit" Usage="System.GC.ReRegisterForFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="20d1b-376">El objeto cuyo finalizador debe llamarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-376">The object that a finalizer must be called for.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-377">Solicita que el sistema llame al finalizador del objeto especificado, para el que previamente se ha llamado a <see cref="M:System.GC.SuppressFinalize(System.Object)" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-377">Requests that the system call the finalizer for the specified object for which <see cref="M:System.GC.SuppressFinalize(System.Object)" /> has previously been called.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-378">El <xref:System.GC.ReRegisterForFinalize%2A> método agrega el `obj` parámetro a la lista de objetos que solicitan una finalización antes de que el recolector de elementos no utilizados libere el objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-378">The <xref:System.GC.ReRegisterForFinalize%2A> method adds the `obj` parameter to the list of objects that request finalization before the garbage collector frees the object.</span></span> <span data-ttu-id="20d1b-379">El `obj` parámetro debe ser el llamador de este método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-379">The `obj` parameter must be the caller of this method.</span></span>  
  
 <span data-ttu-id="20d1b-380">Una llamada a la <xref:System.GC.ReRegisterForFinalize%2A> método no garantiza que el recolector de elementos no utilizados llame al finalizador de un objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-380">Calling the <xref:System.GC.ReRegisterForFinalize%2A> method does not guarantee that the garbage collector will call an object's finalizer.</span></span>  
  
 <span data-ttu-id="20d1b-381">De forma predeterminada, todos los objetos que implementan los finalizadores se agregan a la lista de objetos que requieren la finalización; Sin embargo, es posible que ya ha finalizado o es posible que haya deshabilitado la finalización mediante una llamada a un objeto el <xref:System.GC.SuppressFinalize%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-381">By default, all objects that implement finalizers are added to the list of objects that require finalization; however, an object might have already been finalized or might have disabled finalization by calling the <xref:System.GC.SuppressFinalize%2A> method.</span></span>  
  
 <span data-ttu-id="20d1b-382">Un finalizador puede usar este método a resucitar a sí mismo o a un objeto que hace referencia.</span><span class="sxs-lookup"><span data-stu-id="20d1b-382">A finalizer can use this method to resurrect itself or an object that it references.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-383">En el ejemplo siguiente se muestra cómo usar el método ReRegisterForFinalize para finalizar un objeto una segunda vez después de la recolección de elementos.</span><span class="sxs-lookup"><span data-stu-id="20d1b-383">The following example demonstrates how to use the ReRegisterForFinalize method to finalize an object a second time after garbage collection.</span></span>  
  
 [!code-cpp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/CS/class1.cs#1)]
 [!code-vb[System.GC.ReregisterForFinalize Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.ReRegisterForFinalize Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="20d1b-384">El valor de <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-384">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.SuppressFinalize(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="SuppressFinalize">
      <MemberSignature Language="C#" Value="public static void SuppressFinalize (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SuppressFinalize(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.SuppressFinalize(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SuppressFinalize (obj As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SuppressFinalize(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="static member SuppressFinalize : obj -&gt; unit" Usage="System.GC.SuppressFinalize obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">
          <span data-ttu-id="20d1b-385">El objeto cuyo finalizador no debe ejecutarse.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-385">The object whose finalizer must not be executed.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-386">Solicita que Common Language Runtime no llame al finalizador del objeto especificado.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-386">Requests that the common language runtime not call the finalizer for the specified object.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-387">Este método establece un bit en el encabezado del objeto de `obj`, lo que el tiempo de ejecución comprueba cuando se llama a los finalizadores.</span><span class="sxs-lookup"><span data-stu-id="20d1b-387">This method sets a bit in the object header of `obj`, which the runtime checks when calling finalizers.</span></span> <span data-ttu-id="20d1b-388">Un finalizador, que viene representado por la <xref:System.Object.Finalize%2A?displayProperty=nameWithType> método, se usa para liberar recursos no administrados antes de que un objeto se recopila de elementos no utilizados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-388">A finalizer, which is represented by the <xref:System.Object.Finalize%2A?displayProperty=nameWithType> method, is used to release unmanaged resources before an object is garbage-collected.</span></span> <span data-ttu-id="20d1b-389">Si `obj` no tiene un finalizador, la llamada a la <xref:System.GC.SuppressFinalize%2A> método no tiene ningún efecto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-389">If `obj` does not have a finalizer, the call to the <xref:System.GC.SuppressFinalize%2A> method has no effect.</span></span>  
  
 <span data-ttu-id="20d1b-390">Los objetos que implementan la <xref:System.IDisposable> interfaz puede llamar a este método desde el objeto <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación para evitar que el recolector de elementos no utilizados que realiza la llamada <xref:System.Object.Finalize%2A?displayProperty=nameWithType> en un objeto que no la necesita.</span><span class="sxs-lookup"><span data-stu-id="20d1b-390">Objects that implement the <xref:System.IDisposable> interface can call this method from the object's <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation to prevent the garbage collector from calling <xref:System.Object.Finalize%2A?displayProperty=nameWithType> on an object that does not require it.</span></span> <span data-ttu-id="20d1b-391">Normalmente, esto se hace para evitar que el finalizador de liberar recursos no administrados que ya se han liberado por el <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-391">Typically, this is done to prevent the finalizer from releasing unmanaged resources that have already been freed by the <xref:System.IDisposable.Dispose%2A?displayProperty=nameWithType> implementation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-392">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.SuppressFinalize%2A> método en una clase de recurso para evitar que una recolección redundantes desde que se llama.</span><span class="sxs-lookup"><span data-stu-id="20d1b-392">The following example demonstrates how to use the <xref:System.GC.SuppressFinalize%2A> method in a resource class to prevent a redundant garbage collection from being called.</span></span> <span data-ttu-id="20d1b-393">El ejemplo se usa el [patrón de dispose](~/docs/standard/design-guidelines/dispose-pattern.md) liberar tanto recursos administrados (es decir, los objetos que implementan <xref:System.IDisposable>) y los recursos no administrados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-393">The example uses the [dispose pattern](~/docs/standard/design-guidelines/dispose-pattern.md) to free both managed resources (that is, objects that implement <xref:System.IDisposable>) and unmanaged resources.</span></span>  
  
 [!code-csharp[System.GC.SuppressFinalize#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.gc.suppressfinalize/cs/suppressfinalize1.cs#1)]
 [!code-vb[System.GC.SuppressFinalize#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.gc.suppressfinalize/vb/suppressfinalize1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <span data-ttu-id="20d1b-394">El valor de <paramref name="obj" /> es <see langword="null" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-394">
              <paramref name="obj" /> is <see langword="null" />.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.ReRegisterForFinalize(System.Object)" />
        <altmember cref="M:System.Object.Finalize" />
        <related type="Article" href="https://msdn.microsoft.com/library/31a6c13b-d6a2-492b-9a9f-e5238c983bcb">
          <span data-ttu-id="20d1b-395">Patrón de Dispose</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-395">Dispose Pattern</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryStartNoGCRegion">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-396">Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-396">Attempts to disallow garbage collection during the execution of a critical path.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!IMPORTANT]
>  <span data-ttu-id="20d1b-397">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-397">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-398">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-398">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.GC.EndNoGCRegion" />
      </Docs>
    </MemberGroup>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion totalSize" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="20d1b-399">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-399">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="20d1b-400">Debe ser menor o igual que el tamaño de un segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-400">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="20d1b-401">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-401">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-402">Intenta suspender la recolección de elementos durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-402">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-403">
            <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-403">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-404">El <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-404">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="20d1b-405">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional.</span><span class="sxs-lookup"><span data-stu-id="20d1b-405">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="20d1b-406">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 \* `totalSize` bytes (intenta asignar `totalSize` bytes para el montón de objetos pequeños y `totalSize` bytes para el montón de objetos grandes).</span><span class="sxs-lookup"><span data-stu-id="20d1b-406">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` bytes (it attempts to allocate `totalSize` bytes for the small object heap and `totalSize` bytes for the large object heap).</span></span>  
  
 <span data-ttu-id="20d1b-407">`totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica.</span><span class="sxs-lookup"><span data-stu-id="20d1b-407">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="20d1b-408">Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-408">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20d1b-409">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-409">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-410">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-410">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="20d1b-411">No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-411">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-412">
            <paramref name="totalSize" /> supera el tamaño del segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-412">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-413">El proceso ya está en modo de no latencia de región de GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-413">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="20d1b-414">Fundamentos de la recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-414">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="20d1b-415">Modos de latencia</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-415">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="20d1b-416">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-416">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="20d1b-417">Debe ser menor o igual que el tamaño de un segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-417">It must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="20d1b-418">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-418">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="20d1b-419">
            <see langword="true" /> para omitir una recolección de elementos no utilizados de bloqueo completa si el recolector de elementos no utilizados no puede asignar inicialmente <paramref name="totalSize" /> bytes; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-419">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate <paramref name="totalSize" /> bytes; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-420">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-420">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-421">
            <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-421">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-422">El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-422">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="20d1b-423">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional; de lo contrario, la asignación se produce un error y el método devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-423">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="20d1b-424">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar la cantidad necesaria de memoria, lo que en este caso es realmente 2 \* `totalSize` (intenta asignar `totalSize` para el montón de objetos pequeños y `totalSize` para el objeto grande montón).</span><span class="sxs-lookup"><span data-stu-id="20d1b-424">The garbage collector enters no GC region latency mode if it is able to allocate the required amount of memory, which in this case is actually 2 \* `totalSize` (it attempts to allocate `totalSize` for the small object heap and `totalSize` for the large object heap).</span></span>  
  
 <span data-ttu-id="20d1b-425">`totalSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica.</span><span class="sxs-lookup"><span data-stu-id="20d1b-425">`totalSize` must be large enough to handle all memory allocations that occur in the critical path.</span></span> <span data-ttu-id="20d1b-426">Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-426">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="20d1b-427">Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente es muy útil en escenarios de equilibrio de carga: puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve un sistema `true`, y tiene el equilibrador de carga redirigir las solicitudes a otros sistemas si devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-427">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="20d1b-428">A continuación, hacer una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-428">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20d1b-429">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-429">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-430">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-430">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="20d1b-431">No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-431">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-432">
            <paramref name="totalSize" /> supera el tamaño del segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-432">
              <paramref name="totalSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-433">El proceso ya está en modo de no latencia de región de GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-433">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="20d1b-434">Fundamentos de la recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-434">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="20d1b-435">Modos de latencia</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-435">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="20d1b-436">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-436">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="20d1b-437">
            <paramref name="totalSize" /> –<paramref name="lohSize" /> debe ser menor o igual que el tamaño de un segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-437">
              <paramref name="totalSize" /> –<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="20d1b-438">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-438">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="20d1b-439">El número de bytes de <paramref name="totalSize" /> que se utilizarán para las asignaciones de montones de objetos grandes (LOH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-439">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-440">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad específica de memoria está disponible para los montones de objetos pequeños y grandes.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-440">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-441">
            <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-441">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-442">El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-442">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="20d1b-443">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional.</span><span class="sxs-lookup"><span data-stu-id="20d1b-443">If the runtime is unable to initially allocate the requested amount of memory, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory.</span></span> <span data-ttu-id="20d1b-444">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize` – `lohSize` para el montón de objetos pequeños (SOH).</span><span class="sxs-lookup"><span data-stu-id="20d1b-444">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="20d1b-445">`lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande y `totalSize` – `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el informe de mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="20d1b-445">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="20d1b-446">Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-446">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20d1b-447">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-447">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-448">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-448">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="20d1b-449">No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-449">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-450">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> supera el tamaño del segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-450">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-451">El proceso ya está en modo de no latencia de región de GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-451">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="20d1b-452">Fundamentos de la recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-452">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="20d1b-453">Modos de latencia</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-453">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="TryStartNoGCRegion">
      <MemberSignature Language="C#" Value="public static bool TryStartNoGCRegion (long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryStartNoGCRegion(int64 totalSize, int64 lohSize, bool disallowFullBlockingGC) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.TryStartNoGCRegion(System.Int64,System.Int64,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryStartNoGCRegion (totalSize As Long, lohSize As Long, disallowFullBlockingGC As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);" />
      <MemberSignature Language="F#" Value="static member TryStartNoGCRegion : int64 * int64 * bool -&gt; bool" Usage="System.GC.TryStartNoGCRegion (totalSize, lohSize, disallowFullBlockingGC)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="totalSize" Type="System.Int64" />
        <Parameter Name="lohSize" Type="System.Int64" />
        <Parameter Name="disallowFullBlockingGC" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="totalSize">
          <span data-ttu-id="20d1b-454">La cantidad de memoria en bytes que se asignan sin desencadenar una recolección.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-454">The amount of memory in bytes to allocate without triggering a garbage collection.</span>
          </span>
          <span data-ttu-id="20d1b-455">
            <paramref name="totalSize" /> –<paramref name="lohSize" /> debe ser menor o igual que el tamaño de un segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-455">
              <paramref name="totalSize" /> –<paramref name="lohSize" /> must be less than or equal to the size of an ephemeral segment.</span>
          </span>
          <span data-ttu-id="20d1b-456">Para saber más sobre el tamaño de un segmento efímero, vea la sección "Generaciones y segmentos efímeros" del artículo [Fundamentos de la recolección de elementos no utilizados](~/docs/standard/garbage-collection/fundamentals.md).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-456">For information on the size of an ephemeral segment, see the "Ephemeral generations and segments" section in the [Fundamentals of Garbage Collection](~/docs/standard/garbage-collection/fundamentals.md) article.</span>
          </span>
        </param>
        <param name="lohSize">
          <span data-ttu-id="20d1b-457">El número de bytes de <paramref name="totalSize" /> que se utilizarán para las asignaciones de montones de objetos grandes (LOH).</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-457">The number of bytes in <paramref name="totalSize" /> to use for large object heap (LOH) allocations.</span>
          </span>
        </param>
        <param name="disallowFullBlockingGC">
          <span data-ttu-id="20d1b-458">
            <see langword="true" /> para omitir una recolección de elementos no utilizados si el recolector de elementos no utilizados no puede asignar inicialmente la memoria especificada al montón de objetos pequeños (SOH) y LOH; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-458">
              <see langword="true" /> to omit a full blocking garbage collection if the garbage collector is initially unable to allocate the specified memory on the small object heap (SOH) and LOH; otherwise, <see langword="false" />.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-459">Intenta suspender la recolección de elementos no usados durante la ejecución de una ruta crítica si una cantidad especificada de memoria está disponible para los montones de objetos grandes y pequeños, y controla si el recolector de elementos no usados realiza una recolección de elementos no usados de bloqueo completa si no hay suficiente memoria disponible inicialmente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-459">Attempts to disallow garbage collection during the execution of a critical path if a specified amount of memory is available for the large object heap and the small object heap, and controls whether the garbage collector does a full blocking garbage collection if not enough memory is initially available.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-460">
            <see langword="true" /> si el tiempo de ejecución pudo confirmar la cantidad necesaria de memoria y el recolector de elementos no utilizados puede entrar en el modo de no latencia en la región GC; en caso contrario, <see langword="false" />.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-460">
              <see langword="true" /> if the runtime was able to commit the required amount of memory and the garbage collector is able to enter no GC region latency mode; otherwise, <see langword="false" />.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-461">El <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> método intenta poner el recolector de elementos no utilizados en ningún modo de latencia de región de GC, lo que impide la recolección de elementos mientras una región crítica del código ejecuta una aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-461">The <xref:System.GC.TryStartNoGCRegion%28System.Int64%2CSystem.Int64%2CSystem.Boolean%29> method attempts to place the garbage collector in no GC region latency mode, which disallows garbage collection while an app executes a critical region of code.</span></span>  <span data-ttu-id="20d1b-462">Si el tiempo de ejecución no puede asignar inicialmente la cantidad de memoria solicitada y la `disallowFullBlockingGC` argumento es `false`, el recolector de elementos no utilizados realiza una recolección de elementos no utilizados de bloqueo completa en un intento para liberar memoria adicional; de lo contrario, la asignación se produce un error y el método devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-462">If the runtime is unable to initially allocate the requested amount of memory and the `disallowFullBlockingGC` argument is `false`, the garbage collector performs a full blocking garbage collection in an attempt to free additional memory; otherwise, the allocation fails, and the method returns `false`.</span></span> <span data-ttu-id="20d1b-463">El recolector de elementos no utilizados entra en modo de no latencia de la región de GC si es capaz de asignar `lohSize` para el montón de objeto grande y `totalSize` – `lohSize` para el montón de objetos pequeños (SOH).</span><span class="sxs-lookup"><span data-stu-id="20d1b-463">The garbage collector enters no GC region latency mode if it is able to allocate `lohSize` for the LOH and `totalSize` – `lohSize` for the small object heap (SOH).</span></span>  
  
 <span data-ttu-id="20d1b-464">`lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el montón de objeto grande y `totalSize` – `lohSize` debe ser lo suficientemente grande como para controlar todas las asignaciones de memoria que se producen en la ruta crítica para el informe de mantenimiento.</span><span class="sxs-lookup"><span data-stu-id="20d1b-464">`lohSize` must be large enough to handle all memory allocations that occur in the critical path for the LOH, and `totalSize` – `lohSize` must be large enough to handle all memory allocations that occur in the critical path for the SOH.</span></span> <span data-ttu-id="20d1b-465">Esto incluye las asignaciones por la aplicación, así como las asignaciones que el tiempo de ejecución se realiza en nombre de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="20d1b-465">This includes allocations by the app, as well as allocations that the runtime makes on the app's behalf.</span></span>  
  
 <span data-ttu-id="20d1b-466">Establecer `disallowFullBlockingGC` a `true` para evitar un elementos no utilizados bloqueo completa colección si no hay suficiente memoria disponible inicialmente es muy útil en escenarios de equilibrio de carga: puede llamar a este método y se presenta como listo para aceptar las solicitudes si devuelve un sistema `true`, y tiene el equilibrador de carga redirigir las solicitudes a otros sistemas si devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-466">Setting `disallowFullBlockingGC` to `true` to prevent a full blocking garbage collection if not enough memory is initially available is most useful in load balancing scenarios: one system can call this method and report itself as ready to accept requests if it returns `true`, and have the load balancer redirect requests to other systems if it returns `false`.</span></span> <span data-ttu-id="20d1b-467">A continuación, hacer una recolección de elementos no utilizados de bloqueo completa cuando no está controlando las solicitudes mediante una llamada a la <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-467">It can then do a full blocking garbage collection when it's not handling requests by calling the <xref:System.GC.Collect%28System.Int32%2CSystem.GCCollectionMode%2CSystem.Boolean%2CSystem.Boolean%29> method.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="20d1b-468">No se pueden anidar las llamadas a la <xref:System.GC.TryStartNoGCRegion%2A> solo debe llamar al método y el <xref:System.GC.EndNoGCRegion%2A> método si el tiempo de ejecución está actualmente en modo de no latencia de la región de GC.</span><span class="sxs-lookup"><span data-stu-id="20d1b-468">You cannot nest calls to the <xref:System.GC.TryStartNoGCRegion%2A> method, and you should only call the <xref:System.GC.EndNoGCRegion%2A> method if the runtime is currently in no GC region latency mode.</span></span> <span data-ttu-id="20d1b-469">En otras palabras, no debería llamar <xref:System.GC.TryStartNoGCRegion%2A> varias veces (después de la primera llamada de método, las llamadas subsiguientes no surtirán efecto), y no debe esperar que las llamadas a <xref:System.GC.EndNoGCRegion%2A> sea correcta sólo porque la primera llamada a <xref:System.GC.TryStartNoGCRegion%2A> se realizó correctamente.</span><span class="sxs-lookup"><span data-stu-id="20d1b-469">In other words, you should not call <xref:System.GC.TryStartNoGCRegion%2A> multiple times (after the first method call, subsequent calls will not succeed), and you should not expect calls to <xref:System.GC.EndNoGCRegion%2A> to succeed just because the first call to <xref:System.GC.TryStartNoGCRegion%2A> succeeded.</span></span>  
  
 <span data-ttu-id="20d1b-470">No salir del modo de latencia región de GC llamando el <xref:System.GC.EndNoGCRegion%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-470">You exit the no GC region latency mode by calling the <xref:System.GC.EndNoGCRegion%2A> method.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-471">
            <paramref name="totalSize" /> – <paramref name="lohSize" /> supera el tamaño del segmento efímero.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-471">
              <paramref name="totalSize" /> – <paramref name="lohSize" /> exceeds the ephemeral segment size.</span>
          </span>
        </exception>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-472">El proceso ya está en modo de no latencia de región de GC.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-472">The process is already in no GC region latency mode.</span>
          </span>
        </exception>
        <altmember cref="M:System.GC.EndNoGCRegion" />
        <related type="Article" href="https://msdn.microsoft.com/library/67c5a20d-1be1-4ea7-8a9a-92b0b08658d2">
          <span data-ttu-id="20d1b-473">Fundamentos de la recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-473">Fundamentals of Garbage Collection</span>
          </span>
        </related>
        <related type="Article" href="https://msdn.microsoft.com/library/96278bb7-6eab-4612-8594-ceebfc887d81">
          <span data-ttu-id="20d1b-474">Modos de latencia</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-474">Latency Modes</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCApproach">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-475">Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-475">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-476">Devuelve el estado de una notificación registrada para determinar si es inminente una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-476">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-477">El estado de la notificación registrada de recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-477">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-478">Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-478">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="20d1b-479">También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-479">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="20d1b-480">Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como impide que los objetos adicionales que se asigna y provocar una colección con el <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-480">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="20d1b-481">Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, sólo que condiciones han alcanzado el umbral de favorable para una colección de elementos no utilizados completa que se produzca.</span><span class="sxs-lookup"><span data-stu-id="20d1b-481">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="20d1b-482">Este método espera indefinidamente para que obtener una notificación de recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-482">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="20d1b-483">Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-483">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="20d1b-484">Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más de preferido.</span><span class="sxs-lookup"><span data-stu-id="20d1b-484">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="20d1b-485">Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-485">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="20d1b-486">Si solo llama a este método, pueden producirse resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-486">Calling this method alone causes indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-487">En el ejemplo siguiente se muestra cómo usar este método para determinar si se está agotando un completo, la recolección de elementos no utilizados de bloqueo.</span><span class="sxs-lookup"><span data-stu-id="20d1b-487">The following example shows how to use this method to determine whether a full, blocking garbage collection is approaching.</span></span> <span data-ttu-id="20d1b-488">Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCApproachNotify` se llama para realizar acciones en respuesta a la colección de proximidad.</span><span class="sxs-lookup"><span data-stu-id="20d1b-488">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCApproachNotify` is called to perform actions in response to the approaching collection.</span></span> <span data-ttu-id="20d1b-489">Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-489">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#3](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#3)]
 [!code-csharp[GCNotification#3](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#3)]
 [!code-vb[GCNotification#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#3)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-490">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-490">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-491">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-491">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-492">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-492">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-493">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-493">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-494">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-494">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCApproach">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCApproach (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCApproach(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCApproach(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCApproach (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCApproach : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCApproach millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="20d1b-495">Cantidad de tiempo que hay que esperar para obtener un estado de notificación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-495">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="20d1b-496">Especifique -1 para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-496">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-497">Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime es inminente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-497">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime is imminent.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-498">El estado de la notificación registrada de recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-498">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-499">Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-499">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="20d1b-500">También puede usar el <xref:System.GC.WaitForFullGCComplete%2A> método para determinar si se ha completado la colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-500">You can also use the <xref:System.GC.WaitForFullGCComplete%2A> method to determine whether the full garbage collection has completed.</span></span>  
  
 <span data-ttu-id="20d1b-501">Tenga en cuenta que este método devuelve un valor inmediatamente cada vez que se obtiene un estado de notificación de la colección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-501">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="20d1b-502">Si no se consigue un estado de notificación de la colección de elementos no utilizados antes de `millisecondsTimeout` veces, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-502">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="20d1b-503">Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como impide que los objetos adicionales que se asigna y provocar una colección con el <xref:System.GC.Collect%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-503">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as preventing additional objects from being allocated and inducing a collection yourself with the <xref:System.GC.Collect%2A> method.</span></span> <span data-ttu-id="20d1b-504">Tenga en cuenta que la notificación no garantiza que una colección de elementos no utilizados completa se produzca, sólo que condiciones han alcanzado el umbral de favorable para una colección de elementos no utilizados completa que se produzca.</span><span class="sxs-lookup"><span data-stu-id="20d1b-504">Note that the notification does not guarantee that a full garbage collection will occur, only that conditions have reached the threshold that are favorable for a full garbage collection to occur.</span></span>  
  
 <span data-ttu-id="20d1b-505">Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="20d1b-505">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="20d1b-506">Debe seguir este método con una llamada a la <xref:System.GC.WaitForFullGCComplete%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-506">You should follow this method with a call to the <xref:System.GC.WaitForFullGCComplete%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="20d1b-507">Si solo llama a este método, pueden producirse resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-507">Calling this method alone causes indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <span data-ttu-id="20d1b-508">
            <paramref name="millisecondsTimeout" /> debe ser no negativo, o bien menor o igual que <see cref="F:System.Int32.MaxValue" /> o -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-508">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-509">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-509">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-510">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-510">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-511">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-511">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-512">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-512">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-513">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-513">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <MemberGroup MemberName="WaitForFullGCComplete">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-514">Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-514">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete () As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete();" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : unit -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-515">Devuelve el estado de una notificación registrada para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-515">Returns the status of a registered notification for determining whether a full, blocking garbage collection by the common language runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-516">El estado de la notificación registrada de recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-516">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-517">Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-517">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="20d1b-518">También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-518">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="20d1b-519">Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="20d1b-519">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="20d1b-520">Este método espera indefinidamente para que obtener una notificación de recolección.</span><span class="sxs-lookup"><span data-stu-id="20d1b-520">This method waits indefinitely for a garbage collection notification to be obtained.</span></span> <span data-ttu-id="20d1b-521">Si desea especificar un período de tiempo de espera para el método devolver si no se puede obtener la notificación, utilice el <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-521">If you want to specify a time-out period for the method to return if the notification cannot be obtained, use the <xref:System.GC.WaitForFullGCApproach%28System.Int32%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="20d1b-522">Si se llama a este método sin especificar un tiempo de espera, puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método si se esperan más de preferido.</span><span class="sxs-lookup"><span data-stu-id="20d1b-522">If you call this method without specifying a time-out, you can call the <xref:System.GC.CancelFullGCNotification%2A> method if you are waiting longer than preferred.</span></span>  
  
 <span data-ttu-id="20d1b-523">Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-523">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="20d1b-524">Llamar a este método solo puede producir resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-524">Calling this method alone can produce indeterminate results.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-525">El ejemplo siguiente muestra cómo usar este método para determinar si se ha completado una recolección completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-525">The following example shows how to use this method to determine whether a full garbage collection has completed.</span></span> <span data-ttu-id="20d1b-526">Cada vez que el estado de la notificación es <xref:System.GCNotificationStatus.Succeeded>, el método de usuario `OnFullGCCompletedNotify` se llama para realizar acciones en respuesta a la colección completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-526">Whenever the status of the notification is <xref:System.GCNotificationStatus.Succeeded>, the user method `OnFullGCCompletedNotify` is called to perform actions in response to the completed collection.</span></span> <span data-ttu-id="20d1b-527">Este ejemplo de código forma parte de un ejemplo más extenso de [notificaciones de recolección de elementos no utilizados](~/docs/standard/garbage-collection/notifications.md) tema.</span><span class="sxs-lookup"><span data-stu-id="20d1b-527">This code example is part of a larger example provided for [Garbage Collection Notifications](~/docs/standard/garbage-collection/notifications.md) topic.</span></span>  
  
 [!code-cpp[GCNotification#4](~/samples/snippets/cpp/VS_Snippets_CLR/GCNotification/cpp/program.cpp#4)]
 [!code-csharp[GCNotification#4](~/samples/snippets/csharp/VS_Snippets_CLR/GCNotification/cs/Program.cs#4)]
 [!code-vb[GCNotification#4](~/samples/snippets/visualbasic/VS_Snippets_CLR/GCNotification/vb/program.vb#4)]  
  
 ]]></format>
        </remarks>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-528">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-528">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-529">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-529">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-530">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-530">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-531">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-531">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-532">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-532">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForFullGCComplete">
      <MemberSignature Language="C#" Value="public static GCNotificationStatus WaitForFullGCComplete (int millisecondsTimeout);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.GCNotificationStatus WaitForFullGCComplete(int32 millisecondsTimeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForFullGCComplete(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function WaitForFullGCComplete (millisecondsTimeout As Integer) As GCNotificationStatus" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);" />
      <MemberSignature Language="F#" Value="static member WaitForFullGCComplete : int -&gt; GCNotificationStatus" Usage="System.GC.WaitForFullGCComplete millisecondsTimeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.GCNotificationStatus</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="millisecondsTimeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="millisecondsTimeout">
          <span data-ttu-id="20d1b-533">Cantidad de tiempo que hay que esperar para obtener un estado de notificación.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-533">The length of time to wait before a notification status can be obtained.</span>
          </span>
          <span data-ttu-id="20d1b-534">Especifique -1 para esperar indefinidamente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-534">Specify -1 to wait indefinitely.</span>
          </span>
        </param>
        <summary>
          <span data-ttu-id="20d1b-535">Devuelve el estado de una notificación registrada, en un tiempo de espera especificado, para determinar si se ha completado una recolección completa de elementos no utilizados bloqueada por parte de Common Language Runtime.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-535">Returns, in a specified time-out period, the status of a registered notification for determining whether a full, blocking garbage collection by common language the runtime has completed.</span>
          </span>
        </summary>
        <returns>
          <span data-ttu-id="20d1b-536">El estado de la notificación registrada de recolección de elementos no utilizados.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-536">The status of the registered garbage collection notification.</span>
          </span>
        </returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-537">Use la <xref:System.GCNotificationStatus> enumeración devuelta por este método para determinar el estado de la notificación de recolección actual que se ha registrado mediante el <xref:System.GC.RegisterForFullGCNotification%2A> método.</span><span class="sxs-lookup"><span data-stu-id="20d1b-537">Use the <xref:System.GCNotificationStatus> enumeration returned by this method to determine the status of the current garbage collection notification that was registered by using the <xref:System.GC.RegisterForFullGCNotification%2A> method.</span></span> <span data-ttu-id="20d1b-538">También puede usar el <xref:System.GC.WaitForFullGCApproach%2A> método para determinar si es inminente una recolección completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-538">You can also use the <xref:System.GC.WaitForFullGCApproach%2A> method to determine whether a full garbage collection is imminent.</span></span>  
  
 <span data-ttu-id="20d1b-539">Tenga en cuenta que este método devuelve un valor inmediatamente cada vez que se obtiene un estado de notificación de la colección de elementos no utilizados, independientemente del valor especificado por `millisecondsTimeout`.</span><span class="sxs-lookup"><span data-stu-id="20d1b-539">Note that this method returns immediately whenever a garbage collection notification status is obtained, regardless of the value specified by `millisecondsTimeout`.</span></span> <span data-ttu-id="20d1b-540">Si no se consigue un estado de notificación de la colección de elementos no utilizados antes de `millisecondsTimeout` veces, este método devuelve <xref:System.GCNotificationStatus.NotApplicable>.</span><span class="sxs-lookup"><span data-stu-id="20d1b-540">If a garbage collection notification status is not obtained before `millisecondsTimeout` times out, this method returns <xref:System.GCNotificationStatus.NotApplicable>.</span></span>  
  
 <span data-ttu-id="20d1b-541">Cuando se devuelve la enumeración <xref:System.GCNotificationStatus.Succeeded>, puede hacer tareas como reanudar el trabajo y obtener un recuento de la colección con el <xref:System.GC.CollectionCount%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="20d1b-541">When the enumeration returns <xref:System.GCNotificationStatus.Succeeded>, you can do tasks such as resuming work and obtaining a collection count with the <xref:System.GC.CollectionCount%2A> property.</span></span>  
  
 <span data-ttu-id="20d1b-542">Puede llamar a la <xref:System.GC.CancelFullGCNotification%2A> método cuando no puede esperar a que transcurra el tiempo de espera.</span><span class="sxs-lookup"><span data-stu-id="20d1b-542">You can call the <xref:System.GC.CancelFullGCNotification%2A> method when you cannot wait for the time-out period to elapse.</span></span>  
  
 <span data-ttu-id="20d1b-543">Esta llamada al método debe ir precedida por una llamada a la <xref:System.GC.WaitForFullGCApproach%2A> método para asegurarse de que haya tenido una colección de elementos no utilizados completa.</span><span class="sxs-lookup"><span data-stu-id="20d1b-543">This method call should be preceded with a call to the <xref:System.GC.WaitForFullGCApproach%2A> method to make sure that you have had a full garbage collection.</span></span> <span data-ttu-id="20d1b-544">Llamar a este método solo puede producir resultados indeterminados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-544">Calling this method alone can produce indeterminate results.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">
          <span data-ttu-id="20d1b-545">
            <paramref name="millisecondsTimeout" /> debe ser no negativo, o bien menor o igual que <see cref="F:System.Int32.MaxValue" /> o -1.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-545">
              <paramref name="millisecondsTimeout" /> must be either non-negative or less than or equal to <see cref="F:System.Int32.MaxValue" /> or -1.</span>
          </span>
        </exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.LinkDemand">
          <span data-ttu-id="20d1b-546">para plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-546">for full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-547">Un código de confianza parcial no puede utilizar este miembro.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-547">This member cannot be used by partially trusted code.</span>
          </span>
        </permission>
        <permission cref="T:System.Security.SecurityCriticalAttribute">
          <span data-ttu-id="20d1b-548">requiere plena confianza para el llamador inmediato.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-548">requires full trust for the immediate caller.</span>
          </span>
          <span data-ttu-id="20d1b-549">Este miembro no se puede usar código de confianza parcial o transparente.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-549">This member cannot be used by partially trusted or transparent code.</span>
          </span>
        </permission>
        <related type="Article" href="https://msdn.microsoft.com/library/e12d8e74-31e3-4035-a87d-f3e66f0a9b89">
          <span data-ttu-id="20d1b-550">Notificaciones de recolección de elementos no utilizados</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-550">Garbage Collection Notifications</span>
          </span>
        </related>
      </Docs>
    </Member>
    <Member MemberName="WaitForPendingFinalizers">
      <MemberSignature Language="C#" Value="public static void WaitForPendingFinalizers ();" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void WaitForPendingFinalizers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.GC.WaitForPendingFinalizers" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub WaitForPendingFinalizers ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void WaitForPendingFinalizers();" />
      <MemberSignature Language="F#" Value="static member WaitForPendingFinalizers : unit -&gt; unit" Usage="System.GC.WaitForPendingFinalizers " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>
          <span data-ttu-id="20d1b-551">Suspende el subproceso actual hasta que el subproceso que está procesando la cola de finalizadores vacíe dicha cola.</span>
          <span class="sxs-lookup">
            <span data-stu-id="20d1b-551">Suspends the current thread until the thread that is processing the queue of finalizers has emptied that queue.</span>
          </span>
        </summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="20d1b-552">Cuando el recolector de elementos no utilizados detecta los objetos que se pueden reclamar, comprueba cada objeto para determinar los requisitos de finalización del objeto.</span><span class="sxs-lookup"><span data-stu-id="20d1b-552">When the garbage collector finds objects that can be reclaimed, it checks each object to determine the object's finalization requirements.</span></span> <span data-ttu-id="20d1b-553">Si un objeto implementa un finalizador y no se ha deshabilitado la finalización mediante una llamada a <xref:System.GC.SuppressFinalize%2A>, el objeto se coloca en una lista de objetos que se marcan como listos para la finalización.</span><span class="sxs-lookup"><span data-stu-id="20d1b-553">If an object implements a finalizer and has not disabled finalization by calling <xref:System.GC.SuppressFinalize%2A>, the object is placed in a list of objects that are marked as ready for finalization.</span></span> <span data-ttu-id="20d1b-554">El recolector de elementos no utilizados llame al <xref:System.Object.Finalize%2A> métodos para los objetos de esta lista y quita las entradas de la lista.</span><span class="sxs-lookup"><span data-stu-id="20d1b-554">The garbage collector calls the <xref:System.Object.Finalize%2A> methods for the objects in this list and removes the entries from the list.</span></span> <span data-ttu-id="20d1b-555">Este método se bloquea hasta que todos los finalizadores se ha ejecutado hasta su finalización.</span><span class="sxs-lookup"><span data-stu-id="20d1b-555">This method blocks until all finalizers have run to completion.</span></span>  
  
 <span data-ttu-id="20d1b-556">El subproceso en el que se ejecutan los finalizadores no se especifica, por lo que no hay ninguna garantía de que este método se cerrará.</span><span class="sxs-lookup"><span data-stu-id="20d1b-556">The thread on which finalizers are run is unspecified, so there is no guarantee that this method will terminate.</span></span> <span data-ttu-id="20d1b-557">Sin embargo, este subproceso puede ser interrumpido por otro subproceso mientras el <xref:System.GC.WaitForPendingFinalizers%2A> método está en curso.</span><span class="sxs-lookup"><span data-stu-id="20d1b-557">However, this thread can be interrupted by another thread while the <xref:System.GC.WaitForPendingFinalizers%2A> method is in progress.</span></span> <span data-ttu-id="20d1b-558">Por ejemplo, puede iniciar otro subproceso que espera durante un período de tiempo y, a continuación, interrumpe este subproceso si sigue suspendido este subproceso.</span><span class="sxs-lookup"><span data-stu-id="20d1b-558">For example, you can start another thread that waits for a period of time and then interrupts this thread if this thread is still suspended.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="20d1b-559">En el ejemplo siguiente se muestra cómo usar el <xref:System.GC.WaitForPendingFinalizers%2A> método para suspender el subproceso actual hasta que se complete la finalización de todos los objetos recopilados.</span><span class="sxs-lookup"><span data-stu-id="20d1b-559">The following example demonstrates how to use the <xref:System.GC.WaitForPendingFinalizers%2A> method to suspend the current thread until finalization of all the collected objects is complete.</span></span>  
  
 [!code-cpp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CPP/class1.cpp#1)]
 [!code-csharp[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/CS/class1.cs#1)]
 [!code-vb[System.GC.WaitForPendingFinalizers Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.GC.WaitForPendingFinalizers Example/VB/class1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>