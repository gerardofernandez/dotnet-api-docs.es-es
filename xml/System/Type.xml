<Type Name="Type" FullName="System.Type">
  <Metadata><Meta Name="ms.openlocfilehash" Value="7a7712a60e02537eee0dbbcc99b3b64d65925400" /><Meta Name="ms.sourcegitcommit" Value="adc8598fd19d91438cacaa8fa7ce613e28c8218e" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="12/11/2018" /><Meta Name="ms.locfileid" Value="53233723" /></Metadata><TypeSignature Language="C#" Value="public abstract class Type : System.Reflection.MemberInfo, System.Reflection.IReflect, System.Runtime.InteropServices._Type" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract serializable beforefieldinit Type extends System.Reflection.MemberInfo implements class System.Reflection.IReflect, class System.Runtime.InteropServices._Type" />
  <TypeSignature Language="DocId" Value="T:System.Type" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Type&#xA;Inherits MemberInfo&#xA;Implements _Type, IReflect" />
  <TypeSignature Language="C++ CLI" Value="public ref class Type abstract : System::Reflection::MemberInfo, System::Reflection::IReflect, System::Runtime::InteropServices::_Type" />
  <TypeSignature Language="F#" Value="type Type = class&#xA;    inherit MemberInfo&#xA;    interface _Type&#xA;    interface IReflect" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
    <BaseTypeName FrameworkAlternate="netframework-4.5">System.Reflection.MemberInfo</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Reflection.IReflect</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Runtime.InteropServices._Type</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ClassInterface(System.Runtime.InteropServices.ClassInterfaceType.None)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComDefaultInterface(typeof(System.Runtime.InteropServices._Type))</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="60a97-101">Representa declaraciones de tipos: tipos de clase, tipos de interfaz, tipos de matriz, tipos de valor, tipos de enumeración, parámetros de tipo, definiciones de tipo genérico y tipos genéricos construidos abiertos o cerrados.</span><span class="sxs-lookup"><span data-stu-id="60a97-101">Represents type declarations: class types, interface types, array types, value types, enumeration types, type parameters, generic type definitions, and open or closed constructed generic types.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-102">`Type` es la raíz de la <xref:System.Reflection> funcionalidad y es la manera principal para acceder a metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-102">`Type` is the root of the <xref:System.Reflection> functionality and is the primary way to access metadata.</span></span> <span data-ttu-id="60a97-103">Utilice los miembros de <xref:System.Type> para obtener información sobre una declaración de tipos, acerca de los miembros de un tipo (por ejemplo, los constructores, métodos, campos, propiedades y eventos de una clase), así como el módulo y el ensamblado en el que se implementa la clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-103">Use the members of <xref:System.Type> to get information about a type declaration, about the members of a type (such as the constructors, methods, fields, properties, and events of a class), as well as the module and the assembly in which the class is deployed.</span></span>  
  
 <span data-ttu-id="60a97-104">No se requieren permisos para usar la reflexión para obtener información sobre los tipos y sus miembros, independientemente de sus niveles de acceso de código.</span><span class="sxs-lookup"><span data-stu-id="60a97-104">No permissions are required for code to use reflection to get information about types and their members, regardless of their access levels.</span></span> <span data-ttu-id="60a97-105">No se requieren permisos para el código usar la reflexión para tener acceso a los miembros públicos o a otros miembros cuyos niveles de acceso deben que estén visibles durante la compilación normal.</span><span class="sxs-lookup"><span data-stu-id="60a97-105">No permissions are required for code to use reflection to access public members, or other members whose access levels would make them visible during normal compilation.</span></span> <span data-ttu-id="60a97-106">Sin embargo, para el código para usar la reflexión para obtener acceso a miembros que normalmente serían inaccesibles, como métodos privados o internos o campos protegidos de un tipo no hereda la clase, el código debe tener <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="60a97-106">However, in order for your code to use reflection to access members that would normally be inaccessible, such as private or internal methods, or protected fields of a type your class does not inherit, your code must have <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="60a97-107">Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-107">See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span>  
  
 <span data-ttu-id="60a97-108">`Type` es una clase base abstracta que permite varias implementaciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-108">`Type` is an abstract base class that allows multiple implementations.</span></span> <span data-ttu-id="60a97-109">El sistema siempre proporcionará la clase derivada `RuntimeType`.</span><span class="sxs-lookup"><span data-stu-id="60a97-109">The system will always provide the derived class `RuntimeType`.</span></span> <span data-ttu-id="60a97-110">En la reflexión, todas las clases que comiencen por la palabra en tiempo de ejecución se crean una sola vez por cada objeto en el sistema y compatibilidad con las operaciones de comparación.</span><span class="sxs-lookup"><span data-stu-id="60a97-110">In reflection, all classes beginning with the word Runtime are created only once per object in the system and support comparison operations.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-111">En escenarios de multithreading, no bloquee <xref:System.Type> con el fin de sincronizar el acceso a los objetos `static` datos.</span><span class="sxs-lookup"><span data-stu-id="60a97-111">In multithreading scenarios, do not lock <xref:System.Type> objects in order to synchronize access to `static` data.</span></span> <span data-ttu-id="60a97-112">Otro código, en el que no tiene ningún control, también puede bloquear el tipo de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-112">Other code, over which you have no control, might also lock your class type.</span></span> <span data-ttu-id="60a97-113">Esto puede dar lugar a un interbloqueo.</span><span class="sxs-lookup"><span data-stu-id="60a97-113">This might result in a deadlock.</span></span> <span data-ttu-id="60a97-114">En su lugar, sincronizar el acceso a los datos estáticos bloqueando una privada `static` objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-114">Instead, synchronize access to static data by locking a private `static` object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-115">Una clase derivada puede tener acceso a miembros protegidos de clases base del código que realiza la llamada.</span><span class="sxs-lookup"><span data-stu-id="60a97-115">A derived class can access protected members of the calling code's base classes.</span></span> <span data-ttu-id="60a97-116">Además, se permite el acceso a los miembros del ensamblado del ensamblado del código de llamada.</span><span class="sxs-lookup"><span data-stu-id="60a97-116">Also, access is allowed to assembly members of the calling code's assembly.</span></span> <span data-ttu-id="60a97-117">Como norma, si se permite el acceso en tiempo de compilación código, a continuación, se también pueden acceder en el código en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-117">As a rule, if you are allowed access in early-bound code, then you are also allowed access in late-bound code.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-118">Las interfaces que extienden otras interfaces no heredan los métodos definidos en las interfaces extendidas.</span><span class="sxs-lookup"><span data-stu-id="60a97-118">Interfaces that extend other interfaces do not inherit the methods defined in the extended interfaces.</span></span>  
  
 <span data-ttu-id="60a97-119">En esta sección:</span><span class="sxs-lookup"><span data-stu-id="60a97-119">In this section:</span></span>  
  
 <span data-ttu-id="60a97-120">[¿Qué tipos de representa un objeto de tipo?](#WhatTypes) </span><span class="sxs-lookup"><span data-stu-id="60a97-120">[What types does a Type object represent?](#WhatTypes) </span></span>  
 <span data-ttu-id="60a97-121">[Recuperar un objeto de tipo](#Retrieve) </span><span class="sxs-lookup"><span data-stu-id="60a97-121">[Retrieving a Type object](#Retrieve) </span></span>  
 [<span data-ttu-id="60a97-122">Comparar objetos de tipo de igualdad</span><span class="sxs-lookup"><span data-stu-id="60a97-122">Comparing type objects for equality</span></span>](#Equality)  
  
<a name="WhatTypes"></a>   
## <a name="what-types-does-a-type-object-represent"></a><span data-ttu-id="60a97-123">¿Qué tipos de representa un objeto de tipo?</span><span class="sxs-lookup"><span data-stu-id="60a97-123">What types does a Type object represent?</span></span>  
 <span data-ttu-id="60a97-124">Esta clase es seguro para subprocesos; varios subprocesos pueden leer simultáneamente desde una instancia de este tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-124">This class is thread safe; multiple threads can concurrently read from an instance of this type.</span></span> <span data-ttu-id="60a97-125">Una instancia de la <xref:System.Type> clase puede representar cualquiera de los siguientes tipos:</span><span class="sxs-lookup"><span data-stu-id="60a97-125">An instance of the <xref:System.Type> class can represent any of the following types:</span></span>  
  
-   <span data-ttu-id="60a97-126">Clases</span><span class="sxs-lookup"><span data-stu-id="60a97-126">Classes</span></span>  
  
-   <span data-ttu-id="60a97-127">Tipos de valor</span><span class="sxs-lookup"><span data-stu-id="60a97-127">Value types</span></span>  
  
-   <span data-ttu-id="60a97-128">Matrices</span><span class="sxs-lookup"><span data-stu-id="60a97-128">Arrays</span></span>  
  
-   <span data-ttu-id="60a97-129">Interfaces</span><span class="sxs-lookup"><span data-stu-id="60a97-129">Interfaces</span></span>  
  
-   <span data-ttu-id="60a97-130">Enumeraciones</span><span class="sxs-lookup"><span data-stu-id="60a97-130">Enumerations</span></span>  
  
-   <span data-ttu-id="60a97-131">Delegados</span><span class="sxs-lookup"><span data-stu-id="60a97-131">Delegates</span></span>  
  
-   <span data-ttu-id="60a97-132">Tipos genéricos construidos y definiciones de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="60a97-132">Constructed generic types and generic type definitions</span></span>  
  
-   <span data-ttu-id="60a97-133">Argumentos de tipo y parámetros de tipos genéricos construidos, definiciones de tipo genérico y definiciones de método genérico de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-133">Type arguments and type parameters of constructed generic types, generic type definitions, and generic method definitions</span></span>  
  
<a name="Retrieve"></a>   
## <a name="retrieving-a-type-object"></a><span data-ttu-id="60a97-134">Recuperar un objeto de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-134">Retrieving a Type object</span></span>  
 <span data-ttu-id="60a97-135">El <xref:System.Type> se puede obtener el objeto asociado a un tipo determinado de las maneras siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-135">The <xref:System.Type> object associated with a particular type can be obtained in the following ways:</span></span>  
  
-   <span data-ttu-id="60a97-136">La instancia <xref:System.Object.GetType%2A?displayProperty=nameWithType> método devuelve un <xref:System.Type> objeto que representa el tipo de una instancia.</span><span class="sxs-lookup"><span data-stu-id="60a97-136">The instance <xref:System.Object.GetType%2A?displayProperty=nameWithType> method returns a <xref:System.Type> object that represents the type of an instance.</span></span> <span data-ttu-id="60a97-137">Dado que todos los tipos administrados se derivan de <xref:System.Object>, el <xref:System.Object.GetType%2A> método puede llamarse en una instancia de cualquier tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-137">Because all managed types derive from <xref:System.Object>, the <xref:System.Object.GetType%2A> method can be called on an instance of any type.</span></span>  
  
     <span data-ttu-id="60a97-138">El ejemplo siguiente se llama el <xref:System.Object.GetType%2A?displayProperty=nameWithType> método para determinar el tipo en tiempo de ejecución de cada objeto en una matriz de objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-138">The following example calls the <xref:System.Object.GetType%2A?displayProperty=nameWithType> method to determine the runtime type of each object in an object array.</span></span>  
  
     [!code-cpp[System.Type#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/GetType1.cpp#2)]
     [!code-csharp[System.Type#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/GetType1.cs#2)]
     [!code-vb[System.Type#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/GetType1.vb#2)]  
  
-   <span data-ttu-id="60a97-139">Estático <xref:System.Type.GetType%2A?displayProperty=nameWithType> métodos devuelven un <xref:System.Type> objeto que representa un tipo especificado por su nombre completo.</span><span class="sxs-lookup"><span data-stu-id="60a97-139">The static <xref:System.Type.GetType%2A?displayProperty=nameWithType> methods return a <xref:System.Type> object that represents a type specified by its fully qualified name.</span></span>  
  
-   <span data-ttu-id="60a97-140">El <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, y <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> métodos devuelven `Type` objetos que representan los tipos definidos en un módulo.</span><span class="sxs-lookup"><span data-stu-id="60a97-140">The <xref:System.Reflection.Module.GetTypes%2A?displayProperty=nameWithType>, <xref:System.Reflection.Module.GetType%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Module.FindTypes%2A?displayProperty=nameWithType> methods return `Type` objects that represent the types defined in a module.</span></span> <span data-ttu-id="60a97-141">El primer método se puede usar para obtener una matriz de <xref:System.Type> objetos para todos los tipos públicos y privados definidos en un módulo.</span><span class="sxs-lookup"><span data-stu-id="60a97-141">The first method can be used to obtain an array of <xref:System.Type> objects for all the public and private types defined in a module.</span></span> <span data-ttu-id="60a97-142">(Puede obtener una instancia de `Module` a través de la <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> o <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> método, o a través del <xref:System.Type.Module%2A?displayProperty=nameWithType> propiedad.)</span><span class="sxs-lookup"><span data-stu-id="60a97-142">(You can obtain an instance of `Module` through the <xref:System.Reflection.Assembly.GetModule%2A?displayProperty=nameWithType> or <xref:System.Reflection.Assembly.GetModules%2A?displayProperty=nameWithType> method, or through the <xref:System.Type.Module%2A?displayProperty=nameWithType> property.)</span></span>  
  
-   <span data-ttu-id="60a97-143">El <xref:System.Reflection.Assembly?displayProperty=nameWithType> objeto contiene una serie de métodos para recuperar las clases definidas en un ensamblado, incluyendo <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, y <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-143">The <xref:System.Reflection.Assembly?displayProperty=nameWithType> object contains a number of methods to retrieve the classes defined in an assembly, including <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType>, <xref:System.Reflection.Assembly.GetTypes%2A?displayProperty=nameWithType>, and <xref:System.Reflection.Assembly.GetExportedTypes%2A?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60a97-144">El <xref:System.Type.FindInterfaces%2A> método devuelve una lista filtrada de los tipos de interfaz compatible con un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-144">The <xref:System.Type.FindInterfaces%2A> method returns a filtered list of interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="60a97-145">El <xref:System.Type.GetElementType%2A> método devuelve un `Type` objeto que representa el elemento.</span><span class="sxs-lookup"><span data-stu-id="60a97-145">The <xref:System.Type.GetElementType%2A> method returns a `Type` object that represents the element.</span></span>  
  
-   <span data-ttu-id="60a97-146">El <xref:System.Type.GetInterfaces%2A> y <xref:System.Type.GetInterface%2A> métodos devuelven <xref:System.Type> objetos que representan los tipos de interfaz compatibles con un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-146">The <xref:System.Type.GetInterfaces%2A> and <xref:System.Type.GetInterface%2A> methods return <xref:System.Type> objects representing the interface types supported by a type.</span></span>  
  
-   <span data-ttu-id="60a97-147">El <xref:System.Type.GetTypeArray%2A> método devuelve una matriz de <xref:System.Type> objetos que representan los tipos especificados por un conjunto arbitrario de objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-147">The <xref:System.Type.GetTypeArray%2A> method returns an array of <xref:System.Type> objects representing the types specified by an arbitrary set of objects.</span></span> <span data-ttu-id="60a97-148">Los objetos se especifican con una matriz de tipo <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="60a97-148">The objects are specified with an array of type <xref:System.Object>.</span></span>  
  
-   <span data-ttu-id="60a97-149">El <xref:System.Type.GetTypeFromProgID%2A> y <xref:System.Type.GetTypeFromCLSID%2A> se proporcionan métodos para la interoperabilidad COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-149">The <xref:System.Type.GetTypeFromProgID%2A> and <xref:System.Type.GetTypeFromCLSID%2A> methods are provided for COM interoperability.</span></span> <span data-ttu-id="60a97-150">Devuelven un <xref:System.Type> objeto que representa el tipo especificado por un `ProgID` o `CLSID`.</span><span class="sxs-lookup"><span data-stu-id="60a97-150">They return a <xref:System.Type> object that represents the type specified by a `ProgID` or `CLSID`.</span></span>  
  
-   <span data-ttu-id="60a97-151">El <xref:System.Type.GetTypeFromHandle%2A> se proporciona el método de interoperabilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-151">The <xref:System.Type.GetTypeFromHandle%2A> method is provided for interoperability.</span></span> <span data-ttu-id="60a97-152">Devuelve un `Type` objeto que representa el tipo especificado por un identificador de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-152">It returns a `Type` object that represents the type specified by a class handle.</span></span>  
  
-   <span data-ttu-id="60a97-153">C# `typeof` operador, C++ `typeid` operador y el de Visual Basic `GetType` operador obtener el `Type` un tipo de objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-153">The C# `typeof` operator, the C++ `typeid` operator, and the Visual Basic `GetType` operator obtain the `Type` object for a type.</span></span>  
  
-   <span data-ttu-id="60a97-154">El <xref:System.Type.MakeGenericType%2A> método devuelve un <xref:System.Type> objeto que representa un tipo genérico construido, que es un tipo construido abierto si su <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`, y un tipo construido cerrado en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="60a97-154">The <xref:System.Type.MakeGenericType%2A> method returns a <xref:System.Type> object representing a constructed generic type, which is an open constructed type if its <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, and a closed constructed type otherwise.</span></span> <span data-ttu-id="60a97-155">Puede crearse un tipo genérico solo si está cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-155">A generic type can be instantiated only if it is closed.</span></span>  
  
-   <span data-ttu-id="60a97-156">El <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, y <xref:System.Type.MakeByRefType%2A> métodos devuelven <xref:System.Type> objetos que representan, respectivamente, una matriz de un tipo especificado, un puntero a un tipo especificado y el tipo de un parámetro de referencia (`ref` en C#, `ByRef`en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-156">The <xref:System.Type.MakeArrayType%2A>, <xref:System.Type.MakePointerType%2A>, and <xref:System.Type.MakeByRefType%2A> methods return <xref:System.Type> objects that represent, respectively, an array of a specified type, a pointer to a specified type, and the type of a reference parameter (`ref` in C#, `ByRef` in Visual Basic).</span></span>  
  
<a name="Equality"></a>   
## <a name="comparing-type-objects-for-equality"></a><span data-ttu-id="60a97-157">Comparar objetos de tipo de igualdad</span><span class="sxs-lookup"><span data-stu-id="60a97-157">Comparing type objects for equality</span></span>  
 <span data-ttu-id="60a97-158">Un <xref:System.Type> objeto que representa un tipo es único; es decir, dos <xref:System.Type> las referencias de objeto hacen referencia al mismo objeto solo si representan el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-158">A <xref:System.Type> object that represents a type is unique; that is, two <xref:System.Type> object references refer to the same object if and only if they represent the same type.</span></span> <span data-ttu-id="60a97-159">Esto permite la comparación de <xref:System.Type> objetos mediante la igualdad de referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-159">This allows for comparison of <xref:System.Type> objects using reference equality.</span></span> <span data-ttu-id="60a97-160">En el ejemplo siguiente se comparan los <xref:System.Type> objetos que representan un número de valores enteros para determinar si son del mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-160">The following example compares the <xref:System.Type> objects that represent a number of integer values to determine whether they are of the same type.</span></span>  
  
 [!code-cpp[System.Type#3](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/Equals1.cpp#3)]
 [!code-csharp[System.Type#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/Equals1.cs#3)]
 [!code-vb[System.Type#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/Equals1.vb#3)]  
  
   
  
## Examples  
 <span data-ttu-id="60a97-161">El ejemplo siguiente muestra algunas características representativas de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-161">The following  example shows a few representative features of <xref:System.Type>.</span></span> <span data-ttu-id="60a97-162">C# `typeof` operador (`GetType` operador en Visual Basic, `typeid` operador en Visual C++) se utiliza para obtener un <xref:System.Type> que representa el objeto <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="60a97-162">The C# `typeof` operator (`GetType` operator in Visual Basic, `typeid` operator in Visual C++) is used to get a <xref:System.Type> object representing <xref:System.String>.</span></span> <span data-ttu-id="60a97-163">Desde este <xref:System.Type> objeto, el <xref:System.Type.GetMethod%2A> método se utiliza para obtener un <xref:System.Reflection.MethodInfo> que representa el <xref:System.String.Substring%2A> sobrecarga que toma una posición inicial y una longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-163">From this <xref:System.Type> object, the <xref:System.Type.GetMethod%2A> method is used to get a <xref:System.Reflection.MethodInfo> representing the <xref:System.String.Substring%2A> overload that takes a starting location and a length.</span></span>  
  
 <span data-ttu-id="60a97-164">Para identificar la signatura de sobrecarga, el ejemplo de código crea una matriz temporal que contiene dos <xref:System.Type> objetos que representan `int` (`Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-164">To identify the overload signature, the code example creates a temporary array containing two <xref:System.Type> objects representing `int` (`Integer` in Visual Basic).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-165">Para ser exactos, la matriz contiene dos referencias a la instancia de <xref:System.Type> que representa `int` en el dominio de aplicación actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-165">To be precise, the array contains two references to the instance of <xref:System.Type> that represents `int` in the current application domain.</span></span> <span data-ttu-id="60a97-166">Para cualquier tipo, hay solo una instancia de <xref:System.Type> por dominio de aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a97-166">For any type, there is only one instance of <xref:System.Type> per application domain.</span></span>  
  
 <span data-ttu-id="60a97-167">El ejemplo de código se usa el <xref:System.Reflection.MethodInfo> para invocar el <xref:System.String.Substring%2A> método en la cadena "Hello, World!" y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-167">The code example uses the <xref:System.Reflection.MethodInfo> to invoke the <xref:System.String.Substring%2A> method on the string "Hello, World!", and displays the result.</span></span>  
  
 [!code-cpp[System.Type#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type/cpp/source.cpp#1)]
 [!code-csharp[System.Type#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type/cs/source.cs#1)]
 [!code-vb[System.Type#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type/vb/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="60a97-168">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="60a97-168">This type is thread safe.</span></span></threadsafe>
    <block subset="none" type="overrides"><para><span data-ttu-id="60a97-169">Al heredar de <see langword="Type" />, es necesario invalidar los miembros siguientes:.</span><span class="sxs-lookup"><span data-stu-id="60a97-169">When you inherit from <see langword="Type" />, you must override the following members:</span></span> 
-   <see cref="P:System.Type.Assembly" />  
  
-   <see cref="P:System.Type.AssemblyQualifiedName" />  
  
-   <see cref="P:System.Type.BaseType" />  
  
-   <see cref="P:System.Type.FullName" />  
  
-   <see cref="M:System.Type.GetAttributeFlagsImpl" />  
  
-   <see cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetElementType" />  
  
-   <see cref="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetFields(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetInterface(System.String,System.Boolean)" />  
  
-   <see cref="M:System.Type.GetInterfaces" />  
  
-   <see cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />  
  
-   <see cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />  
  
-   <see cref="P:System.Type.GUID" />  
  
-   <see cref="M:System.Type.HasElementTypeImpl" />  
  
-   <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />  
  
-   <see cref="M:System.Type.IsArrayImpl" />  
  
-   <see cref="M:System.Type.IsByRefImpl" />  
  
-   <see cref="M:System.Type.IsCOMObjectImpl" />  
  
-   <see cref="M:System.Type.IsPointerImpl" />  
  
-   <see cref="M:System.Type.IsPrimitiveImpl" />  
  
-   <see cref="P:System.Type.Module" />  
  
-   <see cref="P:System.Type.Namespace" />  
  
-   <see cref="P:System.Type.TypeHandle" />  
  
-   <see cref="P:System.Type.UnderlyingSystemType" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.GetCustomAttributes(System.Type,System.Boolean)" />  
  
-   <see cref="M:System.Reflection.MemberInfo.IsDefined(System.Type,System.Boolean)" />  
  
-   <see cref="P:System.Reflection.MemberInfo.Name" /></para></block>
    <altmember cref="T:System.Object" />
    <altmember cref="N:System.Reflection" />
    <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
    <related type="Article" href="~/docs/framework/reflection-and-codedom/viewing-type-information.md"><span data-ttu-id="60a97-170">Ver información de tipos</span><span class="sxs-lookup"><span data-stu-id="60a97-170">Viewing Type Information</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Type ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Type();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-171">Inicializa una nueva instancia de la clase <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-171">Initializes a new instance of the <see cref="T:System.Type" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-172">Las clases derivadas, se invoca este constructor durante la construcción de objetos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-172">This constructor is invoked by derived classes during the construction of type objects.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Assembly">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Assembly Assembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Assembly Assembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.Assembly" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Assembly As Assembly" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Assembly ^ Assembly { System::Reflection::Assembly ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Assembly : System.Reflection.Assembly" Usage="System.Type.Assembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Assembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Assembly</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-173">Obtiene la propiedad <see cref="T:System.Reflection.Assembly" /> en la que está declarado el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-173">Gets the <see cref="T:System.Reflection.Assembly" /> in which the type is declared.</span></span> <span data-ttu-id="60a97-174">Para los tipos genéricos, obtiene la propiedad <see cref="T:System.Reflection.Assembly" /> en la que está definido el tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-174">For generic types, gets the <see cref="T:System.Reflection.Assembly" /> in which the generic type is defined.</span></span></summary>
        <value><span data-ttu-id="60a97-175">Instancia de <see cref="T:System.Reflection.Assembly" /> que describe el ensamblado que contiene el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-175">An <see cref="T:System.Reflection.Assembly" /> instance that describes the assembly containing the current type.</span></span> <span data-ttu-id="60a97-176">Para los tipos genéricos, la instancia describe el ensamblado que contiene la definición de tipo genérico, no el ensamblado que crea y usa un tipo construido en particular.</span><span class="sxs-lookup"><span data-stu-id="60a97-176">For generic types, the instance describes the assembly that contains the generic type definition, not the assembly that creates and uses a particular constructed type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-177">Si el actual <xref:System.Type> objeto representa un tipo genérico construido, esta propiedad devuelve el ensamblado que contiene la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-177">If the current <xref:System.Type> object represents a constructed generic type, this property returns the assembly that contains the generic type definition.</span></span> <span data-ttu-id="60a97-178">Por ejemplo, suponga que crea un ensamblado denominado MyGenerics.dll que contiene la definición de tipo genérico `MyGenericStack<T>` (`MyGenericStack(Of T)` en Visual Basic, `generic<T> ref class MyGenericStack` en C++).</span><span class="sxs-lookup"><span data-stu-id="60a97-178">For example, suppose you create an assembly named MyGenerics.dll that contains the generic type definition `MyGenericStack<T>` (`MyGenericStack(Of T)` in Visual Basic, `generic<T> ref class MyGenericStack` in C++).</span></span> <span data-ttu-id="60a97-179">Si crea una instancia de `MyGenericStack<int>` (`MyGenericStack(Of Integer)` en Visual Basic) en otro ensamblado, el <xref:System.Type.Assembly%2A> propiedad para el tipo construido devuelve un <xref:System.Reflection.Assembly> objeto que representa MyGenerics.dll.</span><span class="sxs-lookup"><span data-stu-id="60a97-179">If you create an instance of `MyGenericStack<int>` (`MyGenericStack(Of Integer)` in Visual Basic) in another assembly, the <xref:System.Type.Assembly%2A> property for the constructed type returns an <xref:System.Reflection.Assembly> object that represents MyGenerics.dll.</span></span>  
  
 <span data-ttu-id="60a97-180">De forma similar, si el actual <xref:System.Type> objeto representa un parámetro genérico sin asignar `T`, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="60a97-180">Similarly, if the current <xref:System.Type> object represents an unassigned generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
 <span data-ttu-id="60a97-181">Si el <xref:System.Type.Assembly%2A?displayProperty=nameWithType> propiedad no está disponible en una implementación concreta. NET, como .NET Core o la plataforma Universal de Windows, use el <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> propiedad en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60a97-181">If the <xref:System.Type.Assembly%2A?displayProperty=nameWithType> property is not available on a particular .NET implementation, such as .NET Core or the Universal Windows Platform, use the <xref:System.Reflection.TypeInfo.Assembly?displayProperty=nameWithType> property instead.</span></span>      
  
 <span data-ttu-id="60a97-182">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-182">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-183">En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-183">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[Type_Assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[Type_Assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[Type_Assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AssemblyQualifiedName">
      <MemberSignature Language="C#" Value="public abstract string AssemblyQualifiedName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AssemblyQualifiedName" />
      <MemberSignature Language="DocId" Value="P:System.Type.AssemblyQualifiedName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property AssemblyQualifiedName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ AssemblyQualifiedName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.AssemblyQualifiedName : string" Usage="System.Type.AssemblyQualifiedName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.AssemblyQualifiedName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-184">Obtiene el nombre calificado con el ensamblado del tipo, que incluye el nombre del ensamblado a partir del cual se ha cargado el objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-184">Gets the assembly-qualified name of the type, which includes the name of the assembly from which this <see cref="T:System.Type" /> object was loaded.</span></span></summary>
        <value><span data-ttu-id="60a97-185">Nombre calificado con el ensamblado de <see cref="T:System.Type" />, que incluye el nombre del ensamblado a partir del cual se ha cargado <see cref="T:System.Type" />, o <see langword="null" /> si la instancia actual representa un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-185">The assembly-qualified name of the <see cref="T:System.Type" />, which includes the name of the assembly from which the <see cref="T:System.Type" /> was loaded, or <see langword="null" /> if the current instance represents a generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-186">El nombre completo de ensamblado de un tipo consta del nombre de tipo, incluido su espacio de nombres, seguido por una coma, seguida por el nombre para mostrar del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-186">The assembly-qualified name of a type consists of the type name, including its namespace, followed by a comma, followed by the display name of the assembly.</span></span> <span data-ttu-id="60a97-187">El nombre para mostrar de un ensamblado se obtiene mediante la <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-187">The display name of an assembly is obtained using the <xref:System.Reflection.Assembly.FullName%2A?displayProperty=nameWithType> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-188">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-188">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="60a97-189">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="60a97-189">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="60a97-190">Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-190">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="60a97-191">Vea <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-191">See <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60a97-192">El nombre sencillo de una clase anidada de la emisión de todos los compiladores compatibles con common language runtime y reflexión construye un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-192">All compilers that support the common language runtime emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
|<span data-ttu-id="60a97-193">Delimitador</span><span class="sxs-lookup"><span data-stu-id="60a97-193">Delimiter</span></span>|<span data-ttu-id="60a97-194">Significado</span><span class="sxs-lookup"><span data-stu-id="60a97-194">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a97-195">Barra diagonal inversa (\\)</span><span class="sxs-lookup"><span data-stu-id="60a97-195">Backslash (\\)</span></span>|<span data-ttu-id="60a97-196">Carácter de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-196">Escape character.</span></span>|  
|<span data-ttu-id="60a97-197">Coma (,)</span><span class="sxs-lookup"><span data-stu-id="60a97-197">Comma (,)</span></span>|<span data-ttu-id="60a97-198">Precede al nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-198">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="60a97-199">Signo más (+)</span><span class="sxs-lookup"><span data-stu-id="60a97-199">Plus sign (+)</span></span>|<span data-ttu-id="60a97-200">Precede a una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="60a97-200">Precedes a nested class.</span></span>|  
|<span data-ttu-id="60a97-201">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="60a97-201">Period (.)</span></span>|<span data-ttu-id="60a97-202">Denota los identificadores de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-202">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="60a97-203">Corchetes ([])</span><span class="sxs-lookup"><span data-stu-id="60a97-203">Brackets ([])</span></span>|<span data-ttu-id="60a97-204">Después de un nombre de tipo, indica una matriz de ese tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-204">After a type name, denotes an array of that type.</span></span><br /><br /> <span data-ttu-id="60a97-205">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-205">-or-</span></span><br /><br /> <span data-ttu-id="60a97-206">Para un tipo genérico, incluye la lista de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-206">For a generic type, encloses the generic type argument list.</span></span><br /><br /> <span data-ttu-id="60a97-207">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-207">-or-</span></span><br /><br /> <span data-ttu-id="60a97-208">Dentro de una lista de argumentos de tipo incluye un tipo calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-208">Within a type argument list, encloses an assembly-qualified type.</span></span>|  
  
 <span data-ttu-id="60a97-209">Por ejemplo, el nombre completo de ensamblado para una clase podría ser similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-209">For example, the assembly-qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089  
```  
  
 <span data-ttu-id="60a97-210">Si el espacio de nombres contiene un signo más, por ejemplo EspacioNombresPrincipal. Sub+EspacioNombres, entonces el signo más (+) debería ir precedido de un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="60a97-210">If the namespace contained a plus sign, for example TopNamespace.Sub+Namespace, then the plus sign (+) would be preceded by an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="60a97-211">La reflexión emitiría esta cadena como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-211">Reflection would emit this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass, MyAssembly, Version=1.3.0.0, Culture=neutral, PublicKeyToken=b17a5c561934e089   
```  
  
 <span data-ttu-id="60a97-212">Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".</span><span class="sxs-lookup"><span data-stu-id="60a97-212">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="60a97-213">Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-213">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="60a97-214">Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-214">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="60a97-215"><xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</span><span class="sxs-lookup"><span data-stu-id="60a97-215"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="60a97-216"><xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-216"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="60a97-217">Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-217">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="60a97-218">Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-218">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="60a97-219">Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-219">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="60a97-220">En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</span><span class="sxs-lookup"><span data-stu-id="60a97-220">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="60a97-221">Argumentos genéricos de tipos genéricos propios están calificados por el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-221">Generic arguments of generic types are themselves qualified by assembly name.</span></span> <span data-ttu-id="60a97-222">Por ejemplo, en el nombre de tipo calificado con el ensamblado `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic), `int` se expande para el nombre de tipo calificado con el ensamblado <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60a97-222">For example, in the assembly-qualified type name for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic), `int` is expanded to the assembly-qualified type name for <xref:System.Int32>.</span></span>  
  
 <span data-ttu-id="60a97-223">Si el actual <xref:System.Type> objeto representa un parámetro genérico, esta propiedad devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-223">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-224">En el ejemplo siguiente se muestra el nombre del ensamblado asociado a la clase y el nombre completo del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-224">The following example displays the assembly name associated with the class and the fully qualified name of the type.</span></span>  
  
 [!code-cpp[type_assembly#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Assembly/CPP/type_assembly.cpp#1)]
 [!code-csharp[type_assembly#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Assembly/CS/type_assembly.cs#1)]
 [!code-vb[type_assembly#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Assembly/VB/type_assembly.vb#1)]  
  
 <span data-ttu-id="60a97-225">En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-225">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetType" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-226">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-226">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Attributes">
      <MemberSignature Language="C#" Value="public System.Reflection.TypeAttributes Attributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.TypeAttributes Attributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.Attributes" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Attributes As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::TypeAttributes Attributes { System::Reflection::TypeAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.Attributes : System.Reflection.TypeAttributes" Usage="System.Type.Attributes" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Attributes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-227">Obtiene los atributos asociados al objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-227">Gets the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-228">Objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa el conjunto de atributos del objeto <see cref="T:System.Type" />, a menos que el objeto <see cref="T:System.Type" /> represente un parámetro de tipo genérico, en cuyo caso el valor no se especifica.</span><span class="sxs-lookup"><span data-stu-id="60a97-228">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />, unless the <see cref="T:System.Type" /> represents a generic type parameter, in which case the value is unspecified.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-229">Algunos miembros de la <xref:System.Reflection.TypeAttributes> enumeración son máscaras que representan un grupo de valores.</span><span class="sxs-lookup"><span data-stu-id="60a97-229">Some members of the <xref:System.Reflection.TypeAttributes> enumeration are masks that represent a group of values.</span></span> <span data-ttu-id="60a97-230">Cada grupo incluye a un miembro cuyo valor subyacente es cero.</span><span class="sxs-lookup"><span data-stu-id="60a97-230">Each group includes one member whose underlying value is zero.</span></span> <span data-ttu-id="60a97-231">Por ejemplo, el valor subyacente de la <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> miembro en el <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> grupo es cero, como es el <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> miembro en el <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> grupo.</span><span class="sxs-lookup"><span data-stu-id="60a97-231">For example, the underlying value of the <xref:System.Reflection.TypeAttributes.NotPublic?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> group is zero, as is the <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> member in the <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> group.</span></span> <span data-ttu-id="60a97-232">Por este motivo, debe usar la máscara antes de realizar pruebas para esos valores.</span><span class="sxs-lookup"><span data-stu-id="60a97-232">Because of this, you must use the mask before testing for those values.</span></span> <span data-ttu-id="60a97-233">En este ejemplo se ilustra.</span><span class="sxs-lookup"><span data-stu-id="60a97-233">The example provides an illustration.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="60a97-234">Para la mayoría de los casos, al igual que las propiedades <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, y <xref:System.Type.IsSpecialName%2A> son más fáciles de usar que los atributos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-234">For most purposes, properties like <xref:System.Type.IsClass%2A>,<xref:System.Type.IsAutoLayout%2A>, and <xref:System.Type.IsSpecialName%2A> are easier to use than type attributes.</span></span>  
  
 <span data-ttu-id="60a97-235">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve los atributos de la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-235">If the current <xref:System.Type> represents a constructed generic type, this property returns the attributes of the generic type definition.</span></span> <span data-ttu-id="60a97-236">Por ejemplo, los atributos devueltos para `MyGenericClass<int>` (`MyGenericClass(Of Integer)` en Visual Basic) son los atributos de `MyGenericClass<T>` (`MyGenericClass(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-236">For example, the attributes returned for `MyGenericClass<int>` (`MyGenericClass(Of Integer)` in Visual Basic) are the attributes of `MyGenericClass<T>` (`MyGenericClass(Of T)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-237">Si el actual <xref:System.Type> representa un parámetro de tipo genérico: es decir, si la <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` : la <xref:System.Reflection.TypeAttributes> valor devuelto por esta propiedad no se especifica.</span><span class="sxs-lookup"><span data-stu-id="60a97-237">If the current <xref:System.Type> represents a generic type parameter - that is, if the <xref:System.Type.IsGenericParameter%2A> property returns `true` - the <xref:System.Reflection.TypeAttributes> value returned by this property is unspecified.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-238">El siguiente utiliza ejemplo <xref:System.Type.Attributes%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-238">The following example usesthe <xref:System.Type.Attributes%2A> property.</span></span>  
  
 [!code-csharp[System.Type.Attributes#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.attributes/cs/attributes1.cs#1)]
 [!code-vb[System.Type.Attributes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.attributes/vb/attributes1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetAttributeFlagsImpl" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="BaseType">
      <MemberSignature Language="C#" Value="public abstract Type BaseType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type BaseType" />
      <MemberSignature Language="DocId" Value="P:System.Type.BaseType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property BaseType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ BaseType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.BaseType : Type" Usage="System.Type.BaseType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.BaseType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-239">Obtiene el tipo del que hereda directamente el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-239">Gets the type from which the current <see cref="T:System.Type" /> directly inherits.</span></span></summary>
        <value><span data-ttu-id="60a97-240"><see cref="T:System.Type" /> desde el cual el objeto <see cref="T:System.Type" /> actual hereda directamente, o <see langword="null" /> si el objeto <see langword="Type" /> actual representa la clase <see cref="T:System.Object" /> o una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-240">The <see cref="T:System.Type" /> from which the current <see cref="T:System.Type" /> directly inherits, or <see langword="null" /> if the current <see langword="Type" /> represents the <see cref="T:System.Object" /> class or an interface.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-241">El tipo base es el tipo del que hereda directamente el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-241">The base type is the type from which the current type directly inherits.</span></span> <span data-ttu-id="60a97-242"><xref:System.Object> es el único tipo que no tiene un tipo base, por lo tanto, `null` se devuelve como el tipo base del <xref:System.Object>.</span><span class="sxs-lookup"><span data-stu-id="60a97-242"><xref:System.Object> is the only type that does not have a base type, therefore `null` is returned as the base type of <xref:System.Object>.</span></span>  
  
 <span data-ttu-id="60a97-243">Las interfaces heredar de cero o más interfaces base; por lo tanto, esta propiedad devuelve `null` si la `Type` objeto representa una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-243">Interfaces inherit from zero or more base interfaces; therefore, this property returns `null` if the `Type` object represents an interface.</span></span> <span data-ttu-id="60a97-244">Las interfaces base se pueden determinar con <xref:System.Type.GetInterfaces%2A> o <xref:System.Type.FindInterfaces%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-244">The base interfaces can be determined with <xref:System.Type.GetInterfaces%2A> or <xref:System.Type.FindInterfaces%2A>.</span></span>  
  
 <span data-ttu-id="60a97-245">Si el actual <xref:System.Type> representa un tipo genérico construido, el tipo base refleja los argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-245">If the current <xref:System.Type> represents a constructed generic type, the base type reflects the generic arguments.</span></span> <span data-ttu-id="60a97-246">Por ejemplo, consideremos las siguientes declaraciones:</span><span class="sxs-lookup"><span data-stu-id="60a97-246">For example, consider the following declarations:</span></span>  
  
 [!code-cpp[System.Type.BaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.basetype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.BaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/remarks.cs#1)]
 [!code-vb[System.Type.BaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="60a97-247">Para el tipo construido `C<int>` (`C(Of Integer)` en Visual Basic), el <xref:System.Type.BaseType%2A> propiedad devuelve `B<int>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-247">For the constructed type `C<int>` (`C(Of Integer)` in Visual Basic), the <xref:System.Type.BaseType%2A> property returns `B<int>`.</span></span>  
  
 <span data-ttu-id="60a97-248">Si el actual <xref:System.Type> representa un parámetro de tipo de una definición de tipo genérico, <xref:System.Type.BaseType%2A> devuelve la restricción de clase, es decir, la clase debe heredar el parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-248">If the current <xref:System.Type> represents a type parameter of a generic type definition, <xref:System.Type.BaseType%2A> returns the class constraint, that is, the class the type parameter must inherit.</span></span> <span data-ttu-id="60a97-249">Si no hay ninguna restricción de clase, <xref:System.Type.BaseType%2A> devuelve <xref:System.Object?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-249">If there is no class constraint, <xref:System.Type.BaseType%2A> returns <xref:System.Object?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="60a97-250">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-250">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-251">El ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.BaseType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-251">The following example demonstrates using the <xref:System.Type.BaseType%2A> property.</span></span>  
  
 [!code-cpp[TestBaseType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestBaseType/CPP/testbasetype.cpp#1)]
 [!code-csharp[TestBaseType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestBaseType/CS/testbasetype.cs#1)]
 [!code-vb[TestBaseType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestBaseType/VB/testbasetype.vb#1)]  
  
 <span data-ttu-id="60a97-252">El ejemplo siguiente usa la recursividad se muestra la jerarquía de herencia completa de cada clase que se encuentra en un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-252">The following example uses recursion to list the complete inheritance hierarchy of each class found in an assembly.</span></span> <span data-ttu-id="60a97-253">El ejemplo define una clase denominada `C` que se deriva una clase denominada `B`, que, a su vez, deriva una clase denominada `A`.</span><span class="sxs-lookup"><span data-stu-id="60a97-253">The example defines a class named `C` that derives from a class named `B`, which, in turn, derives from a class named `A`.</span></span>  
  
 [!code-csharp[System.Type.BaseType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.basetype/cs/basetype3.cs#2)]
 [!code-vb[System.Type.BaseType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.basetype/vb/basetype3.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Object" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
        <altmember cref="P:System.Type.UnderlyingSystemType" />
        <altmember cref="M:System.Type.IsSubclassOf(System.Type)" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-254">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-254">Reflection and Generic Types</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ContainsGenericParameters">
      <MemberSignature Language="C#" Value="public virtual bool ContainsGenericParameters { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ContainsGenericParameters" />
      <MemberSignature Language="DocId" Value="P:System.Type.ContainsGenericParameters" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property ContainsGenericParameters As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool ContainsGenericParameters { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.ContainsGenericParameters : bool" Usage="System.Type.ContainsGenericParameters" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-255">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual tiene parámetros de tipo que no han sido reemplazados por tipos específicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-255">Gets a value indicating whether the current <see cref="T:System.Type" /> object has type parameters that have not been replaced by specific types.</span></span></summary>
        <value><span data-ttu-id="60a97-256"><see langword="true" /> si el objeto <see cref="T:System.Type" /> es un parámetro de tipo genérico o tiene parámetros de tipo para los que no se han proporcionado tipos específicos; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-256"><see langword="true" /> if the <see cref="T:System.Type" /> object is itself a generic type parameter or has type parameters for which specific types have not been supplied; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-257">Para crear una instancia de un tipo, no debe haber ninguna definición de tipo genérico o tipos construidos abiertos en los argumentos de tipo del tipo en Sí, en los tipos genéricos envolventes, o en todos los elementos del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-257">In order to create an instance of a type, there must be no generic type definitions or open constructed types in the type arguments of the type itself, in any enclosing generic types, or in any elements of the type.</span></span> <span data-ttu-id="60a97-258">Otra forma de expresarlo es que, cuando examina de forma recursiva, el tipo no debe contener ningún parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-258">Another way of saying this is that when examined recursively, the type must contain no generic type parameters.</span></span>  
  
 <span data-ttu-id="60a97-259">Puesto que los tipos pueden ser arbitrariamente complejos, es difícil tomar esta decisión.</span><span class="sxs-lookup"><span data-stu-id="60a97-259">Since types can be arbitrarily complex, making this determination is difficult.</span></span> <span data-ttu-id="60a97-260">Por comodidad y para reducir la posibilidad de error, el <xref:System.Type.ContainsGenericParameters%2A> propiedad proporciona una manera estándar para distinguir entre tipos construidos cerrados, que se pueden crear instancias, y construido abierto tipos, que no se pueden.</span><span class="sxs-lookup"><span data-stu-id="60a97-260">For convenience and to reduce the chance of error, the <xref:System.Type.ContainsGenericParameters%2A> property provides a standard way to distinguish between closed constructed types, which can be instantiated, and open constructed types, which cannot.</span></span> <span data-ttu-id="60a97-261">Si el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`, no pueden crearse instancias del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-261">If the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`, the type cannot be instantiated.</span></span>  
  
 <span data-ttu-id="60a97-262">El <xref:System.Type.ContainsGenericParameters%2A> propiedad busca los parámetros de tipo de forma recursiva.</span><span class="sxs-lookup"><span data-stu-id="60a97-262">The <xref:System.Type.ContainsGenericParameters%2A> property searches recursively for type parameters.</span></span> <span data-ttu-id="60a97-263">Por ejemplo, devuelve `true` para una matriz cuyos elementos son de tipo `A<T>` (`A(Of T)` en Visual Basic), aunque la matriz no es genérico en sí mismo.</span><span class="sxs-lookup"><span data-stu-id="60a97-263">For example, it returns `true` for an array whose elements are type `A<T>` (`A(Of T)` in Visual Basic), even though the array is not itself generic.</span></span> <span data-ttu-id="60a97-264">Compare esto con el comportamiento de la <xref:System.Type.IsGenericType%2A> propiedad, que devuelve `false` para las matrices.</span><span class="sxs-lookup"><span data-stu-id="60a97-264">Contrast this with the behavior of the <xref:System.Type.IsGenericType%2A> property, which returns `false` for arrays.</span></span>  
  
 <span data-ttu-id="60a97-265">Para un conjunto de clases de ejemplo y una tabla que muestra los valores de la <xref:System.Type.ContainsGenericParameters%2A> propiedad, vea <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-265">For a set of example classes and a table showing the values of the <xref:System.Type.ContainsGenericParameters%2A> property, see <xref:System.Type.IsGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-266">El ejemplo siguiente define una clase genérica con dos parámetros de tipo y, a continuación, define una segunda clase genérica que se deriva de la primera clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-266">The following example defines a generic class with two type parameters and then defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="60a97-267">Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <xref:System.Int32> y el segundo es un parámetro de tipo del tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="60a97-267">The derived class's base class has two type arguments: the first is <xref:System.Int32> and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="60a97-268">En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <xref:System.Type.GenericParameterPosition%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-268">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-269">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-269">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-270">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-270">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringMethod">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MethodBase DeclaringMethod { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.MethodBase DeclaringMethod" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringMethod" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property DeclaringMethod As MethodBase" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MethodBase ^ DeclaringMethod { System::Reflection::MethodBase ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringMethod : System.Reflection.MethodBase" Usage="System.Type.DeclaringMethod" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodBase</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-271">Obtiene un objeto <see cref="T:System.Reflection.MethodBase" /> que representa el método declarativo si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-271">Gets a <see cref="T:System.Reflection.MethodBase" /> that represents the declaring method, if the current <see cref="T:System.Type" /> represents a type parameter of a generic method.</span></span></summary>
        <value><span data-ttu-id="60a97-272">Si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo de un método genérico, <see cref="T:System.Reflection.MethodBase" /> que representa el método de declaración; de lo contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-272">If the current <see cref="T:System.Type" /> represents a type parameter of a generic method, a <see cref="T:System.Reflection.MethodBase" /> that represents declaring method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-273">El método declarativo es una definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-273">The declaring method is a generic method definition.</span></span> <span data-ttu-id="60a97-274">Es decir, si <xref:System.Type.DeclaringMethod%2A> no devuelve `null`, a continuación, `DeclaringMethod.IsGenericMethodDefinition` devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-274">That is, if <xref:System.Type.DeclaringMethod%2A> does not return `null`, then `DeclaringMethod.IsGenericMethodDefinition` returns `true`.</span></span>  
  
 <span data-ttu-id="60a97-275">El <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo genérico o una definición de método genérico en el que se definió originalmente el parámetro de tipo genérico:</span><span class="sxs-lookup"><span data-stu-id="60a97-275">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition in which the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="60a97-276">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-276">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="60a97-277">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.</span><span class="sxs-lookup"><span data-stu-id="60a97-277">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="60a97-278">Obteniendo el <xref:System.Type.DeclaringMethod%2A> propiedad en un tipo cuyo <xref:System.Type.IsGenericParameter%2A> propiedad es `false` produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="60a97-278">Getting the <xref:System.Type.DeclaringMethod%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
 <span data-ttu-id="60a97-279">El <xref:System.Reflection.MethodBase> devuelta por la <xref:System.Type.DeclaringMethod%2A> propiedad sea un <xref:System.Reflection.MethodInfo> en el caso de un método genérico, o un <xref:System.Reflection.ConstructorInfo> en el caso de un constructor genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-279">The <xref:System.Reflection.MethodBase> that is returned by the <xref:System.Type.DeclaringMethod%2A> property is either a <xref:System.Reflection.MethodInfo> in the case of a generic method, or a <xref:System.Reflection.ConstructorInfo> in the case of a generic constructor.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-280">En la versión 2.0 de .NET Framework, no se admiten constructores genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-280">In the .NET Framework version 2.0, generic constructors are not supported.</span></span>  
  
 <span data-ttu-id="60a97-281">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-281">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-282">El ejemplo de código siguiente define una clase que tiene un método genérico, asigna un argumento de tipo para el método e invoca el método genérico construido resultante.</span><span class="sxs-lookup"><span data-stu-id="60a97-282">The following code example defines a class that has a generic method, assigns a type argument to the method, and invokes the resulting constructed generic method.</span></span> <span data-ttu-id="60a97-283">También muestra información acerca de la definición de método genérico y el método construido.</span><span class="sxs-lookup"><span data-stu-id="60a97-283">It also displays information about the generic method definition and the constructed method.</span></span> <span data-ttu-id="60a97-284">Al mostrar información acerca de los parámetros de tipo de la definición de método genérico, en el `DisplayGenericMethodInfo` método, el código de ejemplo muestra el valor de la <xref:System.Type.DeclaringMethod%2A> propiedad para el parámetro de tipo genérico del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-284">When displaying information about the type parameters of the generic method definition, in the `DisplayGenericMethodInfo` method, the example code shows the value of the <xref:System.Type.DeclaringMethod%2A> property for the method's generic type parameter.</span></span>  
  
 [!code-cpp[MethodInfo.Generics#1](~/samples/snippets/cpp/VS_Snippets_CLR/MethodInfo.Generics/cpp/source.cpp#1)]
 [!code-csharp[MethodInfo.Generics#1](~/samples/snippets/csharp/VS_Snippets_CLR/MethodInfo.Generics/CS/source.cs#1)]
 [!code-vb[MethodInfo.Generics#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/MethodInfo.Generics/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-285">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-285">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-286">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-286">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="DeclaringType">
      <MemberSignature Language="C#" Value="public override Type DeclaringType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type DeclaringType" />
      <MemberSignature Language="DocId" Value="P:System.Type.DeclaringType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DeclaringType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ DeclaringType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DeclaringType : Type" Usage="System.Type.DeclaringType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.DeclaringType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-287">Obtiene el tipo que declara el tipo anidado actual o el parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-287">Gets the type that declares the current nested type or generic type parameter.</span></span></summary>
        <value><span data-ttu-id="60a97-288">Un objeto <see cref="T:System.Type" /> que representa el tipo envolvente, si el tipo actual es un tipo anidado; o la definición de tipo genérico, si el tipo actual es un parámetro de tipo de un tipo genérico; o el tipo que declara el método genérico, si el tipo actual es un parámetro de tipo de un método genérico; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-288">A <see cref="T:System.Type" /> object representing the enclosing type, if the current type is a nested type; or the generic type definition, if the current type is a type parameter of a generic type; or the type that declares the generic method, if the current type is a type parameter of a generic method; otherwise, <see langword="null" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-289">Si el actual <xref:System.Type> objeto representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-289">If the current <xref:System.Type> object represents a type parameter of a generic type, this property returns the generic type definition.</span></span>  
  
 <span data-ttu-id="60a97-290">Si el actual <xref:System.Type> objeto representa un parámetro de tipo de un método genérico, esta propiedad devuelve el tipo que contiene la definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-290">If the current <xref:System.Type> object represents a type parameter of a generic method, this property returns the type that contains the generic method definition.</span></span> <span data-ttu-id="60a97-291">Si el tipo es genérico, se devuelve la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-291">If the type is generic, the generic type definition is returned.</span></span> <span data-ttu-id="60a97-292">Es decir, el código siguiente devuelve la definición de tipo genérico de la <xref:System.Collections.Generic.List%601> clase genérica, que contiene el <xref:System.Collections.Generic.List%601.ConvertAll%2A> método genérico:</span><span class="sxs-lookup"><span data-stu-id="60a97-292">That is, the following code returns the generic type definition of the <xref:System.Collections.Generic.List%601> generic class, which contains the <xref:System.Collections.Generic.List%601.ConvertAll%2A> generic method:</span></span>  
  
 [!code-cpp[System.Type.DeclaringType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.declaringtype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.DeclaringType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.declaringtype/cs/remarks.cs#1)]
 [!code-vb[System.Type.DeclaringType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.declaringtype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="60a97-293">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, la <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo genérico o la definición de método genérico donde el parámetro de tipo genérico se definió originalmente:</span><span class="sxs-lookup"><span data-stu-id="60a97-293">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, the <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type definition or generic method definition where the generic type parameter was originally defined:</span></span>  
  
-   <span data-ttu-id="60a97-294">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-294">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="60a97-295">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.</span><span class="sxs-lookup"><span data-stu-id="60a97-295">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
-   <span data-ttu-id="60a97-296">Obteniendo el <xref:System.Type.DeclaringType%2A> propiedad en un tipo cuyo <xref:System.Type.IsGenericParameter%2A> propiedad es `false` produce una <xref:System.InvalidOperationException>.</span><span class="sxs-lookup"><span data-stu-id="60a97-296">Getting the <xref:System.Type.DeclaringType%2A> property on a type whose <xref:System.Type.IsGenericParameter%2A> property is `false` throws an <xref:System.InvalidOperationException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-297">En este ejemplo se muestra el tipo declarativo de un método en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-297">This example displays the declaring type of a method in a derived class.</span></span>  
  
 [!code-cpp[Classic Type.DeclaringType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.DeclaringType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.DeclaringType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.DeclaringType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.ReflectedType" />
      </Docs>
    </Member>
    <Member MemberName="DefaultBinder">
      <MemberSignature Language="C#" Value="public static System.Reflection.Binder DefaultBinder { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Reflection.Binder DefaultBinder" />
      <MemberSignature Language="DocId" Value="P:System.Type.DefaultBinder" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property DefaultBinder As Binder" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Reflection::Binder ^ DefaultBinder { System::Reflection::Binder ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultBinder : System.Reflection.Binder" Usage="System.Type.DefaultBinder" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.Binder</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-298">Obtiene una referencia al enlazador predeterminado, que implementa varias reglas internas para seleccionar los miembros adecuados a los que llamará el método <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-298">Gets a reference to the default binder, which implements internal rules for selecting the appropriate members to be called by <see cref="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />.</span></span></summary>
        <value><span data-ttu-id="60a97-299">Referencia al enlazador predeterminado que el sistema usa.</span><span class="sxs-lookup"><span data-stu-id="60a97-299">A reference to the default binder used by the system.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-300">El enlazador predeterminado suministrado con common language runtime es aplicable en todas las circunstancias más especializadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-300">The default binder provided with the common language runtime is applicable in all but the most specialized circumstances.</span></span> <span data-ttu-id="60a97-301">Si necesita un cuaderno que sigue las reglas que difieren de las del enlazador predeterminado proporcionado, definen un tipo derivado de la <xref:System.Reflection.Binder> clase y pasar una instancia de ese tipo mediante el `binder` parámetro de uno de los <xref:System.Type.InvokeMember%2A> sobrecargas.</span><span class="sxs-lookup"><span data-stu-id="60a97-301">If you need a binder that follows rules that differ from those of the supplied default binder, define a type derived from the <xref:System.Reflection.Binder> class and pass an instance of that type using the `binder` parameter of one of the <xref:System.Type.InvokeMember%2A> overloads.</span></span>  
  
 <span data-ttu-id="60a97-302">Las reglas de accesibilidad de common type system de los modelos de reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-302">Reflection models the accessibility rules of the common type system.</span></span> <span data-ttu-id="60a97-303">Por ejemplo, si el llamador está en el mismo ensamblado, el llamador no necesita permisos especiales para los miembros internos.</span><span class="sxs-lookup"><span data-stu-id="60a97-303">For example, if the caller is in the same assembly, the caller does not need special permissions for internal members.</span></span> <span data-ttu-id="60a97-304">En caso contrario, el llamador necesita <xref:System.Security.Permissions.ReflectionPermission>.</span><span class="sxs-lookup"><span data-stu-id="60a97-304">Otherwise, the caller needs <xref:System.Security.Permissions.ReflectionPermission>.</span></span> <span data-ttu-id="60a97-305">Esto es coherente con la búsqueda de miembros que están protegidas, privadas y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-305">This is consistent with lookup of members that are protected, private, and so on.</span></span>  
  
 <span data-ttu-id="60a97-306">El principio general es que <xref:System.Reflection.Binder.ChangeType%2A> debe realizar sólo conversiones de ampliación, que nunca se pierden datos.</span><span class="sxs-lookup"><span data-stu-id="60a97-306">The general principle is that <xref:System.Reflection.Binder.ChangeType%2A> should perform only widening conversions, which never lose data.</span></span> <span data-ttu-id="60a97-307">Un ejemplo de una conversión de ampliación es convertir un valor que es un entero de 32 bits con signo en un valor que es un entero con signo de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="60a97-307">An example of a widening conversion is converting a value that is a 32-bit signed integer to a value that is a 64-bit signed integer.</span></span> <span data-ttu-id="60a97-308">Esto se diferencia de una conversión de restricción, que se puede perder datos.</span><span class="sxs-lookup"><span data-stu-id="60a97-308">This is distinguished from a narrowing conversion, which may lose data.</span></span> <span data-ttu-id="60a97-309">Un ejemplo de una conversión de restricción es convertir a un entero de 64 bits con signo en un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="60a97-309">An example of a narrowing conversion is converting a 64-bit signed integer to a 32-bit signed integer.</span></span>  
  
 <span data-ttu-id="60a97-310">En la tabla siguiente se enumera las conversiones compatibles con el enlazador predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-310">The following table lists the conversions supported by the default binder.</span></span>  
  
|<span data-ttu-id="60a97-311">Tipo de origen</span><span class="sxs-lookup"><span data-stu-id="60a97-311">Source Type</span></span>|<span data-ttu-id="60a97-312">Tipo de destino</span><span class="sxs-lookup"><span data-stu-id="60a97-312">Target Type</span></span>|  
|-----------------|-----------------|  
|<span data-ttu-id="60a97-313">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-313">Any type</span></span>|<span data-ttu-id="60a97-314">Su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60a97-314">Its base type.</span></span>|  
|<span data-ttu-id="60a97-315">Cualquier tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-315">Any type</span></span>|<span data-ttu-id="60a97-316">La interfaz que implementa.</span><span class="sxs-lookup"><span data-stu-id="60a97-316">The interface it implements.</span></span>|  
|<span data-ttu-id="60a97-317">Char</span><span class="sxs-lookup"><span data-stu-id="60a97-317">Char</span></span>|<span data-ttu-id="60a97-318">Unt16, Int32, UInt32, UInt64, Int64, Single o Double</span><span class="sxs-lookup"><span data-stu-id="60a97-318">Unt16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-319">Byte</span><span class="sxs-lookup"><span data-stu-id="60a97-319">Byte</span></span>|<span data-ttu-id="60a97-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single o Double</span><span class="sxs-lookup"><span data-stu-id="60a97-320">Char, Unt16, Int16, UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-321">SByte</span><span class="sxs-lookup"><span data-stu-id="60a97-321">SByte</span></span>|<span data-ttu-id="60a97-322">Int16, Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-322">Int16, Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-323">UInt16</span><span class="sxs-lookup"><span data-stu-id="60a97-323">UInt16</span></span>|<span data-ttu-id="60a97-324">UInt32, Int32, UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-324">UInt32, Int32, UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-325">Int16</span><span class="sxs-lookup"><span data-stu-id="60a97-325">Int16</span></span>|<span data-ttu-id="60a97-326">Int32, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-326">Int32, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-327">UInt32</span><span class="sxs-lookup"><span data-stu-id="60a97-327">UInt32</span></span>|<span data-ttu-id="60a97-328">UInt64, Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-328">UInt64, Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-329">Int32</span><span class="sxs-lookup"><span data-stu-id="60a97-329">Int32</span></span>|<span data-ttu-id="60a97-330">Int64, Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-330">Int64, Single, Double</span></span>|  
|<span data-ttu-id="60a97-331">UInt64</span><span class="sxs-lookup"><span data-stu-id="60a97-331">UInt64</span></span>|<span data-ttu-id="60a97-332">Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-332">Single, Double</span></span>|  
|<span data-ttu-id="60a97-333">Int64</span><span class="sxs-lookup"><span data-stu-id="60a97-333">Int64</span></span>|<span data-ttu-id="60a97-334">Single, Double</span><span class="sxs-lookup"><span data-stu-id="60a97-334">Single, Double</span></span>|  
|<span data-ttu-id="60a97-335">Single</span><span class="sxs-lookup"><span data-stu-id="60a97-335">Single</span></span>|<span data-ttu-id="60a97-336">Doble</span><span class="sxs-lookup"><span data-stu-id="60a97-336">Double</span></span>|  
|<span data-ttu-id="60a97-337">Sin referencia</span><span class="sxs-lookup"><span data-stu-id="60a97-337">Non-reference</span></span>|<span data-ttu-id="60a97-338">Por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-338">By-reference.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="60a97-339">En el ejemplo siguiente se obtiene el enlazador predeterminado desde el `DefaultBinder` propiedad y se invoca a un miembro de MyClass pasando el `DefaultBinder` valor como un parámetro a <xref:System.Type.InvokeMember%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-339">The following example gets the default binder from the `DefaultBinder` property, and invokes a member of MyClass by passing the `DefaultBinder` value as a parameter to <xref:System.Type.InvokeMember%2A>.</span></span>  
  
 [!code-cpp[Type_DefaultBinder#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_DefaultBinder/CPP/type_defaultbinder.cpp#1)]
 [!code-csharp[Type_DefaultBinder#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_DefaultBinder/CS/type_defaultbinder.cs#1)]
 [!code-vb[Type_DefaultBinder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_DefaultBinder/VB/type_defaultbinder.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Binder" />
      </Docs>
    </Member>
    <Member MemberName="Delimiter">
      <MemberSignature Language="C#" Value="public static readonly char Delimiter;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly char Delimiter" />
      <MemberSignature Language="DocId" Value="F:System.Type.Delimiter" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Delimiter As Char " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly char Delimiter;" />
      <MemberSignature Language="F#" Value=" staticval mutable Delimiter : char" Usage="System.Type.Delimiter" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Char</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-340">Separa los nombres en el espacio de nombres de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-340">Separates names in the namespace of the <see cref="T:System.Type" />.</span></span> <span data-ttu-id="60a97-341">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-341">This field is read-only.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EmptyTypes">
      <MemberSignature Language="C#" Value="public static readonly Type[] EmptyTypes;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Type[] EmptyTypes" />
      <MemberSignature Language="DocId" Value="F:System.Type.EmptyTypes" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly EmptyTypes As Type() " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly cli::array &lt;Type ^&gt; ^ EmptyTypes;" />
      <MemberSignature Language="F#" Value=" staticval mutable EmptyTypes : Type[]" Usage="System.Type.EmptyTypes" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-342">Representa una matriz vacía de tipo <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-342">Represents an empty array of type <see cref="T:System.Type" />.</span></span> <span data-ttu-id="60a97-343">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-343">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60a97-344">El siguiente ejemplo de código muestra la `EmptyTypes` campo utilizado en uno de los `GetConstructor` métodos para obtener un constructor que no toma ningún parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-344">The following code example shows the `EmptyTypes` field used in one of the `GetConstructor` methods to get a constructor that takes no parameters.</span></span>  
  
 [!code-cpp[Classic Type.EmptyTypes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.EmptyTypes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/CS/source.cs#1)]
 [!code-vb[Classic Type.EmptyTypes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.EmptyTypes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-345">Determina si el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Object" /> o <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-345">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Object" /> or <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="60a97-346">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-346">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span> <span data-ttu-id="60a97-347">Para que la comparación se realice correctamente, <paramref name="o" /> debe poder convertirse en un objeto de tipo <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-347">For the comparison to succeed, <paramref name="o" /> must be able to be cast or converted to an object of type   <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="60a97-348">Determina si el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual es el mismo que el tipo del sistema subyacente del objeto <see cref="T:System.Object" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-348">Determines if the underlying system type of the current <see cref="T:System.Type" /> object is the same as the underlying system type of the specified <see cref="T:System.Object" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-349">Es <see langword="true" /> si el tipo del sistema subyacente de <paramref name="o" /> coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-349"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="60a97-350">Este método también devuelve <see langword="false" /> si:</span><span class="sxs-lookup"><span data-stu-id="60a97-350">This method also returns <see langword="false" /> if: .</span></span>  
  <span data-ttu-id="60a97-351">El valor de 
-   <paramref name="o" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-351">
-   <paramref name="o" /> is <see langword="null" />.</span></span>  
  <span data-ttu-id="60a97-352">
-   <paramref name="o" /> no se puede convertir en un objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-352">
-   <paramref name="o" /> cannot be cast or converted to a <see cref="T:System.Type" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-353">Este método invalida <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-353">This method overrides <xref:System.Object.Equals%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60a97-354">Proyecta `o` a un objeto de tipo <xref:System.Type> y llama a la <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-354">It casts `o` to an object of type <xref:System.Type> and calls the <xref:System.Type.Equals%28System.Type%29?displayProperty=nameWithType> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-355">En el ejemplo siguiente se usa <xref:System.Type.Equals%28System.Object%29> para comparar varios <xref:System.Type> instancias con distintos de un objeto <xref:System.Object> instancias.</span><span class="sxs-lookup"><span data-stu-id="60a97-355">The following example uses <xref:System.Type.Equals%28System.Object%29> to compare various <xref:System.Type> object instances with various <xref:System.Object> instances.</span></span>  
  
 [!code-csharp[System.Type.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.Equals/cs/EqualsEx1.cs#1)]
 [!code-vb[System.Type.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.Equals/vb/EqualsEx1.vb#1)]  
  
 <span data-ttu-id="60a97-356">Dos cosas son especialmente que vale la pena tener en cuenta sobre el ejemplo:</span><span class="sxs-lookup"><span data-stu-id="60a97-356">Two things are particularly worth noting about the example:</span></span>  
  
-   <span data-ttu-id="60a97-357">La comparación de un <xref:System.Type> objeto que representa un entero con un <xref:System.Reflection.TypeInfo> objeto que representa un valor devuelto entero `true` porque <xref:System.Reflection.TypeInfo> se deriva de <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-357">The comparison of a <xref:System.Type> object that represents an integer with a <xref:System.Reflection.TypeInfo> object that represents an integer return `true` because <xref:System.Reflection.TypeInfo> is derived from <xref:System.Type>.</span></span>  
  
-   <span data-ttu-id="60a97-358">La comparación de un <xref:System.Type> objeto que representa un <xref:System.Collections.Generic.IList%601> objeto (un tipo genérico abierto) con un `List(Of String)` devuelve el objeto (un tipo genérico cerrado) `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-358">The comparison of a  <xref:System.Type> object that represents a <xref:System.Collections.Generic.IList%601> object (an open generic type) with a `List(Of String)` object (a closed generic type) returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public virtual bool Equals (Type o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(class System.Type o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.Equals(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Equals (o As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(Type ^ o);" />
      <MemberSignature Language="F#" Value="override this.Equals : Type -&gt; bool" Usage="type.Equals o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Equals(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="60a97-359">Objeto cuyo tipo de sistema subyacente se va a comparar con el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-359">The object whose underlying system type is to be compared with the underlying system type of the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="60a97-360">Determina si el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> actual es igual que el tipo de sistema subyacente del objeto <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-360">Determines if the underlying system type of the current <see cref="T:System.Type" /> is the same as the underlying system type of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-361">Es <see langword="true" /> si el tipo del sistema subyacente de <paramref name="o" /> coincide con el tipo del sistema subyacente del objeto <see cref="T:System.Type" /> actual; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-361"><see langword="true" /> if the underlying system type of <paramref name="o" /> is the same as the underlying system type of the current <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60a97-362">En el ejemplo siguiente se usa `Equals` para comparar dos tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-362">The following example uses `Equals` to compare two types.</span></span>  
  
 [!code-csharp[Classic Type.Equals1 Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/CS/source.cs#1)]
 [!code-vb[Classic Type.Equals1 Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Equals1 Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.UnderlyingSystemType" />
      </Docs>
    </Member>
    <Member MemberName="FilterAttribute">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterAttribute;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterAttribute" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterAttribute As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterAttribute;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterAttribute : System.Reflection.MemberFilter" Usage="System.Type.FilterAttribute" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-363">Representa el filtro de miembros que se usa para los atributos.</span><span class="sxs-lookup"><span data-stu-id="60a97-363">Represents the member filter used on attributes.</span></span> <span data-ttu-id="60a97-364">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-364">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-365">Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-365">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="60a97-366">El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-366">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="60a97-367">El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-367">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="60a97-368">El `Object` puede tener asignado el valor de uno de los campos en las clases <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, o <xref:System.Reflection.MethodImplAttributes>.</span><span class="sxs-lookup"><span data-stu-id="60a97-368">The `Object` may be assigned the value of any one of the fields on the classes <xref:System.Reflection.FieldAttributes>, <xref:System.Reflection.MethodAttributes>, or <xref:System.Reflection.MethodImplAttributes>.</span></span>  
  
 <span data-ttu-id="60a97-369">Por ejemplo, el `Object` se puede asignar el valor de un campo de `FieldAttributes` como Public.</span><span class="sxs-lookup"><span data-stu-id="60a97-369">For example, the `Object` can be assigned the value of a field from `FieldAttributes` such as Public.</span></span> <span data-ttu-id="60a97-370">En ese caso, cuando el `FilterAttribute` delegado se invoca, devolverá `true` sólo si el método representado por la `MemberInfo` objeto está decorado con el atributo de campo público en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-370">In that case, when the `FilterAttribute` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object is decorated with the public field attribute in metadata.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-371">En el ejemplo siguiente se obtiene el `FilterAttribute` delegado, lo pasa como un parámetro a la <xref:System.Type.FindMembers%2A> método y muestra los miembros especificados y sus atributos.</span><span class="sxs-lookup"><span data-stu-id="60a97-371">The following example gets the `FilterAttribute` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the specified members and their attributes.</span></span>  
  
 [!code-cpp[Type_FilterAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterAttribute/CPP/type_filterattribute.cpp#1)]
 [!code-csharp[Type_FilterAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterAttribute/CS/type_filterattribute.cs#1)]
 [!code-vb[Type_FilterAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterAttribute/VB/type_filterattribute.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterName">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterName;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterName" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterName" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterName As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterName;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterName : System.Reflection.MemberFilter" Usage="System.Type.FilterName" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-372">Representa el filtro de miembros que distingue mayúsculas de minúsculas y que se aplica a los nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-372">Represents the case-sensitive member filter used on names.</span></span> <span data-ttu-id="60a97-373">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-373">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-374">Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-374">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="60a97-375">El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-375">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="60a97-376">El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-376">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="60a97-377">El `Object` se asigna un valor de cadena, que puede incluir un carácter "\*" carácter comodín.</span><span class="sxs-lookup"><span data-stu-id="60a97-377">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="60a97-378">Coincidencia de cadenas de final de carácter comodín solo se admite.</span><span class="sxs-lookup"><span data-stu-id="60a97-378">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="60a97-379">Por ejemplo, el `Object` puede tener asignado el valor "Byte \*".</span><span class="sxs-lookup"><span data-stu-id="60a97-379">For example, the `Object` may be assigned the value "Byte\*".</span></span> <span data-ttu-id="60a97-380">En ese caso, cuando el `FilterName` delegado se invoca, devolverá `true` sólo si el método representado por la `MemberInfo` objeto tiene un nombre que comienza con "Bytes".</span><span class="sxs-lookup"><span data-stu-id="60a97-380">In that case, when the `FilterName` delegate is invoked, it will return `true` only if the method represented by the `MemberInfo` object has a name that begins with "Byte".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-381">El ejemplo de código siguiente obtiene los métodos asociados con el definido por el usuario `Application` tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-381">The following code example gets the methods associated with the user-defined `Application` type.</span></span>  
  
 [!code-cpp[Classic Type.FilterName Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.FilterName Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.FilterName Example/CS/source.cs#1)]
 [!code-vb[Classic Type.FilterName Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.FilterName Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FilterNameIgnoreCase">
      <MemberSignature Language="C#" Value="public static readonly System.Reflection.MemberFilter FilterNameIgnoreCase;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Reflection.MemberFilter FilterNameIgnoreCase" />
      <MemberSignature Language="DocId" Value="F:System.Type.FilterNameIgnoreCase" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly FilterNameIgnoreCase As MemberFilter " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Reflection::MemberFilter ^ FilterNameIgnoreCase;" />
      <MemberSignature Language="F#" Value=" staticval mutable FilterNameIgnoreCase : System.Reflection.MemberFilter" Usage="System.Type.FilterNameIgnoreCase" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberFilter</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-382">Representa el filtro de miembros que no distingue mayúsculas de minúsculas y que se aplica a los nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-382">Represents the case-insensitive member filter used on names.</span></span> <span data-ttu-id="60a97-383">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-383">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-384">Este campo contiene una referencia al delegado usado por el <xref:System.Type.FindMembers%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-384">This field holds a reference to the delegate used by the <xref:System.Type.FindMembers%2A> method.</span></span> <span data-ttu-id="60a97-385">El método encapsulado por este delegado toma dos parámetros: el primero es un <xref:System.Reflection.MemberInfo> objeto y el segundo es un `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-385">The method encapsulated by this delegate takes two parameters: the first is a <xref:System.Reflection.MemberInfo> object and the second is an `Object`.</span></span> <span data-ttu-id="60a97-386">El método determina si el `MemberInfo` objeto coincide con los criterios especificados por el `Object`.</span><span class="sxs-lookup"><span data-stu-id="60a97-386">The method determines whether the `MemberInfo` object matches the criteria specified by the `Object`.</span></span> <span data-ttu-id="60a97-387">El `Object` se asigna un valor de cadena, que puede incluir un carácter "\*" carácter comodín.</span><span class="sxs-lookup"><span data-stu-id="60a97-387">The `Object` is assigned a string value, which may include a trailing "\*" wildcard character.</span></span> <span data-ttu-id="60a97-388">Coincidencia de cadenas de final de carácter comodín solo se admite.</span><span class="sxs-lookup"><span data-stu-id="60a97-388">Only wildcard end string matching is supported.</span></span>  
  
 <span data-ttu-id="60a97-389">Por ejemplo, el `Object` puede tener asignado el valor "ByTe \*".</span><span class="sxs-lookup"><span data-stu-id="60a97-389">For example, the `Object` may be assigned the value "ByTe\*".</span></span> <span data-ttu-id="60a97-390">En ese caso, cuando el `FilterName` delegado se invoca, devolverá true solo si el método representado por la `MemberInfo` objeto tiene un nombre que comienza con "bytes", mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-390">In that case, when the `FilterName` delegate is invoked, it will return true only if the method represented by the `MemberInfo` object has a name that begins with "byte", ignoring case.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-391">En el ejemplo siguiente se obtiene el `MemberFilter` delegado, lo pasa como un parámetro a la <xref:System.Type.FindMembers%2A> método y muestra los métodos y los atributos de la `String` clase que comienzan por la letra "c", omitiendo el caso.</span><span class="sxs-lookup"><span data-stu-id="60a97-391">The following example gets the `MemberFilter` delegate, passes it as a parameter to the <xref:System.Type.FindMembers%2A> method, and displays the methods and their attributes of the `String` class that begin with the letter "c", disregarding the case.</span></span>  
  
 [!code-cpp[Type_FilterNameIgnoreCase#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CPP/type_filternameignorecase.cpp#1)]
 [!code-csharp[Type_FilterNameIgnoreCase#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FilterNameIgnoreCase/CS/type_filternameignorecase.cs#1)]
 [!code-vb[Type_FilterNameIgnoreCase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FilterNameIgnoreCase/VB/type_filternameignorecase.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
        <altmember cref="T:System.Reflection.MemberFilter" />
      </Docs>
    </Member>
    <Member MemberName="FindInterfaces">
      <MemberSignature Language="C#" Value="public virtual Type[] FindInterfaces (System.Reflection.TypeFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] FindInterfaces(class System.Reflection.TypeFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindInterfaces (filter As TypeFilter, filterCriteria As Object) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ FindInterfaces(System::Reflection::TypeFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]&#xA;override this.FindInterfaces : System.Reflection.TypeFilter * obj -&gt; Type[]" Usage="type.FindInterfaces (filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="filter" Type="System.Reflection.TypeFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="filter"><span data-ttu-id="60a97-392">Delegado que compara las interfaces con <paramref name="filterCriteria" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-392">The delegate that compares the interfaces against <paramref name="filterCriteria" />.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="60a97-393">Criterios de búsqueda que determinan si una interfaz se debe incluir en la matriz devuelta.</span><span class="sxs-lookup"><span data-stu-id="60a97-393">The search criteria that determines whether an interface should be included in the returned array.</span></span></param>
        <summary><span data-ttu-id="60a97-394">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representa una lista filtrada de interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-394">Returns an array of <see cref="T:System.Type" /> objects representing a filtered list of interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-395">Matriz de objetos <see cref="T:System.Type" /> que representa una lista filtrada de las interfaces implementadas o heredadas por el <see cref="T:System.Type" /> actual, o una matriz vacía de tipo <see cref="T:System.Type" /> si no hay ninguna interfaz que coincida con el filtro y que haya sido implementada o heredada por el <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-395">An array of <see cref="T:System.Type" /> objects representing a filtered list of the interfaces implemented or inherited by the current <see cref="T:System.Type" />, or an empty array of type <see cref="T:System.Type" /> if no interfaces matching the filter are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-396">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-396">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-397">El <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> y <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegados proporcionados por el <xref:System.Reflection.Module?displayProperty=nameWithType> clase también puede utilizarse, en lugar de la <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegar.</span><span class="sxs-lookup"><span data-stu-id="60a97-397">The <xref:System.Reflection.Module.FilterTypeName?displayProperty=nameWithType> and <xref:System.Reflection.Module.FilterTypeNameIgnoreCase?displayProperty=nameWithType> delegates supplied by the <xref:System.Reflection.Module?displayProperty=nameWithType> class may also be used, in lieu of the <xref:System.Reflection.TypeFilter?displayProperty=nameWithType> delegate.</span></span>  
  
 <span data-ttu-id="60a97-398">Todas las interfaces implementadas por esta clase se consideran durante la búsqueda, si declara una clase base o esta misma clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-398">All of the interfaces implemented by this class are considered during the search, whether declared by a base class or this class itself.</span></span>  
  
 <span data-ttu-id="60a97-399">Este método busca en la jerarquía de clases base, devolver interfaces cada una de las interfaces coincidentes de cada clase implementa, así como la coincidencia de cada uno de esos implementa interfaces (es decir, se devuelve el cierre transitivo de las interfaces coincidentes).</span><span class="sxs-lookup"><span data-stu-id="60a97-399">This method searches the base class hierarchy, returning each of the matching interfaces each class implements as well as all the matching interfaces each of those interfaces implements (that is, the transitive closure of the matching interfaces is returned).</span></span> <span data-ttu-id="60a97-400">No hay ninguna interfaz duplicada se devuelve.</span><span class="sxs-lookup"><span data-stu-id="60a97-400">No duplicate interfaces are returned.</span></span>  
  
 <span data-ttu-id="60a97-401">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, <xref:System.Type.FindInterfaces%2A> busca todas las interfaces declaradas en las restricciones del parámetro de tipo, y todas las interfaces heredadas a través de interfaces declarado en las restricciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-401">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, <xref:System.Type.FindInterfaces%2A> searches all the interfaces declared in the constraints on the type parameter, and all interfaces inherited through the interfaces declared in the constraints.</span></span> <span data-ttu-id="60a97-402">Si el actual <xref:System.Type> representa un argumento de tipo de un tipo genérico, <xref:System.Type.FindInterfaces%2A> busca todas las interfaces implementadas por el tipo, si no coinciden con las restricciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-402">If the current <xref:System.Type> represents a type argument of a generic type, <xref:System.Type.FindInterfaces%2A> searches all the interfaces implemented by the type, whether or not they match constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-403"><xref:System.Type.FindInterfaces%2A> puede devolver interfaces genéricas, incluso en los tipos que no son genéricas.</span><span class="sxs-lookup"><span data-stu-id="60a97-403"><xref:System.Type.FindInterfaces%2A> can return generic interfaces, even on types that are not generic.</span></span> <span data-ttu-id="60a97-404">Por ejemplo, podría implementar un tipo no genérico `IEnumerable<int>` (`IEnumerable(Of Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-404">For example, a nongeneric type might implement `IEnumerable<int>` (`IEnumerable(Of Integer)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-405">En el ejemplo siguiente se busca la interfaz especificada implementada o heredada por el tipo especificado y, a continuación, muestra los nombres de interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-405">The following example finds the specified interface implemented or inherited by the specified type, and then displays the interface names.</span></span>  
  
 [!code-cpp[Type_FindInterfaces#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindInterfaces/CPP/type_findinterfaces.cpp#1)]
 [!code-csharp[Type_FindInterfaces#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindInterfaces/CS/type_findinterfaces.cs#1)]
 [!code-vb[Type_FindInterfaces#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindInterfaces/VB/type_findinterfaces.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-406">El valor de <paramref name="filter" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-406"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-407">Se invoca un inicializador estático y produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-407">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.Reflection.Module" />
        <altmember cref="T:System.Reflection.TypeFilter" />
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.GetInterfaces" />
      </Docs>
    </Member>
    <Member MemberName="FindMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] FindMembers (System.Reflection.MemberTypes memberType, System.Reflection.BindingFlags bindingAttr, System.Reflection.MemberFilter filter, object filterCriteria);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] FindMembers(valuetype System.Reflection.MemberTypes memberType, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.MemberFilter filter, object filterCriteria) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function FindMembers (memberType As MemberTypes, bindingAttr As BindingFlags, filter As MemberFilter, filterCriteria As Object) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ FindMembers(System::Reflection::MemberTypes memberType, System::Reflection::BindingFlags bindingAttr, System::Reflection::MemberFilter ^ filter, System::Object ^ filterCriteria);" />
      <MemberSignature Language="F#" Value="abstract member FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]&#xA;override this.FindMembers : System.Reflection.MemberTypes * System.Reflection.BindingFlags * System.Reflection.MemberFilter * obj -&gt; System.Reflection.MemberInfo[]" Usage="type.FindMembers (memberType, bindingAttr, filter, filterCriteria)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="memberType" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="filter" Type="System.Reflection.MemberFilter" />
        <Parameter Name="filterCriteria" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="memberType"><span data-ttu-id="60a97-408">Objeto que indica el tipo de miembro que se va a buscar.</span><span class="sxs-lookup"><span data-stu-id="60a97-408">An object that indicates the type of member to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-409">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-409">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-410">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-410">-or-</span></span> 
<span data-ttu-id="60a97-411">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-411">Zero, to return <see langword="null" />.</span></span></param>
        <param name="filter"><span data-ttu-id="60a97-412">Delegado que realiza las comparaciones y que devuelve <see langword="true" /> si el miembro inspeccionado coincide con <paramref name="filterCriteria" /> y <see langword="false" /> en caso contrario.</span><span class="sxs-lookup"><span data-stu-id="60a97-412">The delegate that does the comparisons, returning <see langword="true" /> if the member currently being inspected matches the <paramref name="filterCriteria" /> and <see langword="false" /> otherwise.</span></span> <span data-ttu-id="60a97-413">Es posible usar los delegados <see langword="FilterAttribute" />, <see langword="FilterName" /> y <see langword="FilterNameIgnoreCase" /> que esta clase proporciona.</span><span class="sxs-lookup"><span data-stu-id="60a97-413">You can use the <see langword="FilterAttribute" />, <see langword="FilterName" />, and <see langword="FilterNameIgnoreCase" /> delegates supplied by this class.</span></span> <span data-ttu-id="60a97-414">El primero usa los campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> y <see langword="MethodImplAttributes" /> como criterios de búsqueda, y los otros dos usan objetos <see langword="String" /> como criterios de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-414">The first uses the fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> as search criteria, and the other two delegates use <see langword="String" /> objects as the search criteria.</span></span></param>
        <param name="filterCriteria"><span data-ttu-id="60a97-415">Criterios de búsqueda que determinan si se devuelve un miembro en la matriz de objetos <see langword="MemberInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-415">The search criteria that determines whether a member is returned in the array of <see langword="MemberInfo" /> objects.</span></span>  
  
<span data-ttu-id="60a97-416">Los campos de <see langword="FieldAttributes" />, <see langword="MethodAttributes" /> y <see langword="MethodImplAttributes" /> se pueden usar junto con el delegado <see langword="FilterAttribute" /> que esta clase proporciona.</span><span class="sxs-lookup"><span data-stu-id="60a97-416">The fields of <see langword="FieldAttributes" />, <see langword="MethodAttributes" />, and <see langword="MethodImplAttributes" /> can be used in conjunction with the <see langword="FilterAttribute" /> delegate supplied by this class.</span></span></param>
        <summary><span data-ttu-id="60a97-417">Devuelve una matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> del tipo del miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-417">Returns a filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span></summary>
        <returns><span data-ttu-id="60a97-418">Matriz filtrada de objetos <see cref="T:System.Reflection.MemberInfo" /> del tipo del miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-418">A filtered array of <see cref="T:System.Reflection.MemberInfo" /> objects of the specified member type.</span></span>  
  
<span data-ttu-id="60a97-419">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-419">-or-</span></span> 
<span data-ttu-id="60a97-420">Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> en caso de que el objeto <see cref="T:System.Type" /> actual no tenga miembros del tipo <paramref name="memberType" /> que coincidan con los criterios del filtro.</span><span class="sxs-lookup"><span data-stu-id="60a97-420">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have members of type <paramref name="memberType" /> that match the filter criteria.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-421">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-421">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-422">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-422">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-423">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-423">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-424">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-424">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-425">Especificar `BindingFlags.Instance` para incluir los miembros de instancia en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-425">Specify `BindingFlags.Instance` to include instance members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-426">Especificar `BindingFlags.Static` para incluir los miembros estáticos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-426">Specify `BindingFlags.Static` to include static members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-427">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-427">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-428">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-428">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
 <span data-ttu-id="60a97-429">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-429">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-430">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-430">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-431">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-431">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-432">Los valores válidos para <xref:System.Type.MemberType%2A> se definen en <xref:System.Reflection.MemberInfo>.</span><span class="sxs-lookup"><span data-stu-id="60a97-432">Valid values for <xref:System.Type.MemberType%2A> are defined in <xref:System.Reflection.MemberInfo>.</span></span> <span data-ttu-id="60a97-433">Si dichos miembros no se encuentran, se devuelve una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-433">If no such members are found, an empty array is returned.</span></span>  
  
 <span data-ttu-id="60a97-434">Para obtener el inicializador de clase (.cctor) con este método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-434">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-435">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-435">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-436">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico o un método genérico, <xref:System.Type.FindMembers%2A> procesa los miembros declarados por la restricción de clase y las restricciones del parámetro de tipo de interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-436">If the current <xref:System.Type> represents a type parameter of a generic type or generic method, <xref:System.Type.FindMembers%2A> processes any members declared by the class constraint and the interface constraints of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-437">El ejemplo siguiente busca a todos los miembros de una clase que coinciden con los criterios de búsqueda especificado y, a continuación, muestra a los miembros coincidentes.</span><span class="sxs-lookup"><span data-stu-id="60a97-437">The following example finds all the members in a class that match the specified search criteria, and then displays the matched members.</span></span>  
  
 [!code-cpp[Type_FindMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_FindMembers/CPP/type_findmembers.cpp#1)]
 [!code-csharp[Type_FindMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_FindMembers/CS/type_findmembers.cs#1)]
 [!code-vb[Type_FindMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_FindMembers/VB/type_findmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-438">El valor de <paramref name="filter" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-438"><paramref name="filter" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
      </Docs>
    </Member>
    <Member MemberName="FullName">
      <MemberSignature Language="C#" Value="public abstract string FullName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FullName" />
      <MemberSignature Language="DocId" Value="P:System.Type.FullName" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property FullName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ FullName { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FullName : string" Usage="System.Type.FullName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.FullName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-439">Obtiene el nombre completo del tipo, incluido su espacio de nombres, pero no su ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-439">Gets the fully qualified name of the type, including its namespace but not its assembly.</span></span></summary>
        <value><span data-ttu-id="60a97-440">Nombre completo del tipo, con espacio de nombres y sin ensamblado; o bien, <see langword="null" /> si la instancia actual representa un parámetro de tipo genérico, un tipo de matriz, un tipo de puntero o un tipo <see langword="byref" /> basado en un parámetro de tipo, o un tipo genérico que no sea una definición de tipo genérico, pero que contenga parámetros de tipo sin resolver.</span><span class="sxs-lookup"><span data-stu-id="60a97-440">The fully qualified name of the type, including its namespace but not its assembly; or <see langword="null" /> if the current instance represents a generic type parameter, an array type, pointer type, or <see langword="byref" /> type based on a type parameter, or a generic type that is not a generic type definition but contains unresolved type parameters.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-441">Por ejemplo, el nombre completo de la <xref:System.String> es de tipo `System.String`.</span><span class="sxs-lookup"><span data-stu-id="60a97-441">For example, the fully qualified name of the <xref:System.String> type is `System.String`.</span></span> <span data-ttu-id="60a97-442">Compare esto con el nombre completo del ensamblado devuelto por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, compuesto por el nombre completo más el nombre completo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-442">Contrast this with the assembly-qualified name returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, which consists of the full name plus the full assembly name.</span></span>  
  
 <span data-ttu-id="60a97-443">Si el tipo actual representa un tipo genérico cerrado, los argumentos de tipo en la cadena devuelven por la <xref:System.Type.FullName%2A> propiedad se califican por su nombre completo del ensamblado, aunque la representación de cadena del tipo genérico en sí no está calificada con su completo nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-443">If the current type represents a closed generic type, the type arguments in the string returned by the <xref:System.Type.FullName%2A> property are qualified by their full assembly name, even though the string representation of the generic type itself is not qualified by its full assembly name.</span></span> <span data-ttu-id="60a97-444">El ejemplo siguiente muestra la diferencia en la propiedad FullName para un tipo que representa la definición de tipo genérico y otro que representa un tipo genérico cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-444">The following example illustrates the difference in the FullName property for a type that represents generic type definition and one that represents a closed generic type.</span></span>  
  
 [!code-csharp[System.Type.FullName#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/fullnameex1.cs#2)]
 [!code-vb[System.Type.FullName#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/fullnameex1.vb#2)]  
  
 <span data-ttu-id="60a97-445">Esta propiedad devuelve `null` si:</span><span class="sxs-lookup"><span data-stu-id="60a97-445">This property returns `null` if:</span></span>  
  
-   <span data-ttu-id="60a97-446">Actual <xref:System.Type> objeto representa un parámetro de tipo de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-446">The current <xref:System.Type> object represents a type parameter of a generic type.</span></span>  
  
     <span data-ttu-id="60a97-447">En el ejemplo siguiente se recupera el parámetro de tipo de la <xref:System.Nullable%601> tipo e intenta mostrar su <xref:System.Type.FullName%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-447">The following example retrieves the type parameter of the <xref:System.Nullable%601> type and attempts to display its <xref:System.Type.FullName%2A> property.</span></span>  
  
     [!code-csharp[System.Type.FullName#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname3.cs#3)]
     [!code-vb[System.Type.FullName#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/Fullname3.vb#3)]  
  
-   <span data-ttu-id="60a97-448">Actual <xref:System.Type> objeto representa un tipo de matriz, un tipo de puntero, o un `byref` tipo que se basa en un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-448">The current <xref:System.Type> object represents an array type, a pointer  type, or a `byref` type that is based on a generic type parameter.</span></span>  
  
     <span data-ttu-id="60a97-449">En el ejemplo siguiente se define un tipo genérico, `Generictype1<T>`, con tres métodos: `Display(T[])`, que se pasa una matriz de tipo T; `HandleT(T)`, que se pasa un objeto T; y `ChangeValue(ref T)`, un objeto T que se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-449">The following example defines a generic type, `Generictype1<T>`, with three methods: `Display(T[])`, which is passed an array of type T; `HandleT(T)`, which is passed a T object; and `ChangeValue(ref T)`, which is passed a T object by reference.</span></span> <span data-ttu-id="60a97-450">Dado que C# y Visual Basic no nos permiten definir T como un puntero en el `HandleT` método, se debe llamar a la <xref:System.Type.MakePointerType%2A> método en el <xref:System.Type> objeto que representa el tipo de parámetro del método para crear un puntero a un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-450">Because C# and Visual Basic do not allow us to define T as a pointer in the `HandleT` method, we have to call the <xref:System.Type.MakePointerType%2A> method on the <xref:System.Type> object that represents the method's parameter type to create a pointer to a generic type.</span></span> <span data-ttu-id="60a97-451">El resultado del ejemplo muestra en los tres casos, el <xref:System.Type.FullName%2A> propiedad es `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-451">The output from the example shows that in all three cases, the <xref:System.Type.FullName%2A> property is `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname4.cs#4)]
     [!code-vb[System.Type.FullName#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName4.vb#4)]  
  
-   <span data-ttu-id="60a97-452">El tipo actual contiene parámetros de tipo genérico que no han sido reemplazados por tipos específicos (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`), pero el tipo no es una definición de tipo genérico (es decir, el <xref:System.Type.IsGenericTypeDefinition%2A> devuelve de la propiedad `false`</span><span class="sxs-lookup"><span data-stu-id="60a97-452">The current type contains generic type parameters that have not been replaced by specific types (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`), but the type is not a generic type definition (that is, the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `false`</span></span>  
  
     <span data-ttu-id="60a97-453">En el ejemplo siguiente, `Derived<T>` hereda de `Base<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-453">In the following example, `Derived<T>` inherits from `Base<T>`.</span></span> <span data-ttu-id="60a97-454">El <xref:System.Type.BaseType%2A> propiedad obtiene el <xref:System.Type> objeto que representa el tipo base del `Derived<T>`y su <xref:System.Type.FullName%2A> propiedad devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-454">The <xref:System.Type.BaseType%2A> property obtains the  <xref:System.Type> object that represents the base type of `Derived<T>`, and its <xref:System.Type.FullName%2A> property returns `null`.</span></span>  
  
     [!code-csharp[System.Type.FullName#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.fullname/cs/Fullname5.cs#5)]
     [!code-vb[System.Type.FullName#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.fullname/vb/FullName5.vb#5)]  
  
     <span data-ttu-id="60a97-455">Para obtener un <xref:System.Type.FullName%2A> que no es `null`, puede usar el <xref:System.Type.GetGenericTypeDefinition%2A> método para obtener la definición de tipo genérico, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-455">To get a <xref:System.Type.FullName%2A> that is not `null`, you can use the <xref:System.Type.GetGenericTypeDefinition%2A> method to get the generic type definition, as the example illustrates.</span></span>  
  
 <span data-ttu-id="60a97-456">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-456">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-457">El ejemplo siguiente muestra el nombre completo del tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-457">The following example displays the full name of the specified type.</span></span>  
  
 [!code-cpp[TestFullName#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestFullName/CPP/TestFullName.cpp#1)]
 [!code-csharp[TestFullName#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestFullName/CS/testfullname.cs#1)]
 [!code-vb[TestFullName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestFullName/VB/testfullname.vb#1)]  
  
 <span data-ttu-id="60a97-458">En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-458">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.Namespace" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-459">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-459">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterAttributes">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.GenericParameterAttributes GenericParameterAttributes { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.GenericParameterAttributes GenericParameterAttributes" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterAttributes" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterAttributes As GenericParameterAttributes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::GenericParameterAttributes GenericParameterAttributes { System::Reflection::GenericParameterAttributes get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterAttributes : System.Reflection.GenericParameterAttributes" Usage="System.Type.GenericParameterAttributes" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.GenericParameterAttributes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-460">Obtiene una combinación de marcas <see cref="T:System.Reflection.GenericParameterAttributes" /> que describen la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-460">Gets a combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> flags that describe the covariance and special constraints of the current generic type parameter.</span></span></summary>
        <value><span data-ttu-id="60a97-461">Combinación bit a bit de valores de <see cref="T:System.Reflection.GenericParameterAttributes" /> que describe la covarianza y las restricciones especiales del parámetro de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-461">A bitwise combination of <see cref="T:System.Reflection.GenericParameterAttributes" /> values that describes the covariance and special constraints of the current generic type parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-462">El valor de esta propiedad contiene las marcas que describen si el parámetro de tipo genérico actual es covariante y las marcas que describen las restricciones especiales.</span><span class="sxs-lookup"><span data-stu-id="60a97-462">The value of this property contains flags that describe whether the current generic type parameter is covariant, and flags that describe any special constraints.</span></span> <span data-ttu-id="60a97-463">Utilice la <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> valor para seleccionar los indicadores de covarianza y usar el <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> valor para seleccionar los indicadores de restricción.</span><span class="sxs-lookup"><span data-stu-id="60a97-463">Use the <xref:System.Reflection.GenericParameterAttributes.VarianceMask?displayProperty=nameWithType> value to select the covariance flags, and use the <xref:System.Reflection.GenericParameterAttributes.SpecialConstraintMask?displayProperty=nameWithType> value to select the constraint flags.</span></span>  
  
 <span data-ttu-id="60a97-464">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-464">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-465">El ejemplo de código siguiente define un tipo genérico `Test` con dos parámetros de tipo que tienen distintas restricciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-465">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="60a97-466">Cuando se ejecuta el programa, se examinan las restricciones mediante la <xref:System.Type.GenericParameterAttributes%2A> propiedad y el <xref:System.Type.GetGenericParameterConstraints%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-466">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-467">El objeto <see cref="T:System.Type" /> actual no es un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-467">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="60a97-468">Es decir, la propiedad <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-468">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-469">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-469">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-470">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-470">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-471">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-471">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericParameterPosition">
      <MemberSignature Language="C#" Value="public virtual int GenericParameterPosition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 GenericParameterPosition" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericParameterPosition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericParameterPosition As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property int GenericParameterPosition { int get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericParameterPosition : int" Usage="System.Type.GenericParameterPosition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-472">Obtiene la posición del parámetro de tipo en la lista de parámetros de tipo del tipo o método genérico que declaró el parámetro, siempre que el objeto <see cref="T:System.Type" /> represente un parámetro de tipo de un tipo genérico o de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-472">Gets the position of the type parameter in the type parameter list of the generic type or method that declared the parameter, when the <see cref="T:System.Type" /> object represents a type parameter of a generic type or a generic method.</span></span></summary>
        <value><span data-ttu-id="60a97-473">Posición de un parámetro de tipo en la lista de parámetros de tipo del método o tipo genérico que define el parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-473">The position of a type parameter in the type parameter list of the generic type or method that defines the parameter.</span></span> <span data-ttu-id="60a97-474">Los números de posición comienzan en 0.</span><span class="sxs-lookup"><span data-stu-id="60a97-474">Position numbers begin at 0.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-475">El <xref:System.Type.GenericParameterPosition%2A> propiedad devuelve la posición de un parámetro de tipo en la lista de parámetros de la definición de tipo genérico o una definición de método genérico donde se definió originalmente el parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-475">The <xref:System.Type.GenericParameterPosition%2A> property returns the position of a type parameter in the parameter list of the generic type definition or generic method definition where the type parameter was originally defined.</span></span> <span data-ttu-id="60a97-476">El <xref:System.Type.DeclaringType%2A> y <xref:System.Type.DeclaringMethod%2A> propiedades identifican la definición de tipo o método genérico:</span><span class="sxs-lookup"><span data-stu-id="60a97-476">The <xref:System.Type.DeclaringType%2A> and <xref:System.Type.DeclaringMethod%2A> properties identify the generic type or method definition:</span></span>  
  
-   <span data-ttu-id="60a97-477">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve un <xref:System.Reflection.MethodInfo>, que <xref:System.Reflection.MethodInfo> representa una definición de método genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de esa definición de método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-477">If the <xref:System.Type.DeclaringMethod%2A> property returns a <xref:System.Reflection.MethodInfo>, that <xref:System.Reflection.MethodInfo> represents a generic method definition, and the current <xref:System.Type> object represents a type parameter of that generic method definition.</span></span>  
  
-   <span data-ttu-id="60a97-478">Si el <xref:System.Type.DeclaringMethod%2A> propiedad devuelve `null`, el <xref:System.Type.DeclaringType%2A> propiedad siempre devuelve un <xref:System.Type> objeto que representa una definición de tipo genérico y la actual <xref:System.Type> objeto representa un parámetro de tipo de ese tipo genérico definición.</span><span class="sxs-lookup"><span data-stu-id="60a97-478">If the <xref:System.Type.DeclaringMethod%2A> property returns `null`, then the <xref:System.Type.DeclaringType%2A> property always returns a <xref:System.Type> object representing a generic type definition, and the current <xref:System.Type> object represents a type parameter of that generic type definition.</span></span>  
  
 <span data-ttu-id="60a97-479">Para proporcionar el contexto correcto para el valor de la <xref:System.Type.GenericParameterPosition%2A> propiedad, es necesario identificar el tipo o método genérico al que pertenece un parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-479">To provide the correct context for the value of the <xref:System.Type.GenericParameterPosition%2A> property, it is necessary to identify the generic type or method a type parameter belongs to.</span></span> <span data-ttu-id="60a97-480">Por ejemplo, considere el valor devuelto del método genérico `GetSomething` en el código siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-480">For example, consider the return value of the generic method `GetSomething` in the following code:</span></span>  
  
 [!code-cpp[System.Type.GenericParameterPosition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.genericparameterposition/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.GenericParameterPosition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.genericparameterposition/cs/remarks.cs#1)]
 [!code-vb[System.Type.GenericParameterPosition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.genericparameterposition/vb/remarks.vb#1)]  
  
 <span data-ttu-id="60a97-481">El tipo devuelto por `GetSomething` depende de los argumentos de tipo proporcionados a la clase `A` y `GetSomething` propio.</span><span class="sxs-lookup"><span data-stu-id="60a97-481">The type returned by `GetSomething` depends on the type arguments supplied to class `A` and to `GetSomething` itself.</span></span> <span data-ttu-id="60a97-482">Puede obtener un <xref:System.Reflection.MethodInfo> para `GetSomething`, y desde el que se puede obtener el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-482">You can obtain a <xref:System.Reflection.MethodInfo> for `GetSomething`, and from that you can obtain the return type.</span></span> <span data-ttu-id="60a97-483">Al examinar los parámetros de tipo del tipo de valor devuelto, <xref:System.Type.GenericParameterPosition%2A> devuelve 0 para ambos.</span><span class="sxs-lookup"><span data-stu-id="60a97-483">When you examine the type parameters of the return type, <xref:System.Type.GenericParameterPosition%2A> returns 0 for both.</span></span> <span data-ttu-id="60a97-484">La posición de `V` es 0 porque `V` es el primer parámetro de tipo en la lista de parámetros de tipo para la clase `A`.</span><span class="sxs-lookup"><span data-stu-id="60a97-484">The position of `V` is 0 because `V` is the first type parameter in the type parameter list for class `A`.</span></span> <span data-ttu-id="60a97-485">La posición de `X` es 0 porque `X` es el primer parámetro de tipo en la lista de parámetros de tipo `GetSomething`.</span><span class="sxs-lookup"><span data-stu-id="60a97-485">The position of `X` is 0 because `X` is the first type parameter in the type parameter list for `GetSomething`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-486">Una llamada a la <xref:System.Type.GenericParameterPosition%2A> propiedad produce una excepción si el actual <xref:System.Type> no representa un parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-486">Calling the <xref:System.Type.GenericParameterPosition%2A> property causes an exception if the current <xref:System.Type> does not represent a type parameter.</span></span> <span data-ttu-id="60a97-487">Al examinar los argumentos de tipo de un tipo construido abierto, use el <xref:System.Type.IsGenericParameter%2A> propiedad para indicar que son parámetros de tipo y cuáles son los tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-487">When you examine the type arguments of an open constructed type, use the <xref:System.Type.IsGenericParameter%2A> property to tell which are type parameters and which are types.</span></span> <span data-ttu-id="60a97-488">El <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` para un parámetro de tipo; a continuación, puede usar el <xref:System.Type.GenericParameterPosition%2A> método obtener su posición y utilizar el <xref:System.Type.DeclaringMethod%2A> y <xref:System.Type.DeclaringType%2A> propiedades para determinar el método genérico o que lo define la definición de tipo .</span><span class="sxs-lookup"><span data-stu-id="60a97-488">The <xref:System.Type.IsGenericParameter%2A> property returns `true` for a type parameter; you can then use the <xref:System.Type.GenericParameterPosition%2A> method to obtain its position and use the <xref:System.Type.DeclaringMethod%2A> and <xref:System.Type.DeclaringType%2A> properties to determine the generic method or type definition that defines it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-489">El ejemplo siguiente define una clase genérica con dos parámetros de tipo y define una segunda clase genérica que se deriva de la primera clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-489">The following example defines a generic class with two type parameters and defines a second generic class that derives from the first class.</span></span> <span data-ttu-id="60a97-490">Clase base de la clase derivada tiene dos argumentos de tipo: el primero es <xref:System.Int32>, y el segundo es un parámetro de tipo del tipo derivado.</span><span class="sxs-lookup"><span data-stu-id="60a97-490">The derived class's base class has two type arguments: the first is <xref:System.Int32>, and the second is a type parameter of the derived type.</span></span> <span data-ttu-id="60a97-491">En el ejemplo se muestra información acerca de estas clases genéricas, incluidas las posiciones notifican por el <xref:System.Type.GenericParameterPosition%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-491">The example displays information about these generic classes, including the positions reported by the <xref:System.Type.GenericParameterPosition%2A> property.</span></span>  
  
 [!code-cpp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.HasUnboundGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.HasUnboundGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-492">El tipo actual no representa un parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-492">The current type does not represent a type parameter.</span></span> <span data-ttu-id="60a97-493">Es decir, <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-493">That is, <see cref="P:System.Type.IsGenericParameter" /> returns <see langword="false" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-494">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-494">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-495">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-495">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GenericTypeArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GenericTypeArguments { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type[] GenericTypeArguments" />
      <MemberSignature Language="DocId" Value="P:System.Type.GenericTypeArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property GenericTypeArguments As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property cli::array &lt;Type ^&gt; ^ GenericTypeArguments { cli::array &lt;Type ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.GenericTypeArguments : Type[]" Usage="System.Type.GenericTypeArguments" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-496">Obtiene una matriz de los argumentos de tipo genérico para este tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-496">Gets an array of the generic type arguments for this type.</span></span></summary>
        <value><span data-ttu-id="60a97-497">Una matriz de argumentos de tipo genérico para este tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-497">An array of the generic type arguments for this type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-498">Esta propiedad obtiene solo los argumentos de tipo genérico; es decir, los tipos que se han especificado para los parámetros de tipo genérico del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-498">This property gets only the generic type arguments; that is, the types that have been specified for the generic type parameters of the current type.</span></span> <span data-ttu-id="60a97-499">Si el tipo actual es una definición de tipo genérico, esta propiedad devuelve una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-499">If the current type is a generic type definition, this property returns an empty array.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-500">Si se usa un tipo genérico en un método genérico o en otro tipo genérico, algunos de sus argumentos de tipo genérico podrían ser parámetros de tipo genérico del método o tipo envolvente.</span><span class="sxs-lookup"><span data-stu-id="60a97-500">If a generic type is used in a generic method or in another generic type, some of its generic type arguments might be generic type parameters of the enclosing method or type.</span></span>  
  
 <span data-ttu-id="60a97-501">Para obtener los parámetros de tipo genérico de un tipo que representa una definición de tipo genérico, use el <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-501">To get the generic type parameters of a type that represents a generic type definition, use the <xref:System.Reflection.TypeInfo.GenericTypeParameters%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="60a97-502">Para obtener un <xref:System.Reflection.TypeInfo> objeto actual <xref:System.Type> de objeto, utilice el <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> método de extensión.</span><span class="sxs-lookup"><span data-stu-id="60a97-502">To get a <xref:System.Reflection.TypeInfo> object for the current <xref:System.Type> object, use the <xref:System.Reflection.IntrospectionExtensions.GetTypeInfo%2A?displayProperty=nameWithType> extension method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetArrayRank">
      <MemberSignature Language="C#" Value="public virtual int GetArrayRank ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 GetArrayRank() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetArrayRank" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetArrayRank () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int GetArrayRank();" />
      <MemberSignature Language="F#" Value="abstract member GetArrayRank : unit -&gt; int&#xA;override this.GetArrayRank : unit -&gt; int" Usage="type.GetArrayRank " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetArrayRank</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-503">Obtiene el número de dimensiones de una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-503">Gets the number of dimensions in an array.</span></span></summary>
        <returns><span data-ttu-id="60a97-504">Entero que contiene el número de dimensiones del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-504">An integer that contains the number of dimensions in the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60a97-505">El ejemplo siguiente muestra el número de dimensiones en una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-505">The following example displays the number of dimensions in an array.</span></span>  
  
 [!code-cpp[Type_GetArrayRank#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetArrayRank/CPP/type_getarrayrank.cpp#1)]
 [!code-csharp[Type_GetArrayRank#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetArrayRank/CS/type_getarrayrank.cs#1)]
 [!code-vb[Type_GetArrayRank#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetArrayRank/VB/type_getarrayrank.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-506">La funcionalidad de este método no se admite en la clase base y debe implementarse en una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-506">The functionality of this method is unsupported in the base class and must be implemented in a derived class instead.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-507">El tipo actual no es una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-507">The current type is not an array.</span></span></exception>
        <altmember cref="T:System.Array" />
        <altmember cref="P:System.Array.Rank" />
      </Docs>
    </Member>
    <Member MemberName="GetAttributeFlagsImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.TypeAttributes GetAttributeFlagsImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.Reflection.TypeAttributes GetAttributeFlagsImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetAttributeFlagsImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetAttributeFlagsImpl () As TypeAttributes" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::TypeAttributes GetAttributeFlagsImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetAttributeFlagsImpl : unit -&gt; System.Reflection.TypeAttributes" Usage="type.GetAttributeFlagsImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.TypeAttributes</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-508">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.Attributes" /> y obtiene una máscara de bits que indica los atributos asociados a <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-508">When overridden in a derived class, implements the <see cref="P:System.Type.Attributes" /> property and gets a bitmask indicating the attributes associated with the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-509">Objeto <see cref="T:System.Reflection.TypeAttributes" /> que representa el conjunto de atributos de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-509">A <see cref="T:System.Reflection.TypeAttributes" /> object representing the attribute set of the <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.Attributes" />
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructor">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-510">Obtiene un constructor específico del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-510">Gets a specific constructor of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructor (types As Type()) As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : Type[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor types" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="types"><span data-ttu-id="60a97-511">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de los parámetros del constructor deseado.</span><span class="sxs-lookup"><span data-stu-id="60a97-511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the desired constructor.</span></span>  
  
<span data-ttu-id="60a97-512">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-512">-or-</span></span> 
<span data-ttu-id="60a97-513">Matriz vacía de objetos <see cref="T:System.Type" />, para obtener un constructor que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-513">An empty array of <see cref="T:System.Type" /> objects, to get a constructor that takes no parameters.</span></span> <span data-ttu-id="60a97-514">El campo <see langword="static" /> <see cref="F:System.Type.EmptyTypes" /> proporciona dicha matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-514">Such an empty array is provided by the <see langword="static" /> field <see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <summary><span data-ttu-id="60a97-515">Busca un constructor de instancia público cuyos parámetros coincidan con los tipos de la matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-515">Searches for a public instance constructor whose parameters match the types in the specified array.</span></span></summary>
        <returns><span data-ttu-id="60a97-516">Objeto que representa el constructor de instancia público cuyos parámetros coinciden con los tipos de la matriz de tipos de parámetro, si se encuentra; de lo contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-516">An object representing the public instance constructor whose parameters match the types in the parameter type array, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-517">Esta sobrecarga del método busca constructores de instancia públicos y no se puede usar para obtener a un inicializador de clase (.cctor).</span><span class="sxs-lookup"><span data-stu-id="60a97-517">This method overload looks for public instance constructors and cannot be used to obtain a class initializer (.cctor).</span></span> <span data-ttu-id="60a97-518">Para obtener un inicializador de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-518">To get a class initializer, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-519">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-519">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-520">Si el constructor solicitado no es público, este método devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-520">If the requested constructor is non-public, this method returns `null`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-521">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-521">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-522">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-522">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-523">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-523">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-524">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-524">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-525">En el ejemplo siguiente se obtiene el tipo de `MyClass`, obtiene el <xref:System.Reflection.ConstructorInfo> de objetos y muestra la firma del constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-525">The following example obtains the type of `MyClass`, gets the <xref:System.Reflection.ConstructorInfo> object, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor/CPP/type_getconstructor.cpp#1)]
 [!code-csharp[Type_GetConstructor#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor/CS/type_getconstructor.cs#1)]
 [!code-vb[Type_GetConstructor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor/VB/type_getconstructor.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-526">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-526"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-527">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-527">-or-</span></span> 
<span data-ttu-id="60a97-528">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-528">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-529"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-529"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-530">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-530">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-531">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-531">-or-</span></span> 
<span data-ttu-id="60a97-532">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-532">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-533">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-533">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-534">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-534">-or-</span></span> 
<span data-ttu-id="60a97-535">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-535">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-536">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-536">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="60a97-537">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-537">-or-</span></span> 
<span data-ttu-id="60a97-538">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-538">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span>  
  
<span data-ttu-id="60a97-539">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-539">-or-</span></span> 
 <span data-ttu-id="60a97-540"><see cref="F:System.Type.EmptyTypes" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-540"><see cref="F:System.Type.EmptyTypes" />.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-541">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz de tipo de parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-541">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the parameter type array.</span></span> <span data-ttu-id="60a97-542">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-542">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-543">Busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, mediante las restricciones de enlace también especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-543">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-544">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-544">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-545">Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-545">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="60a97-546">Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="60a97-546">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="60a97-547">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-547">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-548">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-548">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-549">Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-549">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="60a97-550">Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-550">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="60a97-551">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-551">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-552">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-552">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-553">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-553">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-554">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-554">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-555">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-555">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-556">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-556">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-557">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-557">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-558">El programa siguiente obtiene el tipo de `MyClass1` clase, obtiene el <xref:System.Reflection.ConstructorInfo> coincidencia de las marcas de enlace especificado de objetos y muestra la firma del constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-558">The following program obtains the type of `MyClass1` class, gets the <xref:System.Reflection.ConstructorInfo> object matching the specified binding flags, and displays the signature of the constructor.</span></span>  
  
 [!code-cpp[Type_GetConstructor2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor2/CPP/type_getconstructor2.cpp#1)]
 [!code-csharp[Type_GetConstructor2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor2/CS/type_getconstructor2.cs#1)]
 [!code-vb[Type_GetConstructor2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor2/VB/type_getconstructor2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-559">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-559"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-560">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-560">-or-</span></span> 
<span data-ttu-id="60a97-561">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-561">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-562"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-562"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-563">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-563">-or-</span></span> 
 <span data-ttu-id="60a97-564"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-564"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-565">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-565">-or-</span></span> 
 <span data-ttu-id="60a97-566"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-566"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructor">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo GetConstructor (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructor(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::ConstructorInfo ^ GetConstructor(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo&#xA;override this.GetConstructor : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructor (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-567">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-567">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-568">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-568">-or-</span></span> 
<span data-ttu-id="60a97-569">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-569">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-570">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-570">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-571">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-571">-or-</span></span> 
<span data-ttu-id="60a97-572">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-572">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="60a97-573">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</span><span class="sxs-lookup"><span data-stu-id="60a97-573">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-574">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-574">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="60a97-575">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-575">-or-</span></span> 
<span data-ttu-id="60a97-576">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-576">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-577">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-577">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-578">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-578">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-579">Busca un constructor cuyos parámetros coincidan con los modificadores y tipos de argumento especificados, mediante las restricciones de enlace indicadas y la convención de llamadas también especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-579">Searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="60a97-580">Objeto que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-580">An object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-581">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-581">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-582">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-582">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-583">Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-583">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="60a97-584">Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="60a97-584">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="60a97-585">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-585">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-586">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-586">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-587">Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-587">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="60a97-588">Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-588">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="60a97-589">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-589">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-590">Para obtener el inicializador de clase (.cctor) con este método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-590">To get the class initializer (.cctor) using this method, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-591">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-591">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-592">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-592">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-593">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-593">Member Type</span></span>|<span data-ttu-id="60a97-594">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-594">Static</span></span>|<span data-ttu-id="60a97-595">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-595">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-596">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-596">Constructor</span></span>|<span data-ttu-id="60a97-597">No</span><span class="sxs-lookup"><span data-stu-id="60a97-597">No</span></span>|<span data-ttu-id="60a97-598">No</span><span class="sxs-lookup"><span data-stu-id="60a97-598">No</span></span>|  
|<span data-ttu-id="60a97-599">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-599">Field</span></span>|<span data-ttu-id="60a97-600">No</span><span class="sxs-lookup"><span data-stu-id="60a97-600">No</span></span>|<span data-ttu-id="60a97-601">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-601">Yes.</span></span> <span data-ttu-id="60a97-602">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-602">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-603">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-603">Event</span></span>|<span data-ttu-id="60a97-604">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-604">Not applicable</span></span>|<span data-ttu-id="60a97-605">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-605">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-606">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-606">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-607">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-607">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-608">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-608">Method</span></span>|<span data-ttu-id="60a97-609">No</span><span class="sxs-lookup"><span data-stu-id="60a97-609">No</span></span>|<span data-ttu-id="60a97-610">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-610">Yes.</span></span> <span data-ttu-id="60a97-611">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-611">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-612">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-612">Nested Type</span></span>|<span data-ttu-id="60a97-613">No</span><span class="sxs-lookup"><span data-stu-id="60a97-613">No</span></span>|<span data-ttu-id="60a97-614">No</span><span class="sxs-lookup"><span data-stu-id="60a97-614">No</span></span>|  
|<span data-ttu-id="60a97-615">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-615">Property</span></span>|<span data-ttu-id="60a97-616">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-616">Not applicable</span></span>|<span data-ttu-id="60a97-617">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-617">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-618">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-618">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-619">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-619">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-620">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-620">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-621">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-621">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-622">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-622">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-623">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-623">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-624">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-624">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-625">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-625">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-626">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-626">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-627">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-627">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-628">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método siempre devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-628">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method always returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-629">En el ejemplo siguiente se obtiene el tipo de `MyClass1`, obtiene el <xref:System.Reflection.ConstructorInfo> objeto que coincide con las marcas de enlace especificadas y muestra la firma del constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-629">The following example obtains the type of `MyClass1`, gets the <xref:System.Reflection.ConstructorInfo> object that matches the specified binding flags, and displays the constructor signature.</span></span>  
  
 [!code-cpp[Type_GetConstructor3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetConstructor3/CPP/type_getconstructor3.cpp#1)]
 [!code-csharp[Type_GetConstructor3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetConstructor3/CS/type_getconstructor3.cs#1)]
 [!code-vb[Type_GetConstructor3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetConstructor3/VB/type_getconstructor3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-630">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-630"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-631">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-631">-or-</span></span> 
<span data-ttu-id="60a97-632">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-632">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-633"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-633"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-634">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-634">-or-</span></span> 
 <span data-ttu-id="60a97-635"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-635"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-636">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-636">-or-</span></span> 
 <span data-ttu-id="60a97-637"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-637"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructorImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.ConstructorInfo GetConstructorImpl (System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.ConstructorInfo GetConstructorImpl(valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructorImpl(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::ConstructorInfo ^ GetConstructorImpl(System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructorImpl : System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.ConstructorInfo" Usage="type.GetConstructorImpl (bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-638">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-638">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-639">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-639">-or-</span></span> 
<span data-ttu-id="60a97-640">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-640">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-641">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-641">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-642">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-642">-or-</span></span> 
<span data-ttu-id="60a97-643">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-643">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="60a97-644">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y al diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la pila que se limpia.</span><span class="sxs-lookup"><span data-stu-id="60a97-644">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-645">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el constructor debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-645">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the constructor to get.</span></span>  
  
<span data-ttu-id="60a97-646">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-646">-or-</span></span> 
<span data-ttu-id="60a97-647">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un constructor que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-647">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a constructor that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-648">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-648">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-649">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-649">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-650">Cuando se invalida en una clase derivada, busca un constructor cuyos parámetros coincidan con los tipos y modificadores de argumento especificados, y aplica las restricciones de enlace especificadas y la convención de llamadas especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-650">When overridden in a derived class, searches for a constructor whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="60a97-651">Objeto <see cref="T:System.Reflection.ConstructorInfo" /> que representa el constructor que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-651">A <see cref="T:System.Reflection.ConstructorInfo" /> object representing the constructor that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-652">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-652">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-653">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-653">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-654">Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-654">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="60a97-655">Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="60a97-655">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="60a97-656">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-656">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-657">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-657">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-658">Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-658">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="60a97-659">Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-659">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span>  
  
 <span data-ttu-id="60a97-660">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-660">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-661">Este método implementa <xref:System.Type.GetConstructor%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-661">This method implements <xref:System.Type.GetConstructor%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-662">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-662"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-663">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-663">-or-</span></span> 
<span data-ttu-id="60a97-664">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-664">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-665"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-665"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-666">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-666">-or-</span></span> 
 <span data-ttu-id="60a97-667"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-667"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-668">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-668">-or-</span></span> 
 <span data-ttu-id="60a97-669"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-669"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-670">El tipo actual es <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-670">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetConstructors" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetConstructors">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-671">Obtiene los constructores del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-671">Gets the constructors of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo[] GetConstructors ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConstructors () As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors();" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]&#xA;override this.GetConstructors : unit -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-672">Devuelve todos los constructores públicos definidos para el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-672">Returns all the public constructors defined for the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-673">Matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representan todos los constructores de instancias públicos definidos para el objeto <see cref="T:System.Type" /> actual, pero sin incluir el inicializador de tipo (constructor estático).</span><span class="sxs-lookup"><span data-stu-id="60a97-673">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all the public instance constructors defined for the current <see cref="T:System.Type" />, but not including the type initializer (static constructor).</span></span> <span data-ttu-id="60a97-674">Si no se han definido constructores de instancia públicos para el objeto <see cref="T:System.Type" /> actual o si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico, se devuelve una matriz vacía de tipo <see cref="T:System.Reflection.ConstructorInfo" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-674">If no public instance constructors are defined for the current <see cref="T:System.Type" />, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method, an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> is returned.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-675">El <xref:System.Type.GetConstructors%2A> método no devuelve los constructores en un orden determinado, por ejemplo, el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-675">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="60a97-676">El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-676">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-677">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-677">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-678">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-678">Member Type</span></span>|<span data-ttu-id="60a97-679">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-679">Static</span></span>|<span data-ttu-id="60a97-680">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-680">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-681">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-681">Constructor</span></span>|<span data-ttu-id="60a97-682">No</span><span class="sxs-lookup"><span data-stu-id="60a97-682">No</span></span>|<span data-ttu-id="60a97-683">No</span><span class="sxs-lookup"><span data-stu-id="60a97-683">No</span></span>|  
|<span data-ttu-id="60a97-684">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-684">Field</span></span>|<span data-ttu-id="60a97-685">No</span><span class="sxs-lookup"><span data-stu-id="60a97-685">No</span></span>|<span data-ttu-id="60a97-686">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-686">Yes.</span></span> <span data-ttu-id="60a97-687">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-687">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-688">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-688">Event</span></span>|<span data-ttu-id="60a97-689">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-689">Not applicable</span></span>|<span data-ttu-id="60a97-690">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-690">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-691">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-691">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-692">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-692">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-693">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-693">Method</span></span>|<span data-ttu-id="60a97-694">No</span><span class="sxs-lookup"><span data-stu-id="60a97-694">No</span></span>|<span data-ttu-id="60a97-695">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-695">Yes.</span></span> <span data-ttu-id="60a97-696">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-696">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-697">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-697">Nested Type</span></span>|<span data-ttu-id="60a97-698">No</span><span class="sxs-lookup"><span data-stu-id="60a97-698">No</span></span>|<span data-ttu-id="60a97-699">No</span><span class="sxs-lookup"><span data-stu-id="60a97-699">No</span></span>|  
|<span data-ttu-id="60a97-700">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-700">Property</span></span>|<span data-ttu-id="60a97-701">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-701">Not applicable</span></span>|<span data-ttu-id="60a97-702">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-702">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-703">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-703">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-704">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-704">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-705">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-705">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-706">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-706">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-707">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-707">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-708">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-708">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-709">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-709">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-710">Esta sobrecarga del método llama a la <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga del método, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-710">This method overload calls the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-711">No encontrará a inicializadores de clase (.cctor).</span><span class="sxs-lookup"><span data-stu-id="60a97-711">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="60a97-712">Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-712">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-713">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-713">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-714">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-714">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-715">Por ejemplo, si clase `C<T>` tiene un constructor `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), que realiza la llamada <xref:System.Type.GetConstructors%2A> en `C<int>` devuelve un <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` en C# (`Sub New(ByVal t1 As Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-715">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-716">Si el actual <xref:System.Type> representa un parámetro de tipo genérico, la <xref:System.Type.GetConstructors%2A> método devuelve una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-716">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-717">En este ejemplo se muestra la salida de la <xref:System.Type.GetConstructors%2A> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="60a97-717">This example shows the output of the <xref:System.Type.GetConstructors%2A> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="60a97-718">El resultado de este código es:</span><span class="sxs-lookup"><span data-stu-id="60a97-718">The output of this code is:</span></span>  
  
 <span data-ttu-id="60a97-719">2</span><span class="sxs-lookup"><span data-stu-id="60a97-719">2</span></span>  
  
 <span data-ttu-id="60a97-720">False</span><span class="sxs-lookup"><span data-stu-id="60a97-720">False</span></span>  
  
 <span data-ttu-id="60a97-721">False</span><span class="sxs-lookup"><span data-stu-id="60a97-721">False</span></span>  
  
 <span data-ttu-id="60a97-722">Dado que el <xref:System.Type.GetConstructors> sobrecarga se utiliza solo <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, el constructor estático no se calcula mediante la `for` expresión ni se evalúa con `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="60a97-722">Because the <xref:System.Type.GetConstructors> overload uses only <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="60a97-723">Para buscar los constructores estáticos, utilice el <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> sobrecarga y pase la combinación (lógico `OR`) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, tal y como se muestra en el ejemplo de código siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-723">To find static constructors, use the <xref:System.Type.GetConstructors%28System.Reflection.BindingFlags%29> overload, and pass the combination (logical `OR`) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="60a97-724">Ahora, el resultado es:</span><span class="sxs-lookup"><span data-stu-id="60a97-724">Now the output is:</span></span>  
  
 <span data-ttu-id="60a97-725">3</span><span class="sxs-lookup"><span data-stu-id="60a97-725">3</span></span>  
  
 <span data-ttu-id="60a97-726">False</span><span class="sxs-lookup"><span data-stu-id="60a97-726">False</span></span>  
  
 <span data-ttu-id="60a97-727">True</span><span class="sxs-lookup"><span data-stu-id="60a97-727">True</span></span>  
  
 <span data-ttu-id="60a97-728">False</span><span class="sxs-lookup"><span data-stu-id="60a97-728">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetConstructors">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.ConstructorInfo[] GetConstructors (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.ConstructorInfo[] GetConstructors(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetConstructors(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetConstructors (bindingAttr As BindingFlags) As ConstructorInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::ConstructorInfo ^&gt; ^ GetConstructors(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetConstructors : System.Reflection.BindingFlags -&gt; System.Reflection.ConstructorInfo[]" Usage="type.GetConstructors bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetConstructors(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-729">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-729">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-730">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-730">-or-</span></span> 
<span data-ttu-id="60a97-731">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-731">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-732">Cuando se invalida en una clase derivada, busca los constructores definidos para el objeto <see cref="T:System.Type" /> actual, con las enumeraciones <see langword="BindingFlags" /> especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-732">When overridden in a derived class, searches for the constructors defined for the current <see cref="T:System.Type" />, using the specified <see langword="BindingFlags" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-733">Matriz de objetos <see cref="T:System.Reflection.ConstructorInfo" /> que representa todos los constructores definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas, incluido el inicializador de tipo si está definido.</span><span class="sxs-lookup"><span data-stu-id="60a97-733">An array of <see cref="T:System.Reflection.ConstructorInfo" /> objects representing all constructors defined for the current <see cref="T:System.Type" /> that match the specified binding constraints, including the type initializer if it is defined.</span></span> <span data-ttu-id="60a97-734">Devuelve una matriz vacía de tipo <see cref="T:System.Reflection.ConstructorInfo" /> si no se definen constructores para el objeto <see cref="T:System.Type" /> actual, si ninguno de los constructores definidos cumple las restricciones de enlace o si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-734">Returns an empty array of type <see cref="T:System.Reflection.ConstructorInfo" /> if no constructors are defined for the current <see cref="T:System.Type" />, if none of the defined constructors match the binding constraints, or if the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-735">El <xref:System.Type.GetConstructors%2A> método no devuelve los constructores en un orden determinado, por ejemplo, el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-735">The <xref:System.Type.GetConstructors%2A> method does not return constructors in a particular order, such as declaration order.</span></span> <span data-ttu-id="60a97-736">El código no debe depender del orden en que se devuelven los constructores, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-736">Your code must not depend on the order in which constructors are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-737">`bindingAttr` puede usarse para especificar si se deben devolver sólo los constructores públicos o constructores públicos y no públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-737">`bindingAttr` can be used to specify whether to return only public constructors or both public and non-public constructors.</span></span>  
  
 <span data-ttu-id="60a97-738">Si no existe una coincidencia exacta, la `binder` intentará convertir los tipos de parámetro especificados en la `types` matriz para seleccionar una coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-738">If an exact match does not exist, the `binder` will attempt to coerce the parameter types specified in the `types` array in order to select a match.</span></span> <span data-ttu-id="60a97-739">Si el `binder` no puede seleccionar una coincidencia, a continuación, `null` se devuelve.</span><span class="sxs-lookup"><span data-stu-id="60a97-739">If the `binder` is unable to select a match, then `null` is returned.</span></span>  
  
 <span data-ttu-id="60a97-740">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los constructores que deben incluirse en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-740">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which constructors to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-741">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-741">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-742">Especificar `BindingFlags.Public` para incluir los constructores públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-742">Specify `BindingFlags.Public` to include public constructors in the search.</span></span>  
  
-   <span data-ttu-id="60a97-743">Especificar `BindingFlags.NonPublic` para incluir constructores no públicos (es decir, constructores privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-743">Specify `BindingFlags.NonPublic` to include non-public constructors (that is, private, internal, and protected constructors) in the search.</span></span> <span data-ttu-id="60a97-744">No se devuelven los constructores de clases bases.</span><span class="sxs-lookup"><span data-stu-id="60a97-744">Constructors of base classes are not returned.</span></span>  
  
 <span data-ttu-id="60a97-745">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-745">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-746">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-746">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-747">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-747">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-748">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.ConstructorInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-748">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.ConstructorInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-749">Por ejemplo, si clase `C<T>` tiene un constructor `C(T t1)` (`Sub New(ByVal t1 As T)` en Visual Basic), que realiza la llamada <xref:System.Type.GetConstructors%2A> en `C<int>` devuelve un <xref:System.Reflection.ConstructorInfo> que representa `C(int t1)` en C# (`Sub New(ByVal t1 As Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-749">For example, if class `C<T>` has a constructor `C(T t1)` (`Sub New(ByVal t1 As T)` in Visual Basic), calling <xref:System.Type.GetConstructors%2A> on `C<int>` returns a <xref:System.Reflection.ConstructorInfo> that represents `C(int t1)` in C# (`Sub New(ByVal t1 As Integer)` in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-750">Si el actual <xref:System.Type> representa un parámetro de tipo genérico, la <xref:System.Type.GetConstructors%2A> método devuelve una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-750">If the current <xref:System.Type> represents a generic type parameter, the <xref:System.Type.GetConstructors%2A> method returns an empty array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-751">En este ejemplo se muestra la salida de la <xref:System.Type.GetConstructors> sobrecarga de una clase que tiene dos constructores de instancia y un constructor estático.</span><span class="sxs-lookup"><span data-stu-id="60a97-751">This example shows the output of the <xref:System.Type.GetConstructors> overload from a class that has two instance constructors and one static constructor.</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source1.cpp#1)]
 [!code-csharp[Classic Type.GetConstructors Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source1.cs#1)]
 [!code-vb[Classic Type.GetConstructors Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source1.vb#1)]  
  
 <span data-ttu-id="60a97-752">El resultado de este código es:</span><span class="sxs-lookup"><span data-stu-id="60a97-752">The output of this code is:</span></span>  
  
 <span data-ttu-id="60a97-753">2</span><span class="sxs-lookup"><span data-stu-id="60a97-753">2</span></span>  
  
 <span data-ttu-id="60a97-754">False</span><span class="sxs-lookup"><span data-stu-id="60a97-754">False</span></span>  
  
 <span data-ttu-id="60a97-755">False</span><span class="sxs-lookup"><span data-stu-id="60a97-755">False</span></span>  
  
 <span data-ttu-id="60a97-756">Dado que el <xref:System.Type.GetConstructors%2A> sobrecarga se utiliza solo <xref:System.Reflection.BindingFlags.Public> y <xref:System.Reflection.BindingFlags.Instance>, el constructor estático no se calcula mediante la `for` expresión ni se evalúa con `IsStatic`.</span><span class="sxs-lookup"><span data-stu-id="60a97-756">Because the <xref:System.Type.GetConstructors%2A> overload uses only <xref:System.Reflection.BindingFlags.Public> and <xref:System.Reflection.BindingFlags.Instance>, the static constructor is neither counted by the `for` expression nor evaluated by `IsStatic`.</span></span>  
  
 <span data-ttu-id="60a97-757">Para buscar los constructores estáticos, utilice el <xref:System.Type.GetConstructors%2A> sobrecarga y pásele la combinación (OR lógico) de <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, tal y como se muestra en el ejemplo de código siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-757">To find static constructors, use the <xref:System.Type.GetConstructors%2A> overload, and pass it the combination (logical OR) of <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType>, <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>, as shown in the following code example:</span></span>  
  
 [!code-cpp[Classic Type.GetConstructors Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CPP/source2.cpp#2)]
 [!code-csharp[Classic Type.GetConstructors Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/CS/source2.cs#2)]
 [!code-vb[Classic Type.GetConstructors Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.GetConstructors Example/VB/source2.vb#2)]  
  
 <span data-ttu-id="60a97-758">Ahora, el resultado es:</span><span class="sxs-lookup"><span data-stu-id="60a97-758">Now the output is:</span></span>  
  
 <span data-ttu-id="60a97-759">3</span><span class="sxs-lookup"><span data-stu-id="60a97-759">3</span></span>  
  
 <span data-ttu-id="60a97-760">False</span><span class="sxs-lookup"><span data-stu-id="60a97-760">False</span></span>  
  
 <span data-ttu-id="60a97-761">True</span><span class="sxs-lookup"><span data-stu-id="60a97-761">True</span></span>  
  
 <span data-ttu-id="60a97-762">False</span><span class="sxs-lookup"><span data-stu-id="60a97-762">False</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetConstructor(System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetDefaultMembers">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetDefaultMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetDefaultMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetDefaultMembers" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetDefaultMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetDefaultMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetDefaultMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetDefaultMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetDefaultMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-763">Busca los miembros definidos para el objeto <see cref="T:System.Type" /> actual cuya clase <see cref="T:System.Reflection.DefaultMemberAttribute" /> esté establecida.</span><span class="sxs-lookup"><span data-stu-id="60a97-763">Searches for the members defined for the current <see cref="T:System.Type" /> whose <see cref="T:System.Reflection.DefaultMemberAttribute" /> is set.</span></span></summary>
        <returns><span data-ttu-id="60a97-764">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros predeterminados del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-764">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all default members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-765">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-765">-or-</span></span> 
<span data-ttu-id="60a97-766">Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene miembros predeterminados.</span><span class="sxs-lookup"><span data-stu-id="60a97-766">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have default members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-767">El <xref:System.Type.GetDefaultMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-767">The <xref:System.Type.GetDefaultMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-768">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-768">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-769">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-769">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-770">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-770">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-771">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-771">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-772">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-772">Member Type</span></span>|<span data-ttu-id="60a97-773">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-773">Static</span></span>|<span data-ttu-id="60a97-774">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-774">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-775">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-775">Constructor</span></span>|<span data-ttu-id="60a97-776">No</span><span class="sxs-lookup"><span data-stu-id="60a97-776">No</span></span>|<span data-ttu-id="60a97-777">No</span><span class="sxs-lookup"><span data-stu-id="60a97-777">No</span></span>|  
|<span data-ttu-id="60a97-778">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-778">Field</span></span>|<span data-ttu-id="60a97-779">No</span><span class="sxs-lookup"><span data-stu-id="60a97-779">No</span></span>|<span data-ttu-id="60a97-780">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-780">Yes.</span></span> <span data-ttu-id="60a97-781">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-781">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-782">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-782">Event</span></span>|<span data-ttu-id="60a97-783">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-783">Not applicable</span></span>|<span data-ttu-id="60a97-784">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-784">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-785">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-785">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-786">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-786">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-787">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-787">Method</span></span>|<span data-ttu-id="60a97-788">No</span><span class="sxs-lookup"><span data-stu-id="60a97-788">No</span></span>|<span data-ttu-id="60a97-789">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-789">Yes.</span></span> <span data-ttu-id="60a97-790">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-790">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-791">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-791">Nested Type</span></span>|<span data-ttu-id="60a97-792">No</span><span class="sxs-lookup"><span data-stu-id="60a97-792">No</span></span>|<span data-ttu-id="60a97-793">No</span><span class="sxs-lookup"><span data-stu-id="60a97-793">No</span></span>|  
|<span data-ttu-id="60a97-794">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-794">Property</span></span>|<span data-ttu-id="60a97-795">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-795">Not applicable</span></span>|<span data-ttu-id="60a97-796">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-796">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-797">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-797">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-798">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-798">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-799">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-799">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-800">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-800">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-801">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-801">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-802">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-802">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-803">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-803">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-804">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-804">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span> <span data-ttu-id="60a97-805">Por ejemplo, si clase `C<T>` tiene una propiedad `P` que devuelve `T`, al llamar a <xref:System.Type.GetDefaultMembers%2A> en `C<int>` devuelve `int P` en C# (`Property P As Integer` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-805">For example, if class `C<T>` has a property `P` that returns `T`, calling <xref:System.Type.GetDefaultMembers%2A> on `C<int>` returns `int P` in C# (`Property P As Integer` in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-806">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-806">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-807">En el ejemplo siguiente se obtiene la información del miembro predeterminado de `MyClass` y muestra los miembros predeterminados.</span><span class="sxs-lookup"><span data-stu-id="60a97-807">The following example obtains the default member information of `MyClass` and displays the default members.</span></span>  
  
 [!code-cpp[Type_GetDefaultMembers#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetDefaultMembers/CPP/type_getdefaultmembers.cpp#1)]
 [!code-csharp[Type_GetDefaultMembers#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetDefaultMembers/CS/type_getdefaultmembers.cs#1)]
 [!code-vb[Type_GetDefaultMembers#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetDefaultMembers/VB/type_getdefaultmembers.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.DefaultMemberAttribute" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetElementType">
      <MemberSignature Language="C#" Value="public abstract Type GetElementType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetElementType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetElementType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetElementType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetElementType();" />
      <MemberSignature Language="F#" Value="abstract member GetElementType : unit -&gt; Type" Usage="type.GetElementType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-808">Cuando se invalida en una clase derivada, devuelve la clase <see cref="T:System.Type" /> del objeto englobado o al que hace referencia la matriz, el puntero o el tipo de referencia actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-808">When overridden in a derived class, returns the <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer or reference type.</span></span></summary>
        <returns><span data-ttu-id="60a97-809"><see cref="T:System.Type" /> del objeto englobado o al que hace referencia la matriz, puntero o tipo de referencia actual; o bien, <see langword="null" /> si el objeto <see cref="T:System.Type" /> actual no es una matriz o un puntero, o si no se pasa por referencia, o si representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o de un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-809">The <see cref="T:System.Type" /> of the object encompassed or referred to by the current array, pointer, or reference type, or <see langword="null" /> if the current <see cref="T:System.Type" /> is not an array or a pointer, or is not passed by reference, or represents a generic type or a type parameter in the definition of a generic type or generic method.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-810">Este método devuelve `null` para el <xref:System.Array> clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-810">This method returns `null` for the <xref:System.Array> class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-811">El ejemplo siguiente se muestra cómo utilizar el `GetElementType` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-811">The following example demonstrates using the `GetElementType` method.</span></span>  
  
 [!code-cpp[TestGetElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestGetElementType/CPP/TestGetElementType.cpp#1)]
 [!code-csharp[TestGetElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestGetElementType/CS/testgetelementtype.cs#1)]
 [!code-vb[TestGetElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestGetElementType/VB/testgetelementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
      </Docs>
    </Member>
    <Member MemberName="GetEnumName">
      <MemberSignature Language="C#" Value="public virtual string GetEnumName (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string GetEnumName(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumName(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumName (value As Object) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ GetEnumName(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member GetEnumName : obj -&gt; string&#xA;override this.GetEnumName : obj -&gt; string" Usage="type.GetEnumName value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60a97-812">Valor cuyo nombre se va a recuperar.</span><span class="sxs-lookup"><span data-stu-id="60a97-812">The value whose name is to be retrieved.</span></span></param>
        <summary><span data-ttu-id="60a97-813">Devuelve el nombre de la constante que tiene el valor especificado para el tipo de enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-813">Returns the name of the constant that has the specified value, for the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="60a97-814">Nombre del miembro del tipo de enumeración actual que tiene el valor especificado o <see langword="null" /> si no se encuentra tal constante.</span><span class="sxs-lookup"><span data-stu-id="60a97-814">The name of the member of the current enumeration type that has the specified value, or <see langword="null" /> if no such constant is found.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-815">El tipo actual no es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-815">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="60a97-816">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-816">-or-</span></span> 
 <span data-ttu-id="60a97-817"><paramref name="value" /> no es ni del tipo actual ni tiene el mismo tipo subyacente que el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-817"><paramref name="value" /> is neither of the current type nor does it have the same underlying type as the current type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-818">El valor de <paramref name="value" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-818"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumNames">
      <MemberSignature Language="C#" Value="public virtual string[] GetEnumNames ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string[] GetEnumNames() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumNames" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumNames () As String()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::String ^&gt; ^ GetEnumNames();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumNames : unit -&gt; string[]&#xA;override this.GetEnumNames : unit -&gt; string[]" Usage="type.GetEnumNames " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-819">Devuelve los nombres de los miembros del tipo de enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-819">Returns the names of the members of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="60a97-820">Una matriz que contiene los nombres de los miembros de la enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-820">An array that contains the names of the members of the enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-821">Los elementos de la matriz de valores devueltos se ordenan por los valores binarios (es decir, los valores sin signo) de las constantes enumeradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-821">The elements of the return value array are sorted by the binary values (that is, the unsigned values) of the enumerated constants.</span></span> <span data-ttu-id="60a97-822">Si la matriz contiene constantes enumeradas con el mismo valor, se especifica el orden de los nombres correspondientes.</span><span class="sxs-lookup"><span data-stu-id="60a97-822">If the array contains enumerated constants with the same value, the order of their corresponding names is unspecified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-823">El tipo actual no es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-823">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumUnderlyingType">
      <MemberSignature Language="C#" Value="public virtual Type GetEnumUnderlyingType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetEnumUnderlyingType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumUnderlyingType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumUnderlyingType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetEnumUnderlyingType();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumUnderlyingType : unit -&gt; Type&#xA;override this.GetEnumUnderlyingType : unit -&gt; Type" Usage="type.GetEnumUnderlyingType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-824">Devuelve el tipo subyacente del tipo de enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-824">Returns the underlying type of the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="60a97-825">Tipo subyacente de la enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-825">The underlying type of the current enumeration.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-826">De forma predeterminada, el tipo subyacente de una enumeración en C# y Visual Basic es <xref:System.Int32>.</span><span class="sxs-lookup"><span data-stu-id="60a97-826">By default, the underlying type of an enumeration in C# and Visual Basic is <xref:System.Int32>.</span></span> <span data-ttu-id="60a97-827">Se pueden especificar otros tipos de enteros.</span><span class="sxs-lookup"><span data-stu-id="60a97-827">Other integer types can be specified.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-828">El tipo actual no es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-828">The current type is not an enumeration.</span></span>  
  
<span data-ttu-id="60a97-829">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-829">-or-</span></span> 
<span data-ttu-id="60a97-830">El tipo de enumeración no es válido, ya que contiene más de un campo de instancia.</span><span class="sxs-lookup"><span data-stu-id="60a97-830">The enumeration type is not valid, because it contains more than one instance field.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumValues">
      <MemberSignature Language="C#" Value="public virtual Array GetEnumValues ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Array GetEnumValues() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEnumValues" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEnumValues () As Array" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Array ^ GetEnumValues();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumValues : unit -&gt; Array&#xA;override this.GetEnumValues : unit -&gt; Array" Usage="type.GetEnumValues " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Array</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-831">Devuelve una matriz con los valores de las constantes en el tipo de enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-831">Returns an array of the values of the constants in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="60a97-832">Matriz que contiene los valores.</span><span class="sxs-lookup"><span data-stu-id="60a97-832">An array that contains the values.</span></span> <span data-ttu-id="60a97-833">Los elementos de la matriz se ordenan en función de los valores binarios (es decir, los valores sin firmar) de las constantes de enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-833">The elements of the array are sorted by the binary values (that is, the unsigned values) of the enumeration constants.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-834">El tipo actual no es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-834">The current type is not an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvent">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-835">Obtiene un evento específico declarado o heredado por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-835">Gets a specific event declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public System.Reflection.EventInfo GetEvent (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetEvent (name As String) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::EventInfo ^ GetEvent(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string -&gt; System.Reflection.EventInfo&#xA;override this.GetEvent : string -&gt; System.Reflection.EventInfo" Usage="type.GetEvent name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-836">Cadena que contiene el nombre de un evento que la clase <see cref="T:System.Type" /> actual declaró o heredó.</span><span class="sxs-lookup"><span data-stu-id="60a97-836">The string containing the name of an event that is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <summary><span data-ttu-id="60a97-837">Devuelve el objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento público especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-837">Returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified public event.</span></span></summary>
        <returns><span data-ttu-id="60a97-838">Objeto que representa el evento público especificado que declara o hereda el <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-838">The object representing the specified public event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-839">Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-839">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="60a97-840">En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-840">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-841">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-841">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-842">La búsqueda incluye los eventos de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-842">The search includes public static and public instance events.</span></span>  
  
 <span data-ttu-id="60a97-843">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-843">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-844">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-844">Member Type</span></span>|<span data-ttu-id="60a97-845">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-845">Static</span></span>|<span data-ttu-id="60a97-846">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-846">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-847">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-847">Constructor</span></span>|<span data-ttu-id="60a97-848">No</span><span class="sxs-lookup"><span data-stu-id="60a97-848">No</span></span>|<span data-ttu-id="60a97-849">No</span><span class="sxs-lookup"><span data-stu-id="60a97-849">No</span></span>|  
|<span data-ttu-id="60a97-850">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-850">Field</span></span>|<span data-ttu-id="60a97-851">No</span><span class="sxs-lookup"><span data-stu-id="60a97-851">No</span></span>|<span data-ttu-id="60a97-852">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-852">Yes.</span></span> <span data-ttu-id="60a97-853">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-853">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-854">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-854">Event</span></span>|<span data-ttu-id="60a97-855">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-855">Not applicable</span></span>|<span data-ttu-id="60a97-856">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-856">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-857">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-857">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-858">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-858">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-859">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-859">Method</span></span>|<span data-ttu-id="60a97-860">No</span><span class="sxs-lookup"><span data-stu-id="60a97-860">No</span></span>|<span data-ttu-id="60a97-861">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-861">Yes.</span></span> <span data-ttu-id="60a97-862">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-862">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-863">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-863">Nested Type</span></span>|<span data-ttu-id="60a97-864">No</span><span class="sxs-lookup"><span data-stu-id="60a97-864">No</span></span>|<span data-ttu-id="60a97-865">No</span><span class="sxs-lookup"><span data-stu-id="60a97-865">No</span></span>|  
|<span data-ttu-id="60a97-866">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-866">Property</span></span>|<span data-ttu-id="60a97-867">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-867">Not applicable</span></span>|<span data-ttu-id="60a97-868">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-868">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-869">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-869">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-870">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-870">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-871">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-871">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-872">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-872">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-873">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-873">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-874">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-874">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-875">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-875">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-876">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-876">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-877">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-877">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-878">En el ejemplo siguiente se crea un <xref:System.Reflection.EventInfo> de objetos y obtiene el evento de una clase de botón para el evento especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-878">The following example creates an <xref:System.Reflection.EventInfo> object and gets the event for a button class for the specified event.</span></span>  
  
 [!code-cpp[Type_GetEvent#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetEvent/CPP/type_getevent.cpp#1)]
 [!code-csharp[Type_GetEvent#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetEvent/CS/type_getevent.cs#1)]
 [!code-vb[Type_GetEvent#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetEvent/VB/type_getevent.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-879">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-879"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <Member MemberName="GetEvent">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo GetEvent (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo GetEvent(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvent(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvent (name As String, bindingAttr As BindingFlags) As EventInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::EventInfo ^ GetEvent(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvent : string * System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo" Usage="type.GetEvent (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvent(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-880">Cadena que contiene el nombre de un evento que la clase <see cref="T:System.Type" /> actual declara o hereda.</span><span class="sxs-lookup"><span data-stu-id="60a97-880">The string containing the name of an event which is declared or inherited by the current <see cref="T:System.Type" />.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-881">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-881">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-882">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-882">-or-</span></span> 
<span data-ttu-id="60a97-883">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-883">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-884">Cuando se invalida en una clase derivada, devuelve el objeto <see cref="T:System.Reflection.EventInfo" /> que representa el evento especificado y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-884">When overridden in a derived class, returns the <see cref="T:System.Reflection.EventInfo" /> object representing the specified event, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-885">Objeto que representa el evento especificado que declara o hereda el <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-885">The object representing the specified event that is declared or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-886">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los eventos que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-886">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-887">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-887">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-888">Especificar `BindingFlags.Public` para incluir eventos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-888">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="60a97-889">Especificar `BindingFlags.NonPublic` para incluir eventos no públicos (es decir, los eventos protegidos, internos y privados) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-889">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-890">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-890">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-891">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-891">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-892">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-892">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-893">`BindingFlags.DeclaredOnly` para buscar sólo los eventos declarados en el <xref:System.Type>, no los eventos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-893">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-894">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-894">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-895">Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-895">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="60a97-896">En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-896">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-897">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-897">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-898">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-898">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-899">El siguiente ejemplo de código utiliza el <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> para buscar un tipo para un evento público o no público denominado "Click" que no sea `static` (`Shared` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-899">The following code example uses the <xref:System.Type.GetEvent%28System.String%2CSystem.Reflection.BindingFlags%29> method to search a type for a public or non-public event named "Click" that is not `static` (`Shared` in Visual Basic).</span></span>  
  
 [!code-cpp[Type_GetEvent1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevent1/CPP/type_getevent1.cpp#1)]
 [!code-csharp[Type_GetEvent1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevent1/CS/type_getevent1.cs#1)]
 [!code-vb[Type_GetEvent1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevent1/VB/type_getevent1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-900">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-900"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvents" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetEvents">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-901">Obtiene los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-901">Gets the events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.EventInfo[] GetEvents ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetEvents () As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents();" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : unit -&gt; System.Reflection.EventInfo[]&#xA;override this.GetEvents : unit -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-902">Devuelve todos los eventos públicos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-902">Returns all the public events that are declared or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-903">Matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa todos los eventos públicos declarados o heredados por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-903">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all the public events which are declared or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-904">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-904">-or-</span></span> 
<span data-ttu-id="60a97-905">Matriz vacía de tipo <see cref="T:System.Reflection.EventInfo" /> si el objeto actual <see cref="T:System.Type" /> no tiene eventos públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-905">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have public events.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-906">Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-906">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="60a97-907">En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-907">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-908">El <xref:System.Type.GetEvents%2A> método no devuelve eventos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-908">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-909">El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-909">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-910">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-910">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-911">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-911">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-912">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-912">Member Type</span></span>|<span data-ttu-id="60a97-913">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-913">Static</span></span>|<span data-ttu-id="60a97-914">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-914">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-915">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-915">Constructor</span></span>|<span data-ttu-id="60a97-916">No</span><span class="sxs-lookup"><span data-stu-id="60a97-916">No</span></span>|<span data-ttu-id="60a97-917">No</span><span class="sxs-lookup"><span data-stu-id="60a97-917">No</span></span>|  
|<span data-ttu-id="60a97-918">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-918">Field</span></span>|<span data-ttu-id="60a97-919">No</span><span class="sxs-lookup"><span data-stu-id="60a97-919">No</span></span>|<span data-ttu-id="60a97-920">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-920">Yes.</span></span> <span data-ttu-id="60a97-921">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-921">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-922">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-922">Event</span></span>|<span data-ttu-id="60a97-923">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-923">Not applicable</span></span>|<span data-ttu-id="60a97-924">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-924">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-925">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-925">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-926">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-926">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-927">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-927">Method</span></span>|<span data-ttu-id="60a97-928">No</span><span class="sxs-lookup"><span data-stu-id="60a97-928">No</span></span>|<span data-ttu-id="60a97-929">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-929">Yes.</span></span> <span data-ttu-id="60a97-930">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-930">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-931">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-931">Nested Type</span></span>|<span data-ttu-id="60a97-932">No</span><span class="sxs-lookup"><span data-stu-id="60a97-932">No</span></span>|<span data-ttu-id="60a97-933">No</span><span class="sxs-lookup"><span data-stu-id="60a97-933">No</span></span>|  
|<span data-ttu-id="60a97-934">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-934">Property</span></span>|<span data-ttu-id="60a97-935">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-935">Not applicable</span></span>|<span data-ttu-id="60a97-936">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-936">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-937">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-937">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-938">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-938">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-939">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-939">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-940">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-940">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-941">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-941">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-942">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-942">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-943">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-943">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-944">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-944">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-945">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-945">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-946">En el ejemplo siguiente se obtiene una matriz de <xref:System.Reflection.EventInfo> los objetos, obtiene todos los eventos de un `Button` clase y muestra los nombres de evento.</span><span class="sxs-lookup"><span data-stu-id="60a97-946">The following example obtains an array of <xref:System.Reflection.EventInfo> objects, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="60a97-947">Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:</span><span class="sxs-lookup"><span data-stu-id="60a97-947">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents1.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents1#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents1/CPP/type_getevents1.cpp#1)]
 [!code-csharp[Type_GetEvents1#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents1/CS/type_getevents1.cs#1)]
 [!code-vb[Type_GetEvents1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents1/VB/type_getevents1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetEvents">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.EventInfo[] GetEvents (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.EventInfo[] GetEvents(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetEvents(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetEvents (bindingAttr As BindingFlags) As EventInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::EventInfo ^&gt; ^ GetEvents(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetEvents : System.Reflection.BindingFlags -&gt; System.Reflection.EventInfo[]" Usage="type.GetEvents bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetEvents(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.EventInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-948">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-948">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-949">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-949">-or-</span></span> 
<span data-ttu-id="60a97-950">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-950">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-951">Cuando se invalida en una clase derivada, busca los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-951">When overridden in a derived class, searches for events that are declared or inherited by the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-952">Matriz de objetos <see cref="T:System.Reflection.EventInfo" /> que representa todos los eventos declarados o heredados por el objeto <see cref="T:System.Type" /> actual que cumplen las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-952">An array of <see cref="T:System.Reflection.EventInfo" /> objects representing all events that are declared or inherited by the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="60a97-953">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-953">-or-</span></span> 
<span data-ttu-id="60a97-954">Matriz vacía de tipo <see cref="T:System.Reflection.EventInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene eventos o si ninguno de los eventos coincide con las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-954">An empty array of type <see cref="T:System.Reflection.EventInfo" />, if the current <see cref="T:System.Type" /> does not have events, or if none of the events match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-955">El <xref:System.Type.GetEvents%2A> método no devuelve eventos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-955">The <xref:System.Type.GetEvents%2A> method does not return events in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-956">El código no debe depender del orden en que se devuelven los eventos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-956">Your code must not depend on the order in which events are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-957">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los eventos que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-957">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which events to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-958">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-958">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-959">Especificar `BindingFlags.Public` para incluir eventos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-959">Specify `BindingFlags.Public` to include public events in the search.</span></span>  
  
-   <span data-ttu-id="60a97-960">Especificar `BindingFlags.NonPublic` para incluir eventos no públicos (es decir, los eventos protegidos, internos y privados) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-960">Specify `BindingFlags.NonPublic` to include non-public events (that is, private, internal, and protected events) in the search.</span></span> <span data-ttu-id="60a97-961">Solo se devuelven eventos internos de las clases base; y protegidos no se devuelven los eventos privados de clases base.</span><span class="sxs-lookup"><span data-stu-id="60a97-961">Only protected and internal events on base classes are returned; private events on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="60a97-962">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-962">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-963">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-963">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-964">`BindingFlags.DeclaredOnly` para buscar sólo los eventos declarados en el <xref:System.Type>, no los eventos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-964">`BindingFlags.DeclaredOnly` to search only the events declared on the <xref:System.Type>, not events that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-965">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-965">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-966">Un evento se considera público para la reflexión si tiene al menos un método o un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-966">An event is considered public to reflection if it has at least one method or accessor that is public.</span></span> <span data-ttu-id="60a97-967">En caso contrario, el evento se considera privado, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-967">Otherwise the event is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-968">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.EventInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-968">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.EventInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-969">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los eventos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-969">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the events of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-970">En el ejemplo siguiente se obtiene una matriz de <xref:System.Reflection.EventInfo> objetos que coinciden con las marcas de enlace especificadas, obtiene todos los eventos de un `Button` clase y muestra los nombres de evento.</span><span class="sxs-lookup"><span data-stu-id="60a97-970">The following example obtains an array of <xref:System.Reflection.EventInfo> objects that match the specified binding flags, gets all the events for a `Button` class, and displays the event names.</span></span> <span data-ttu-id="60a97-971">Para compilar el ejemplo de Visual Basic, use la siguiente línea de comandos:</span><span class="sxs-lookup"><span data-stu-id="60a97-971">To compile the Visual Basic example, use the following command line:</span></span>  
  
 `vbc type_getevents2.vb /r:System.Windows.Forms.dll /r:System.dll`  
  
 [!code-cpp[Type_GetEvents2#1](~/samples/snippets/cpp/VS_Snippets_CLR/type_getevents2/CPP/type_getevents2.cpp#1)]
 [!code-csharp[Type_GetEvents2#1](~/samples/snippets/csharp/VS_Snippets_CLR/type_getevents2/CS/type_getevents2.cs#1)]
 [!code-vb[Type_GetEvents2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/type_getevents2/VB/type_getevents2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.EventInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetEvent(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetField">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-972">Obtiene un campo específico del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-972">Gets a specific field of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo GetField (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetField (name As String) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::FieldInfo ^ GetField(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string -&gt; System.Reflection.FieldInfo&#xA;override this.GetField : string -&gt; System.Reflection.FieldInfo" Usage="type.GetField name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-973">Cadena que contiene el nombre del campo de datos que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-973">The string containing the name of the data field to get.</span></span></param>
        <summary><span data-ttu-id="60a97-974">Busca el campo público con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-974">Searches for the public field with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-975">Objeto que representa el campo público con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-975">An object representing the public field with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-976">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-976">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-977">La búsqueda incluye los campos de instancia públicos y estáticos públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-977">The search includes public static and public instance fields.</span></span>  
  
 <span data-ttu-id="60a97-978">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-978">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-979">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-979">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-980">En el ejemplo siguiente se obtiene el `Type` de objeto para la clase especificada, se obtiene el <xref:System.Reflection.FieldInfo> objeto para el campo y muestra el valor del campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-980">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#1)]
 [!code-csharp[Type_GetField#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#1)]
 [!code-vb[Type_GetField#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-981">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-981"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-982">Este objeto <see cref="T:System.Type" /> es un <see cref="T:System.Reflection.Emit.TypeBuilder" /> a cuyo método <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> aún no se ha llamado.</span><span class="sxs-lookup"><span data-stu-id="60a97-982">This <see cref="T:System.Type" /> object is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> whose <see cref="M:System.Reflection.Emit.TypeBuilder.CreateType" /> method has not yet been called.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <Member MemberName="GetField">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo GetField (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo GetField(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetField (name As String, bindingAttr As BindingFlags) As FieldInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Reflection::FieldInfo ^ GetField(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetField : string * System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo" Usage="type.GetField (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetField(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-983">Cadena que contiene el nombre del campo de datos que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-983">The string containing the name of the data field to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-984">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-984">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-985">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-985">-or-</span></span> 
<span data-ttu-id="60a97-986">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-986">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-987">Busca el campo especificado mediante las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-987">Searches for the specified field, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-988">Objeto que representa el campo que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-988">An object representing the field that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-989">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-989">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-990">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-990">Member Type</span></span>|<span data-ttu-id="60a97-991">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-991">Static</span></span>|<span data-ttu-id="60a97-992">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-992">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-993">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-993">Constructor</span></span>|<span data-ttu-id="60a97-994">No</span><span class="sxs-lookup"><span data-stu-id="60a97-994">No</span></span>|<span data-ttu-id="60a97-995">No</span><span class="sxs-lookup"><span data-stu-id="60a97-995">No</span></span>|  
|<span data-ttu-id="60a97-996">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-996">Field</span></span>|<span data-ttu-id="60a97-997">No</span><span class="sxs-lookup"><span data-stu-id="60a97-997">No</span></span>|<span data-ttu-id="60a97-998">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-998">Yes.</span></span> <span data-ttu-id="60a97-999">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-999">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1000">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1000">Event</span></span>|<span data-ttu-id="60a97-1001">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1001">Not applicable</span></span>|<span data-ttu-id="60a97-1002">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1002">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1003">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1003">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1004">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1004">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1005">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1005">Method</span></span>|<span data-ttu-id="60a97-1006">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1006">No</span></span>|<span data-ttu-id="60a97-1007">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1007">Yes.</span></span> <span data-ttu-id="60a97-1008">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1008">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1009">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1009">Nested Type</span></span>|<span data-ttu-id="60a97-1010">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1010">No</span></span>|<span data-ttu-id="60a97-1011">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1011">No</span></span>|  
|<span data-ttu-id="60a97-1012">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1012">Property</span></span>|<span data-ttu-id="60a97-1013">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1013">Not applicable</span></span>|<span data-ttu-id="60a97-1014">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1014">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1015">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1015">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1016">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1016">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1017">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1017">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1018">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1018">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1019">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1019">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1020">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1020">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1021">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1021">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1022">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir qué campos desea incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1022">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1023">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1023">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1024">Especificar `BindingFlags.Public` para incluir campos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1024">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1025">Especificar `BindingFlags.NonPublic` para incluir campos no públicos (es decir, campos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1025">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1026">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1026">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1027">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1027">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1028">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1028">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1029">`BindingFlags.DeclaredOnly` para buscar solo los campos declarados en el <xref:System.Type>, no los campos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1029">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1030">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1030">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1031">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1031">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1032">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1032">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1033">En el ejemplo siguiente se obtiene el `Type` de objeto para la clase especificada, se obtiene el <xref:System.Reflection.FieldInfo> objeto para el campo que coincide con las marcas de enlace especificadas y muestra el valor del campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1033">The following example gets the `Type` object for the specified class, obtains the <xref:System.Reflection.FieldInfo> object for the field that matches the specified binding flags, and displays the value of the field.</span></span>  
  
 [!code-cpp[Type_GetField#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetField/CPP/type_getfield.cpp#2)]
 [!code-csharp[Type_GetField#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetField/CS/type_getfield.cs#2)]
 [!code-vb[Type_GetField#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetField/VB/type_getfield.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1034">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1034"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetFields" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetFields">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1035">Obtiene los campos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1035">Gets the fields of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public System.Reflection.FieldInfo[] GetFields ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields" />
      <MemberSignature Language="VB.NET" Value="Public Function GetFields () As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields();" />
      <MemberSignature Language="F#" Value="abstract member GetFields : unit -&gt; System.Reflection.FieldInfo[]&#xA;override this.GetFields : unit -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1036">Devuelve todos los campos públicos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1036">Returns all the public fields of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1037">Matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos los campos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1037">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all the public fields defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-1038">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1038">-or-</span></span> 
<span data-ttu-id="60a97-1039">Matriz vacía de tipo <see cref="T:System.Reflection.FieldInfo" /> si no hay campos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1039">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no public fields are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1040">El <xref:System.Type.GetFields%2A> método no devuelve los campos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1040">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1041">El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1041">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1042">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1042">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1043">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1043">Member Type</span></span>|<span data-ttu-id="60a97-1044">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1044">Static</span></span>|<span data-ttu-id="60a97-1045">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1045">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1046">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1046">Constructor</span></span>|<span data-ttu-id="60a97-1047">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1047">No</span></span>|<span data-ttu-id="60a97-1048">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1048">No</span></span>|  
|<span data-ttu-id="60a97-1049">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1049">Field</span></span>|<span data-ttu-id="60a97-1050">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1050">No</span></span>|<span data-ttu-id="60a97-1051">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1051">Yes.</span></span> <span data-ttu-id="60a97-1052">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1052">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1053">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1053">Event</span></span>|<span data-ttu-id="60a97-1054">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1054">Not applicable</span></span>|<span data-ttu-id="60a97-1055">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1055">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1056">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1056">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1057">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1057">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1058">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1058">Method</span></span>|<span data-ttu-id="60a97-1059">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1059">No</span></span>|<span data-ttu-id="60a97-1060">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1060">Yes.</span></span> <span data-ttu-id="60a97-1061">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1061">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1062">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1062">Nested Type</span></span>|<span data-ttu-id="60a97-1063">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1063">No</span></span>|<span data-ttu-id="60a97-1064">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1064">No</span></span>|  
|<span data-ttu-id="60a97-1065">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1065">Property</span></span>|<span data-ttu-id="60a97-1066">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1066">Not applicable</span></span>|<span data-ttu-id="60a97-1067">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1067">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1068">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1068">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1069">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1069">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1070">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1070">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1071">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1071">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1072">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1072">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1073">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1073">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1074">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1074">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1075">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1075">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1076">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos públicos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1076">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1077">El ejemplo siguiente muestra un uso de la `GetFields()` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1077">The following example shows a use of the `GetFields()` method.</span></span>  
  
 [!code-cpp[FieldInfo_IsSpecialName#1](~/samples/snippets/cpp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CPP/fieldinfo_isspecialname.cpp#1)]
 [!code-csharp[FieldInfo_IsSpecialName#1](~/samples/snippets/csharp/VS_Snippets_CLR/FieldInfo_IsSpecialName/CS/fieldinfo_isspecialname.cs#1)]
 [!code-vb[FieldInfo_IsSpecialName#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/FieldInfo_IsSpecialName/VB/fieldinfo_isspecialname.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetFields">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.FieldInfo[] GetFields (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.FieldInfo[] GetFields(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetFields(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetFields (bindingAttr As BindingFlags) As FieldInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::FieldInfo ^&gt; ^ GetFields(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetFields : System.Reflection.BindingFlags -&gt; System.Reflection.FieldInfo[]" Usage="type.GetFields bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetFields(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.FieldInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-1078">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1078">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1079">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1079">-or-</span></span> 
<span data-ttu-id="60a97-1080">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1080">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1081">Cuando se invalida en una clase derivada, busca los campos definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1081">When overridden in a derived class, searches for the fields defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1082">Matriz de objetos <see cref="T:System.Reflection.FieldInfo" /> que representa todos los campos definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1082">An array of <see cref="T:System.Reflection.FieldInfo" /> objects representing all fields defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="60a97-1083">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1083">-or-</span></span> 
<span data-ttu-id="60a97-1084">Matriz vacía de tipo <see cref="T:System.Reflection.FieldInfo" /> si no se han definido campos para el objeto <see cref="T:System.Type" /> actual o si ninguno de los campos definidos coincide con las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1084">An empty array of type <see cref="T:System.Reflection.FieldInfo" />, if no fields are defined for the current <see cref="T:System.Type" />, or if none of the defined fields match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1085">El <xref:System.Type.GetFields%2A> método no devuelve los campos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1085">The <xref:System.Type.GetFields%2A> method does not return fields in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1086">El código no debe depender del orden en que se devuelven los campos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1086">Your code must not depend on the order in which fields are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1087">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir qué campos desea incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1087">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which fields to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1088">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1088">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1089">Especificar `BindingFlags.Public` para incluir campos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1089">Specify `BindingFlags.Public` to include public fields in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1090">Especificar `BindingFlags.NonPublic` para incluir campos no públicos (es decir, campos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1090">Specify `BindingFlags.NonPublic` to include non-public fields (that is, private, internal, and protected fields) in the search.</span></span> <span data-ttu-id="60a97-1091">Solo protegido y se devuelven los campos internos en las clases base; no se devuelven los campos privados de las clases base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1091">Only protected and internal fields on base classes are returned; private fields on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="60a97-1092">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1092">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1093">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1093">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1094">`BindingFlags.DeclaredOnly` para buscar solo los campos declarados en el <xref:System.Type>, no los campos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1094">`BindingFlags.DeclaredOnly` to search only the fields declared on the <xref:System.Type>, not fields that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1095">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1095">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1096">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.FieldInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1096">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.FieldInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1097">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en los campos públicos de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1097">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the public fields of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1098">El ejemplo siguiente muestra un uso de la `GetFields(BindingFlags)` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1098">The following example shows a use of the `GetFields(BindingFlags)` method.</span></span>  
  
 [!code-cpp[Classic MethodBase.Attributes Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CPP/source.cpp#1)]
 [!code-csharp[Classic MethodBase.Attributes Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/CS/source.cs#1)]
 [!code-vb[Classic MethodBase.Attributes Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic MethodBase.Attributes Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.FieldInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetField(System.String,System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetGenericArguments">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericArguments ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericArguments() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericArguments" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericArguments () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericArguments();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericArguments : unit -&gt; Type[]&#xA;override this.GetGenericArguments : unit -&gt; Type[]" Usage="type.GetGenericArguments " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1099">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico o los parámetros de tipo de una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1099">Returns an array of <see cref="T:System.Type" /> objects that represent the type arguments of a closed generic type or the type parameters of a generic type definition.</span></span></summary>
        <returns><span data-ttu-id="60a97-1100">Matriz de objetos <see cref="T:System.Type" /> que representan los argumentos de tipo de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1100">An array of <see cref="T:System.Type" /> objects that represent the type arguments of a generic type.</span></span> <span data-ttu-id="60a97-1101">Devuelve una matriz vacía si el tipo actual no es un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1101">Returns an empty array if the current type is not a generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1102">Los elementos de matriz se devuelven en el orden en que aparecen en la lista de argumentos de tipo para el tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1102">The array elements are returned in the order in which they appear in the list of type arguments for the generic type.</span></span>  
  
-   <span data-ttu-id="60a97-1103">Si el tipo actual es un tipo construido cerrado (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `false`), la matriz devuelta por la <xref:System.Type.GetGenericArguments%2A> método contiene los tipos que se han asignado a los parámetros de tipo genérico de la definición de tipo genérico .</span><span class="sxs-lookup"><span data-stu-id="60a97-1103">If the current type is a closed constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `false`), the array returned by the <xref:System.Type.GetGenericArguments%2A> method contains the types that have been assigned to the generic type parameters of the generic type definition.</span></span>  
  
-   <span data-ttu-id="60a97-1104">Si el tipo actual es una definición de tipo genérico, la matriz contiene los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1104">If the current type is a generic type definition, the array contains the type parameters.</span></span>  
  
-   <span data-ttu-id="60a97-1105">Si el tipo actual es un tipo construido abierto (es decir, el <xref:System.Type.ContainsGenericParameters%2A> propiedad devuelve `true`) en los tipos específicos no se asignaron a todos los parámetros de tipo y parámetros de tipo envolvente métodos ni tipos genéricos, contiene la matriz tipos y parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1105">If the current type is an open constructed type (that is, the <xref:System.Type.ContainsGenericParameters%2A> property returns `true`) in which specific types have not been assigned to all of the type parameters and type parameters of enclosing generic types or methods, the array contains both types and type parameters.</span></span> <span data-ttu-id="60a97-1106">Use el <xref:System.Type.IsGenericParameter%2A> propiedad para distinguirlos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1106">Use the <xref:System.Type.IsGenericParameter%2A> property to tell them apart.</span></span> <span data-ttu-id="60a97-1107">Para ver una demostración de este escenario, vea el ejemplo de código para el <xref:System.Type.ContainsGenericParameters%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1107">For a demonstration of this scenario, see the code example for the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1108">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1108">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1109">El siguiente ejemplo de código utiliza el <xref:System.Type.GetGenericArguments%2A> método para mostrar los argumentos de tipo de un tipo construido y los parámetros de tipo de su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1109">The following code example uses the <xref:System.Type.GetGenericArguments%2A> method to display the type arguments of a constructed type and the type parameters of its generic type definition.</span></span>  
  
 <span data-ttu-id="60a97-1110">Este ejemplo de código forma parte de un ejemplo más extenso proporcionado para el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1110">This code example is part of a larger example provided for the <xref:System.Type.IsGenericTypeDefinition%2A> property.</span></span> <span data-ttu-id="60a97-1111">Vea el ejemplo más extenso de salida de ejemplo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1111">See the larger example for sample output.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericTypeDefinition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-1112">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1112">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="60a97-1113">Las clases derivadas deben proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-1113">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-1114">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-1114">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-1115">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-1115">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericParameterConstraints">
      <MemberSignature Language="C#" Value="public virtual Type[] GetGenericParameterConstraints ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetGenericParameterConstraints() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericParameterConstraints" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericParameterConstraints () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetGenericParameterConstraints();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericParameterConstraints : unit -&gt; Type[]&#xA;override this.GetGenericParameterConstraints : unit -&gt; Type[]" Usage="type.GetGenericParameterConstraints " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1116">Devuelve una matriz de objetos <see cref="T:System.Type" /> que representan las restricciones en el parámetro de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1116">Returns an array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></summary>
        <returns><span data-ttu-id="60a97-1117">Matriz de objetos <see cref="T:System.Type" /> que representan las restricciones en el parámetro de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1117">An array of <see cref="T:System.Type" /> objects that represent the constraints on the current generic type parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1118">Cada restricción en un parámetro de tipo genérico se expresa como un <xref:System.Type> objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1118">Each constraint on a generic type parameter is expressed as a <xref:System.Type> object.</span></span> <span data-ttu-id="60a97-1119">Use la <xref:System.Type.IsClass%2A> propiedad para determinar si una restricción es la restricción de clase base; si la propiedad devuelve `false`, la restricción es una restricción de interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1119">Use the <xref:System.Type.IsClass%2A> property to determine whether a constraint is the base class constraint; if the property returns `false`, the constraint is an interface constraint.</span></span> <span data-ttu-id="60a97-1120">Si un parámetro de tipo tiene ninguna restricción de clase y no hay restricciones de interfaz, se devuelve una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1120">If a type parameter has no class constraint and no interface constraints, an empty array is returned.</span></span>  
  
 <span data-ttu-id="60a97-1121">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1121">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1122">El ejemplo de código siguiente define un tipo genérico `Test` con dos parámetros de tipo que tienen distintas restricciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-1122">The following code example defines a generic type `Test` with two type parameters that have different constraints.</span></span> <span data-ttu-id="60a97-1123">Cuando se ejecuta el programa, se examinan las restricciones mediante la <xref:System.Type.GenericParameterAttributes%2A> propiedad y el <xref:System.Type.GetGenericParameterConstraints%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1123">When the program executes, the constraints are examined using the <xref:System.Type.GenericParameterAttributes%2A> property and the <xref:System.Type.GetGenericParameterConstraints%2A> method.</span></span>  
  
 [!code-cpp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericParameterConstraints#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericParameterConstraints/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-1124">El objeto <see cref="T:System.Type" /> actual no es un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1124">The current <see cref="T:System.Type" /> object is not a generic type parameter.</span></span> <span data-ttu-id="60a97-1125">Es decir, la propiedad <see cref="P:System.Type.IsGenericParameter" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1125">That is, the <see cref="P:System.Type.IsGenericParameter" /> property returns <see langword="false" />.</span></span></exception>
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <altmember cref="P:System.Type.IsGenericParameter" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-1126">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-1126">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual Type GetGenericTypeDefinition ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetGenericTypeDefinition() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetGenericTypeDefinition () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetGenericTypeDefinition();" />
      <MemberSignature Language="F#" Value="abstract member GetGenericTypeDefinition : unit -&gt; Type&#xA;override this.GetGenericTypeDefinition : unit -&gt; Type" Usage="type.GetGenericTypeDefinition " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1127">Devuelve un objeto <see cref="T:System.Type" /> que representa una definición de tipo genérico a partir de la cual se puede construir el tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1127">Returns a <see cref="T:System.Type" /> object that represents a generic type definition from which the current generic type can be constructed.</span></span></summary>
        <returns><span data-ttu-id="60a97-1128">Objeto <see cref="T:System.Type" /> que representa un tipo genérico a partir del cual se puede construir el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1128">A <see cref="T:System.Type" /> object representing a generic type from which the current type can be constructed.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1129">Una definición de tipo genérico es una plantilla desde el que se pueden construir otros tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1129">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="60a97-1130">Por ejemplo, desde la definición de tipo genérico `G<T>` (expresada en sintaxis de C#; `G(Of T)` en Visual Basic o `generic <typename T> ref class G` en C++) puede construir y crear instancias del tipo `G<int>` (`G(Of Integer)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1130">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic).</span></span> <span data-ttu-id="60a97-1131">Dado un <xref:System.Type> construido de objeto que representa este tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> método devuelve la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1131">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the generic type definition.</span></span>  
  
 <span data-ttu-id="60a97-1132">Si se crean dos tipos construidos desde la misma definición de tipo genérico, con los mismos argumentos de tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> que devuelve el mismo método <xref:System.Type> objeto para ambos tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1132">If two constructed types are created from the same generic type definition, using the same type arguments, the <xref:System.Type.GetGenericTypeDefinition%2A> method returns the same <xref:System.Type> object for both types.</span></span>  
  
 <span data-ttu-id="60a97-1133">Si se llama a la <xref:System.Type.GetGenericTypeDefinition%2A> método en un <xref:System.Type> objeto que ya representa una definición de tipo genérico, devuelve el valor actual <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1133">If you call the <xref:System.Type.GetGenericTypeDefinition%2A> method on a <xref:System.Type> object that already represents a generic type definition, it returns the current <xref:System.Type>.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60a97-1134">Una matriz de tipos genéricos no es genérico en sí mismo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1134">An array of generic types is not itself generic.</span></span> <span data-ttu-id="60a97-1135">En el código de C# `A<int>[] v;` o el código de Visual Basic `Dim v() As A(Of Integer)`, el tipo de variable `v` no es genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1135">In the C# code `A<int>[] v;` or the Visual Basic code `Dim v() As A(Of Integer)`, the type of variable `v` is not generic.</span></span> <span data-ttu-id="60a97-1136">Use <xref:System.Type.IsGenericType%2A> para determinar si un tipo es genérico antes de llamar a <xref:System.Type.GetGenericTypeDefinition%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1136">Use <xref:System.Type.IsGenericType%2A> to determine whether a type is generic before calling <xref:System.Type.GetGenericTypeDefinition%2A>.</span></span>  
  
 <span data-ttu-id="60a97-1137">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1137">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1138">En el ejemplo de código siguiente se crea una instancia de un tipo construido mediante la creación de la instancia normal y, a continuación, usa el <xref:System.Type.GetType%2A> y <xref:System.Type.GetGenericTypeDefinition%2A> métodos para recuperar el tipo construido y la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1138">The following code example creates an instance of a constructed type by using ordinary instance creation and then uses the <xref:System.Type.GetType%2A> and <xref:System.Type.GetGenericTypeDefinition%2A> methods to retrieve the constructed type and the generic type definition.</span></span> <span data-ttu-id="60a97-1139">Este ejemplo usa el modelo genérico <xref:System.Collections.Generic.Dictionary%602> tipo; el tipo construido representa un <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos con claves de cadena.</span><span class="sxs-lookup"><span data-stu-id="60a97-1139">This example uses the generic <xref:System.Collections.Generic.Dictionary%602> type; the constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.GetGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.GetGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-1140">El tipo actual no es un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1140">The current type is not a generic type.</span></span>  <span data-ttu-id="60a97-1141">Es decir, <see cref="P:System.Type.IsGenericType" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1141">That is, <see cref="P:System.Type.IsGenericType" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-1142">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1142">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="60a97-1143">Las clases derivadas deben proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-1143">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="M:System.Type.MakeGenericType(System.Type[])" />
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-1144">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-1144">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-1145">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-1145">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="type.GetHashCode " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetHashCode</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1146">Devuelve el código hash de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1146">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="60a97-1147">Código hash de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1147">The hash code for this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1148">Este método invalida <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1148">This method overrides <xref:System.Object.GetHashCode%2A?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1149">En el ejemplo siguiente se muestra el código hash de la `System.Windows.Forms.Button` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1149">The following example displays the hash code of the `System.Windows.Forms.Button` class.</span></span>  
  
 [!code-cpp[Type_GetHashCode_GetFields#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CPP/type_gethashcode_getfields.cpp#1)]
 [!code-csharp[Type_GetHashCode_GetFields#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetHashCode_GetFields/CS/type_gethashcode_getfields.cs#1)]
 [!code-vb[Type_GetHashCode_GetFields#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetHashCode_GetFields/VB/type_gethashcode_getfields.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetInterface">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1150">Obtiene una interfaz específica implementada o heredada por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1150">Gets a specific interface implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public Type GetInterface (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetInterface (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetInterface(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string -&gt; Type&#xA;override this.GetInterface : string -&gt; Type" Usage="type.GetInterface name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1151">Cadena que contiene el nombre de la interfaz que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1151">The string containing the name of the interface to get.</span></span> <span data-ttu-id="60a97-1152">Para las interfaces genéricas, este es el nombre con sufijo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1152">For generic interfaces, this is the mangled name.</span></span></param>
        <summary><span data-ttu-id="60a97-1153">Busca la interfaz con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1153">Searches for the interface with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1154">Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1154">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1155">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1155">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="60a97-1156">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1156">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1157">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1157">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1158">Para las interfaces genéricas, el `name` parámetro es el nombre alterado y termina con un acento grave (\`) y el número de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1158">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="60a97-1159">Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1159">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="60a97-1160">Por ejemplo, para buscar `IExample<T>` (`IExample(Of T)` en Visual Basic) o `IExample<string>` (`IExample(Of String)` en Visual Basic), busque ``"IExample`1"``.</span><span class="sxs-lookup"><span data-stu-id="60a97-1160">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for ``"IExample`1"``.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1161">El siguiente ejemplo de código utiliza el <xref:System.Type.GetInterface%28System.String%29> para buscar el <xref:System.Collections.Hashtable> de clases para el <xref:System.Runtime.Serialization.IDeserializationCallback> interfaz y se enumeran los métodos de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1161">The following code example uses the <xref:System.Type.GetInterface%28System.String%29> method to search the <xref:System.Collections.Hashtable> class for the <xref:System.Runtime.Serialization.IDeserializationCallback> interface, and lists the methods of the interface.</span></span>  
  
 <span data-ttu-id="60a97-1162">El ejemplo de código también muestra el <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> sobrecarga del método y el <xref:System.Type.GetInterfaceMap%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1162">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#1)]
 [!code-csharp[Type_GetInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#1)]
 [!code-vb[Type_GetInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1163">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1163"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1164">El <see cref="T:System.Type" /> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1164">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterface">
      <MemberSignature Language="C#" Value="public abstract Type GetInterface (string name, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetInterface(string name, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterface(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterface (name As String, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetInterface(System::String ^ name, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="abstract member GetInterface : string * bool -&gt; Type" Usage="type.GetInterface (name, ignoreCase)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterface(System.String,System.Boolean)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1165">Cadena que contiene el nombre de la interfaz que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1165">The string containing the name of the interface to get.</span></span> <span data-ttu-id="60a97-1166">Para las interfaces genéricas, este es el nombre con sufijo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1166">For generic interfaces, this is the mangled name.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="60a97-1167"><see langword="true" /> para omitir la grafía de la parte de <paramref name="name" /> que especifica el nombre de interfaz simple (se debe respetar la grafía de la parte que especifica el espacio de nombres).</span><span class="sxs-lookup"><span data-stu-id="60a97-1167"><see langword="true" /> to ignore the case of that part of <paramref name="name" /> that specifies the simple interface name (the part that specifies the namespace must be correctly cased).</span></span>  
  
<span data-ttu-id="60a97-1168">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1168">-or-</span></span> 
 <span data-ttu-id="60a97-1169"><see langword="false" /> para realizar una búsqueda de todas las partes de <paramref name="name" /> que distinga mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1169"><see langword="false" /> to perform a case-sensitive search for all parts of <paramref name="name" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1170">Cuando se invalida en una clase derivada, busca la interfaz especificada e indica si la búsqueda no debe distinguir entre mayúsculas y minúsculas para el nombre de la interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1170">When overridden in a derived class, searches for the specified interface, specifying whether to do a case-insensitive search for the interface name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1171">Objeto que representa la interfaz con el nombre especificado, implementada o heredada por el objeto <see cref="T:System.Type" /> actual, si se encuentra; de lo contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1171">An object representing the interface with the specified name, implemented or inherited by the current <see cref="T:System.Type" />, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1172">El `ignoreCase` parámetro solo se aplica a lo nombre de interfaz simple, no al espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-1172">The `ignoreCase` parameter applies only to the simple interface name, not to the namespace.</span></span> <span data-ttu-id="60a97-1173">La parte de `name` que especifica el espacio de nombres debe tener el formato correcto o no se encuentra la interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1173">The portion of `name` that specifies the namespace must have the correct case, or the interface will not be found.</span></span> <span data-ttu-id="60a97-1174">Por ejemplo, la cadena "System.icomparable" busca la <xref:System.IComparable> interfaz, pero la cadena "system.icomparable" no es así.</span><span class="sxs-lookup"><span data-stu-id="60a97-1174">For example, the string "System.icomparable" finds the <xref:System.IComparable> interface, but the string "system.icomparable" does not.</span></span>  
  
 <span data-ttu-id="60a97-1175">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1175">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1176">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1176">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1177">Para las interfaces genéricas, el `name` parámetro es el nombre alterado y termina con un acento grave (\`) y el número de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1177">For generic interfaces, the `name` parameter is the mangled name, ending with a grave accent (\`) and the number of type parameters.</span></span> <span data-ttu-id="60a97-1178">Esto es cierto para las definiciones de interfaz genérica e interfaces genéricas construidas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1178">This is true for both generic interface definitions and constructed generic interfaces.</span></span> <span data-ttu-id="60a97-1179">Por ejemplo, para buscar `IExample<T>` (`IExample(Of T)` en Visual Basic) o `IExample<string>` (`IExample(Of String)` en Visual Basic), busque `"IExample`1"'.</span><span class="sxs-lookup"><span data-stu-id="60a97-1179">For example, to find `IExample<T>` (`IExample(Of T)` in Visual Basic) or `IExample<string>` (`IExample(Of String)` in Visual Basic), search for `"IExample`1"\`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1180">El siguiente ejemplo de código utiliza el <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> método para realizar una búsqueda de mayúsculas y minúsculas de la <xref:System.Collections.Hashtable> de clases para el <xref:System.Collections.IEnumerable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1180">The following code example uses the <xref:System.Type.GetInterface%28System.String%2CSystem.Boolean%29> method to perform a case-insensitive search of the <xref:System.Collections.Hashtable> class for the <xref:System.Collections.IEnumerable> interface.</span></span>  
  
 <span data-ttu-id="60a97-1181">El ejemplo de código también muestra el <xref:System.Type.GetInterface%28System.String%29> sobrecarga del método y el <xref:System.Type.GetInterfaceMap%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1181">The code example also demonstrates the <xref:System.Type.GetInterface%28System.String%29> method overload and the <xref:System.Type.GetInterfaceMap%2A> method.</span></span>  
  
 [!code-cpp[Type_GetInterface#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterface/CPP/type_getinterface.cpp#2)]
 [!code-csharp[Type_GetInterface#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterface/CS/type_getinterface.cs#2)]
 [!code-vb[Type_GetInterface#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterface/VB/type_getinterface.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1182">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1182"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1183">El <see cref="T:System.Type" /> actual representa un tipo que implementa la misma interfaz genérica con argumentos de tipo diferente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1183">The current <see cref="T:System.Type" /> represents a type that implements the same generic interface with different type arguments.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="M:System.Type.GetInterfaces" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaceMap">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.InterfaceMapping GetInterfaceMap (Type interfaceType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance valuetype System.Reflection.InterfaceMapping GetInterfaceMap(class System.Type interfaceType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaceMap(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetInterfaceMap (interfaceType As Type) As InterfaceMapping" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::InterfaceMapping GetInterfaceMap(Type ^ interfaceType);" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping&#xA;override this.GetInterfaceMap : Type -&gt; System.Reflection.InterfaceMapping" Usage="type.GetInterfaceMap interfaceType" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaceMap(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.InterfaceMapping</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="interfaceType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="interfaceType"><span data-ttu-id="60a97-1184">Tipo de interfaz para el que recuperar una asignación.</span><span class="sxs-lookup"><span data-stu-id="60a97-1184">The interface type to retrieve a mapping for.</span></span></param>
        <summary><span data-ttu-id="60a97-1185">Devuelve una asignación de interfaz para el tipo de interfaz especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1185">Returns an interface mapping for the specified interface type.</span></span></summary>
        <returns><span data-ttu-id="60a97-1186">Objeto que representa la asignación de interfaz para <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1186">An object that represents the interface mapping for <paramref name="interfaceType" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1187">El mapa de interfaz indica cómo se asigna una interfaz a los miembros reales en una clase que implementa esa interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1187">The interface map denotes how an interface is mapped into the actual members on a class that implements that interface.</span></span>  
  
 <span data-ttu-id="60a97-1188">Si el actual <xref:System.Type> representa un tipo genérico construido, tipo de parámetros se sustituyen por los argumentos de tipo adecuado de los elementos de la <xref:System.Reflection.InterfaceMapping> devuelto por este método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1188">If the current <xref:System.Type> represents a constructed generic type, type parameters are replaced by the appropriate type arguments in the elements of the <xref:System.Reflection.InterfaceMapping> returned by this method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1189">El ejemplo siguiente se llama el <xref:System.Type.GetInterfaceMap%2A> método para determinar cómo el <xref:System.IFormatProvider> interfaz se asigna a <xref:System.Globalization.CultureInfo> métodos y cómo el <xref:System.IAppDomainSetup> interfaz se asigna a <xref:System.AppDomainSetup> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-1189">The following example calls the <xref:System.Type.GetInterfaceMap%2A> method to determine how the <xref:System.IFormatProvider> interface maps to <xref:System.Globalization.CultureInfo> methods, and how the <xref:System.IAppDomainSetup> interface maps to <xref:System.AppDomainSetup> properties.</span></span> <span data-ttu-id="60a97-1190">Tenga en cuenta que, dado el <xref:System.IAppDomainSetup> interfaz define un conjunto de propiedades, el valor devuelto <xref:System.Reflection.InterfaceMapping> objeto incluye independiente <xref:System.Reflection.MethodInfo> objetos para get de una propiedad y descriptores de acceso set.</span><span class="sxs-lookup"><span data-stu-id="60a97-1190">Note that, because the <xref:System.IAppDomainSetup> interface defines a set of properties, the returned <xref:System.Reflection.InterfaceMapping> object includes separate <xref:System.Reflection.MethodInfo> objects for a property's get and set accessors.</span></span>  
  
 [!code-csharp[System.Type.GetInterfaceMap#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.getinterfacemap/cs/interfacemapping1.cs#1)]
 [!code-vb[System.Type.GetInterfaceMap#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.getinterfacemap/vb/interfacemapping1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1191">El tipo actual no implementa <paramref name="interfaceType" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1191"><paramref name="interfaceType" /> is not implemented by the current type.</span></span>  
  
<span data-ttu-id="60a97-1192">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1192">-or-</span></span> 
<span data-ttu-id="60a97-1193">El argumento <paramref name="interfaceType" /> no hace referencia a una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1193">The <paramref name="interfaceType" /> argument does not refer to an interface.</span></span>  
  
<span data-ttu-id="60a97-1194">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1194">-or-</span></span>

<span data-ttu-id="60a97-1195">La instancia actual o el argumento <paramref name="interfaceType" /> es un tipo genérico abierto; es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1195">The current instance or <paramref name="interfaceType" /> argument is an open generic type; that is, the <see cref="P:System.Type.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span>

<span data-ttu-id="60a97-1196">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1196">-or-</span></span>


 <span data-ttu-id="60a97-1197"><paramref name="interfaceType" /> es una interfaz genérica y el tipo actual es un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1197"><paramref name="interfaceType" /> is a generic interface, and the current type is an array type.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1198">El valor de <paramref name="interfaceType" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1198"><paramref name="interfaceType" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-1199">El <see cref="T:System.Type" /> actual representa un parámetro de tipo genérico; es decir, <see cref="P:System.Type.IsGenericParameter" /> es <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1199">The current <see cref="T:System.Type" /> represents a generic type parameter; that is, <see cref="P:System.Type.IsGenericParameter" /> is <see langword="true" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-1200">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1200">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="60a97-1201">Las clases derivadas deben proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-1201">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.InterfaceMapping" />
      </Docs>
    </Member>
    <Member MemberName="GetInterfaces">
      <MemberSignature Language="C#" Value="public abstract Type[] GetInterfaces ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetInterfaces() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetInterfaces" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetInterfaces () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetInterfaces();" />
      <MemberSignature Language="F#" Value="abstract member GetInterfaces : unit -&gt; Type[]" Usage="type.GetInterfaces " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetInterfaces</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1202">Cuando se invalida en una clase derivada, obtiene todas las interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1202">When overridden in a derived class, gets all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1203">Matriz de objetos <see cref="T:System.Type" /> que representa todas las interfaces implementadas o heredadas por el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1203">An array of <see cref="T:System.Type" /> objects representing all the interfaces implemented or inherited by the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-1204">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1204">-or-</span></span> 
<span data-ttu-id="60a97-1205">Matriz vacía de tipo <see cref="T:System.Type" /> en caso de que el objeto <see cref="T:System.Type" /> actual no implemente ni herede ninguna interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1205">An empty array of type <see cref="T:System.Type" />, if no interfaces are implemented or inherited by the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1206">El <xref:System.Type.GetInterfaces%2A> método no devuelve las interfaces en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1206">The <xref:System.Type.GetInterfaces%2A> method does not return interfaces in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1207">El código no debe depender del orden en que se devuelven interfaces, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1207">Your code must not depend on the order in which interfaces are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1208">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Type> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1208">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Type> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1209">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en las restricciones de interfaz y las interfaces heredadas de restricciones de clase o interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1209">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the interface constraints and any interfaces inherited from class or interface constraints.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1210">El ejemplo siguiente obtiene el tipo de la clase especificada y muestra todas las interfaces que implementa el tipo o que hereda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1210">The following example gets the type of the specified class and displays all the interfaces that the type implements or inherits.</span></span> <span data-ttu-id="60a97-1211">Para compilar el ejemplo de Visual Basic, use los siguientes comandos del compilador:</span><span class="sxs-lookup"><span data-stu-id="60a97-1211">To compile the Visual Basic example, use the following compiler commands:</span></span>  
  
 `vbc type_getinterfaces1.vb /r:System.Web.dll /r:System.dll`  
  
 [!code-cpp[Type_GetInterfaces1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetInterfaces1/CPP/type_getinterfaces1.cpp#1)]
 [!code-csharp[Type_GetInterfaces1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetInterfaces1/CS/type_getinterfaces1.cs#1)]
 [!code-vb[Type_GetInterfaces1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetInterfaces1/VB/type_getinterfaces1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-1212">Se invoca un inicializador estático y produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-1212">A static initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="M:System.Type.GetInterface(System.String)" />
        <altmember cref="M:System.Type.FindInterfaces(System.Reflection.TypeFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1213">Obtiene los miembros especificados del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1213">Gets the specified members of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMember (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMember (name As String) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1214">Cadena que contiene el nombre de los miembros públicos que se van a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1214">The string containing the name of the public members to get.</span></span></param>
        <summary><span data-ttu-id="60a97-1215">Busca los miembros públicos con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1215">Searches for the public members with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1216">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1216">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1217">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1217">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-1218">La búsqueda incluye a los miembros de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-1218">The search includes public static and public instance members.</span></span>  
  
 <span data-ttu-id="60a97-1219">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1219">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-1220">El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1220">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1221">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1221">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1222">Esta sobrecarga del método no encontrará a inicializadores de clase (.cctor).</span><span class="sxs-lookup"><span data-stu-id="60a97-1222">This method overload will not find class initializers (.cctor).</span></span> <span data-ttu-id="60a97-1223">Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1223">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-1224">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1224">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1225">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1225">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1226">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1226">Member Type</span></span>|<span data-ttu-id="60a97-1227">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1227">Static</span></span>|<span data-ttu-id="60a97-1228">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1228">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1229">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1229">Constructor</span></span>|<span data-ttu-id="60a97-1230">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1230">No</span></span>|<span data-ttu-id="60a97-1231">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1231">No</span></span>|  
|<span data-ttu-id="60a97-1232">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1232">Field</span></span>|<span data-ttu-id="60a97-1233">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1233">No</span></span>|<span data-ttu-id="60a97-1234">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1234">Yes.</span></span> <span data-ttu-id="60a97-1235">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1235">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1236">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1236">Event</span></span>|<span data-ttu-id="60a97-1237">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1237">Not applicable</span></span>|<span data-ttu-id="60a97-1238">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1238">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1239">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1239">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1240">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1240">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1241">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1241">Method</span></span>|<span data-ttu-id="60a97-1242">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1242">No</span></span>|<span data-ttu-id="60a97-1243">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1243">Yes.</span></span> <span data-ttu-id="60a97-1244">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1244">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1245">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1245">Nested Type</span></span>|<span data-ttu-id="60a97-1246">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1246">No</span></span>|<span data-ttu-id="60a97-1247">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1247">No</span></span>|  
|<span data-ttu-id="60a97-1248">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1248">Property</span></span>|<span data-ttu-id="60a97-1249">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1249">Not applicable</span></span>|<span data-ttu-id="60a97-1250">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1250">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1251">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1251">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1252">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1252">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1253">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1253">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1254">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1254">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1255">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1255">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1256">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1256">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1257">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1257">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1258">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1258">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1259">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1259">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1260">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1260">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1261">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1261">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1262">El ejemplo siguiente muestra todos los miembros de la `String` clase que empiezan por la letra C.</span><span class="sxs-lookup"><span data-stu-id="60a97-1262">The following example displays all the members of the `String` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#1)]
 [!code-csharp[Type_GetMember#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#1)]
 [!code-vb[Type_GetMember#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1263">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1263"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMember(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1264">Cadena que contiene el nombre de los miembros que se van a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1264">The string containing the name of the members to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1265">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1265">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1266">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1266">-or-</span></span> 
<span data-ttu-id="60a97-1267">Cero, para que se devuelva una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1267">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="60a97-1268">Busca los miembros especificados mediante las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1268">Searches for the specified members, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1269">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1269">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1270">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1270">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-1271">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1271">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-1272">El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1272">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1273">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1273">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1274">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1274">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1275">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1275">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1276">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1276">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1277">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1277">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1278">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1278">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1279">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1279">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1280">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1280">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1281">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1281">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1282">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1282">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1283">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, debe especificar ".cctor" para `name`, y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) para `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1283">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="60a97-1284">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1284">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1285">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1285">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1286">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1286">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1287">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1287">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1288">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1288">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1289">El ejemplo siguiente muestra todos los miembros estáticos públicos de la `myString` clase que empiezan por la letra C.</span><span class="sxs-lookup"><span data-stu-id="60a97-1289">The following example displays all the public static members of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#2)]
 [!code-csharp[Type_GetMember#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#2)]
 [!code-vb[Type_GetMember#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1290">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1290"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMember">
      <MemberSignature Language="C#" Value="public virtual System.Reflection.MemberInfo[] GetMember (string name, System.Reflection.MemberTypes type, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMember(string name, valuetype System.Reflection.MemberTypes type, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetMember (name As String, type As MemberTypes, bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMember(System::String ^ name, System::Reflection::MemberTypes type, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMember : string * System.Reflection.MemberTypes * System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMember (name, type, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMember(System.String,System.Reflection.MemberTypes,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="type" Type="System.Reflection.MemberTypes" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1291">Cadena que contiene el nombre de los miembros que se van a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1291">The string containing the name of the members to get.</span></span></param>
        <param name="type"><span data-ttu-id="60a97-1292">Valor que se va a buscar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1292">The value to search for.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1293">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1293">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1294">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1294">-or-</span></span> 
<span data-ttu-id="60a97-1295">Cero, para que se devuelva una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1295">Zero, to return an empty array.</span></span></param>
        <summary><span data-ttu-id="60a97-1296">Busca los miembros especificados que sean del tipo de miembro especificado mediante las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1296">Searches for the specified members of the specified member type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1297">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa los miembros públicos con el nombre especificado, si se encuentran; de lo contrario, una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1297">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing the public members with the specified name, if found; otherwise, an empty array.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1298">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1298">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-1299">El <xref:System.Type.GetMember%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1299">The <xref:System.Type.GetMember%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1300">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1300">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1301">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1301">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1302">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1302">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1303">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1303">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1304">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1304">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1305">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1305">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1306">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1306">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1307">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1307">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1308">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1308">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1309">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1309">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1310">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, debe especificar ".cctor" para `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> para `type`, y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic) para `bindingAttr`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1310">To get the class initializer (.cctor) using this method overload, you must specify ".cctor" for `name`, <xref:System.Reflection.MemberTypes.Constructor?displayProperty=nameWithType> for `type`, and  <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic) for `bindingAttr`.</span></span> <span data-ttu-id="60a97-1311">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1311">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1312">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1312">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1313">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1313">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1314">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1314">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1315">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1315">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1316">El ejemplo siguiente muestra todos los métodos de la `myString` clase que empiezan por la letra C.</span><span class="sxs-lookup"><span data-stu-id="60a97-1316">The following example displays all the methods of the `myString` class that start with the letter C.</span></span>  
  
 [!code-cpp[Type_GetMember#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMember/CPP/type_getmember.cpp#3)]
 [!code-csharp[Type_GetMember#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMember/CS/type_getmember.cs#3)]
 [!code-vb[Type_GetMember#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMember/VB/type_getmember.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1317">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1317"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-1318">La clase derivada debe proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-1318">A derived class must provide an implementation.</span></span></exception>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMembers" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMembers">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1319">Obtiene los miembros (propiedades, métodos, campos, eventos, etc.) del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1319">Gets the members (properties, methods, fields, events, and so on) of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public System.Reflection.MemberInfo[] GetMembers ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMembers () As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers();" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : unit -&gt; System.Reflection.MemberInfo[]&#xA;override this.GetMembers : unit -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1320">Devuelve todos los miembros públicos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1320">Returns all the public members of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1321">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros públicos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1321">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all the public members of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-1322">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1322">-or-</span></span> 
<span data-ttu-id="60a97-1323">Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene miembros públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1323">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if the current <see cref="T:System.Type" /> does not have public members.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1324">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1324">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-1325">El <xref:System.Type.GetMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1325">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1326">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1326">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1327">Esta sobrecarga del método llama a la <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga del método, con <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1327">This method overload calls the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload, with <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-1328">No encontrará a inicializadores de clase (.cctor).</span><span class="sxs-lookup"><span data-stu-id="60a97-1328">It will not find class initializers (.cctor).</span></span> <span data-ttu-id="60a97-1329">Para buscar los inicializadores de clase, use una sobrecarga que toma <xref:System.Reflection.BindingFlags>y especifique <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1329">To find class initializers, use an overload that takes <xref:System.Reflection.BindingFlags>, and specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-1330">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1330">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1331">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1331">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1332">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1332">Member Type</span></span>|<span data-ttu-id="60a97-1333">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1333">Static</span></span>|<span data-ttu-id="60a97-1334">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1334">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1335">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1335">Constructor</span></span>|<span data-ttu-id="60a97-1336">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1336">No</span></span>|<span data-ttu-id="60a97-1337">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1337">No</span></span>|  
|<span data-ttu-id="60a97-1338">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1338">Field</span></span>|<span data-ttu-id="60a97-1339">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1339">No</span></span>|<span data-ttu-id="60a97-1340">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1340">Yes.</span></span> <span data-ttu-id="60a97-1341">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1341">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1342">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1342">Event</span></span>|<span data-ttu-id="60a97-1343">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1343">Not applicable</span></span>|<span data-ttu-id="60a97-1344">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1344">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1345">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1345">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1346">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1346">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1347">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1347">Method</span></span>|<span data-ttu-id="60a97-1348">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1348">No</span></span>|<span data-ttu-id="60a97-1349">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1349">Yes.</span></span> <span data-ttu-id="60a97-1350">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1350">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1351">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1351">Nested Type</span></span>|<span data-ttu-id="60a97-1352">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1352">No</span></span>|<span data-ttu-id="60a97-1353">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1353">No</span></span>|  
|<span data-ttu-id="60a97-1354">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1354">Property</span></span>|<span data-ttu-id="60a97-1355">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1355">Not applicable</span></span>|<span data-ttu-id="60a97-1356">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1356">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1357">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1357">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1358">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1358">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1359">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1359">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1360">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1360">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1361">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1361">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1362">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1362">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1363">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1363">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1364">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1364">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1365">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1365">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1366">En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetMembers> sobrecarga del método para recopilar información sobre todos los miembros públicos de una clase especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1366">The following code example demonstrates how to use the <xref:System.Type.GetMembers> method overload to collect information about all public members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers1/CPP/type_getmembers1.cpp#1)]
 [!code-csharp[Type_GetMembers1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers1/CS/type_getmembers1.cs#1)]
 [!code-vb[Type_GetMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers1/VB/type_getmembers1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="GetMembers">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MemberInfo[] GetMembers (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MemberInfo[] GetMembers(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMembers(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMembers (bindingAttr As BindingFlags) As MemberInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MemberInfo ^&gt; ^ GetMembers(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMembers : System.Reflection.BindingFlags -&gt; System.Reflection.MemberInfo[]" Usage="type.GetMembers bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMembers(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-1367">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1367">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1368">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1368">-or-</span></span> 
<span data-ttu-id="60a97-1369">Cero (<see cref="F:System.Reflection.BindingFlags.Default" />), para que se devuelva una matriz vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1369">Zero (<see cref="F:System.Reflection.BindingFlags.Default" />), to return an empty array.</span></span></param>
        <summary><span data-ttu-id="60a97-1370">Cuando se invalida en una clase derivada, busca los miembros definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1370">When overridden in a derived class, searches for the members defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1371">Matriz de objetos <see cref="T:System.Reflection.MemberInfo" /> que representa todos los miembros definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1371">An array of <see cref="T:System.Reflection.MemberInfo" /> objects representing all members defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="60a97-1372">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1372">-or-</span></span> 
<span data-ttu-id="60a97-1373">Matriz vacía de tipo <see cref="T:System.Reflection.MemberInfo" /> si no se han definido miembros para el objeto <see cref="T:System.Type" /> actual o si ninguno de los miembros definidos coincide con las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1373">An empty array of type <see cref="T:System.Reflection.MemberInfo" />, if no members are defined for the current <see cref="T:System.Type" />, or if none of the defined members match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1374">Los miembros incluyen propiedades, métodos, campos, eventos y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-1374">Members include properties, methods, fields, events, and so on.</span></span>  
  
 <span data-ttu-id="60a97-1375">El <xref:System.Type.GetMembers%2A> método no devuelve los miembros en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1375">The <xref:System.Type.GetMembers%2A> method does not return members in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1376">El código no debe depender el orden en que se devuelven los miembros, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1376">Your code must not depend on the order in which members are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1377">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1377">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1378">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1378">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1379">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1379">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1380">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1380">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span> <span data-ttu-id="60a97-1381">Solo se devuelven miembros internos de las clases base; y protegidos no se devuelven los miembros privados de clases base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1381">Only protected and internal members on base classes are returned; private members on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="60a97-1382">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1382">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1383">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1383">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1384">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1384">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1385">Llamar a este método solamente con el `Public` marca o solo el `NonPublic` marca devolverá los miembros especificados y no requiere otros indicadores.</span><span class="sxs-lookup"><span data-stu-id="60a97-1385">Calling this method with only the `Public` flag or only the `NonPublic` flag will return the specified members and does not require any other flags.</span></span>  
  
 <span data-ttu-id="60a97-1386">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1386">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1387">Para obtener el inicializador de clase (.cctor) utilizando esta sobrecarga del método, se debe especificar <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1387">To get the class initializer (.cctor) using this method overload, you must specify <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> (<xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> in Visual Basic).</span></span> <span data-ttu-id="60a97-1388">También puede obtener el inicializador de clase utilizando el <xref:System.Type.TypeInitializer%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1388">You can also get the class initializer using the <xref:System.Type.TypeInitializer%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-1389">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MemberInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1389">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MemberInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1390">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca los miembros de la restricción de clase o los miembros de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1390">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the members of the class constraint, or the members of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1391">En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> sobrecarga del método para recopilar información sobre todos los miembros de instancia pública de una clase especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1391">The following code example demonstrates how to use the <xref:System.Type.GetMembers%28System.Reflection.BindingFlags%29> method overload to collect information about all public instance members of a specified class.</span></span>  
  
 [!code-cpp[Type_GetMembers2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMembers2/CPP/type_getmembers2.cpp#1)]
 [!code-csharp[Type_GetMembers2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMembers2/CS/type_getmembers2.cs#1)]
 [!code-vb[Type_GetMembers2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMembers2/VB/type_getmembers2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMember(System.String)" />
        <altmember cref="M:System.Type.GetDefaultMembers" />
        <altmember cref="M:System.Type.FindMembers(System.Reflection.MemberTypes,System.Reflection.BindingFlags,System.Reflection.MemberFilter,System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethod">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1392">Obtiene un método específico del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1392">Gets a specific method of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1393">Cadena que contiene el nombre del método público que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1393">The string containing the name of the public method to get.</span></span></param>
        <summary><span data-ttu-id="60a97-1394">Busca el método público con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1394">Searches for the public method with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1395">Objeto que representa al método público con el nombre especificado, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1395">An object that represents the public method with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1396">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1396">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-1397">La búsqueda incluye métodos de instancia públicos y estáticos públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1397">The search includes public static and public instance methods.</span></span>  
  
 <span data-ttu-id="60a97-1398">Si un método está sobrecargado y tiene más de un método público, el <xref:System.Type.GetMethod%28System.String%29> método produce una <xref:System.Reflection.AmbiguousMatchException> excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-1398">If a method is overloaded and has more than one public method, the <xref:System.Type.GetMethod%28System.String%29> method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="60a97-1399">En el ejemplo siguiente, se produce una excepción porque no hay más de una sobrecarga pública de la <xref:System.Int32.ToString%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1399">In the following example, an exception is thrown because there is more than one public overload of the <xref:System.Int32.ToString%2A?displayProperty=nameWithType> method.</span></span>  <span data-ttu-id="60a97-1400">Por otro lado, dado que el `Person.ToString` reemplazos de método <xref:System.Object.ToString%2A?displayProperty=nameWithType> y, por tanto, no está sobrecargado, el <xref:System.Type.GetMethod%28System.String%29> método es capaz de recuperar el <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1400">On the other hand, because the `Person.ToString` method overrides  <xref:System.Object.ToString%2A?displayProperty=nameWithType> and therefore is not overloaded, the <xref:System.Type.GetMethod%28System.String%29> method is able to retrieve the <xref:System.Reflection.MethodInfo> object.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads2.cs#3)]
 [!code-vb[System.Type.GetMethod#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads2.vb#3)]  
  
 <span data-ttu-id="60a97-1401">Puede hacer lo siguiente para recuperar un método específico:</span><span class="sxs-lookup"><span data-stu-id="60a97-1401">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="60a97-1402">Llame a la <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> método y especifique un `bindingAttr` argumento que identifica el método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1402">Call the <xref:System.Type.GetMethod%28System.String%2CSystem.Reflection.BindingFlags%29> method and specify a `bindingAttr` argument that uniquely identifies the method.</span></span> <span data-ttu-id="60a97-1403">Por ejemplo, si se produce la excepción porque un tipo tiene una estática y una sobrecarga de la instancia, puede especificar un `bindingAttr` argumento de <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> `Or` <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1403">For example, if the exception is thrown because a type has a static and an instance overload, you can specify a  `bindingAttr` argument  of <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>`Or`<xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="60a97-1404">Llamar a una sobrecarga de la <xref:System.Type.GetMethod%2A> método que incluye un `types` parámetro que define los tipos de los parámetros del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1404">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="60a97-1405">Llame a la <xref:System.Type.GetMethods> método para recuperar una matriz que contiene todos los métodos públicos que pertenecen a un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1405">Call the <xref:System.Type.GetMethods> method to retrieve an array containing all of the public methods belonging to a type.</span></span> <span data-ttu-id="60a97-1406">A continuación, puede iterar para identificar los duplicados métodos denominados `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1406">You can then iterate it to identify the duplicate methods named `name`.</span></span>  
  
 <span data-ttu-id="60a97-1407">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1407">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1408">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1408">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1409">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1409">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1410">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1410">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1411">En el ejemplo siguiente se obtiene un método denominado `MethodA`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1411">The following example gets a method named `MethodA`.</span></span>  
  
 [!code-cpp[Type_GetMethod1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod1/CPP/type_getmethod1.cpp#1)]
 [!code-csharp[Type_GetMethod1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod1/CS/type_getmethod1.cs#1)]
 [!code-vb[Type_GetMethod1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod1/VB/type_getmethod1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1412">Se encontró más de un método con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1412">More than one method is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1413">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1413"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, bindingAttr As BindingFlags) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1414">Cadena que contiene el nombre del método que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1414">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1415">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1415">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1416">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1416">-or-</span></span> 
<span data-ttu-id="60a97-1417">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1417">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1418">Busca el método especificado mediante las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1418">Searches for the specified method, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1419">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1419">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1420">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1420">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1421">Debe especificar <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1421">You must specify either <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1422">Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir métodos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1422">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1423">Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1423">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1424">Especificar <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1424">Specify <xref:System.Reflection.BindingFlags.FlattenHierarchy?displayProperty=nameWithType> to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1425">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1425">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1426"><xref:System.Reflection.BindingFlags.IgnoreCase?displayProperty=nameWithType> to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1427"><xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1428">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1428">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1429">Si un método está sobrecargado y más de una sobrecarga cumple las restricciones especificadas por el `bindingAttr` argumento, el método produce una <xref:System.Reflection.AmbiguousMatchException> excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-1429">If a method is overloaded and more than one overload meets the constraints specified by the `bindingAttr` argument, the method throws an <xref:System.Reflection.AmbiguousMatchException> exception.</span></span> <span data-ttu-id="60a97-1430">En el ejemplo siguiente, se produce una excepción porque:</span><span class="sxs-lookup"><span data-stu-id="60a97-1430">In the following example, an exception is thrown because:</span></span>  
  
-   <span data-ttu-id="60a97-1431">El `TestClass` tipo tiene dos sobrecargas de instancia pública de la `DisplayValue` método `DisplayValue(String)` y `DisplayValue(String, Object[])`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1431">The `TestClass` type has two public instance overloads of the `DisplayValue` method, `DisplayValue(String)` and `DisplayValue(String, Object[])`.</span></span>  
  
-   <span data-ttu-id="60a97-1432">El `TestClass` tipo tiene dos sobrecargas de instancia pública de la `Equals` método, uno de los cuales se hereda de <xref:System.Object>: `Equals(TestClass)` y `Equals(Object)`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1432">The `TestClass` type has two public instance overloads of the `Equals` method,  one of which is inherited from <xref:System.Object>: `Equals(TestClass)` and `Equals(Object)`.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethodWithOverloads1.cs#2)]
 [!code-vb[System.Type.GetMethod#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethodWithOverloads1.vb#2)]  
  
 <span data-ttu-id="60a97-1433">Puede hacer lo siguiente para recuperar un método específico:</span><span class="sxs-lookup"><span data-stu-id="60a97-1433">You can do one of the following to retrieve a specific method:</span></span>  
  
-   <span data-ttu-id="60a97-1434">Cambiar las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1434">Change the binding constraints.</span></span> <span data-ttu-id="60a97-1435">En el ejemplo anterior, intenta recuperar una instancia pública `Equals` recupera el método que se declara el tipo y no hereda correctamente `Equals(TestClass)`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1435">In the previous example, attempting to retrieve a public instance `Equals` method that is declared by the type and not inherited successfully retrieves `Equals(TestClass)`.</span></span>  
  
-   <span data-ttu-id="60a97-1436">Llamar a una sobrecarga de la <xref:System.Type.GetMethod%2A> método que incluye un `types` parámetro que define los tipos de los parámetros del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1436">Call an overload of the <xref:System.Type.GetMethod%2A> method that includes a `types` parameter which defines the types of the method's parameters.</span></span>  
  
-   <span data-ttu-id="60a97-1437">Llame a la <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> método para recuperar una matriz que contiene todos los métodos que pertenecen a un tipo que tienen los atributos de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1437">Call the <xref:System.Type.GetMethods%28System.Reflection.BindingFlags%29> method to retrieve an array containing all of the methods belonging to a type that have the specified binding attributes.</span></span> <span data-ttu-id="60a97-1438">A continuación, puede iterar para identificar los duplicados métodos denominados `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1438">You can then iterate it to identify the duplicate methods named `name`.</span></span> <span data-ttu-id="60a97-1439">Este enfoque se ilustra en el controlador del ejemplo anterior para el <xref:System.Reflection.AmbiguousMatchException> excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-1439">This approach is illustrated in the previous example's handler for the <xref:System.Reflection.AmbiguousMatchException> exception.</span></span>  
  
 <span data-ttu-id="60a97-1440">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1440">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1441">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1441">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1442">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1442">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1443">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1443">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1444">El ejemplo siguiente obtiene el método que coincide con las marcas de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1444">The following example gets the method that matches the specified binding flags.</span></span>  
  
 [!code-cpp[Type_GetMethod2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod2/CPP/type_getmethod2.cpp#1)]
 [!code-csharp[Type_GetMethod2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod2/CS/type_getmethod2.cs#1)]
 [!code-vb[Type_GetMethod2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod2/VB/type_getmethod2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1445">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1445">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1446">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1446"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1447">Cadena que contiene el nombre del método público que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1447">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-1448">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1448">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="60a97-1449">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1449">-or-</span></span> 
<span data-ttu-id="60a97-1450">Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1450">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <summary><span data-ttu-id="60a97-1451">Busca el método público especificado cuyos parámetros coincidan con los tipos de argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-1451">Searches for the specified public method whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="60a97-1452">Objeto que representa el método público cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1452">An object representing the public method whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1453">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1453">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-1454">La búsqueda incluye métodos de instancia públicos y estáticos públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1454">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1455">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1455">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1456">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1456">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1457">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1457">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1458">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1458">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1459">El `name` parámetro no puede incluir argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1459">The `name` parameter cannot include type arguments.</span></span> <span data-ttu-id="60a97-1460">Por ejemplo, el código de C# `GetMethod("MyGenericMethod<int>")` busca un método con el nombre de texto "`MyGenericMethod<int>`", en lugar de para un método denominado `MyGenericMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1460">For example, the C# code `GetMethod("MyGenericMethod<int>")` searches for a method with the text name "`MyGenericMethod<int>`", rather than for a method named `MyGenericMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="60a97-1461">En su lugar, use `GetMethod("MyGenericMethod")` con el parámetro correspondiente en el `types` matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1461">Instead, use `GetMethod("MyGenericMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1462">El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar una serie de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="60a97-1462">The following example finds specific overloads of `MethodA`, specifying a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1463">El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.</span><span class="sxs-lookup"><span data-stu-id="60a97-1463">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod4/CPP/type_getmethod4.cpp#1)]
 [!code-csharp[Type_GetMethod4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod4/CS/type_getmethod4.cs#1)]
 [!code-vb[Type_GetMethod4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod4/VB/type_getmethod4.vb#1)]  
  
 <span data-ttu-id="60a97-1464">En el ejemplo siguiente se recuperan <xref:System.Reflection.MethodInfo> objetos que representan el `Add` métodos de un tipo no genérico (la <xref:System.Collections.ArrayList> clase), un tipo genérico abierto (el <xref:System.Collections.Generic.List%601> clase) y un tipo genérico cerrado (el `List(Of String)` tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1464">The following example retrieves <xref:System.Reflection.MethodInfo> objects that represent the `Add` methods  of a non-generic type (the <xref:System.Collections.ArrayList> class), an open generic type (the <xref:System.Collections.Generic.List%601> class), and a closed generic type (the `List(Of String)` type.</span></span>  
  
 [!code-csharp[System.Type.GetMethod#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.Type.GetMethod/cs/GetMethod1.cs#1)]
 [!code-vb[System.Type.GetMethod#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/System.Type.GetMethod/vb/GetMethod1.vb#1)]  
  
 <span data-ttu-id="60a97-1465">El ejemplo define un `GetAddMethod` método que recupera adecuado <xref:System.Reflection.MethodInfo> objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1465">The example defines a `GetAddMethod` method that retrieves the appropriate <xref:System.Reflection.MethodInfo> object.</span></span> <span data-ttu-id="60a97-1466">Para proporcionar la `types` argumento para un tipo genérico abierto, llama a la <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-1466">To provide the `types` argument for an open generic type, it calls the <xref:System.Type.GetGenericArguments%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="60a97-1467">Para proporcionar la `types` argumento para un tipo genérico cerrado, se recupera el valor de la <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1467">To provide the `types` argument for a closed generic type, it retrieves the value of the <xref:System.Type.GenericTypeArguments%2A?displayProperty=nameWithType> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1468">Se encuentra más de un método con el nombre y los parámetros especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-1468">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1469">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1469"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1470">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1470">-or-</span></span> 
 <span data-ttu-id="60a97-1471">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1471"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1472">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1472">-or-</span></span> 
<span data-ttu-id="60a97-1473">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1473">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1474"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1474"><paramref name="types" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1475">Cadena que contiene el nombre del método público que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1475">The string containing the name of the public method to get.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-1476">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1476">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="60a97-1477">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1477">-or-</span></span> 
<span data-ttu-id="60a97-1478">Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1478">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-1479">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1479">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-1480">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1480">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="60a97-1481">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-1481">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-1482">Busca el método público especificado cuyos parámetros coincidan con los tipos y modificadores de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-1482">Searches for the specified public method whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="60a97-1483">Objeto que representa el método público que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1483">An object representing the public method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1484">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1484">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-1485">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1485">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-1486">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1486">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-1487">La búsqueda incluye métodos de instancia públicos y estáticos públicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1487">The search includes public static and public instance methods.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1488">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1488">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1489">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1489">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1490">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1490">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1491">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1491">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1492">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1492">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1493">Por ejemplo, el código de C# `GetMethod("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1493">For example, the C# code `GetMethod("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span> <span data-ttu-id="60a97-1494">En su lugar, use `GetMethod("MyMethod")` con el parámetro correspondiente en el `types` matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-1494">Instead, use `GetMethod("MyMethod")` with the appropriate parameter in the `types` array.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1495">Se encuentra más de un método con el nombre y los parámetros especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-1495">More than one method is found with the specified name and specified parameters.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1496">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1496"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1497">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1497">-or-</span></span> 
 <span data-ttu-id="60a97-1498">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1498"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1499">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1499">-or-</span></span> 
<span data-ttu-id="60a97-1500">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1500">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1501"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1501"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-1502">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1502">-or-</span></span> 
 <span data-ttu-id="60a97-1503"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1503"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethod (name As String, genericParameterCount As Integer, types As Type(), modifiers As ParameterModifier()) As MethodInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1504">Cadena que contiene el nombre del método que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1504">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1505">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1505">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1506">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1506">-or-</span></span> 
<span data-ttu-id="60a97-1507">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1507">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-1508">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-1508">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-1509">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1509">-or-</span></span> 
<span data-ttu-id="60a97-1510">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1510">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-1511">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1511">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="60a97-1512">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1512">-or-</span></span> 
<span data-ttu-id="60a97-1513">Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1513">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-1514">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1514">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-1515">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1515">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="60a97-1516">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-1516">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-1517">Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1517">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1518">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1518">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1519">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1519">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-1520">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1520">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-1521">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1521">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1522">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1522">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1523">Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1523">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1524">Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1524">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1525">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1525">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1526">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1526">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1527">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1527">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1528">`BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1528">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1529">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1529">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1530">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1530">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1531">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1531">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1532">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1532">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1533">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1533">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1534">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1534">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1535">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1535">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1536">El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar restricciones de enlace y una variedad de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="60a97-1536">The following example finds specific overloads of `MethodA`, specifying binding constraints and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1537">El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.</span><span class="sxs-lookup"><span data-stu-id="60a97-1537">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod5/CPP/type_getmethod5.cpp#1)]
 [!code-csharp[Type_GetMethod5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod5/CS/type_getmethod5.cs#1)]
 [!code-vb[Type_GetMethod5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod5/VB/type_getmethod5.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1538">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1538">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1539">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1539"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1540">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1540">-or-</span></span> 
 <span data-ttu-id="60a97-1541">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1541"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1542">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1542">-or-</span></span> 
<span data-ttu-id="60a97-1543">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1543">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1544"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1544"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-1545">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1545">-or-</span></span> 
 <span data-ttu-id="60a97-1546"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1546"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethod(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethod : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1547">Cadena que contiene el nombre del método que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1547">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1548">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1548">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1549">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1549">-or-</span></span> 
<span data-ttu-id="60a97-1550">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1550">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-1551">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-1551">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-1552">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1552">-or-</span></span> 
<span data-ttu-id="60a97-1553">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1553">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="60a97-1554">Objeto que especifica el conjunto de reglas que van a usarse en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y la forma en que se limpia la pila.</span><span class="sxs-lookup"><span data-stu-id="60a97-1554">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and how the stack is cleaned up.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-1555">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1555">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="60a97-1556">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1556">-or-</span></span> 
<span data-ttu-id="60a97-1557">Una matriz vacía de objetos <see cref="T:System.Type" /> (proporcionados por el campo <see cref="F:System.Type.EmptyTypes" />) para obtener un método que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1557">An empty array of <see cref="T:System.Type" /> objects (as provided by the <see cref="F:System.Type.EmptyTypes" /> field) to get a method that takes no parameters.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-1558">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1558">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-1559">Solo se ha de usar cuando se llama mediante la interoperabilidad COM y solo se controlan parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1559">To be only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span> <span data-ttu-id="60a97-1560">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-1560">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-1561">Busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace indicadas y la convención de llamada especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1561">Searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="60a97-1562">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1562">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1563">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1563">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-1564">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1564">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-1565">La siguiente tabla muestra qué miembros de una clase base se devuelven los `GetXXX` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1565">The following table shows what members of a base class are returned by the `GetXXX` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1566">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1566">Member Type</span></span>|<span data-ttu-id="60a97-1567">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1567">Static</span></span>|<span data-ttu-id="60a97-1568">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1568">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1569">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1569">Constructor</span></span>|<span data-ttu-id="60a97-1570">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1570">No</span></span>|<span data-ttu-id="60a97-1571">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1571">No</span></span>|  
|<span data-ttu-id="60a97-1572">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1572">Field</span></span>|<span data-ttu-id="60a97-1573">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1573">No</span></span>|<span data-ttu-id="60a97-1574">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1574">Yes.</span></span> <span data-ttu-id="60a97-1575">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1575">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1576">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1576">Event</span></span>|<span data-ttu-id="60a97-1577">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1577">Not applicable</span></span>|<span data-ttu-id="60a97-1578">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1578">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1579">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1579">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1580">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1580">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1581">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1581">Method</span></span>|<span data-ttu-id="60a97-1582">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1582">No</span></span>|<span data-ttu-id="60a97-1583">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1583">Yes.</span></span> <span data-ttu-id="60a97-1584">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1584">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1585">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1585">Nested Type</span></span>|<span data-ttu-id="60a97-1586">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1586">No</span></span>|<span data-ttu-id="60a97-1587">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1587">No</span></span>|  
|<span data-ttu-id="60a97-1588">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1588">Property</span></span>|<span data-ttu-id="60a97-1589">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1589">Not applicable</span></span>|<span data-ttu-id="60a97-1590">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1590">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1591">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1591">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1592">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1592">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1593">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1593">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1594">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1594">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1595">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1595">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1596">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1596">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1597">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1597">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1598">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1598">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1599">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1599">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1600">Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1600">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1601">Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1601">Specify `BindingFlags.NonPublic` to include nonpublic methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1602">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1602">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1603">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1603">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1604">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1604">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1605">`BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1605">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1606">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1606">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1607">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1607">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1608">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1608">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1609">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1609">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1610">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1610">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1611">Para métodos genéricos, no incluya los argumentos de tipo en `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1611">For generic methods, do not include the type arguments in `name`.</span></span> <span data-ttu-id="60a97-1612">Por ejemplo, el código de C# `GetMember("MyMethod<int>")` busca un miembro con el nombre de texto "`MyMethod<int>`", en lugar de para un método denominado `MyMethod` que tiene un argumento genérico de tipo `int`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1612">For example, the C# code `GetMember("MyMethod<int>")` searches for a member with the text name "`MyMethod<int>`", rather than for a method named `MyMethod` that has one generic argument of type `int`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1613">El ejemplo siguiente busca sobrecargas concretas de `MethodA`, especificar restricciones de enlace, convenciones de llamada y una variedad de tipos de argumento.</span><span class="sxs-lookup"><span data-stu-id="60a97-1613">The following example finds specific overloads of `MethodA`, specifying binding constraints, calling conventions, and a variety of argument types.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1614">El [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] ejemplo requiere la `/unsafe` opción del compilador.</span><span class="sxs-lookup"><span data-stu-id="60a97-1614">The [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)] example requires the `/unsafe` compiler option.</span></span>  
  
 [!code-cpp[Type_GetMethod3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethod3/CPP/type_getmethod3.cpp#1)]
 [!code-csharp[Type_GetMethod3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethod3/CS/type_getmethod3.cs#1)]
 [!code-vb[Type_GetMethod3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethod3/VB/type_getmethod3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1615">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1615">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1616">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1616"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1617">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1617">-or-</span></span> 
 <span data-ttu-id="60a97-1618">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1618"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-1619">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1619">-or-</span></span> 
<span data-ttu-id="60a97-1620">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1620">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1621"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1621"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-1622">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1622">-or-</span></span> 
 <span data-ttu-id="60a97-1623"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1623"><paramref name="modifiers" /> is multidimensional.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethod">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo GetMethod (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Reflection.MethodInfo GetMethod(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethod(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Reflection::MethodInfo ^ GetMethod(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="member this.GetMethod : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethod (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.MethodInfo GetMethodImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1624">Cadena que contiene el nombre del método que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1624">The string containing the name of the method to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1625">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1625">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1626">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1626">-or-</span></span> 
<span data-ttu-id="60a97-1627">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1627">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-1628">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-1628">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-1629">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1629">-or-</span></span> 
<span data-ttu-id="60a97-1630">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1630">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="callConvention"><span data-ttu-id="60a97-1631">Objeto que especifica el conjunto de reglas que se va a usar en cuanto al orden y diseño de los argumentos, la forma de pasar el valor devuelto, los registros que se usan para los argumentos y el proceso encargado de limpiar la pila.</span><span class="sxs-lookup"><span data-stu-id="60a97-1631">The object that specifies the set of rules to use regarding the order and layout of arguments, how the return value is passed, what registers are used for arguments, and what process cleans up the stack.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-1632">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que el método debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1632">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the method to get.</span></span>  
  
<span data-ttu-id="60a97-1633">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1633">-or-</span></span> 
<span data-ttu-id="60a97-1634">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener un método que no requiera parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1634">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a method that takes no parameters.</span></span>  
  
<span data-ttu-id="60a97-1635">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1635">-or-</span></span> 
 <span data-ttu-id="60a97-1636"><see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1636"><see langword="null" />.</span></span> <span data-ttu-id="60a97-1637">Si <paramref name="types" /> es <see langword="null" />, no habrá coincidencias con los argumentos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1637">If <paramref name="types" /> is <see langword="null" />, arguments are not matched.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-1638">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1638">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-1639">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-1639">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-1640">Cuando se invalida en una clase derivada, busca el método especificado cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados y aplica las restricciones de enlace especificadas y la convención de llamada especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1640">When overridden in a derived class, searches for the specified method whose parameters match the specified argument types and modifiers, using the specified binding constraints and the specified calling convention.</span></span></summary>
        <returns><span data-ttu-id="60a97-1641">Objeto que representa el método que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1641">An object representing the method that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1642">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1642">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-1643">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-1643">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-1644">Si `types` es `null`, no habrá coincidencias con los argumentos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1644">If `types` is `null`, arguments are not matched.</span></span>  
  
 <span data-ttu-id="60a97-1645">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1645">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1646">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1646">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1647">Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1647">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1648">Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1648">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1649">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1649">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1650">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1650">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1651">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1651">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1652">`BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1652">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1653">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1653">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1654">Se encontró más de un método con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1654">More than one method is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1655">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1655"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-1656"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1656"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-1657">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1657">-or-</span></span> 
 <span data-ttu-id="60a97-1658"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-1658"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-1659">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1659">-or-</span></span> 
 <span data-ttu-id="60a97-1660"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-1660"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-1661">El tipo actual es <see cref="T:System.Reflection.Emit.TypeBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1661">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" /> or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.CallingConventions" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetMethods" />
      </Docs>
    </Member>
    <Member MemberName="GetMethodImpl">
      <MemberSignature Language="C#" Value="protected virtual System.Reflection.MethodInfo GetMethodImpl (string name, int genericParameterCount, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, System.Reflection.CallingConventions callConvention, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.MethodInfo GetMethodImpl(string name, int32 genericParameterCount, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, valuetype System.Reflection.CallingConventions callConvention, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethodImpl(System.String,System.Int32,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual System::Reflection::MethodInfo ^ GetMethodImpl(System::String ^ name, int genericParameterCount, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, System::Reflection::CallingConventions callConvention, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo&#xA;override this.GetMethodImpl : string * int * System.Reflection.BindingFlags * System.Reflection.Binder * System.Reflection.CallingConventions * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.MethodInfo" Usage="type.GetMethodImpl (name, genericParameterCount, bindingAttr, binder, callConvention, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="genericParameterCount" Type="System.Int32" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="callConvention" Type="System.Reflection.CallingConventions" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name">To be added.</param>
        <param name="genericParameterCount">To be added.</param>
        <param name="bindingAttr">To be added.</param>
        <param name="binder">To be added.</param>
        <param name="callConvention">To be added.</param>
        <param name="types">To be added.</param>
        <param name="modifiers">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetMethods">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1662">Obtiene los métodos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1662">Gets the methods of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public System.Reflection.MethodInfo[] GetMethods ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods" />
      <MemberSignature Language="VB.NET" Value="Public Function GetMethods () As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods();" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : unit -&gt; System.Reflection.MethodInfo[]&#xA;override this.GetMethods : unit -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1663">Devuelve todos los métodos públicos del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1663">Returns all the public methods of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1664">Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa todos los métodos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1664">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all the public methods defined for the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-1665">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1665">-or-</span></span> 
<span data-ttu-id="60a97-1666">Matriz vacía de tipo <see cref="T:System.Reflection.MethodInfo" /> si no hay métodos públicos definidos para el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1666">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no public methods are defined for the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1667">El <xref:System.Type.GetMethods%2A> método no devuelve los métodos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1667">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1668">El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1668">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1669">Los constructores no se incluyen en la matriz de los métodos devueltos por esta llamada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1669">Constructors are not included in the array of methods returned by this call.</span></span> <span data-ttu-id="60a97-1670">Realizar una llamada independiente a `GetConstructors()` para obtener los métodos de constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-1670">Make a separate call to `GetConstructors()` to get the constructor methods.</span></span>  
  
 <span data-ttu-id="60a97-1671">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1671">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1672">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1672">Member Type</span></span>|<span data-ttu-id="60a97-1673">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1673">Static</span></span>|<span data-ttu-id="60a97-1674">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1674">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1675">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1675">Constructor</span></span>|<span data-ttu-id="60a97-1676">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1676">No</span></span>|<span data-ttu-id="60a97-1677">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1677">No</span></span>|  
|<span data-ttu-id="60a97-1678">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1678">Field</span></span>|<span data-ttu-id="60a97-1679">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1679">No</span></span>|<span data-ttu-id="60a97-1680">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1680">Yes.</span></span> <span data-ttu-id="60a97-1681">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1681">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1682">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1682">Event</span></span>|<span data-ttu-id="60a97-1683">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1683">Not applicable</span></span>|<span data-ttu-id="60a97-1684">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1684">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1685">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1685">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1686">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1686">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1687">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1687">Method</span></span>|<span data-ttu-id="60a97-1688">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1688">No</span></span>|<span data-ttu-id="60a97-1689">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1689">Yes.</span></span> <span data-ttu-id="60a97-1690">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1690">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1691">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1691">Nested Type</span></span>|<span data-ttu-id="60a97-1692">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1692">No</span></span>|<span data-ttu-id="60a97-1693">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1693">No</span></span>|  
|<span data-ttu-id="60a97-1694">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1694">Property</span></span>|<span data-ttu-id="60a97-1695">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1695">Not applicable</span></span>|<span data-ttu-id="60a97-1696">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1696">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1697">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1697">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1698">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1698">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1699">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1699">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1700">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1700">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1701">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1701">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1702">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1702">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1703">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1703">Custom attributes are not part of the common type system.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1704">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1704">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1705">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1705">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1706">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1706">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1707">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1707">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetMethods">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.MethodInfo[] GetMethods (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.MethodInfo[] GetMethods(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetMethods(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetMethods (bindingAttr As BindingFlags) As MethodInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::MethodInfo ^&gt; ^ GetMethods(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetMethods : System.Reflection.BindingFlags -&gt; System.Reflection.MethodInfo[]" Usage="type.GetMethods bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetMethods(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MethodInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-1708">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1708">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1709">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1709">-or-</span></span> 
<span data-ttu-id="60a97-1710">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1710">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1711">Cuando se invalida en una clase derivada, busca los métodos definidos para el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1711">When overridden in a derived class, searches for the methods defined for the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1712">Matriz de objetos <see cref="T:System.Reflection.MethodInfo" /> que representa todos los métodos definidos para el objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1712">An array of <see cref="T:System.Reflection.MethodInfo" /> objects representing all methods defined for the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="60a97-1713">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1713">-or-</span></span> 
<span data-ttu-id="60a97-1714">Matriz vacía de tipo <see cref="T:System.Reflection.MethodInfo" /> si no se han definido métodos para el objeto <see cref="T:System.Type" /> actual o si ninguno de los métodos definidos coincide con las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1714">An empty array of type <see cref="T:System.Reflection.MethodInfo" />, if no methods are defined for the current <see cref="T:System.Type" />, or if none of the defined methods match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1715">El <xref:System.Type.GetMethods%2A> método no devuelve los métodos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1715">The <xref:System.Type.GetMethods%2A> method does not return methods in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1716">El código no debe depender del orden en que se devuelven los métodos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1716">Your code must not depend on the order in which methods are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1717">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los métodos van a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1717">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which methods to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1718">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1718">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1719">Especificar `BindingFlags.Public` para incluir métodos públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1719">Specify `BindingFlags.Public` to include public methods in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1720">Especificar `BindingFlags.NonPublic` para incluir métodos no públicos (es decir, métodos privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1720">Specify `BindingFlags.NonPublic` to include non-public methods (that is, private, internal, and protected methods) in the search.</span></span> <span data-ttu-id="60a97-1721">Solo protegido y se devuelven los métodos internos de las clases base; no se devuelven los métodos privados de las clases base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1721">Only protected and internal methods on base classes are returned; private methods on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="60a97-1722">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1722">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1723">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1723">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1724">`BindingFlags.DeclaredOnly` para buscar sólo los métodos declarados en el <xref:System.Type>, no los métodos que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1724">`BindingFlags.DeclaredOnly` to search only the methods declared on the <xref:System.Type>, not methods that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1725">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1725">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1726">No se puede omitir los parámetros al buscar los constructores y métodos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1726">You cannot omit parameters when looking up constructors and methods.</span></span> <span data-ttu-id="60a97-1727">Solo puede omitir los parámetros al invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-1727">You can only omit parameters when invoking.</span></span>  
  
 <span data-ttu-id="60a97-1728">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.MethodInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1728">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.MethodInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1729">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método busca en los métodos de la restricción de clase o los métodos de <xref:System.Object> si no hay ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1729">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the methods of the class constraint, or the methods of <xref:System.Object> if there is no class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1730">El ejemplo siguiente se crea una clase con dos métodos públicos y un método protegido, se crea un `Type` correspondiente objeto `MyTypeClass`, obtiene todos los métodos públicos y no públicos y se muestran sus nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-1730">The following example creates a class with two public methods and one protected method, creates a `Type` object corresponding to `MyTypeClass`, gets all public and non-public methods, and displays their names.</span></span>  
  
 [!code-cpp[Type_GetMethods2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetMethods2/CPP/type_getmethods2.cpp#1)]
 [!code-csharp[Type_GetMethods2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetMethods2/CS/type_getmethods2.cs#1)]
 [!code-vb[Type_GetMethods2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetMethods2/VB/type_getmethods2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MethodInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetMethod(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Reflection.CallingConventions,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1731">Obtiene un tipo específico anidado dentro del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1731">Gets a specific type nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public Type GetNestedType (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedType (name As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetNestedType(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string -&gt; Type&#xA;override this.GetNestedType : string -&gt; Type" Usage="type.GetNestedType name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1732">Cadena que contiene el nombre del tipo anidado que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1732">The string containing the name of the nested type to get.</span></span></param>
        <summary><span data-ttu-id="60a97-1733">Busca el tipo anidado público con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1733">Searches for the public nested type with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1734">Objeto que representa el tipo anidado público con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1734">An object representing the public nested type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1735">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1735">The search for `name` is case-sensitive.</span></span>  
  
 <span data-ttu-id="60a97-1736">Utilice el nombre sencillo de la clase anidada para `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1736">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="60a97-1737">No califique con el nombre de la clase externa.</span><span class="sxs-lookup"><span data-stu-id="60a97-1737">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="60a97-1738">Para una clase anidada genérica, utilice el nombre alterado: es decir, agregue un acento grave y el número de argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1738">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic arguments.</span></span> <span data-ttu-id="60a97-1739">Por ejemplo, use la cadena "interna\`1" obtener el tipo genérico de clase anidada `Inner<T>` (`Inner(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1739">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="60a97-1740">No incluya la sintaxis específica del lenguaje para los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1740">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="60a97-1741">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1741">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1742">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1742">Member Type</span></span>|<span data-ttu-id="60a97-1743">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1743">Static</span></span>|<span data-ttu-id="60a97-1744">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1744">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1745">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1745">Constructor</span></span>|<span data-ttu-id="60a97-1746">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1746">No</span></span>|<span data-ttu-id="60a97-1747">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1747">No</span></span>|  
|<span data-ttu-id="60a97-1748">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1748">Field</span></span>|<span data-ttu-id="60a97-1749">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1749">No</span></span>|<span data-ttu-id="60a97-1750">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1750">Yes.</span></span> <span data-ttu-id="60a97-1751">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1751">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1752">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1752">Event</span></span>|<span data-ttu-id="60a97-1753">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1753">Not applicable</span></span>|<span data-ttu-id="60a97-1754">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1754">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1755">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1755">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1756">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1756">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1757">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1757">Method</span></span>|<span data-ttu-id="60a97-1758">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1758">No</span></span>|<span data-ttu-id="60a97-1759">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1759">Yes.</span></span> <span data-ttu-id="60a97-1760">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1760">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1761">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1761">Nested Type</span></span>|<span data-ttu-id="60a97-1762">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1762">No</span></span>|<span data-ttu-id="60a97-1763">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1763">No</span></span>|  
|<span data-ttu-id="60a97-1764">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1764">Property</span></span>|<span data-ttu-id="60a97-1765">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1765">Not applicable</span></span>|<span data-ttu-id="60a97-1766">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1766">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1767">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1767">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1768">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1768">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1769">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1769">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1770">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1770">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1771">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1771">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1772">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1772">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1773">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1773">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1774">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1774">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-1775">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1775">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="60a97-1776">Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1776">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1777">Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios.</span><span class="sxs-lookup"><span data-stu-id="60a97-1777">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="60a97-1778">Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-1778">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="60a97-1779">Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1779">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1780">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1780"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedType">
      <MemberSignature Language="C#" Value="public abstract Type GetNestedType (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetNestedType(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedType(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedType (name As String, bindingAttr As BindingFlags) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract Type ^ GetNestedType(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedType : string * System.Reflection.BindingFlags -&gt; Type" Usage="type.GetNestedType (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedType(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1781">Cadena que contiene el nombre del tipo anidado que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1781">The string containing the name of the nested type to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1782">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1782">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1783">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1783">-or-</span></span> 
<span data-ttu-id="60a97-1784">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1784">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1785">Cuando se invalida en una clase derivada, busca el tipo anidado especificado y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1785">When overridden in a derived class, searches for the specified nested type, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1786">Objeto que representa el tipo anidado que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1786">An object representing the nested type that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1787">Utilice el nombre sencillo de la clase anidada para `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1787">Use the simple name of the nested class for `name`.</span></span> <span data-ttu-id="60a97-1788">No califique con el nombre de la clase externa.</span><span class="sxs-lookup"><span data-stu-id="60a97-1788">Do not qualify it with the name of the outer class.</span></span> <span data-ttu-id="60a97-1789">Para una clase anidada genérica, utilice el nombre alterado: es decir, agregue un acento grave y el número de parámetros genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1789">For a generic nested class, use the mangled name - that is, append a grave accent and the number of generic parameters.</span></span> <span data-ttu-id="60a97-1790">Por ejemplo, use la cadena "interna\`1" obtener el tipo genérico de clase anidada `Inner<T>` (`Inner(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1790">For example, use the string "Inner\`1" to get the generic nested class `Inner<T>` (`Inner(Of T)` in Visual Basic).</span></span> <span data-ttu-id="60a97-1791">No incluya la sintaxis específica del lenguaje para los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1791">Do not include language-specific syntax for type parameters.</span></span>  
  
 <span data-ttu-id="60a97-1792">La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1792">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1793">Debe especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1793">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1794">Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir los tipos anidados públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1794">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1795">Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1795">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="60a97-1796">Este método devuelve sólo los tipos anidados del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1796">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="60a97-1797">No se busca las clases base del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1797">It does not search the base classes of the current type.</span></span> <span data-ttu-id="60a97-1798">Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <xref:System.Type.GetNestedType%2A> en cada nivel.</span><span class="sxs-lookup"><span data-stu-id="60a97-1798">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedType%2A> at each level.</span></span>  
  
 <span data-ttu-id="60a97-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> se omiten.</span><span class="sxs-lookup"><span data-stu-id="60a97-1799"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="60a97-1800">Llamar a este método solamente con el <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> marca o solo el <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> marca devolverá los tipos anidados especificados y no requieren otros indicadores.</span><span class="sxs-lookup"><span data-stu-id="60a97-1800">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="60a97-1801">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1801">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1802">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1802">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-1803">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1803">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="60a97-1804">Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1804">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1805">Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios.</span><span class="sxs-lookup"><span data-stu-id="60a97-1805">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="60a97-1806">Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-1806">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="60a97-1807">Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1807">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1808">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1808"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedTypes" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetNestedTypes">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1809">Obtiene los tipos anidados dentro del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1809">Gets the types nested within the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public Type[] GetNestedTypes ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes" />
      <MemberSignature Language="VB.NET" Value="Public Function GetNestedTypes () As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;Type ^&gt; ^ GetNestedTypes();" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : unit -&gt; Type[]&#xA;override this.GetNestedTypes : unit -&gt; Type[]" Usage="type.GetNestedTypes " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1810">Devuelve los tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1810">Returns the public types nested in the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1811">Una matriz de objetos <see cref="T:System.Type" /> que representan los tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual (la búsqueda no es recursiva), o una matriz vacía de tipo <see cref="T:System.Type" /> si no hay tipos públicos anidados en el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1811">An array of <see cref="T:System.Type" /> objects representing the public types nested in the current <see cref="T:System.Type" /> (the search is not recursive), or an empty array of type <see cref="T:System.Type" /> if no public types are nested in the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1812">El <xref:System.Type.GetNestedTypes%2A> método no devuelve tipos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1812">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1813">El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1813">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1814">Se devuelven los tipos públicos anidados inmediatamente en el tipo actual; la búsqueda no es recursiva.</span><span class="sxs-lookup"><span data-stu-id="60a97-1814">Only the public types immediately nested in the current type are returned; the search is not recursive.</span></span>  
  
 <span data-ttu-id="60a97-1815">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1815">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1816">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1816">Member Type</span></span>|<span data-ttu-id="60a97-1817">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1817">Static</span></span>|<span data-ttu-id="60a97-1818">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1818">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1819">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1819">Constructor</span></span>|<span data-ttu-id="60a97-1820">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1820">No</span></span>|<span data-ttu-id="60a97-1821">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1821">No</span></span>|  
|<span data-ttu-id="60a97-1822">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1822">Field</span></span>|<span data-ttu-id="60a97-1823">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1823">No</span></span>|<span data-ttu-id="60a97-1824">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1824">Yes.</span></span> <span data-ttu-id="60a97-1825">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1825">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1826">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1826">Event</span></span>|<span data-ttu-id="60a97-1827">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1827">Not applicable</span></span>|<span data-ttu-id="60a97-1828">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1828">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1829">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1829">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1830">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1830">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1831">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1831">Method</span></span>|<span data-ttu-id="60a97-1832">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1832">No</span></span>|<span data-ttu-id="60a97-1833">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1833">Yes.</span></span> <span data-ttu-id="60a97-1834">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1834">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1835">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1835">Nested Type</span></span>|<span data-ttu-id="60a97-1836">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1836">No</span></span>|<span data-ttu-id="60a97-1837">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1837">No</span></span>|  
|<span data-ttu-id="60a97-1838">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1838">Property</span></span>|<span data-ttu-id="60a97-1839">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1839">Not applicable</span></span>|<span data-ttu-id="60a97-1840">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1840">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1841">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1841">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1842">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1842">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1843">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1843">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1844">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1844">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1845">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1845">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1846">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1846">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1847">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1847">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1848">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1848">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-1849">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1849">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="60a97-1850">Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1850">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1851">Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios.</span><span class="sxs-lookup"><span data-stu-id="60a97-1851">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="60a97-1852">Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-1852">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="60a97-1853">Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1853">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1854">En el ejemplo siguiente se define una clase anidada y un `struct` en `MyClass`y, a continuación, obtiene los objetos de los tipos anidados utilizando el tipo de `MyClass`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1854">The following example defines a nested class and a `struct` in `MyClass`, and then obtains objects of the nested types using the type of `MyClass`.</span></span>  
  
 [!code-cpp[Type_GetNestedTypes#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedTypes/CPP/type_getnestedtypes.cpp#1)]
 [!code-csharp[Type_GetNestedTypes#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedTypes/CS/type_getnestedtypes.cs#1)]
 [!code-vb[Type_GetNestedTypes#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedTypes/VB/type_getnestedtypes.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="GetNestedTypes">
      <MemberSignature Language="C#" Value="public abstract Type[] GetNestedTypes (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type[] GetNestedTypes(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetNestedTypes(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetNestedTypes (bindingAttr As BindingFlags) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;Type ^&gt; ^ GetNestedTypes(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetNestedTypes : System.Reflection.BindingFlags -&gt; Type[]" Usage="type.GetNestedTypes bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetNestedTypes(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-1855">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1855">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1856">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1856">-or-</span></span> 
<span data-ttu-id="60a97-1857">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1857">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1858">Cuando se invalida en una clase derivada, busca los tipos anidados en el objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1858">When overridden in a derived class, searches for the types nested in the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1859">Una matriz de objetos <see cref="T:System.Type" /> que representan todos los tipos anidados en el objeto <see cref="T:System.Type" /> actual que cumplen las restricciones de enlace especificadas (la búsqueda no es recursiva), o una matriz vacía de tipo <see cref="T:System.Type" />, si no se encuentran tipos anidados que cumplan las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1859">An array of <see cref="T:System.Type" /> objects representing all the types nested in the current <see cref="T:System.Type" /> that match the specified binding constraints (the search is not recursive), or an empty array of type <see cref="T:System.Type" />, if no nested types are found that match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1860">La búsqueda para los tipos anidados no es recursiva.</span><span class="sxs-lookup"><span data-stu-id="60a97-1860">The search for nested types is not recursive.</span></span>  
  
 <span data-ttu-id="60a97-1861">El <xref:System.Type.GetNestedTypes%2A> método no devuelve tipos en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1861">The <xref:System.Type.GetNestedTypes%2A> method does not return types in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1862">El código no debe depender del orden en que se devuelven los tipos, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1862">Your code must not depend on the order in which types are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1863">La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1863">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1864">Debe especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> o <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1864">You must specify either <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> or <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1865">Especificar <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> para incluir los tipos anidados públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1865">Specify <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> to include public nested types in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1866">Especificar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> para incluir los tipos anidados no públicos (es decir, privados, internos y protegidos tipos anidados) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1866">Specify <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> to include non-public nested types (that is, private, internal, and protected nested types) in the search.</span></span>  
  
 <span data-ttu-id="60a97-1867">Este método devuelve sólo los tipos anidados del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1867">This method returns only the nested types of the current type.</span></span> <span data-ttu-id="60a97-1868">No se busca las clases base del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1868">It does not search the base classes of the current type.</span></span> <span data-ttu-id="60a97-1869">Para buscar tipos que están anidados en clases base, debe recorrer la jerarquía de herencia, una llamada a <xref:System.Type.GetNestedTypes%2A> en cada nivel.</span><span class="sxs-lookup"><span data-stu-id="60a97-1869">To find types that are nested in base classes, you must walk the inheritance hierarchy, calling <xref:System.Type.GetNestedTypes%2A> at each level.</span></span>  
  
 <span data-ttu-id="60a97-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> y <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> se omiten.</span><span class="sxs-lookup"><span data-stu-id="60a97-1870"><xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> and <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> are ignored.</span></span>  
  
 <span data-ttu-id="60a97-1871">Llamar a este método solamente con el <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> marca o solo el <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> marca devolverá los tipos anidados especificados y no requieren otros indicadores.</span><span class="sxs-lookup"><span data-stu-id="60a97-1871">Calling this method with only the <xref:System.Reflection.BindingFlags.Public?displayProperty=nameWithType> flag or only the <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> flag will return the specified nested types and does not require any other flags.</span></span>  
  
 <span data-ttu-id="60a97-1872">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1872">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1873">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca los tipos anidados de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1873">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the nested types of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-1874">Si un tipo anidado es genérico, este método devuelve su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-1874">If a nested type is generic, this method returns its generic type definition.</span></span> <span data-ttu-id="60a97-1875">Esto es cierto incluso si el tipo genérico envolvente es un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1875">This is true even if the enclosing generic type is a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-1876">Si el actual <xref:System.Type> representa un tipo genérico definido en C#, Visual Basic o C++, sus tipos anidados son todos genéricos incluso si tienen que no hay parámetros genéricos de sus propios.</span><span class="sxs-lookup"><span data-stu-id="60a97-1876">If the current <xref:System.Type> represents a generic type defined in C#, Visual Basic, or C++, its nested types are all generic even if they have no generic parameters of their own.</span></span> <span data-ttu-id="60a97-1877">Esto no es necesariamente cierto de tipos anidados definidos en ensamblados dinámicos o compilados con la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-1877">This is not necessarily true of nested types defined in dynamic assemblies or compiled with the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span>  
  
 <span data-ttu-id="60a97-1878">Para obtener información sobre los tipos genéricos anidados y sobre cómo crear tipos genéricos anidados de sus definiciones de tipo genérico, vea <xref:System.Type.MakeGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1878">For information on nested generic types, and on constructing nested generic types from their generic type definitions, see <xref:System.Type.MakeGenericType%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1879">El ejemplo siguiente crea dos clases públicas anidadas y dos clases protegidas anidadas y muestra información para las clases que coinciden con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1879">The following example creates two nested public classes and two nested protected classes, and displays information for classes that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetNestedClassesAbs#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CPP/type_getnestedclassesabs.cpp#1)]
 [!code-csharp[Type_GetNestedClassesAbs#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetNestedClassesAbs/CS/type_getnestedclassesabs.cs#1)]
 [!code-vb[Type_GetNestedClassesAbs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetNestedClassesAbs/VB/type_getnestedclassesabs.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetNestedType(System.String)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperties">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1880">Obtiene las propiedades del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1880">Gets the properties of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo[] GetProperties ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperties () As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties();" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : unit -&gt; System.Reflection.PropertyInfo[]&#xA;override this.GetProperties : unit -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-1881">Devuelve todas las propiedades públicas del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1881">Returns all the public properties of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-1882">Matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa todas las propiedades públicas del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1882">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all public properties of the current <see cref="T:System.Type" />.</span></span>  
  
<span data-ttu-id="60a97-1883">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1883">-or-</span></span> 
<span data-ttu-id="60a97-1884">Matriz vacía de tipo <see cref="T:System.Reflection.PropertyInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene propiedades públicas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1884">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have public properties.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1885">Llamar a esta sobrecarga es equivalente a llamar a la <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> sobrecarga con un `bindingAttr` igual al argumento `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` en C# y `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60a97-1885">Calling this overload is equivalent to calling the <xref:System.Type.GetProperties%28System.Reflection.BindingFlags%29> overload with a `bindingAttr` argument equal to `BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public` in C# and  `BindingFlags.Instance Or BindingFlags.Static Or BindingFlags.Public` in Visual Basic.</span></span> <span data-ttu-id="60a97-1886">Devuelve todas las instancias públicos y propiedades estáticas, tanto los definidos por el tipo representado por el actual <xref:System.Type> objeto, así como las que se hereden de sus tipos base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1886">It returns all public instance and static properties, both those defined by the type represented by the current <xref:System.Type> object as well as those inherited from its base types.</span></span>  
  
 <span data-ttu-id="60a97-1887">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-1887">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-1888">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1888">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-1889">El <xref:System.Type.GetProperties%2A> método no devuelve las propiedades en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1889">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1890">El código no debe depender del orden en que se devuelven las propiedades, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1890">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1891">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1891">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-1892">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-1892">Member Type</span></span>|<span data-ttu-id="60a97-1893">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1893">Static</span></span>|<span data-ttu-id="60a97-1894">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-1894">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-1895">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-1895">Constructor</span></span>|<span data-ttu-id="60a97-1896">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1896">No</span></span>|<span data-ttu-id="60a97-1897">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1897">No</span></span>|  
|<span data-ttu-id="60a97-1898">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-1898">Field</span></span>|<span data-ttu-id="60a97-1899">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1899">No</span></span>|<span data-ttu-id="60a97-1900">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1900">Yes.</span></span> <span data-ttu-id="60a97-1901">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1901">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1902">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-1902">Event</span></span>|<span data-ttu-id="60a97-1903">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1903">Not applicable</span></span>|<span data-ttu-id="60a97-1904">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1904">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1905">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1905">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1906">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1906">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-1907">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-1907">Method</span></span>|<span data-ttu-id="60a97-1908">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1908">No</span></span>|<span data-ttu-id="60a97-1909">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-1909">Yes.</span></span> <span data-ttu-id="60a97-1910">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-1910">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-1911">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-1911">Nested Type</span></span>|<span data-ttu-id="60a97-1912">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1912">No</span></span>|<span data-ttu-id="60a97-1913">No</span><span class="sxs-lookup"><span data-stu-id="60a97-1913">No</span></span>|  
|<span data-ttu-id="60a97-1914">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1914">Property</span></span>|<span data-ttu-id="60a97-1915">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-1915">Not applicable</span></span>|<span data-ttu-id="60a97-1916">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1916">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-1917">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1917">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1918">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-1918">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-1919">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1919">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-1920">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-1920">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-1921">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-1921">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-1922">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1922">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-1923">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-1923">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-1924">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1924">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1925">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1925">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1926">En el siguiente ejemplo se muestra el uso del método `GetProperties`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1926">The following example demonstrates the use of the `GetProperties` method.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#2)]
 [!code-csharp[Type_GetTypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#2)]
 [!code-vb[Type_GetTypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <Member MemberName="GetProperties">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.PropertyInfo[] GetProperties (System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo[] GetProperties(valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetProperties (bindingAttr As BindingFlags) As PropertyInfo()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract cli::array &lt;System::Reflection::PropertyInfo ^&gt; ^ GetProperties(System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperties : System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo[]" Usage="type.GetProperties bindingAttr" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperties(System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="bindingAttr"><span data-ttu-id="60a97-1927">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1927">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1928">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1928">-or-</span></span> 
<span data-ttu-id="60a97-1929">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1929">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1930">Cuando se invalida en una clase derivada, busca las propiedades del objeto <see cref="T:System.Type" /> actual y aplica las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1930">When overridden in a derived class, searches for the properties of the current <see cref="T:System.Type" />, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1931">Matriz de objetos <see cref="T:System.Reflection.PropertyInfo" /> que representa a todas las propiedades del objeto <see cref="T:System.Type" /> actual que coincidan con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1931">An array of <see cref="T:System.Reflection.PropertyInfo" /> objects representing all properties of the current <see cref="T:System.Type" /> that match the specified binding constraints.</span></span>  
  
<span data-ttu-id="60a97-1932">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1932">-or-</span></span> 
<span data-ttu-id="60a97-1933">Matriz vacía de tipo <see cref="T:System.Reflection.PropertyInfo" /> si el objeto <see cref="T:System.Type" /> actual no tiene propiedades o si ninguna de las propiedades coincide con las restricciones de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-1933">An empty array of type <see cref="T:System.Reflection.PropertyInfo" />, if the current <see cref="T:System.Type" /> does not have properties, or if none of the properties match the binding constraints.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1934">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-1934">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-1935">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1935">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-1936">El <xref:System.Type.GetProperties%2A> método no devuelve las propiedades en un orden concreto, como alfabético o el orden de declaración.</span><span class="sxs-lookup"><span data-stu-id="60a97-1936">The <xref:System.Type.GetProperties%2A> method does not return properties in a particular order, such as alphabetical or declaration order.</span></span> <span data-ttu-id="60a97-1937">El código no debe depender del orden en que se devuelven las propiedades, porque ese orden varía.</span><span class="sxs-lookup"><span data-stu-id="60a97-1937">Your code must not depend on the order in which properties are returned, because that order varies.</span></span>  
  
 <span data-ttu-id="60a97-1938">La siguiente <xref:System.Reflection.BindingFlags> filtro indicadores pueden utilizarse para definir que anidar tipos debe para incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1938">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which nested types to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1939">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1939">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1940">Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1940">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1941">Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1941">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span> <span data-ttu-id="60a97-1942">Solo se devuelven propiedades internas de las clases base; y protegidos no se devuelven las propiedades privadas de las clases base.</span><span class="sxs-lookup"><span data-stu-id="60a97-1942">Only protected and internal properties on base classes are returned; private properties on base classes are not returned.</span></span>  
  
-   <span data-ttu-id="60a97-1943">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1943">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1944">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1944">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1945">`BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1945">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-1946">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-1946">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-1947">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-1947">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-1948">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1948">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-1949">Si el Type actual representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> objetos con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1949">If the current T:System.Type represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> objects with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1950">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1950">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1951">En el ejemplo siguiente se define una clase denominada `PropertyClass` que incluye seis propiedades: dos son públicos, uno es privado, uno está protegida, uno es interno (`Friend` en Visual Basic), y uno es protected internal (`Protected Friend` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1951">The following example defines a class named `PropertyClass` that includes six properties: two are public, one is private, one is protected, one is internal (`Friend` in Visual Basic), and one is protected internal (`Protected Friend` in Visual Basic).</span></span> <span data-ttu-id="60a97-1952">A continuación, muestra información básica de propiedad (el nombre de propiedad y el tipo, si es lectura/escritura y la visibilidad de su `get` y `set` descriptores de acceso) para las propiedades que coinciden con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1952">It then displays some basic property information (the property name and type, whether it is read/write, and the visibility of its `get` and `set` accessors) for the properties that match the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperties2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperties2/CPP/type_getproperties2.cpp#1)]
 [!code-csharp[Type_GetProperties2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperties2/CS/type_getproperties2.cs#1)]
 [!code-vb[Type_GetProperties2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperties2/VB/type_getproperties2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetProperty">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-1953">Obtiene una propiedad específica del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-1953">Gets a specific property of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty name" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1954">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1954">The string containing the name of the public property to get.</span></span></param>
        <summary><span data-ttu-id="60a97-1955">Busca la propiedad pública con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1955">Searches for the public property with the specified name.</span></span></summary>
        <returns><span data-ttu-id="60a97-1956">Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1956">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1957">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1957">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-1958">La búsqueda incluye las propiedades de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-1958">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="60a97-1959">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-1959">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-1960">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1960">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-1961">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1961">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-1962">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-1962">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-1963">Situaciones en las que <xref:System.Reflection.AmbiguousMatchException> se produce incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-1963">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="60a97-1964">Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero distintos números de parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-1964">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="60a97-1965">Para resolver la ambigüedad, use una sobrecarga de la <xref:System.Type.GetProperty%2A> método que especifica los tipos de parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-1965">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="60a97-1966">Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, mediante el uso de la `new` modificador (`Shadows` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-1966">A derived type declares a property that hides an inherited property with the same name, by using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="60a97-1967">Para resolver la ambigüedad, use el <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> sobrecarga de método y agregue el <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> marca para restringir la búsqueda a los miembros que no se heredan.</span><span class="sxs-lookup"><span data-stu-id="60a97-1967">To resolve the ambiguity, use the <xref:System.Type.GetProperty%28System.String%2CSystem.Reflection.BindingFlags%29> method overload and add the <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> flag to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-1968">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-1968">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1969">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-1970">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-1970">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-1971">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1971">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-1972">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-1972">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-1973">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-1973">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-1974">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-1974">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-1975">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-1975">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-1976">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-1976">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-1977">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1977">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-1978">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-1978">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-1979">En el ejemplo siguiente se recupera el `Type` objeto de una clase definida por el usuario, recupera una propiedad de esa clase y muestra el nombre de propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1979">The following example retrieves the `Type` object of a user-defined class, retrieves a property of that class, and displays the property name.</span></span>  
  
 [!code-cpp[Type_GetProperty1#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty1/CPP/type_getproperty1.cpp#1)]
 [!code-csharp[Type_GetProperty1#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty1/CS/type_getproperty1.cs#1)]
 [!code-vb[Type_GetProperty1#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty1/VB/type_getproperty1.vb#1)]  
  
 <span data-ttu-id="60a97-1980">Internamente, esta propiedad se conoce en los metadatos con el nombre "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-1980">Internally, this property is referred to in the metadata by the name "Item."</span></span> <span data-ttu-id="60a97-1981">Cualquier intento de obtener `PropertyInfo` mediante reflexión, debe especificar este nombre interno para devolver correctamente la `PropertyInfo` propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-1981">Any attempt to get `PropertyInfo` using reflection must specify this internal name in order to correctly return the `PropertyInfo` property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-1982">Se encontró más de una propiedad con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1982">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-1983">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1983"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, bindingAttr As BindingFlags) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-1984">Cadena que contiene el nombre de la propiedad que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-1984">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-1985">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1985">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-1986">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-1986">-or-</span></span> 
<span data-ttu-id="60a97-1987">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1987">Zero, to return <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="60a97-1988">Busca la propiedad especificada, mediante las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-1988">Searches for the specified property, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-1989">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-1989">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-1990">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-1990">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-1991">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-1991">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-1992">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1992">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-1993">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-1993">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-1994">Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1994">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1995">Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-1995">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-1996">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-1996">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-1997">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-1997">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-1998">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-1998">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-1999">`BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-1999">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-2000">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-2000">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-2001">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2001">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2002">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2002">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
 <span data-ttu-id="60a97-2003">Situaciones en las que <xref:System.Reflection.AmbiguousMatchException> se produce incluyen lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-2003">Situations in which <xref:System.Reflection.AmbiguousMatchException> occurs include the following:</span></span>  
  
-   <span data-ttu-id="60a97-2004">Un tipo contiene dos propiedades indizadas que tienen el mismo nombre pero distintos números de parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-2004">A type contains two indexed properties that have the same name but different numbers of parameters.</span></span> <span data-ttu-id="60a97-2005">Para resolver la ambigüedad, use una sobrecarga de la <xref:System.Type.GetProperty%2A> método que especifica los tipos de parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2005">To resolve the ambiguity, use an overload of the <xref:System.Type.GetProperty%2A> method that specifies parameter types.</span></span>  
  
-   <span data-ttu-id="60a97-2006">Un tipo derivado declara una propiedad que oculta una propiedad heredada con el mismo nombre, mediante el `new` modificador (`Shadows` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-2006">A derived type declares a property that hides an inherited property with the same name, using the `new` modifier (`Shadows` in Visual Basic).</span></span> <span data-ttu-id="60a97-2007">Para resolver la ambigüedad, incluya <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> para restringir la búsqueda a los miembros que no se heredan.</span><span class="sxs-lookup"><span data-stu-id="60a97-2007">To resolve the ambiguity, include <xref:System.Reflection.BindingFlags.DeclaredOnly?displayProperty=nameWithType> to restrict the search to members that are not inherited.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2008">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2008">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2009">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2010">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2010">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2011">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2011">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2012">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2012">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2013">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2013">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2014">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2014">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2015">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2015">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2016">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2016">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2017">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2017">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2018">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2018">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2019">El ejemplo siguiente recupera el tipo de una clase definida por el usuario, recupera una propiedad de esa clase y muestra el nombre de propiedad de acuerdo con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2019">The following example retrieves the type of a user-defined class, retrieves a property of that class and displays the property name in accordance with the specified binding constraints.</span></span>  
  
 [!code-cpp[Type_GetProperty2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty2/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty2/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty2/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2020">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2020">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2021">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2021"><paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2022">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2022">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="60a97-2023">Tipo de valor devuelto de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2023">The return type of the property.</span></span></param>
        <summary><span data-ttu-id="60a97-2024">Busca la propiedad pública con el nombre especificado y el tipo de valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-2024">Searches for the public property with the specified name and return type.</span></span></summary>
        <returns><span data-ttu-id="60a97-2025">Objeto que representa la propiedad pública con el nombre especificado, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2025">An object representing the public property with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2026">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-2026">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-2027">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2027">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-2028">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2028">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-2029">La búsqueda incluye las propiedades de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-2029">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="60a97-2030">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2030">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2031">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2031">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2032">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2032">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2033">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2034">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2034">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2035">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2035">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2036">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2036">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2037">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2037">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2038">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2038">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2039">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2039">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2040">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2040">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2041">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2041">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2042">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2042">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2043">El ejemplo siguiente define una clase con una propiedad y recupera el nombre y tipo de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2043">The following example defines a class with one property and retrieves the name and type of the property.</span></span>  
  
 [!code-cpp[Type_GetProperty_Types#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty_Types/CPP/type_getproperty_types.cpp#1)]
 [!code-csharp[Type_GetProperty_Types#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty_Types/CS/type_getproperty_types.cs#1)]
 [!code-vb[Type_GetProperty_Types#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty_Types/VB/type_getproperty_types.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2044">Se encontró más de una propiedad con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2044">More than one property is found with the specified name.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2045"><paramref name="name" /> es <see langword="null" /> o <paramref name="returnType" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2045"><paramref name="name" /> is <see langword="null" />, or <paramref name="returnType" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2046">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2046">The string containing the name of the public property to get.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-2047">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2047">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="60a97-2048">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2048">-or-</span></span> 
<span data-ttu-id="60a97-2049">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2049">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="60a97-2050">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2050">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="60a97-2051">Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2051">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2052">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-2052">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-2053">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2053">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-2054">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2054">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-2055">La búsqueda incluye las propiedades de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-2055">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="60a97-2056">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2056">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2057">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2057">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2058">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2058">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2059">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2060">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2060">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2061">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2061">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2062">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2062">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2063">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2063">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2064">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2064">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2065">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2065">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2066">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2066">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2067">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2067">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2068">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2068">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2069">En el ejemplo siguiente se recupera el `Type` objeto de una clase definida por el usuario, recupera la propiedad de esa clase y muestra el nombre de propiedad y el tipo de la propiedad según lo especificado por los argumentos pasados a `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2069">The following example retrieves the `Type` object of a user-defined class, retrieves the property of that class, and displays the property name and type of the property as specified by the arguments passed to `GetProperty`.</span></span>  
  
 [!code-cpp[Type_GetProperty3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty3/CPP/type_getproperty3.cpp#1)]
 [!code-csharp[Type_GetProperty3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty3/CS/type_getproperty3.cs#1)]
 [!code-vb[Type_GetProperty3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty3/VB/type_getproperty3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2070">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2070">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2071">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2071"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2072">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2072">-or-</span></span> 
 <span data-ttu-id="60a97-2073">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2073"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2074"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2074"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="60a97-2075">Un elemento de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2075">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2076">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2076">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="60a97-2077">Tipo de valor devuelto de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2077">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-2078">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2078">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="60a97-2079">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2079">-or-</span></span> 
<span data-ttu-id="60a97-2080">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2080">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <summary><span data-ttu-id="60a97-2081">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos de argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2081">Searches for the specified public property whose parameters match the specified argument types.</span></span></summary>
        <returns><span data-ttu-id="60a97-2082">Objeto que representa la propiedad pública cuyos parámetros coinciden con los tipos de argumentos especificados, si se encuentra; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2082">An object representing the public property whose parameters match the specified argument types, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2083">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-2083">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-2084">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2084">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-2085">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2085">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-2086">La búsqueda incluye las propiedades de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-2086">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="60a97-2087">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2087">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2088">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2088">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2089">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2089">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2090">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2091">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2091">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2092">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2092">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2093">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2093">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2094">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2094">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2095">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2095">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2096">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2096">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2097">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2097">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2098">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2098">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2099">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2099">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2100">Se encontró más de una propiedad con el nombre especificado y que coincide con los tipos de argumento especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2100">More than one property is found with the specified name and matching the specified argument types.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2101">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2101"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2102">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2102">-or-</span></span> 
 <span data-ttu-id="60a97-2103">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2103"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2104"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2104"><paramref name="types" /> is multidimensional.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="60a97-2105">Un elemento de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2105">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="VB.NET" Value="Public Function GetProperty (name As String, returnType As Type, types As Type(), modifiers As ParameterModifier()) As PropertyInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2106">Cadena que contiene el nombre de la propiedad pública que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2106">The string containing the name of the public property to get.</span></span></param>
        <param name="returnType"><span data-ttu-id="60a97-2107">Tipo de valor devuelto de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2107">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-2108">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2108">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="60a97-2109">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2109">-or-</span></span> 
<span data-ttu-id="60a97-2110">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2110">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-2111">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2111">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-2112">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2112">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-2113">Busca la propiedad pública especificada cuyos parámetros coincidan con los tipos y modificadores de los argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2113">Searches for the specified public property whose parameters match the specified argument types and modifiers.</span></span></summary>
        <returns><span data-ttu-id="60a97-2114">Objeto que representa la propiedad pública que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2114">An object representing the public property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2115">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-2115">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-2116">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2116">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-2117">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2117">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-2118">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-2118">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-2119">La búsqueda de `name` distingue mayúsculas de minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2119">The search for `name` is case-sensitive.</span></span> <span data-ttu-id="60a97-2120">La búsqueda incluye las propiedades de instancia pública de static y public.</span><span class="sxs-lookup"><span data-stu-id="60a97-2120">The search includes public static and public instance properties.</span></span>  
  
 <span data-ttu-id="60a97-2121">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2121">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2122">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2122">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2123">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2123">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2124">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2125">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2125">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2126">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2126">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2127">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2127">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2128">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2128">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2129">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2129">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2130">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2130">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2131">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2131">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2132">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2132">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2133">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2133">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2134">En el ejemplo siguiente se obtiene un `Type` objeto correspondiente a `MyPropertyClass`, y la propiedad indizada de esta clase se recupera mediante los argumentos pasados a la `GetProperty` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2134">The following example obtains a `Type` object corresponding to `MyPropertyClass`, and the indexed property of this class is retrieved using the arguments passed to the `GetProperty` method.</span></span>  
  
 [!code-cpp[Type_GetProperty5#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetProperty5/CPP/type_getproperty2.cpp#1)]
 [!code-csharp[Type_GetProperty5#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetProperty5/CS/type_getproperty2.cs#1)]
 [!code-vb[Type_GetProperty5#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetProperty5/VB/type_getproperty2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2135">Existe más de una propiedad con el nombre especificado que coincide con los modificadores y tipos de argumentos especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2135">More than one property is found with the specified name and matching the specified argument types and modifiers.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2136">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2136"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2137">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2137">-or-</span></span> 
 <span data-ttu-id="60a97-2138">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2138"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2139"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2139"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2140">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2140">-or-</span></span> 
 <span data-ttu-id="60a97-2141"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2141"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2142">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2142">-or-</span></span> 
 <span data-ttu-id="60a97-2143"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-2143"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="60a97-2144">Un elemento de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2144">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetProperty">
      <MemberSignature Language="C#" Value="public System.Reflection.PropertyInfo GetProperty (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Reflection.PropertyInfo GetProperty(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Reflection::PropertyInfo ^ GetProperty(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo&#xA;override this.GetProperty : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetProperty (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2145">Cadena que contiene el nombre de la propiedad que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2145">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-2146">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2146">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-2147">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2147">-or-</span></span> 
<span data-ttu-id="60a97-2148">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2148">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-2149">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-2149">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-2150">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2150">-or-</span></span> 
<span data-ttu-id="60a97-2151">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2151">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="60a97-2152">Tipo de valor devuelto de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2152">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-2153">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2153">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="60a97-2154">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2154">-or-</span></span> 
<span data-ttu-id="60a97-2155">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2155">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-2156">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2156">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-2157">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2157">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-2158">Busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, mediante las restricciones de enlace indicadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2158">Searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-2159">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2159">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2160">Una propiedad se considera pública para la reflexión si tiene al menos un descriptor de acceso público.</span><span class="sxs-lookup"><span data-stu-id="60a97-2160">A property is considered public to reflection if it has at least one accessor that is public.</span></span> <span data-ttu-id="60a97-2161">En caso contrario, la propiedad se considera privada, y debe utilizar <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (en Visual Basic, combine los valores utilizando `Or`) para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2161">Otherwise the property is considered private, and you must use <xref:System.Reflection.BindingFlags.NonPublic?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Instance?displayProperty=nameWithType> &#124; <xref:System.Reflection.BindingFlags.Static?displayProperty=nameWithType> (in Visual Basic, combine the values using `Or`) to get it.</span></span>  
  
 <span data-ttu-id="60a97-2162">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2162">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-2163">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-2163">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-2164">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2164">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-2165">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-2165">Member Type</span></span>|<span data-ttu-id="60a97-2166">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2166">Static</span></span>|<span data-ttu-id="60a97-2167">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2167">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-2168">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-2168">Constructor</span></span>|<span data-ttu-id="60a97-2169">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2169">No</span></span>|<span data-ttu-id="60a97-2170">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2170">No</span></span>|  
|<span data-ttu-id="60a97-2171">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-2171">Field</span></span>|<span data-ttu-id="60a97-2172">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2172">No</span></span>|<span data-ttu-id="60a97-2173">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2173">Yes.</span></span> <span data-ttu-id="60a97-2174">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2174">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2175">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-2175">Event</span></span>|<span data-ttu-id="60a97-2176">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2176">Not applicable</span></span>|<span data-ttu-id="60a97-2177">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2177">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2178">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2178">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2179">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2179">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-2180">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-2180">Method</span></span>|<span data-ttu-id="60a97-2181">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2181">No</span></span>|<span data-ttu-id="60a97-2182">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2182">Yes.</span></span> <span data-ttu-id="60a97-2183">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-2183">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2184">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-2184">Nested Type</span></span>|<span data-ttu-id="60a97-2185">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2185">No</span></span>|<span data-ttu-id="60a97-2186">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2186">No</span></span>|  
|<span data-ttu-id="60a97-2187">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2187">Property</span></span>|<span data-ttu-id="60a97-2188">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2188">Not applicable</span></span>|<span data-ttu-id="60a97-2189">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2189">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2190">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2190">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2191">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2191">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-2192">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2192">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-2193">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2193">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-2194">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2194">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2195">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-2195">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-2196">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-2196">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-2197">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-2197">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-2198">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-2198">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-2199">Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2199">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="60a97-2200">Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2200">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-2201">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-2201">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-2202">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-2202">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-2203">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2203">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-2204">`BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2204">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-2205">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-2205">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-2206">Si el actual <xref:System.Type> representa un tipo genérico construido, este método devuelve el <xref:System.Reflection.PropertyInfo> con los parámetros de tipo sustituidos por los argumentos de tipo adecuado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2206">If the current <xref:System.Type> represents a constructed generic type, this method returns the <xref:System.Reflection.PropertyInfo> with the type parameters replaced by the appropriate type arguments.</span></span>  
  
 <span data-ttu-id="60a97-2207">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, este método busca en las propiedades de la restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-2207">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method searches the properties of the class constraint.</span></span>  
  
## <a name="indexers-and-default-properties"></a><span data-ttu-id="60a97-2208">Los indizadores y propiedades predeterminadas</span><span class="sxs-lookup"><span data-stu-id="60a97-2208">Indexers and Default Properties</span></span>  
 [!INCLUDE[vbprvblong](~/includes/vbprvblong-md.md)]<span data-ttu-id="60a97-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], y [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] tienen una sintaxis para tener acceso a las propiedades indizadas simplificada y permitir que una propiedad indizada para formar un valor predeterminado para su tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2209">, [!INCLUDE[csprcslong](~/includes/csprcslong-md.md)], and [!INCLUDE[vcprvclong](~/includes/vcprvclong-md.md)] have simplified syntax for accessing indexed properties and allow one indexed property to be a default for its type.</span></span> <span data-ttu-id="60a97-2210">Por ejemplo, si la variable `myList` hace referencia a un <xref:System.Collections.ArrayList>, la sintaxis `myList[3]` (`myList(3)` en Visual Basic) recupera el elemento con el índice 3.</span><span class="sxs-lookup"><span data-stu-id="60a97-2210">For example, if the variable `myList` refers to an <xref:System.Collections.ArrayList>, the syntax `myList[3]` (`myList(3)` in Visual Basic) retrieves the element with the index of 3.</span></span> <span data-ttu-id="60a97-2211">Puede sobrecargar la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2211">You can overload the property.</span></span>  
  
 <span data-ttu-id="60a97-2212">En C#, esta característica se llama a un indizador y no se refiere por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-2212">In C#, this feature is called an indexer and cannot be refered to by name.</span></span> <span data-ttu-id="60a97-2213">De forma predeterminada, un indizador de C# aparece en los metadatos como una propiedad indizada denominada "Item".</span><span class="sxs-lookup"><span data-stu-id="60a97-2213">By default, a C# indexer appears in metadata as an indexed property named "Item".</span></span> <span data-ttu-id="60a97-2214">Sin embargo, puede usar un desarrollador de bibliotecas de clase el <xref:System.Runtime.CompilerServices.IndexerNameAttribute> atributo para cambiar el nombre del indizador en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2214">However, a class library developer can use the <xref:System.Runtime.CompilerServices.IndexerNameAttribute> attribute to change the name of the indexer in the metadata.</span></span> <span data-ttu-id="60a97-2215">Por ejemplo, el <xref:System.String> clase tiene un indizador denominado <xref:System.String.Chars%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2215">For example, the <xref:System.String> class has an indexer named <xref:System.String.Chars%2A>.</span></span> <span data-ttu-id="60a97-2216">Las propiedades indizadas creadas mediante lenguajes diferentes de C# pueden tener nombres que no sean elementos, también.</span><span class="sxs-lookup"><span data-stu-id="60a97-2216">Indexed properties created using languages other than C# can have names other than Item, as well.</span></span>  
  
 <span data-ttu-id="60a97-2217">Para determinar si un tipo tiene una propiedad predeterminada, utilice el <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> método para probar la <xref:System.Reflection.DefaultMemberAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2217">To determine whether a type has a default property, use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%28System.Type%2CSystem.Boolean%29> method to test for the <xref:System.Reflection.DefaultMemberAttribute> attribute.</span></span> <span data-ttu-id="60a97-2218">Si el tipo tiene <xref:System.Reflection.DefaultMemberAttribute>, el <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> propiedad devuelve el nombre de la propiedad predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2218">If the type has <xref:System.Reflection.DefaultMemberAttribute>, the <xref:System.Reflection.DefaultMemberAttribute.MemberName%2A> property returns the name of the default property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2219">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2219">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2220">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2220"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2221">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2221">-or-</span></span> 
 <span data-ttu-id="60a97-2222">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2222"><paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2223"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2223"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2224">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2224">-or-</span></span> 
 <span data-ttu-id="60a97-2225"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2225"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2226">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2226">-or-</span></span> 
 <span data-ttu-id="60a97-2227"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-2227"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NullReferenceException"><span data-ttu-id="60a97-2228">Un elemento de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2228">An element of <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <Member MemberName="GetPropertyImpl">
      <MemberSignature Language="C#" Value="protected abstract System.Reflection.PropertyInfo GetPropertyImpl (string name, System.Reflection.BindingFlags bindingAttr, System.Reflection.Binder binder, Type returnType, Type[] types, System.Reflection.ParameterModifier[] modifiers);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Reflection.PropertyInfo GetPropertyImpl(string name, valuetype System.Reflection.BindingFlags bindingAttr, class System.Reflection.Binder binder, class System.Type returnType, class System.Type[] types, valuetype System.Reflection.ParameterModifier[] modifiers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetPropertyImpl(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Reflection::PropertyInfo ^ GetPropertyImpl(System::String ^ name, System::Reflection::BindingFlags bindingAttr, System::Reflection::Binder ^ binder, Type ^ returnType, cli::array &lt;Type ^&gt; ^ types, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers);" />
      <MemberSignature Language="F#" Value="abstract member GetPropertyImpl : string * System.Reflection.BindingFlags * System.Reflection.Binder * Type * Type[] * System.Reflection.ParameterModifier[] -&gt; System.Reflection.PropertyInfo" Usage="type.GetPropertyImpl (name, bindingAttr, binder, returnType, types, modifiers)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.PropertyInfo</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="bindingAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="returnType" Type="System.Type" />
        <Parameter Name="types" Type="System.Type[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-2229">Cadena que contiene el nombre de la propiedad que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2229">The string containing the name of the property to get.</span></span></param>
        <param name="bindingAttr"><span data-ttu-id="60a97-2230">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2230">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span>  
  
<span data-ttu-id="60a97-2231">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2231">-or-</span></span> 
<span data-ttu-id="60a97-2232">Cero, para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2232">Zero, to return <see langword="null" />.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-2233">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace que pueden implicar la selección de un miembro sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-2233">An object that defines a set of properties and enables binding, which can involve selection of an overloaded member, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-2234">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2234">-or-</span></span> 
<span data-ttu-id="60a97-2235">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2235">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span></param>
        <param name="returnType"><span data-ttu-id="60a97-2236">Tipo de valor devuelto de la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2236">The return type of the property.</span></span></param>
        <param name="types"><span data-ttu-id="60a97-2237">Matriz de objetos <see cref="T:System.Type" /> que representa el número, el orden y el tipo de parámetros que la propiedad indizada debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2237">An array of <see cref="T:System.Type" /> objects representing the number, order, and type of the parameters for the indexed property to get.</span></span>  
  
<span data-ttu-id="60a97-2238">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2238">-or-</span></span> 
<span data-ttu-id="60a97-2239">Matriz vacía del tipo <see cref="T:System.Type" /> (es decir, Type[] types = new Type[0]) para obtener una propiedad que no esté indizada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2239">An empty array of the type <see cref="T:System.Type" /> (that is, Type[] types = new Type[0]) to get a property that is not indexed.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-2240">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="types" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2240">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="types" /> array.</span></span> <span data-ttu-id="60a97-2241">El enlazador predeterminado no procesa este parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2241">The default binder does not process this parameter.</span></span></param>
        <summary><span data-ttu-id="60a97-2242">Cuando se invalida en una clase derivada, busca la propiedad especificada cuyos parámetros coincidan con los tipos y modificadores de argumentos especificados, usando las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2242">When overridden in a derived class, searches for the specified property whose parameters match the specified argument types and modifiers, using the specified binding constraints.</span></span></summary>
        <returns><span data-ttu-id="60a97-2243">Objeto que representa la propiedad que cumple los requisitos especificados, si se encuentra; en caso contrario, es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2243">An object representing the property that matches the specified requirements, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2244">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> (el `modifiers` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2244">Although the default binder does not process <xref:System.Reflection.ParameterModifier> (the `modifiers` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers`.</span></span> <span data-ttu-id="60a97-2245">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-2245">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-2246">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir las propiedades que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-2246">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which properties to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-2247">Debe especificar `BindingFlags.Instance` o `BindingFlags.Static` con el fin de obtener un valor devuelto.</span><span class="sxs-lookup"><span data-stu-id="60a97-2247">You must specify either `BindingFlags.Instance` or `BindingFlags.Static` in order to get a return.</span></span>  
  
-   <span data-ttu-id="60a97-2248">Especificar `BindingFlags.Public` para incluir propiedades públicas en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2248">Specify `BindingFlags.Public` to include public properties in the search.</span></span>  
  
-   <span data-ttu-id="60a97-2249">Especificar `BindingFlags.NonPublic` para incluir propiedades no públicas (es decir, las propiedades privadas, internas y protegidas) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-2249">Specify `BindingFlags.NonPublic` to include non-public properties (that is, private, internal, and protected properties) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-2250">Especificar `BindingFlags.FlattenHierarchy` para incluir `public` y `protected` miembros estáticos en la jerarquía; `private` miembros estáticos de las clases heredadas no se incluyen.</span><span class="sxs-lookup"><span data-stu-id="60a97-2250">Specify `BindingFlags.FlattenHierarchy` to include `public` and `protected` static members up the hierarchy; `private` static members in inherited classes are not included.</span></span>  
  
 <span data-ttu-id="60a97-2251">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-2251">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-2252">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2252">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-2253">`BindingFlags.DeclaredOnly` para buscar sólo las propiedades declaradas en el <xref:System.Type>, no las propiedades que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2253">`BindingFlags.DeclaredOnly` to search only the properties declared on the <xref:System.Type>, not properties that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-2254">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-2254">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-2255">Se encontró más de una propiedad con el nombre especificado y que coincide con las restricciones de enlace especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2255">More than one property is found with the specified name and matching the specified binding constraints.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2256">El valor de <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2256"><paramref name="name" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2257">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2257">-or-</span></span> 
 <span data-ttu-id="60a97-2258">El valor de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2258"><paramref name="types" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-2259">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2259">-or-</span></span> 
<span data-ttu-id="60a97-2260">Uno de los elementos de <paramref name="types" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2260">One of the elements in <paramref name="types" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2261"><paramref name="types" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2261"><paramref name="types" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2262">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2262">-or-</span></span> 
 <span data-ttu-id="60a97-2263"><paramref name="modifiers" /> es multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-2263"><paramref name="modifiers" /> is multidimensional.</span></span>  
  
<span data-ttu-id="60a97-2264">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2264">-or-</span></span> 
 <span data-ttu-id="60a97-2265"><paramref name="types" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-2265"><paramref name="types" /> and <paramref name="modifiers" /> do not have the same length.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-2266">El tipo actual es un objeto <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" /> o <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2266">The current type is a <see cref="T:System.Reflection.Emit.TypeBuilder" />, <see cref="T:System.Reflection.Emit.EnumBuilder" />, or <see cref="T:System.Reflection.Emit.GenericTypeParameterBuilder" />.</span></span></exception>
        <altmember cref="T:System.Reflection.PropertyInfo" />
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="M:System.Type.GetProperty(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Type,System.Type[],System.Reflection.ParameterModifier[])" />
        <altmember cref="M:System.Type.GetProperties(System.Reflection.BindingFlags)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetType">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-2267">Obtiene un objeto <see cref="T:System.Type" /> que representa el tipo especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2267">Gets a <see cref="T:System.Type" /> object that represents the specified type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public Type GetType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type GetType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType" />
      <MemberSignature Language="VB.NET" Value="Public Function GetType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ GetType();" />
      <MemberSignature Language="F#" Value="override this.GetType : unit -&gt; Type" Usage="type.GetType " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-2268">Obtiene la estructura <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-2268">Gets the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-2269">Objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-2269">The current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2270">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2270">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.TypeLoadException" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-2271">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-2271">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName);" />
      <MemberSignature Language="F#" Value="static member GetType : string -&gt; Type" Usage="System.Type.GetType typeName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2272">Nombre calificado con el ensamblado del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2272">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="60a97-2273">Vea <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2273">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="60a97-2274">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2274">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <summary><span data-ttu-id="60a97-2275">Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado, mediante una búsqueda en la que se distingue entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2275">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="60a97-2276">Tipo con el nombre especificado, si se encuentra; de lo contrario <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2276">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2277">Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2277">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="60a97-2278"><xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2278"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="60a97-2279">También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2279">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="60a97-2280">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar en C#, <xref:System.Type.GetType%2A> en Visual Basic o C++.</span><span class="sxs-lookup"><span data-stu-id="60a97-2280">If a type is in an assembly known to your program at compile time, it is more efficient to use  in C#, <xref:System.Type.GetType%2A> in Visual Basic, or  in C++.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2281">Si `typeName` no se encuentra, la llamada a la <xref:System.Type.GetType%28System.String%29> devuelve del método `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2281">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%29> method returns `null`.</span></span> <span data-ttu-id="60a97-2282">No se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2282">It does not throw an exception.</span></span> <span data-ttu-id="60a97-2283">Para controlar si se produce una excepción, llamar a una sobrecarga de la <xref:System.Type.GetType%2A> método que tiene un `throwOnError` parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2283">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="60a97-2284"><xref:System.Type.GetType%2A> solo funciona en los ensamblados cargados desde el disco.</span><span class="sxs-lookup"><span data-stu-id="60a97-2284"><xref:System.Type.GetType%2A> only works on assemblies loaded from disk.</span></span> <span data-ttu-id="60a97-2285">Si se llama a <xref:System.Type.GetType%2A> para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2285">If you call <xref:System.Type.GetType%2A> to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="60a97-2286">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-2286">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="60a97-2287">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2287">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="60a97-2288">Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2288">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="60a97-2289">`GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2289">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="60a97-2290">Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2290">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="60a97-2291">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2291">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="60a97-2292">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2292">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-2293">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-2293">Member Type</span></span>|<span data-ttu-id="60a97-2294">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2294">Static</span></span>|<span data-ttu-id="60a97-2295">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2295">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-2296">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-2296">Constructor</span></span>|<span data-ttu-id="60a97-2297">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2297">No</span></span>|<span data-ttu-id="60a97-2298">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2298">No</span></span>|  
|<span data-ttu-id="60a97-2299">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-2299">Field</span></span>|<span data-ttu-id="60a97-2300">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2300">No</span></span>|<span data-ttu-id="60a97-2301">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2301">Yes.</span></span> <span data-ttu-id="60a97-2302">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2302">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2303">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-2303">Event</span></span>|<span data-ttu-id="60a97-2304">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2304">Not applicable</span></span>|<span data-ttu-id="60a97-2305">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2305">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2306">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2306">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2307">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2307">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-2308">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-2308">Method</span></span>|<span data-ttu-id="60a97-2309">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2309">No</span></span>|<span data-ttu-id="60a97-2310">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2310">Yes.</span></span> <span data-ttu-id="60a97-2311">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-2311">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2312">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-2312">Nested Type</span></span>|<span data-ttu-id="60a97-2313">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2313">No</span></span>|<span data-ttu-id="60a97-2314">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2314">No</span></span>|  
|<span data-ttu-id="60a97-2315">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2315">Property</span></span>|<span data-ttu-id="60a97-2316">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2316">Not applicable</span></span>|<span data-ttu-id="60a97-2317">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2317">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2318">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2318">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2319">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2319">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-2320">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2320">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-2321">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2321">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-2322">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2322">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2323">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-2323">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-2324">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-2324">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-2325">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</span><span class="sxs-lookup"><span data-stu-id="60a97-2325">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="60a97-2326">`typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2326">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="60a97-2327">Vea <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2327">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="60a97-2328">Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</span><span class="sxs-lookup"><span data-stu-id="60a97-2328">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="60a97-2329">Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2329">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="60a97-2330">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2330">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="60a97-2331">El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2331">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic type arguments.</span></span> <span data-ttu-id="60a97-2332">Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2332">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2333">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2333">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="60a97-2334">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="60a97-2334">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="60a97-2335">Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2335">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="60a97-2336">También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2336">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="60a97-2337">A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2337">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="60a97-2338">Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2338">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="60a97-2339">Delimitador</span><span class="sxs-lookup"><span data-stu-id="60a97-2339">Delimiter</span></span>|<span data-ttu-id="60a97-2340">Significado</span><span class="sxs-lookup"><span data-stu-id="60a97-2340">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a97-2341">Barra diagonal inversa (\\)</span><span class="sxs-lookup"><span data-stu-id="60a97-2341">Backslash (\\)</span></span>|<span data-ttu-id="60a97-2342">Carácter de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2342">Escape character.</span></span>|  
|<span data-ttu-id="60a97-2343">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="60a97-2343">Backtick (\`)</span></span>|<span data-ttu-id="60a97-2344">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2344">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="60a97-2345">Corchetes ([])</span><span class="sxs-lookup"><span data-stu-id="60a97-2345">Brackets ([])</span></span>|<span data-ttu-id="60a97-2346">Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2346">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="60a97-2347">Coma (,)</span><span class="sxs-lookup"><span data-stu-id="60a97-2347">Comma (,)</span></span>|<span data-ttu-id="60a97-2348">Precede al nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2348">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="60a97-2349">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="60a97-2349">Period (.)</span></span>|<span data-ttu-id="60a97-2350">Denota los identificadores de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2350">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="60a97-2351">Signo más (+)</span><span class="sxs-lookup"><span data-stu-id="60a97-2351">Plus sign (+)</span></span>|<span data-ttu-id="60a97-2352">Precede a una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2352">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="60a97-2353">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-2353">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2354">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="60a97-2354">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="60a97-2355">La reflexión emite esta cadena como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2355">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2356">Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".</span><span class="sxs-lookup"><span data-stu-id="60a97-2356">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="60a97-2357">Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2357">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="60a97-2358">Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2358">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="60a97-2359"><xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</span><span class="sxs-lookup"><span data-stu-id="60a97-2359"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="60a97-2360"><xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2360"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="60a97-2361">Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2361">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="60a97-2362">Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2362">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="60a97-2363">Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2363">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="60a97-2364">En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</span><span class="sxs-lookup"><span data-stu-id="60a97-2364">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="60a97-2365">El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2365">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="60a97-2366">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</span><span class="sxs-lookup"><span data-stu-id="60a97-2366">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="60a97-2367">Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.</span><span class="sxs-lookup"><span data-stu-id="60a97-2367">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="60a97-2368">Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2368">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="60a97-2369">Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2369">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="60a97-2370">Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2370">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="60a97-2371">Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="60a97-2371">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="60a97-2372">En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales.</span><span class="sxs-lookup"><span data-stu-id="60a97-2372">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="60a97-2373">Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` fromMyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2373">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` fromMyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2374">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2374">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="60a97-2375">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2375">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="60a97-2376">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2376">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="60a97-2377">Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="60a97-2377">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2378">En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2378">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="60a97-2379">Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60a97-2379">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="60a97-2380">En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2380">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="60a97-2381">Para obtener</span><span class="sxs-lookup"><span data-stu-id="60a97-2381">To Get</span></span>|<span data-ttu-id="60a97-2382">Usar</span><span class="sxs-lookup"><span data-stu-id="60a97-2382">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="60a97-2383">Acepta valores null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="60a97-2383">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="60a97-2384">Un puntero no administrado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2384">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="60a97-2385">Un puntero no administrado a un puntero a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2385">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="60a97-2386">Un puntero administrado o una referencia a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2386">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="60a97-2387">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2387">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="60a97-2388">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</span><span class="sxs-lookup"><span data-stu-id="60a97-2388">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="60a97-2389">Una clase primaria y una clase anidada</span><span class="sxs-lookup"><span data-stu-id="60a97-2389">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="60a97-2390">Una matriz unidimensional con un límite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="60a97-2390">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyType[]")`|  
|<span data-ttu-id="60a97-2391">Una matriz unidimensional con un límite inferior desconocido</span><span class="sxs-lookup"><span data-stu-id="60a97-2391">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyType[*]")`|  
|<span data-ttu-id="60a97-2392">Una matriz de n dimensiones</span><span class="sxs-lookup"><span data-stu-id="60a97-2392">An n-dimensional array</span></span>|<span data-ttu-id="60a97-2393">Una coma (,) dentro de los corchetes un total de n-1 veces.</span><span class="sxs-lookup"><span data-stu-id="60a97-2393">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="60a97-2394">Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2394">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="60a97-2395">Una matriz de matrices unidimensionales</span><span class="sxs-lookup"><span data-stu-id="60a97-2395">An array of one-dimensional arrays</span></span>|`Type.GetType("MyType[][]")`|  
|<span data-ttu-id="60a97-2396">Una matriz bidimensional rectangular con límites inferiores desconocidos</span><span class="sxs-lookup"><span data-stu-id="60a97-2396">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyType[,]")`|  
|<span data-ttu-id="60a97-2397">Un tipo genérico con un argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2397">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="60a97-2398">Un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2398">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="60a97-2399">Un tipo genérico con dos argumentos de tipo calificado con el ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2399">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="60a97-2400">Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2400">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|<span data-ttu-id="60a97-2401">'' Type.GetType ("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</span><span class="sxs-lookup"><span data-stu-id="60a97-2401">\`\`Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")`</span></span>|  
|<span data-ttu-id="60a97-2402">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2402">A generic type whose type argument is a generic type with two type arguments</span></span>|<span data-ttu-id="60a97-2403">'' Type.GetType ("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")'</span><span class="sxs-lookup"><span data-stu-id="60a97-2403">\`\`Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")\`</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2404">El ejemplo siguiente recupera el tipo de `System.Int32` y usa ese objeto de tipo para mostrar el <xref:System.Type.FullName%2A> propiedad de `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2404">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2405">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2405"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2406">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2406">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2407"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2407"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-2408">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2408">-or-</span></span> 
 <span data-ttu-id="60a97-2409"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2409"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-2410">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2410">-or-</span></span> 
 <span data-ttu-id="60a97-2411"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2411"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-2412"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2412"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="60a97-2413">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2413">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="60a97-2414">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2414">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-2415">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2415">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-2416">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2416">-or-</span></span> 
<span data-ttu-id="60a97-2417">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="60a97-2417">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-2418">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-2418">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2419">Nombre calificado con el ensamblado del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2419">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="60a97-2420">Vea <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2420">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="60a97-2421">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2421">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-2422">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2422"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="60a97-2423">Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2423">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="60a97-2424">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2424">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="60a97-2425">Obtiene el objeto <see cref="T:System.Type" /> con el nombre especificado, que realiza una búsqueda donde se distingue entre mayúsculas y minúsculas y especifica si se va a producir o no una excepción si no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2425">Gets the <see cref="T:System.Type" /> with the specified name, performing a case-sensitive search and specifying whether to throw an exception if the type is not found.</span></span></summary>
        <returns><span data-ttu-id="60a97-2426">Tipo con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2426">The type with the specified name.</span></span> <span data-ttu-id="60a97-2427">Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2427">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="60a97-2428">En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2428">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="60a97-2429">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2429">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2430">Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2430">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="60a97-2431"><xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2431"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="60a97-2432">También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2432">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="60a97-2433">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar `typeof` en C#, <xref:System.Type.GetType%2A> en Visual Basic, o `typeid` en C++.</span><span class="sxs-lookup"><span data-stu-id="60a97-2433">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="60a97-2434">`GetType` solo funciona en los ensamblados cargados desde el disco.</span><span class="sxs-lookup"><span data-stu-id="60a97-2434">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="60a97-2435">Si se llama a `GetType` para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2435">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="60a97-2436">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-2436">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="60a97-2437">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2437">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="60a97-2438">Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2438">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="60a97-2439">`GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2439">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="60a97-2440">Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2440">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="60a97-2441">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2441">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="60a97-2442">El `throwOnError` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2442">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="60a97-2443">Algunas excepciones se producen independientemente del valor de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2443">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="60a97-2444">Por ejemplo, si se encuentra el tipo, pero no se puede cargar, un <xref:System.TypeLoadException> se produce incluso si `throwOnError` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2444">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="60a97-2445">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2445">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-2446">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-2446">Member Type</span></span>|<span data-ttu-id="60a97-2447">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2447">Static</span></span>|<span data-ttu-id="60a97-2448">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2448">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-2449">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-2449">Constructor</span></span>|<span data-ttu-id="60a97-2450">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2450">No</span></span>|<span data-ttu-id="60a97-2451">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2451">No</span></span>|  
|<span data-ttu-id="60a97-2452">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-2452">Field</span></span>|<span data-ttu-id="60a97-2453">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2453">No</span></span>|<span data-ttu-id="60a97-2454">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2454">Yes.</span></span> <span data-ttu-id="60a97-2455">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2455">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2456">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-2456">Event</span></span>|<span data-ttu-id="60a97-2457">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2457">Not applicable</span></span>|<span data-ttu-id="60a97-2458">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2458">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2459">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2459">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2460">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2460">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-2461">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-2461">Method</span></span>|<span data-ttu-id="60a97-2462">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2462">No</span></span>|<span data-ttu-id="60a97-2463">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2463">Yes.</span></span> <span data-ttu-id="60a97-2464">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-2464">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2465">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-2465">Nested Type</span></span>|<span data-ttu-id="60a97-2466">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2466">No</span></span>|<span data-ttu-id="60a97-2467">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2467">No</span></span>|  
|<span data-ttu-id="60a97-2468">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2468">Property</span></span>|<span data-ttu-id="60a97-2469">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2469">Not applicable</span></span>|<span data-ttu-id="60a97-2470">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2470">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2471">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2471">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2472">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2472">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-2473">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2473">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-2474">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2474">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-2475">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2475">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2476">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-2476">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-2477">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-2477">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-2478">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</span><span class="sxs-lookup"><span data-stu-id="60a97-2478">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="60a97-2479">`typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2479">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="60a97-2480">Vea <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2480">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="60a97-2481">Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</span><span class="sxs-lookup"><span data-stu-id="60a97-2481">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="60a97-2482">Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2482">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="60a97-2483">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2483">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="60a97-2484">El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2484">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and generic arguments.</span></span> <span data-ttu-id="60a97-2485">Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2485">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2486">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2486">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="60a97-2487">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="60a97-2487">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="60a97-2488">Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2488">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="60a97-2489">También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2489">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="60a97-2490">A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2490">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="60a97-2491">Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2491">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="60a97-2492">Delimitador</span><span class="sxs-lookup"><span data-stu-id="60a97-2492">Delimiter</span></span>|<span data-ttu-id="60a97-2493">Significado</span><span class="sxs-lookup"><span data-stu-id="60a97-2493">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a97-2494">Barra diagonal inversa (\\)</span><span class="sxs-lookup"><span data-stu-id="60a97-2494">Backslash (\\)</span></span>|<span data-ttu-id="60a97-2495">Carácter de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2495">Escape character.</span></span>|  
|<span data-ttu-id="60a97-2496">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="60a97-2496">Backtick (\`)</span></span>|<span data-ttu-id="60a97-2497">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2497">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="60a97-2498">Corchetes ([])</span><span class="sxs-lookup"><span data-stu-id="60a97-2498">Brackets ([])</span></span>|<span data-ttu-id="60a97-2499">Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2499">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="60a97-2500">Coma (,)</span><span class="sxs-lookup"><span data-stu-id="60a97-2500">Comma (,)</span></span>|<span data-ttu-id="60a97-2501">Precede al nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2501">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="60a97-2502">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="60a97-2502">Period (.)</span></span>|<span data-ttu-id="60a97-2503">Denota los identificadores de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2503">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="60a97-2504">Signo más (+)</span><span class="sxs-lookup"><span data-stu-id="60a97-2504">Plus sign (+)</span></span>|<span data-ttu-id="60a97-2505">Precede a una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2505">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="60a97-2506">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-2506">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2507">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="60a97-2507">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="60a97-2508">La reflexión emite esta cadena como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2508">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2509">Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".</span><span class="sxs-lookup"><span data-stu-id="60a97-2509">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="60a97-2510">Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2510">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="60a97-2511">Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2511">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="60a97-2512"><xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</span><span class="sxs-lookup"><span data-stu-id="60a97-2512"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="60a97-2513"><xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2513"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="60a97-2514">Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2514">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="60a97-2515">Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2515">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="60a97-2516">Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2516">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="60a97-2517">En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</span><span class="sxs-lookup"><span data-stu-id="60a97-2517">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="60a97-2518">El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2518">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="60a97-2519">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</span><span class="sxs-lookup"><span data-stu-id="60a97-2519">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="60a97-2520">Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.</span><span class="sxs-lookup"><span data-stu-id="60a97-2520">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="60a97-2521">Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2521">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="60a97-2522">Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2522">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="60a97-2523">Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2523">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="60a97-2524">Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="60a97-2524">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="60a97-2525">En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales.</span><span class="sxs-lookup"><span data-stu-id="60a97-2525">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="60a97-2526">Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` en MyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2526">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2527">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2527">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="60a97-2528">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2528">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="60a97-2529">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2529">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="60a97-2530">Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="60a97-2530">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2531">En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2531">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="60a97-2532">Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60a97-2532">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="60a97-2533">En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2533">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="60a97-2534">Para obtener</span><span class="sxs-lookup"><span data-stu-id="60a97-2534">To Get</span></span>|<span data-ttu-id="60a97-2535">Usar</span><span class="sxs-lookup"><span data-stu-id="60a97-2535">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="60a97-2536">Acepta valores null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="60a97-2536">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="60a97-2537">Un puntero no administrado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2537">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="60a97-2538">Un puntero no administrado a un puntero a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2538">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="60a97-2539">Un puntero administrado o una referencia a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2539">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="60a97-2540">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2540">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="60a97-2541">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</span><span class="sxs-lookup"><span data-stu-id="60a97-2541">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="60a97-2542">Una clase primaria y una clase anidada</span><span class="sxs-lookup"><span data-stu-id="60a97-2542">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="60a97-2543">Una matriz unidimensional con un límite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="60a97-2543">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="60a97-2544">Una matriz unidimensional con un límite inferior desconocido</span><span class="sxs-lookup"><span data-stu-id="60a97-2544">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="60a97-2545">Una matriz de n dimensiones</span><span class="sxs-lookup"><span data-stu-id="60a97-2545">An n-dimensional array</span></span>|<span data-ttu-id="60a97-2546">Una coma (,) dentro de los corchetes un total de n-1 veces.</span><span class="sxs-lookup"><span data-stu-id="60a97-2546">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="60a97-2547">Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2547">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="60a97-2548">La matriz de una matriz bidimensional</span><span class="sxs-lookup"><span data-stu-id="60a97-2548">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="60a97-2549">Una matriz bidimensional rectangular con límites inferiores desconocidos</span><span class="sxs-lookup"><span data-stu-id="60a97-2549">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="60a97-2550">Un tipo genérico con un argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2550">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="60a97-2551">Un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2551">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="60a97-2552">Un tipo genérico con dos argumentos de tipo calificado con el ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2552">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="60a97-2553">Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2553">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="60a97-2554">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2554">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
   
  
## Examples  
 <span data-ttu-id="60a97-2555">El ejemplo siguiente recupera el tipo de `System.Int32` y usa ese objeto de tipo para mostrar el <xref:System.Type.FullName%2A> propiedad de `System.Int32`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2555">The following example retrieves the type of `System.Int32` and uses that type object to display the <xref:System.Type.FullName%2A> property of `System.Int32`.</span></span> <span data-ttu-id="60a97-2556">Si un objeto de tipo hace referencia a un ensamblado que no existe, este ejemplo produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2556">If a type object refers to an assembly that does not exist, this example throws an exception.</span></span>  
  
 [!code-cpp[Type_GetType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetType/CPP/type_gettype.cpp#1)]
 [!code-csharp[Type_GetType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetType/CS/type_gettype.cs#1)]
 [!code-vb[Type_GetType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetType/VB/type_gettype.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2557">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2557"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2558">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2558">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-2559"><paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2559"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="60a97-2560">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2560">-or-</span></span> 
 <span data-ttu-id="60a97-2561"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2561"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="60a97-2562">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2562">-or-</span></span> 
 <span data-ttu-id="60a97-2563"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-2563"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="60a97-2564">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2564">-or-</span></span> 
 <span data-ttu-id="60a97-2565"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2565"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="60a97-2566">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2566">-or-</span></span> 
 <span data-ttu-id="60a97-2567"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2567"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2568"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida.</span><span class="sxs-lookup"><span data-stu-id="60a97-2568"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="60a97-2569">Por ejemplo: "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="60a97-2569">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="60a97-2570">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2570">-or-</span></span> 
 <span data-ttu-id="60a97-2571"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2571"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-2572">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2572">-or-</span></span> 
 <span data-ttu-id="60a97-2573"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2573"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-2574">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2574">-or-</span></span> 
 <span data-ttu-id="60a97-2575"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2575"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="60a97-2576"><paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="60a97-2576"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><block subset="none" type="note">
            <para>  
 <span data-ttu-id="60a97-2577">En <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET para aplicaciones de la Tienda Windows</see> o la <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Biblioteca de clases portable</see>, capture en su lugar la excepción de clase base, <see cref="T:System.IO.IOException" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2577">In the <see href="https://go.microsoft.com/fwlink/?LinkID=247912">.NET for Windows Store apps</see> or the <see href="https://docs.microsoft.com/dotnet/standard/cross-platform/cross-platform-development-with-the-portable-class-library">Portable Class Library</see>, catch the base class exception, <see cref="T:System.IO.IOException" />, instead.</span></span>  
  
</para>
          </block>  
  
 <span data-ttu-id="60a97-2578">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2578">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-2579">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2579">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-2580">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2580">-or-</span></span> 
<span data-ttu-id="60a97-2581">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="60a97-2581">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-2582">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-2582">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2583">Nombre calificado con el ensamblado del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2583">The assembly-qualified name of the type to get.</span></span> <span data-ttu-id="60a97-2584">Vea <see cref="P:System.Type.AssemblyQualifiedName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2584">See <see cref="P:System.Type.AssemblyQualifiedName" />.</span></span> <span data-ttu-id="60a97-2585">Si el tipo está en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, es suficiente para proporcionar el nombre completo del tipo por su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2585">If the type is in the currently executing assembly or in Mscorlib.dll, it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-2586"><see langword="true" /> para producir una excepción si no se puede encontrar el tipo; <see langword="false" /> para devolver <see langword="null" />. Especificar <see langword="false" /> también suprime algunas otras condiciones de excepción, pero no todas ellas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2586"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="60a97-2587">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2587">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="60a97-2588"><see langword="true" /> para realizar una búsqueda de <paramref name="typeName" /> que no distinga entre mayúsculas y minúsculas; <see langword="false" /> para realizar una búsqueda de <paramref name="typeName" /> que distinga entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2588"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="60a97-2589">Obtiene el <see cref="T:System.Type" /> con el nombre indicado, que especifica si se genera una excepción en caso de que no se encuentre el tipo y si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2589">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to throw an exception if the type is not found and whether to perform a case-sensitive search.</span></span></summary>
        <returns><span data-ttu-id="60a97-2590">Tipo con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2590">The type with the specified name.</span></span> <span data-ttu-id="60a97-2591">Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2591">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="60a97-2592">En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2592">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="60a97-2593">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2593">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2594">Puede usar el <xref:System.Type.GetType%2A> método para obtener un <xref:System.Type> si sabe su nombre completo de ensamblado que puede obtenerse a partir de objetos para un tipo en otro ensamblado, <xref:System.Type.AssemblyQualifiedName>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2594">You can use the <xref:System.Type.GetType%2A> method to obtain a <xref:System.Type> object for a type in another assembly, if you know its assembly-qualified name which can be obtained from <xref:System.Type.AssemblyQualifiedName>.</span></span> <span data-ttu-id="60a97-2595"><xref:System.Type.GetType%2A> hace que la carga del ensamblado especificado en `typeName`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2595"><xref:System.Type.GetType%2A> causes loading of the assembly specified in `typeName`.</span></span> <span data-ttu-id="60a97-2596">También puede cargar un ensamblado mediante la <xref:System.Reflection.Assembly.Load%2A> método y, a continuación, utilice el <xref:System.Type.GetType%2A> o <xref:System.Reflection.Assembly.GetTypes%2A> métodos de la <xref:System.Reflection.Assembly> clase para obtener <xref:System.Type> objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2596">You can also load an assembly using the <xref:System.Reflection.Assembly.Load%2A> method, and then use the <xref:System.Type.GetType%2A> or <xref:System.Reflection.Assembly.GetTypes%2A> methods of the <xref:System.Reflection.Assembly> class to get <xref:System.Type> objects.</span></span> <span data-ttu-id="60a97-2597">Si un tipo está en un ensamblado que se sabe que el programa en tiempo de compilación, es más eficaz utilizar `typeof` en C#, <xref:System.Type.GetType%2A> en Visual Basic, o `typeid` en C++.</span><span class="sxs-lookup"><span data-stu-id="60a97-2597">If a type is in an assembly known to your program at compile time, it is more efficient to use `typeof` in C#, <xref:System.Type.GetType%2A> in Visual Basic, or `typeid` in C++.</span></span>  
  
 <span data-ttu-id="60a97-2598">`GetType` solo funciona en los ensamblados cargados desde el disco.</span><span class="sxs-lookup"><span data-stu-id="60a97-2598">`GetType` only works on assemblies loaded from disk.</span></span> <span data-ttu-id="60a97-2599">Si se llama a `GetType` para buscar un tipo definido en un ensamblado dinámico definido mediante el <xref:System.Reflection.Emit> servicios, podría obtener un comportamiento incoherente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2599">If you call `GetType` to look up a type defined in a dynamic assembly defined using the <xref:System.Reflection.Emit> services, you might get inconsistent behavior.</span></span> <span data-ttu-id="60a97-2600">El comportamiento depende de si el ensamblado dinámico es persistente, es decir, se crea mediante la `RunAndSave` o `Save` modos de acceso a la <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-2600">The behavior depends on whether the dynamic assembly is persistent, that is, created using the `RunAndSave` or `Save` access modes of the <xref:System.Reflection.Emit.AssemblyBuilderAccess?displayProperty=nameWithType> enumeration.</span></span> <span data-ttu-id="60a97-2601">Si el ensamblado dinámico es persistente y se ha escrito en el disco antes de `GetType` es llamado, el cargador busca el ensamblado guardado en disco, carga ese ensamblado y recupera el tipo del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2601">If the dynamic assembly is persistent and has been written to disk before `GetType` is called, the loader finds the saved assembly on disk, loads that assembly, and retrieves the type from that assembly.</span></span> <span data-ttu-id="60a97-2602">Si el ensamblado no se ha guardado en el disco cuando `GetType` se llama, el método devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2602">If the assembly has not been saved to disk when `GetType` is called, the method returns `null`.</span></span> <span data-ttu-id="60a97-2603">`GetType` no entiende los ensamblados dinámicos transitorios; por lo tanto, una llamada a `GetType` para recuperar un tipo en transitorio devuelve el ensamblado dinámico `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2603">`GetType` does not understand transient dynamic assemblies; therefore, calling `GetType` to retrieve a type in a transient dynamic assembly returns `null`.</span></span>  
  
 <span data-ttu-id="60a97-2604">Para usar `GetType` en un módulo dinámico, suscribirse a la <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> eventos y llamadas `GetType` antes de guardar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2604">To use `GetType` on a dynamic module, subscribe to the <xref:System.AppDomain.AssemblyResolve?displayProperty=nameWithType> event and call `GetType` before saving.</span></span> <span data-ttu-id="60a97-2605">De lo contrario, obtendrá dos copias del ensamblado en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2605">Otherwise, you will get two copies of the assembly in memory.</span></span>  
  
 <span data-ttu-id="60a97-2606">El `throwOnError` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2606">The `throwOnError` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="60a97-2607">Algunas excepciones se producen independientemente del valor de `throwOnError`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2607">Some exceptions are thrown regardless of the value of `throwOnError`.</span></span> <span data-ttu-id="60a97-2608">Por ejemplo, si se encuentra el tipo, pero no se puede cargar, un <xref:System.TypeLoadException> se produce incluso si `throwOnError` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2608">For example, if the type is found but cannot be loaded, a <xref:System.TypeLoadException> is thrown even if `throwOnError` is `false`.</span></span>  
  
 <span data-ttu-id="60a97-2609">La siguiente tabla muestra qué miembros de una clase base se devuelven los `Get` métodos cuando se reflejan en un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2609">The following table shows what members of a base class are returned by the `Get` methods when reflecting on a type.</span></span>  
  
|<span data-ttu-id="60a97-2610">Tipo de miembro</span><span class="sxs-lookup"><span data-stu-id="60a97-2610">Member Type</span></span>|<span data-ttu-id="60a97-2611">Estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2611">Static</span></span>|<span data-ttu-id="60a97-2612">No estático</span><span class="sxs-lookup"><span data-stu-id="60a97-2612">Non-Static</span></span>|  
|-----------------|------------|-----------------|  
|<span data-ttu-id="60a97-2613">Constructor</span><span class="sxs-lookup"><span data-stu-id="60a97-2613">Constructor</span></span>|<span data-ttu-id="60a97-2614">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2614">No</span></span>|<span data-ttu-id="60a97-2615">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2615">No</span></span>|  
|<span data-ttu-id="60a97-2616">Campo</span><span class="sxs-lookup"><span data-stu-id="60a97-2616">Field</span></span>|<span data-ttu-id="60a97-2617">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2617">No</span></span>|<span data-ttu-id="60a97-2618">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2618">Yes.</span></span> <span data-ttu-id="60a97-2619">Un campo siempre es ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2619">A field is always hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2620">evento</span><span class="sxs-lookup"><span data-stu-id="60a97-2620">Event</span></span>|<span data-ttu-id="60a97-2621">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2621">Not applicable</span></span>|<span data-ttu-id="60a97-2622">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2622">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2623">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2623">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2624">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2624">See note 2 below.</span></span>|  
|<span data-ttu-id="60a97-2625">Método</span><span class="sxs-lookup"><span data-stu-id="60a97-2625">Method</span></span>|<span data-ttu-id="60a97-2626">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2626">No</span></span>|<span data-ttu-id="60a97-2627">Sí.</span><span class="sxs-lookup"><span data-stu-id="60a97-2627">Yes.</span></span> <span data-ttu-id="60a97-2628">Ocultar por nombre o de ocultar por nombre y firma, puede ser un método (virtual y no virtual).</span><span class="sxs-lookup"><span data-stu-id="60a97-2628">A method (both virtual and non-virtual) can be hide-by-name or hide-by-name-and-signature.</span></span>|  
|<span data-ttu-id="60a97-2629">Tipo anidado</span><span class="sxs-lookup"><span data-stu-id="60a97-2629">Nested Type</span></span>|<span data-ttu-id="60a97-2630">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2630">No</span></span>|<span data-ttu-id="60a97-2631">No</span><span class="sxs-lookup"><span data-stu-id="60a97-2631">No</span></span>|  
|<span data-ttu-id="60a97-2632">Propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2632">Property</span></span>|<span data-ttu-id="60a97-2633">No es aplicable</span><span class="sxs-lookup"><span data-stu-id="60a97-2633">Not applicable</span></span>|<span data-ttu-id="60a97-2634">La regla del sistema de tipo común es que la herencia es el mismo que el de los métodos que implementa la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2634">The common type system rule is that the inheritance is the same as that of the methods that implement the property.</span></span> <span data-ttu-id="60a97-2635">Reflexión trata las propiedades como ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2635">Reflection treats properties as hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2636">Véase la nota 2.</span><span class="sxs-lookup"><span data-stu-id="60a97-2636">See note 2 below.</span></span>|  
  
1.  <span data-ttu-id="60a97-2637">Ocultar por nombre y firma considera que todas las partes de la firma, incluidos los modificadores personalizados, devolución tipos, tipos de parámetros, centinelas y las convenciones de llamada no administradas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2637">Hide-by-name-and-signature considers all of the parts of the signature, including custom modifiers, return types, parameter types, sentinels, and unmanaged calling conventions.</span></span> <span data-ttu-id="60a97-2638">Se trata de una comparación binaria.</span><span class="sxs-lookup"><span data-stu-id="60a97-2638">This is a binary comparison.</span></span>  
  
2.  <span data-ttu-id="60a97-2639">Para la reflexión, propiedades y eventos son ocultar por nombre y firma.</span><span class="sxs-lookup"><span data-stu-id="60a97-2639">For reflection, properties and events are hide-by-name-and-signature.</span></span> <span data-ttu-id="60a97-2640">Si tiene una propiedad con una operación get y un descriptor de acceso de la clase base, pero la clase derivada tiene solo un descriptor de acceso get, la propiedad de clase derivada oculta la propiedad de clase base y no podrá tener acceso el establecedor de la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-2640">If you have a property with both a get and a set accessor in the base class, but the derived class has only a get accessor, the derived class property hides the base class property, and you will not be able to access the setter on the base class.</span></span>  
  
3.  <span data-ttu-id="60a97-2641">Los atributos personalizados no forman parte de common type system.</span><span class="sxs-lookup"><span data-stu-id="60a97-2641">Custom attributes are not part of the common type system.</span></span>  
  
 <span data-ttu-id="60a97-2642">Las matrices o los tipos COM no se buscan, a menos que ya se han cargado en la tabla de clases disponibles.</span><span class="sxs-lookup"><span data-stu-id="60a97-2642">Arrays or COM types are not searched for unless they have already been loaded into the table of available classes.</span></span>  
  
 <span data-ttu-id="60a97-2643">`typeName` puede ser el nombre de tipo calificado por su espacio de nombres o un nombre completo de ensamblado que incluya una especificación de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2643">`typeName` can be the type name qualified by its namespace or an assembly-qualified name that includes an assembly name specification.</span></span> <span data-ttu-id="60a97-2644">Vea <xref:System.Type.AssemblyQualifiedName%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2644">See <xref:System.Type.AssemblyQualifiedName%2A>.</span></span>  
  
 <span data-ttu-id="60a97-2645">Si `typeName` incluye el espacio de nombres pero no el nombre del ensamblado, este método busca solo ensamblado del objeto que realiza la llamada y Mscorlib.dll, en ese orden.</span><span class="sxs-lookup"><span data-stu-id="60a97-2645">If `typeName` includes the namespace but not the assembly name, this method searches only the calling object's assembly and Mscorlib.dll, in that order.</span></span> <span data-ttu-id="60a97-2646">Si typeName es un nombre completo con el nombre de ensamblado parcial o completo, este método busca en el ensamblado especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2646">If typeName is fully qualified with the partial or complete assembly name, this method searches in the specified assembly.</span></span> <span data-ttu-id="60a97-2647">Si el ensamblado tiene un nombre seguro, se requiere un nombre de ensamblado completo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2647">If the assembly has a strong name, a complete assembly name is required.</span></span>  
  
 <span data-ttu-id="60a97-2648">El <xref:System.Type.AssemblyQualifiedName%2A> propiedad devuelve un nombre de tipo completo incluido tipos anidados, el nombre del ensamblado y los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2648">The <xref:System.Type.AssemblyQualifiedName%2A> property returns a fully qualified type name including nested types, the assembly name, and type arguments.</span></span> <span data-ttu-id="60a97-2649">Todos los compiladores compatibles con common language runtime emitirá el nombre sencillo de una clase anidada y la reflexión construirá un nombre con sufijo cuando se consulta, con arreglo a las siguientes convenciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2649">All compilers that support the common language runtime will emit the simple name of a nested class, and reflection constructs a mangled name when queried, in accordance with the following conventions.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2650">En la versión 2.0 de .NET Framework, la arquitectura de procesador se agrega a la identidad del ensamblado y se puede especificar como parte de las cadenas de nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2650">In the .NET Framework version 2.0, processor architecture is added to assembly identity, and can be specified as part of assembly name strings.</span></span> <span data-ttu-id="60a97-2651">Por ejemplo, "ProcessorArchitecture = msil".</span><span class="sxs-lookup"><span data-stu-id="60a97-2651">For example, "ProcessorArchitecture=msil".</span></span> <span data-ttu-id="60a97-2652">Sin embargo, no se incluye en la cadena devuelta por la <xref:System.Type.AssemblyQualifiedName%2A> propiedad, por motivos de compatibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2652">However, it is not included in the string returned by the <xref:System.Type.AssemblyQualifiedName%2A> property, for compatibility reasons.</span></span> <span data-ttu-id="60a97-2653">También puede cargar tipos mediante la creación de un <xref:System.Reflection.AssemblyName> objeto y pasarlo a una sobrecarga adecuada de la <xref:System.Reflection.Assembly.Load%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2653">You can also load types by creating an <xref:System.Reflection.AssemblyName> object and passing it to an appropriate overload of the <xref:System.Reflection.Assembly.Load%2A> method.</span></span> <span data-ttu-id="60a97-2654">A continuación, puede usar el <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método para cargar tipos desde el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2654">You can then use the <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method to load types from the assembly.</span></span> <span data-ttu-id="60a97-2655">Vea también <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2655">See also <xref:System.Reflection.AssemblyName.ProcessorArchitecture%2A?displayProperty=nameWithType>.</span></span>  
  
|<span data-ttu-id="60a97-2656">Delimitador</span><span class="sxs-lookup"><span data-stu-id="60a97-2656">Delimiter</span></span>|<span data-ttu-id="60a97-2657">Significado</span><span class="sxs-lookup"><span data-stu-id="60a97-2657">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a97-2658">Barra diagonal inversa (\\)</span><span class="sxs-lookup"><span data-stu-id="60a97-2658">Backslash (\\)</span></span>|<span data-ttu-id="60a97-2659">Carácter de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2659">Escape character.</span></span>|  
|<span data-ttu-id="60a97-2660">Acento grave (')</span><span class="sxs-lookup"><span data-stu-id="60a97-2660">Backtick (\`)</span></span>|<span data-ttu-id="60a97-2661">Precede a uno o más dígitos que representa el número de parámetros de tipo, situado al final del nombre de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2661">Precedes one or more digits representing the number of type parameters, located at the end of the name of a generic type.</span></span>|  
|<span data-ttu-id="60a97-2662">Corchetes ([])</span><span class="sxs-lookup"><span data-stu-id="60a97-2662">Brackets ([])</span></span>|<span data-ttu-id="60a97-2663">Incluya una lista de argumentos de tipo genérico, para un tipo genérico construido; dentro de una lista de argumentos de tipo, encierra un tipo calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2663">Enclose a generic type argument list, for a constructed generic type; within a type argument list, enclose an assembly-qualified type.</span></span>|  
|<span data-ttu-id="60a97-2664">Coma (,)</span><span class="sxs-lookup"><span data-stu-id="60a97-2664">Comma (,)</span></span>|<span data-ttu-id="60a97-2665">Precede al nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2665">Precedes the Assembly name.</span></span>|  
|<span data-ttu-id="60a97-2666">Punto (.)</span><span class="sxs-lookup"><span data-stu-id="60a97-2666">Period (.)</span></span>|<span data-ttu-id="60a97-2667">Denota los identificadores de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2667">Denotes namespace identifiers.</span></span>|  
|<span data-ttu-id="60a97-2668">Signo más (+)</span><span class="sxs-lookup"><span data-stu-id="60a97-2668">Plus sign (+)</span></span>|<span data-ttu-id="60a97-2669">Precede a una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2669">Precedes a nested class.</span></span>|  
  
 <span data-ttu-id="60a97-2670">Por ejemplo, el nombre completo para una clase podría ser similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-2670">For example, the fully qualified name for a class might look like this:</span></span>  
  
```  
TopNamespace.SubNameSpace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2671">Si el espacio de nombres fuera EspacioNombresPrincipal. Sub+EspacioNombres, la cadena tendría que ir delante del signo más (+) con un carácter de escape (\\) para evitar que se va a interpretar como un separador de anidamiento.</span><span class="sxs-lookup"><span data-stu-id="60a97-2671">If the namespace were TopNamespace.Sub+Namespace, then the string would have to precede the plus sign (+) with an escape character (\\) to prevent it from being interpreted as a nesting separator.</span></span> <span data-ttu-id="60a97-2672">La reflexión emite esta cadena como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2672">Reflection emits this string as follows:</span></span>  
  
```  
TopNamespace.Sub\+Namespace.ContainingClass+NestedClass,MyAssembly  
```  
  
 <span data-ttu-id="60a97-2673">Un "++" se convierte en "\\+\\+" y un "\\"se convierte en"\\\\".</span><span class="sxs-lookup"><span data-stu-id="60a97-2673">A "++" becomes "\\+\\+", and a "\\" becomes "\\\\".</span></span>  
  
 <span data-ttu-id="60a97-2674">Este nombre completo puede conservarse y usa más adelante para cargar el <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2674">This qualified name can be persisted and later used to load the <xref:System.Type>.</span></span> <span data-ttu-id="60a97-2675">Para buscar y cargar un <xref:System.Type>, utilice <xref:System.Type.GetType%2A> con el tipo de nombre solo o con el nombre de tipo calificado de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2675">To search for and load a <xref:System.Type>, use <xref:System.Type.GetType%2A> either with the type name only or with the assembly qualified type name.</span></span> <span data-ttu-id="60a97-2676"><xref:System.Type.GetType%2A> con el tipo de nombre sólo buscará los <xref:System.Type> en el ensamblado del llamador y, a continuación, en el ensamblado del sistema.</span><span class="sxs-lookup"><span data-stu-id="60a97-2676"><xref:System.Type.GetType%2A> with the type name only will look for the <xref:System.Type> in the caller's assembly and then in the System assembly.</span></span> <span data-ttu-id="60a97-2677"><xref:System.Type.GetType%2A> con el ensamblado de nombre de tipo calificado buscará el <xref:System.Type> en cualquier ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2677"><xref:System.Type.GetType%2A> with the assembly qualified type name will look for the <xref:System.Type> in any assembly.</span></span>  
  
 <span data-ttu-id="60a97-2678">Los nombres de tipo pueden contener caracteres finales que denoten información adicional sobre el tipo, por ejemplo, si el tipo es un tipo de referencia, un tipo de puntero o un tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2678">Type names may include trailing characters that denote additional information about the type, such as whether the type is a reference type, a pointer type or an array type.</span></span> <span data-ttu-id="60a97-2679">Para recuperar el nombre del tipo sin estos caracteres finales, use `t.GetElementType().ToString()`, donde `t` es el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2679">To retrieve the type name without these trailing characters, use `t.GetElementType().ToString()`, where `t` is the type.</span></span>  
  
 <span data-ttu-id="60a97-2680">Espacios son relevantes en todos los componentes de nombre de tipo, excepto el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2680">Spaces are relevant in all type name components except the assembly name.</span></span> <span data-ttu-id="60a97-2681">En el nombre del ensamblado, espacios antes del separador ',' son relevantes, pero se omiten los espacios detrás del separador ','.</span><span class="sxs-lookup"><span data-stu-id="60a97-2681">In the assembly name, spaces before the ',' separator are relevant, but spaces after the ',' separator are ignored.</span></span>  
  
 <span data-ttu-id="60a97-2682">El nombre de un tipo genérico finaliza con un acento grave (\`) seguido de dígitos que representa el número de argumentos de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2682">The name of a generic type ends with a backtick (\`) followed by digits representing the number of generic type arguments.</span></span> <span data-ttu-id="60a97-2683">El propósito de este nombre con sufijo es permitir que los compiladores admitir tipos genéricos con el mismo nombre pero con distintos números de parámetros de tipo, que se producen en el mismo ámbito.</span><span class="sxs-lookup"><span data-stu-id="60a97-2683">The purpose of this name mangling is to allow compilers to support generic types with the same name but with different numbers of type parameters, occurring in the same scope.</span></span> <span data-ttu-id="60a97-2684">Por ejemplo, la reflexión devuelve los nombres alterados `Tuple`1` and `tupla`2` desde los métodos genéricos `Tuple(Of T)` y `Tuple(Of T0, T1)` en Visual Basic, o `Tuple<T>` y tupla`\<T0, T1>` en Visual C#.</span><span class="sxs-lookup"><span data-stu-id="60a97-2684">For example, reflection returns the mangled names `Tuple`1` and `Tuple`2` from the generic methods `Tuple(Of T)` and `Tuple(Of T0, T1)` in Visual Basic, or `Tuple<T>` and Tuple`\<T0, T1>` in Visual C#.</span></span>  
  
 <span data-ttu-id="60a97-2685">Para los tipos genéricos, la lista de argumentos de tipo se encierra entre corchetes y los argumentos de tipo están separados por comas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2685">For generic types, the type argument list is enclosed in brackets, and the type arguments are separated by commas.</span></span> <span data-ttu-id="60a97-2686">Por ejemplo, un tipo genérico <xref:System.Collections.Generic.Dictionary%602> tiene dos parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2686">For example, a generic <xref:System.Collections.Generic.Dictionary%602> has two type parameters.</span></span> <span data-ttu-id="60a97-2687">Un <xref:System.Collections.Generic.Dictionary%602> de `MyType` con claves de tipo <xref:System.String> puede representarse como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2687">A <xref:System.Collections.Generic.Dictionary%602> of `MyType` with keys of type <xref:System.String> might be represented as follows:</span></span>  
  
```  
System.Collections.Generic.Dictionary`2[System.String,MyType]  
```  
  
 <span data-ttu-id="60a97-2688">Para especificar un tipo calificado con el ensamblado en una lista de argumentos de tipo, incluya el tipo de ensamblado completo entre corchetes.</span><span class="sxs-lookup"><span data-stu-id="60a97-2688">To specify an assembly-qualified type within a type argument list, enclose the assembly-qualified type within brackets.</span></span> <span data-ttu-id="60a97-2689">En caso contrario, las comas que separan las partes del nombre completo de ensamblado se interpretan como delimitar los argumentos de tipo adicionales.</span><span class="sxs-lookup"><span data-stu-id="60a97-2689">Otherwise, the commas that separate the parts of the assembly-qualified name are interpreted as delimiting additional type arguments.</span></span> <span data-ttu-id="60a97-2690">Por ejemplo, un <xref:System.Collections.Generic.Dictionary%602> de `MyType` en MyAssembly.dll, con claves de tipo <xref:System.String>, puede especificar como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-2690">For example, a <xref:System.Collections.Generic.Dictionary%602> of `MyType` from MyAssembly.dll, with keys of type <xref:System.String>, might be specified as follows:</span></span>  
  
```  
Type.GetType("System.Collections.Generic.Dictionary`2[System.String,[MyType,MyAssembly]]")  
```  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2691">Un tipo calificado con el ensamblado puede escribirse entre corchetes solo cuando aparece dentro de una lista de parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2691">An assembly-qualified type can be enclosed in brackets only when it appears within a type parameter list.</span></span> <span data-ttu-id="60a97-2692">Las reglas para buscar los ensamblados de tipos completos e incompletos en listas de parámetros de tipo son las mismas que las reglas para tipos no genéricos completos e incompletos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2692">The rules for searching assemblies for qualified and unqualified types in type parameter lists are the same as the rules for qualified and unqualified nongeneric types.</span></span>  
  
 <span data-ttu-id="60a97-2693">Tipos que aceptan valores NULL son un caso especial de tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2693">Nullable types are a special case of generic types.</span></span> <span data-ttu-id="60a97-2694">Por ejemplo, una que acepta valores NULL <xref:System.Int32> representado por la cadena "System.Nullable'1[System.Int32]".</span><span class="sxs-lookup"><span data-stu-id="60a97-2694">For example, a nullable <xref:System.Int32> is represented by the string "System.Nullable\`1[System.Int32]".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2695">En C#, C++ y Visual Basic también puede obtener los tipos que aceptan valores NULL mediante operadores de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2695">In C#, C++, and Visual Basic you can also get nullable types using type operators.</span></span> <span data-ttu-id="60a97-2696">Por ejemplo, el que acepta valores NULL <xref:System.Boolean> tipo devuelto por `typeof(Nullable<bool>)` en C#, por `Nullable<Boolean>::typeid` en C++ y por `GetType(Nullable(Of Boolean))` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60a97-2696">For example, the nullable <xref:System.Boolean> type is returned by `typeof(Nullable<bool>)` in C#, by `Nullable<Boolean>::typeid` in C++, and by `GetType(Nullable(Of Boolean))` in Visual Basic.</span></span>  
  
 <span data-ttu-id="60a97-2697">En la tabla siguiente se muestra la sintaxis que usa con `GetType` para varios tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2697">The following table shows the syntax you use with `GetType` for various types.</span></span>  
  
|<span data-ttu-id="60a97-2698">Para obtener</span><span class="sxs-lookup"><span data-stu-id="60a97-2698">To Get</span></span>|<span data-ttu-id="60a97-2699">Usar</span><span class="sxs-lookup"><span data-stu-id="60a97-2699">Use</span></span>|  
|------------|---------|  
|<span data-ttu-id="60a97-2700">Acepta valores null <xref:System.Int32></span><span class="sxs-lookup"><span data-stu-id="60a97-2700">A nullable <xref:System.Int32></span></span>|``Type.GetType("System.Nullable`1[System.Int32]")``|  
|<span data-ttu-id="60a97-2701">Un puntero no administrado para `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2701">An unmanaged pointer to `MyType`</span></span>|`Type.GetType("MyType*")`|  
|<span data-ttu-id="60a97-2702">Un puntero no administrado a un puntero a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2702">An unmanaged pointer to a pointer to `MyType`</span></span>|`Type.GetType("MyType**")`|  
|<span data-ttu-id="60a97-2703">Un puntero administrado o una referencia a `MyType`</span><span class="sxs-lookup"><span data-stu-id="60a97-2703">A managed pointer or reference to `MyType`</span></span>|<span data-ttu-id="60a97-2704">`Type.GetType("MyType&")`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2704">`Type.GetType("MyType&")`.</span></span> <span data-ttu-id="60a97-2705">Tenga en cuenta que, a diferencia de los punteros, las referencias están limitadas a un nivel.</span><span class="sxs-lookup"><span data-stu-id="60a97-2705">Note that unlike pointers, references are limited to one level.</span></span>|  
|<span data-ttu-id="60a97-2706">Una clase primaria y una clase anidada</span><span class="sxs-lookup"><span data-stu-id="60a97-2706">A parent class and a nested class</span></span>|`Type.GetType("MyParentClass+MyNestedClass")`|  
|<span data-ttu-id="60a97-2707">Una matriz unidimensional con un límite inferior de 0</span><span class="sxs-lookup"><span data-stu-id="60a97-2707">A one-dimensional array with a lower bound of 0</span></span>|`Type.GetType("MyArray[]")`|  
|<span data-ttu-id="60a97-2708">Una matriz unidimensional con un límite inferior desconocido</span><span class="sxs-lookup"><span data-stu-id="60a97-2708">A one-dimensional array with an unknown lower bound</span></span>|`Type.GetType("MyArray[*]")`|  
|<span data-ttu-id="60a97-2709">Una matriz de n dimensiones</span><span class="sxs-lookup"><span data-stu-id="60a97-2709">An n-dimensional array</span></span>|<span data-ttu-id="60a97-2710">Una coma (,) dentro de los corchetes un total de n-1 veces.</span><span class="sxs-lookup"><span data-stu-id="60a97-2710">A comma (,) inside the brackets a total of n-1 times.</span></span> <span data-ttu-id="60a97-2711">Por ejemplo, `System.Object[,,]` representa tridimensional `Object` matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-2711">For example, `System.Object[,,]` represents a three-dimensional `Object` array.</span></span>|  
|<span data-ttu-id="60a97-2712">La matriz de una matriz bidimensional</span><span class="sxs-lookup"><span data-stu-id="60a97-2712">A two-dimensional array's array</span></span>|`Type.GetType("MyArray[][]")`|  
|<span data-ttu-id="60a97-2713">Una matriz bidimensional rectangular con límites inferiores desconocidos</span><span class="sxs-lookup"><span data-stu-id="60a97-2713">A rectangular two-dimensional array with unknown lower bounds</span></span>|`Type.GetType("MyArray[,]")`|  
|<span data-ttu-id="60a97-2714">Un tipo genérico con un argumento de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2714">A generic type with one type argument</span></span>|``Type.GetType("MyGenericType`1[MyType]")``|  
|<span data-ttu-id="60a97-2715">Un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2715">A generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`2[MyType,AnotherType]")``|  
|<span data-ttu-id="60a97-2716">Un tipo genérico con dos argumentos de tipo calificado con el ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2716">A generic type with two assembly-qualified type arguments</span></span>|``Type.GetType("MyGenericType`2[[MyType,MyAssembly],[AnotherType,AnotherAssembly]]")``|  
|<span data-ttu-id="60a97-2717">Un tipo genérico con un argumento de tipo calificado de ensamblado completo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2717">An assembly-qualified generic type with an assembly-qualified type argument</span></span>|``Type.GetType("MyGenericType`1[[MyType,MyAssembly]],MyGenericTypeAssembly")``|  
|<span data-ttu-id="60a97-2718">Un tipo genérico cuyo argumento de tipo es un tipo genérico con dos argumentos de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2718">A generic type whose type argument is a generic type with two type arguments</span></span>|``Type.GetType("MyGenericType`1[AnotherGenericType`2[MyType,AnotherType]]")``|  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2719">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2719"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2720">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2720">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-2721"><paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2721"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="60a97-2722">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2722">-or-</span></span> 
 <span data-ttu-id="60a97-2723"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2723"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="60a97-2724">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2724">-or-</span></span> 
 <span data-ttu-id="60a97-2725"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-2725"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="60a97-2726">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2726">-or-</span></span> 
 <span data-ttu-id="60a97-2727"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2727"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="60a97-2728">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2728">-or-</span></span> 
 <span data-ttu-id="60a97-2729"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2729"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2730"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida.</span><span class="sxs-lookup"><span data-stu-id="60a97-2730"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax.</span></span> <span data-ttu-id="60a97-2731">Por ejemplo: "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="60a97-2731">For example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="60a97-2732">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2732">-or-</span></span> 
 <span data-ttu-id="60a97-2733"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2733"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-2734">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2734">-or-</span></span> 
 <span data-ttu-id="60a97-2735"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2735"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-2736">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2736">-or-</span></span> 
 <span data-ttu-id="60a97-2737"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2737"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="60a97-2738"><paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="60a97-2738"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="60a97-2739">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2739">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-2740">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2740">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-2741">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2741">-or-</span></span> 
<span data-ttu-id="60a97-2742">Actualmente, está cargada la versión 2.0 u otra posterior de Common Language Runtime pero el ensamblado se compiló con una versión posterior.</span><span class="sxs-lookup"><span data-stu-id="60a97-2742">Version 2.0 or later of the common language runtime is currently loaded, and the assembly was compiled with a later version.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-2743">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-2743">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type})" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type)) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2744">Nombre del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2744">The name of the type to get.</span></span> <span data-ttu-id="60a97-2745">Si se proporciona el parámetro <paramref name="typeResolver" />, el nombre del tipo puede ser cualquier cadena que <paramref name="typeResolver" /> pueda resolver.</span><span class="sxs-lookup"><span data-stu-id="60a97-2745">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="60a97-2746">Si se proporciona el parámetro <paramref name="assemblyResolver" /> o se usa la resolución de tipos estándar, <paramref name="typeName" /> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2746">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="60a97-2747">Método que busca y devuelve el ensamblado especificado en <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2747">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="60a97-2748">El nombre del ensamblado se pasa a <paramref name="assemblyResolver" /> como un objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2748">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="60a97-2749">Si <paramref name="typeName" /> no contiene el nombre de un ensamblado, no se llama a <paramref name="assemblyResolver" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2749">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="60a97-2750">Si no se proporciona <paramref name="assemblyResolver" />, se realiza la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2750">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="60a97-2751">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2751">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="60a97-2752">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2752">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="60a97-2753">Use solo los métodos que proporciona o con los que está familiarizado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2753">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="60a97-2754">Método que busca y devuelve el tipo especificado por <paramref name="typeName" /> del ensamblado devuelto por <paramref name="assemblyResolver" /> o mediante la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2754">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="60a97-2755">Si no se proporciona ningún ensamblado, el método <paramref name="typeResolver" /> podrá proporcionar uno.</span><span class="sxs-lookup"><span data-stu-id="60a97-2755">If no assembly is provided, the <paramref name="typeResolver" /> method can provide one.</span></span> <span data-ttu-id="60a97-2756">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <see langword="false" /> a ese parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2756">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="60a97-2757">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2757">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <summary><span data-ttu-id="60a97-2758">Obtiene el tipo con el nombre especificado, que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2758">Gets the type with the specified name, optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-2759">Tipo con el nombre especificado, o <see langword="null" /> si no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2759">The type with the specified name, or <see langword="null" /> if the type is not found.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2760">Escenarios de uso para este método y los detalles sobre la `assemblyResolver` y `typeResolver` parámetros pueden encontrarse en el <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2760">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2761">Si `typeName` no se encuentra, la llamada a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> devuelve del método `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2761">If `typeName` cannot be found, the call to the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> method returns `null`.</span></span> <span data-ttu-id="60a97-2762">No se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2762">It does not throw an exception.</span></span> <span data-ttu-id="60a97-2763">Para controlar si se produce una excepción, llamar a una sobrecarga de la <xref:System.Type.GetType%2A> método que tiene un `throwOnError` parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2763">To control whether an exception is thrown, call an overload of the <xref:System.Type.GetType%2A> method that has a `throwOnError` parameter.</span></span>  
  
 <span data-ttu-id="60a97-2764">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método y especificando `false` para el `throwOnError` y `ignoreCase` parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-2764">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `throwOnError` and `ignoreCase` parameters.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2765">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2765"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2766">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2766">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2767">Se produce un error cuando <paramref name="typeName" /> se analiza en un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre de tipo simple incluye un carácter especial sin escape).</span><span class="sxs-lookup"><span data-stu-id="60a97-2767">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="60a97-2768">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2768">-or-</span></span> 
 <span data-ttu-id="60a97-2769"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2769"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-2770">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2770">-or-</span></span> 
 <span data-ttu-id="60a97-2771"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2771"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-2772">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2772">-or-</span></span> 
 <span data-ttu-id="60a97-2773"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2773"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-2774"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2774"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="60a97-2775">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2775">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="60a97-2776">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2776">-or-</span></span> 
 <span data-ttu-id="60a97-2777"><paramref name="typeName" /> contiene un nombre de ensamblado no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2777"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="60a97-2778">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2778">-or-</span></span> 
 <span data-ttu-id="60a97-2779"><paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2779"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-2780">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2780">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-2781">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2781">-or-</span></span> 
<span data-ttu-id="60a97-2782">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2782">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2783">Nombre del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2783">The name of the type to get.</span></span> <span data-ttu-id="60a97-2784">Si se proporciona el parámetro <paramref name="typeResolver" />, el nombre del tipo puede ser cualquier cadena que <paramref name="typeResolver" /> pueda resolver.</span><span class="sxs-lookup"><span data-stu-id="60a97-2784">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="60a97-2785">Si se proporciona el parámetro <paramref name="assemblyResolver" /> o se usa la resolución de tipos estándar, <paramref name="typeName" /> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2785">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="60a97-2786">Método que busca y devuelve el ensamblado especificado en <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2786">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="60a97-2787">El nombre del ensamblado se pasa a <paramref name="assemblyResolver" /> como un objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2787">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="60a97-2788">Si <paramref name="typeName" /> no contiene el nombre de un ensamblado, no se llama a <paramref name="assemblyResolver" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2788">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="60a97-2789">Si no se proporciona <paramref name="assemblyResolver" />, se realiza la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2789">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="60a97-2790">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2790">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="60a97-2791">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2791">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="60a97-2792">Use solo los métodos que proporciona o con los que está familiarizado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2792">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="60a97-2793">Método que busca y devuelve el tipo especificado por <paramref name="typeName" /> del ensamblado devuelto por <paramref name="assemblyResolver" /> o mediante la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2793">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="60a97-2794">Si no se proporciona ningún ensamblado, el método podrá proporcionar uno.</span><span class="sxs-lookup"><span data-stu-id="60a97-2794">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="60a97-2795">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa <see langword="false" /> a ese parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2795">The method also takes a parameter that specifies whether to perform a case-insensitive search; <see langword="false" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="60a97-2796">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2796">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-2797">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2797"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="60a97-2798">Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2798">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="60a97-2799">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2799">See the Exceptions section.</span></span></param>
        <summary><span data-ttu-id="60a97-2800">Obtiene el tipo con el nombre indicado, que especifica si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2800">Gets the type with the specified name, specifying whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-2801">Tipo con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2801">The type with the specified name.</span></span> <span data-ttu-id="60a97-2802">Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2802">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="60a97-2803">En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2803">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="60a97-2804">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2804">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2805">Escenarios de uso para este método y los detalles sobre la `assemblyResolver` y `typeResolver` parámetros pueden encontrarse en el <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2805">Usage scenarios for this method and details about the `assemblyResolver` and `typeResolver` parameters can be found in the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="60a97-2806">Llamar a esta sobrecarga del método es igual que llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método y especificando `false` para el `ignoreCase` parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2806">Calling this method overload is the same as calling the <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%2CSystem.Boolean%29> method overload and specifying `false` for the `ignoreCase` parameter.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2807">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2807"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2808">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2808">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-2809"><paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2809"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="60a97-2810">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2810">-or-</span></span> 
 <span data-ttu-id="60a97-2811"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2811"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="60a97-2812">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2812">-or-</span></span> 
 <span data-ttu-id="60a97-2813"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-2813"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="60a97-2814">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2814">-or-</span></span> 
 <span data-ttu-id="60a97-2815"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2815"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="60a97-2816">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2816">-or-</span></span> 
 <span data-ttu-id="60a97-2817"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2817"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-2818">Se produce un error si el analizador obtiene de <paramref name="typeName" /> un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre de tipo simple incluye un carácter especial sin escape).</span><span class="sxs-lookup"><span data-stu-id="60a97-2818">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="60a97-2819">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2819">-or-</span></span> 
 <span data-ttu-id="60a97-2820"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida (por ejemplo, "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="60a97-2820"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="60a97-2821">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2821">-or-</span></span> 
 <span data-ttu-id="60a97-2822"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2822"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-2823">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2823">-or-</span></span> 
 <span data-ttu-id="60a97-2824"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2824"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-2825">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2825">-or-</span></span> 
 <span data-ttu-id="60a97-2826"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2826"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="60a97-2827"><paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="60a97-2827"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span>  
  
<span data-ttu-id="60a97-2828">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2828">-or-</span></span> 
 <span data-ttu-id="60a97-2829"><paramref name="typeName" /> contiene un nombre de ensamblado no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2829"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="60a97-2830">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2830">-or-</span></span> 
 <span data-ttu-id="60a97-2831"><paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2831"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="60a97-2832">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2832">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-2833">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2833">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-2834">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-2834">-or-</span></span> 
<span data-ttu-id="60a97-2835">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2835">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetType">
      <MemberSignature Language="C#" Value="public static Type GetType (string typeName, Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt; assemblyResolver, Func&lt;System.Reflection.Assembly,string,bool,Type&gt; typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetType(string typeName, class System.Func`2&lt;class System.Reflection.AssemblyName, class System.Reflection.Assembly&gt; assemblyResolver, class System.Func`4&lt;class System.Reflection.Assembly, string, bool, class System.Type&gt; typeResolver, bool throwOnError, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetType(System.String,System.Func{System.Reflection.AssemblyName,System.Reflection.Assembly},System.Func{System.Reflection.Assembly,System.String,System.Boolean,System.Type},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetType (typeName As String, assemblyResolver As Func(Of AssemblyName, Assembly), typeResolver As Func(Of Assembly, String, Boolean, Type), throwOnError As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetType(System::String ^ typeName, Func&lt;System::Reflection::AssemblyName ^, System::Reflection::Assembly ^&gt; ^ assemblyResolver, Func&lt;System::Reflection::Assembly ^, System::String ^, bool, Type ^&gt; ^ typeResolver, bool throwOnError, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member GetType : string * Func&lt;System.Reflection.AssemblyName, System.Reflection.Assembly&gt; * Func&lt;System.Reflection.Assembly, string, bool, Type&gt; * bool * bool -&gt; Type" Usage="System.Type.GetType (typeName, assemblyResolver, typeResolver, throwOnError, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="assemblyResolver" Type="System.Func&lt;System.Reflection.AssemblyName,System.Reflection.Assembly&gt;" />
        <Parameter Name="typeResolver" Type="System.Func&lt;System.Reflection.Assembly,System.String,System.Boolean,System.Type&gt;" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-2836">Nombre del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-2836">The name of the type to get.</span></span> <span data-ttu-id="60a97-2837">Si se proporciona el parámetro <paramref name="typeResolver" />, el nombre del tipo puede ser cualquier cadena que <paramref name="typeResolver" /> pueda resolver.</span><span class="sxs-lookup"><span data-stu-id="60a97-2837">If the <paramref name="typeResolver" /> parameter is provided, the type name can be any string that <paramref name="typeResolver" /> is capable of resolving.</span></span> <span data-ttu-id="60a97-2838">Si se proporciona el parámetro <paramref name="assemblyResolver" /> o se usa la resolución de tipos estándar, <paramref name="typeName" /> debe ser un nombre calificado con el ensamblado (vea <see cref="P:System.Type.AssemblyQualifiedName" />), a menos que el tipo esté en el ensamblado que se ejecuta actualmente o en Mscorlib.dll, en cuyo caso basta con aplicar el nombre de tipo calificado con su espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2838">If the <paramref name="assemblyResolver" /> parameter is provided or if standard type resolution is used, <paramref name="typeName" /> must be an assembly-qualified name (see <see cref="P:System.Type.AssemblyQualifiedName" />), unless the type is in the currently executing assembly or in Mscorlib.dll, in which case it is sufficient to supply the type name qualified by its namespace.</span></span></param>
        <param name="assemblyResolver"><span data-ttu-id="60a97-2839">Método que busca y devuelve el ensamblado especificado en <paramref name="typeName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2839">A method that locates and returns the assembly that is specified in <paramref name="typeName" />.</span></span> <span data-ttu-id="60a97-2840">El nombre del ensamblado se pasa a <paramref name="assemblyResolver" /> como un objeto <see cref="T:System.Reflection.AssemblyName" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2840">The assembly name is passed to <paramref name="assemblyResolver" /> as an <see cref="T:System.Reflection.AssemblyName" /> object.</span></span> <span data-ttu-id="60a97-2841">Si <paramref name="typeName" /> no contiene el nombre de un ensamblado, no se llama a <paramref name="assemblyResolver" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2841">If <paramref name="typeName" /> does not contain the name of an assembly, <paramref name="assemblyResolver" /> is not called.</span></span> <span data-ttu-id="60a97-2842">Si no se proporciona <paramref name="assemblyResolver" />, se realiza la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2842">If <paramref name="assemblyResolver" /> is not supplied, standard assembly resolution is performed.</span></span>  
  
<span data-ttu-id="60a97-2843">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2843">Caution   Do not pass methods from unknown or untrusted callers.</span></span> <span data-ttu-id="60a97-2844">Hacerlo podría tener como resultado la elevación de privilegios para el código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2844">Doing so could result in elevation of privilege for malicious code.</span></span> <span data-ttu-id="60a97-2845">Use solo los métodos que proporciona o con los que está familiarizado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2845">Use only methods that you provide or that you are familiar with.</span></span></param>
        <param name="typeResolver"><span data-ttu-id="60a97-2846">Método que busca y devuelve el tipo especificado por <paramref name="typeName" /> del ensamblado devuelto por <paramref name="assemblyResolver" /> o mediante la resolución de ensamblados estándar.</span><span class="sxs-lookup"><span data-stu-id="60a97-2846">A method that locates and returns the type that is specified by <paramref name="typeName" /> from the assembly that is returned by <paramref name="assemblyResolver" /> or by standard assembly resolution.</span></span> <span data-ttu-id="60a97-2847">Si no se proporciona ningún ensamblado, el método podrá proporcionar uno.</span><span class="sxs-lookup"><span data-stu-id="60a97-2847">If no assembly is provided, the method can provide one.</span></span> <span data-ttu-id="60a97-2848">El método también toma un parámetro que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas; se pasa el valor de <paramref name="ignoreCase" /> a ese parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2848">The method also takes a parameter that specifies whether to perform a case-insensitive search; the value of <paramref name="ignoreCase" /> is passed to that parameter.</span></span>  
  
<span data-ttu-id="60a97-2849">Precaución   No pase métodos de llamadores desconocidos o que no sean de confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-2849">Caution   Do not pass methods from unknown or untrusted callers.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-2850">Es <see langword="true" /> para producir una excepción si no se puede encontrar el tipo; es <see langword="false" /> para devolver <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2850"><see langword="true" /> to throw an exception if the type cannot be found; <see langword="false" /> to return <see langword="null" />.</span></span> <span data-ttu-id="60a97-2851">Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2851">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="60a97-2852">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2852">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="60a97-2853"><see langword="true" /> para realizar una búsqueda de <paramref name="typeName" /> que no distinga entre mayúsculas y minúsculas; <see langword="false" /> para realizar una búsqueda de <paramref name="typeName" /> que distinga entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-2853"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />, <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="60a97-2854">Obtiene el tipo con el nombre indicado, que especifica si se va a realizar una búsqueda sin distinguir mayúsculas de minúsculas y si se va a iniciar una excepción en caso de que el tipo no se encuentre y que, de manera opcional, puede proporcionar métodos personalizados para resolver el ensamblado y el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2854">Gets the type with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found, and optionally providing custom methods to resolve the assembly and the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-2855">Tipo con el nombre especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2855">The type with the specified name.</span></span> <span data-ttu-id="60a97-2856">Si el tipo no se encuentra, el parámetro <paramref name="throwOnError" /> especifica si se devuelve <see langword="null" /> o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2856">If the type is not found, the <paramref name="throwOnError" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="60a97-2857">En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwOnError" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2857">In some cases, an exception is thrown regardless of the value of <paramref name="throwOnError" />.</span></span> <span data-ttu-id="60a97-2858">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-2858">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-2859">Utilice esta sobrecarga del método y sus sobrecargas asociadas (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> y <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) para reemplazar la implementación predeterminada de la <xref:System.Type.GetType%2A> método con las implementaciones más flexibles.</span><span class="sxs-lookup"><span data-stu-id="60a97-2859">Use this method overload and its associated overloads (<xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%29> and <xref:System.Type.GetType%28System.String%2CSystem.Func%7BSystem.Reflection.AssemblyName%2CSystem.Reflection.Assembly%7D%2CSystem.Func%7BSystem.Reflection.Assembly%2CSystem.String%2CSystem.Boolean%2CSystem.Type%7D%2CSystem.Boolean%29>) to replace the default implementation of the <xref:System.Type.GetType%2A> method with more flexible implementations.</span></span> <span data-ttu-id="60a97-2860">Al proporcionar sus propios métodos que se resuelven los nombres de tipo y los nombres de los ensamblados que los contienen, puede hacer lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-2860">By providing your own methods that resolve type names and the names of the assemblies that contain them, you can do the following:</span></span>  
  
-   <span data-ttu-id="60a97-2861">Controlar qué versión de un ensamblado se carga un tipo de.</span><span class="sxs-lookup"><span data-stu-id="60a97-2861">Control which version of an assembly a type is loaded from.</span></span>  
  
-   <span data-ttu-id="60a97-2862">Proporcionar otro lugar para buscar un nombre de tipo que no incluya un nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2862">Provide another place to look for a type name that does not include an assembly name.</span></span>  
  
-   <span data-ttu-id="60a97-2863">Cargar ensamblados con nombres de ensamblado parciales.</span><span class="sxs-lookup"><span data-stu-id="60a97-2863">Load assemblies using partial assembly names.</span></span>  
  
-   <span data-ttu-id="60a97-2864">Devolver las subclases de <xref:System.Type?displayProperty=nameWithType> no creados por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="60a97-2864">Return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the common language runtime (CLR).</span></span>  
  
 <span data-ttu-id="60a97-2865">Por ejemplo, en la serialización tolerante a versiones este método le permite buscar un ensamblado de "ajuste perfecto" mediante un nombre parcial.</span><span class="sxs-lookup"><span data-stu-id="60a97-2865">For example, in version-tolerant serialization this method enables you to search for a "best fit" assembly by using a partial name.</span></span> <span data-ttu-id="60a97-2866">Otras sobrecargas de los <xref:System.Type.GetType%2A> método requiere un nombre de tipo calificado con el ensamblado, que incluye el número de versión.</span><span class="sxs-lookup"><span data-stu-id="60a97-2866">Other overloads of the <xref:System.Type.GetType%2A> method require an assembly-qualified type name, which includes the version number.</span></span>  
  
 <span data-ttu-id="60a97-2867">Implementaciones alternativas del sistema de tipos que deba devolver las subclases de <xref:System.Type?displayProperty=nameWithType> que no se crean mediante CLR; todos los tipos que son devueltos por otras sobrecargas de los <xref:System.Type.GetType%2A> método son tipos de tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-2867">Alternate implementations of the type system may need to return subclasses of <xref:System.Type?displayProperty=nameWithType> that are not created by the CLR; all types that are returned by other overloads of the <xref:System.Type.GetType%2A> method are runtime types.</span></span>  
  
<a name="usage_notes"></a>   
## <a name="usage-notes"></a><span data-ttu-id="60a97-2868">Notas de uso</span><span class="sxs-lookup"><span data-stu-id="60a97-2868">Usage Notes</span></span>  
 <span data-ttu-id="60a97-2869">Esta sobrecarga del método y sus sobrecargas asociadas analizar `typeName` en el nombre de un tipo y el nombre de un ensamblado y, a continuación, resolver los nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-2869">This method overload and its associated overloads parse `typeName` into the name of a type and the name of an assembly, and then resolve the names.</span></span> <span data-ttu-id="60a97-2870">Resolución del nombre del ensamblado se produce antes de la resolución del nombre de tipo, porque se debe resolver un nombre de tipo en el contexto de un ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2870">Resolution of the assembly name occurs before resolution of the type name, because a type name must be resolved in the context of an assembly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2871">Si no está familiarizado con el concepto de nombres de tipo calificado con el ensamblado, vea el <xref:System.Type.AssemblyQualifiedName%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2871">If you are unfamiliar with the concept of assembly-qualified type names, see the <xref:System.Type.AssemblyQualifiedName%2A> property.</span></span>  
  
 <span data-ttu-id="60a97-2872">Si `typeName` no es un nombre completo de ensamblado, se omite la resolución de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2872">If `typeName` is not an assembly-qualified name, assembly resolution is skipped.</span></span> <span data-ttu-id="60a97-2873">Se pueden resolver los nombres de tipo no calificado en el contexto de Mscorlib.dll o el ensamblado actualmente en ejecución, o puede proporcionar opcionalmente un ensamblado en el `typeResolver` parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-2873">Unqualified type names can be resolved in the context of Mscorlib.dll or the currently executing assembly, or you can optionally provide an assembly in the `typeResolver` parameter.</span></span> <span data-ttu-id="60a97-2874">Los efectos de incluir u omitir el nombre del ensamblado para diferentes tipos de resolución de nombres se muestran como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección.</span><span class="sxs-lookup"><span data-stu-id="60a97-2874">The effects of including or omitting the assembly name for different kinds of name resolution are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section.</span></span>  
  
 <span data-ttu-id="60a97-2875">Notas de uso general:</span><span class="sxs-lookup"><span data-stu-id="60a97-2875">General usage notes:</span></span>  
  
-   <span data-ttu-id="60a97-2876">No pase métodos a `assemblyResolver` o `typeResolver` si proceden de llamadores desconocidos o que no se confía.</span><span class="sxs-lookup"><span data-stu-id="60a97-2876">Do not pass methods to `assemblyResolver` or `typeResolver` if they come from unknown or untrusted callers.</span></span> <span data-ttu-id="60a97-2877">Use solo los métodos que proporciona o con los que está familiarizado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2877">Use only methods that you provide or that you are familiar with.</span></span>  
  
    > [!CAUTION]
    >  <span data-ttu-id="60a97-2878">Mediante métodos de llamadores desconocidos o no confiables podría provocar la elevación de privilegios para el código malintencionado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2878">Using methods from unknown or untrusted callers could result in elevation of privilege for malicious code.</span></span>  
  
-   <span data-ttu-id="60a97-2879">Si se omite el `assemblyResolver` o `typeResolver` parámetros, el valor de la `throwOnError` parámetro se pasa a los métodos que realizan la resolución predeterminada.</span><span class="sxs-lookup"><span data-stu-id="60a97-2879">If you omit the `assemblyResolver` and/or `typeResolver` parameters, the value of the `throwOnError` parameter is passed to the methods that perform the default resolution.</span></span>  
  
-   <span data-ttu-id="60a97-2880">Si `throwOnError` es `true`, este método produce una <xref:System.TypeLoadException> cuando `typeResolver` devuelve `null`y un <xref:System.IO.FileNotFoundException> cuando `assemblyResolver` devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2880">If `throwOnError` is `true`, this method throws a <xref:System.TypeLoadException> when `typeResolver` returns `null`, and a <xref:System.IO.FileNotFoundException> when `assemblyResolver` returns `null`.</span></span>  
  
-   <span data-ttu-id="60a97-2881">Este método no detecta las excepciones producidas por `assemblyResolver` y `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2881">This method does not catch exceptions thrown by `assemblyResolver` and `typeResolver`.</span></span> <span data-ttu-id="60a97-2882">Usted es responsable de las excepciones producidas por los métodos de resolución.</span><span class="sxs-lookup"><span data-stu-id="60a97-2882">You are responsible for any exceptions that are thrown by the resolver methods.</span></span>  
  
<a name="resolving_assemblies"></a>   
### <a name="resolving-assemblies"></a><span data-ttu-id="60a97-2883">Resolver ensamblados</span><span class="sxs-lookup"><span data-stu-id="60a97-2883">Resolving Assemblies</span></span>  
 <span data-ttu-id="60a97-2884">El `assemblyResolver` método recibe una <xref:System.Reflection.AssemblyName> objeto, que se produce al analizar el nombre del ensamblado de cadena que se incluye en `typeName`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2884">The `assemblyResolver` method receives an <xref:System.Reflection.AssemblyName> object, which is produced by parsing the string assembly name that is included in `typeName`.</span></span> <span data-ttu-id="60a97-2885">Si `typeName` no contiene un nombre de ensamblado, `assemblyResolver` no se llama y `null` se pasa a `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2885">If `typeName` does not contain an assembly name, `assemblyResolver` is not called and `null` is passed to `typeResolver`.</span></span>  
  
 <span data-ttu-id="60a97-2886">Si `assemblyResolver` no es el ensamblado proporcionado, estándar de sondeo se usa para buscar el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2886">If `assemblyResolver` is not supplied, standard assembly probing is used to locate the assembly.</span></span> <span data-ttu-id="60a97-2887">Si `assemblyResolver` se proporciona, el <xref:System.Type.GetType%2A> método realiza la búsqueda estándar; en ese caso debe asegurarse de que su `assemblyResolver` puede administrar todos los ensamblados que se pasa a él.</span><span class="sxs-lookup"><span data-stu-id="60a97-2887">If `assemblyResolver` is provided, the <xref:System.Type.GetType%2A> method does not do standard probing; in that case you must ensure that your `assemblyResolver` can handle all the assemblies you pass to it.</span></span>  
  
 <span data-ttu-id="60a97-2888">El `assemblyResolver` método debe devolver `null` si no se puede resolver el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2888">The `assemblyResolver` method should return `null` if the assembly cannot be resolved.</span></span> <span data-ttu-id="60a97-2889">Si `assemblyResolver` devuelve `null`, `typeResolver` no se llama y se produce la ningún procesamiento adicional; además, si `throwOnError` es `true`, un <xref:System.IO.FileNotFoundException> se produce.</span><span class="sxs-lookup"><span data-stu-id="60a97-2889">If `assemblyResolver` returns `null`, `typeResolver` is not called and no further processing occurs; additionally, if `throwOnError` is `true`, a <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="60a97-2890">Si el <xref:System.Reflection.AssemblyName> que se pasa a `assemblyResolver` es una parcial nombre, una o varias de sus partes son `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2890">If the <xref:System.Reflection.AssemblyName> that is passed to `assemblyResolver` is a partial name, one or more of its parts are `null`.</span></span> <span data-ttu-id="60a97-2891">Por ejemplo, si no tiene versión, la <xref:System.Reflection.AssemblyName.Version%2A> propiedad es `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2891">For example, if it has no version, the <xref:System.Reflection.AssemblyName.Version%2A> property is `null`.</span></span> <span data-ttu-id="60a97-2892">Si el <xref:System.Reflection.AssemblyName.Version%2A> propiedad, el <xref:System.Reflection.AssemblyName.CultureInfo%2A> propiedad y el <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> método devuelven `null`, a continuación, solo el nombre sencillo del ensamblado se ha proporcionado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2892">If the <xref:System.Reflection.AssemblyName.Version%2A> property, the <xref:System.Reflection.AssemblyName.CultureInfo%2A> property, and the <xref:System.Reflection.AssemblyName.GetPublicKeyToken%2A> method all return `null`, then only the simple name of the assembly was supplied.</span></span> <span data-ttu-id="60a97-2893">El `assemblyResolver` método puede usar o ignorar todas las partes del nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2893">The `assemblyResolver` method can use or ignore all parts of the assembly name.</span></span>  
  
 <span data-ttu-id="60a97-2894">Los efectos de las opciones de resolución de ensamblado diferentes se muestran como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección para nombres de tipo simple y completo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2894">The effects of different assembly resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
<a name="resolving_types"></a>   
### <a name="resolving-types"></a><span data-ttu-id="60a97-2895">Resolución de tipos</span><span class="sxs-lookup"><span data-stu-id="60a97-2895">Resolving Types</span></span>  
 <span data-ttu-id="60a97-2896">Si `typeName` no especifica un nombre de ensamblado, `typeResolver` siempre se llama.</span><span class="sxs-lookup"><span data-stu-id="60a97-2896">If `typeName` does not specify an assembly name, `typeResolver` is always called.</span></span> <span data-ttu-id="60a97-2897">Si `typeName` especifica un nombre de ensamblado, `typeResolver` sólo se llama cuando el nombre de ensamblado se resuelve correctamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2897">If `typeName` specifies an assembly name, `typeResolver` is called only when the assembly name is successfully resolved.</span></span> <span data-ttu-id="60a97-2898">Si `assemblyResolver` o ensamblado estándar sondeo devuelve `null`, `typeResolver` no se llama.</span><span class="sxs-lookup"><span data-stu-id="60a97-2898">If `assemblyResolver` or standard assembly probing returns `null`, `typeResolver` is not called.</span></span>  
  
 <span data-ttu-id="60a97-2899">El `typeResolver` método recibe tres argumentos:</span><span class="sxs-lookup"><span data-stu-id="60a97-2899">The `typeResolver` method receives three arguments:</span></span>  
  
-   <span data-ttu-id="60a97-2900">El ensamblado para buscar o `null` si `typeName` no contiene un nombre de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2900">The assembly to search or `null` if `typeName` does not contain an assembly name.</span></span>  
  
-   <span data-ttu-id="60a97-2901">Nombre del tipo simple.</span><span class="sxs-lookup"><span data-stu-id="60a97-2901">The simple name of the type.</span></span> <span data-ttu-id="60a97-2902">En el caso de un tipo anidado, se trata del tipo de contenedor más externo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2902">In the case of a nested type, this is the outermost containing type.</span></span> <span data-ttu-id="60a97-2903">En el caso de un tipo genérico, esto es el nombre simple del tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-2903">In the case of a generic type, this is the simple name of the generic type.</span></span>  
  
-   <span data-ttu-id="60a97-2904">Un valor booleano que es `true` si el caso de nombres de tipo se va a omitir.</span><span class="sxs-lookup"><span data-stu-id="60a97-2904">A Boolean value that is `true` if the case of type names is to be ignored.</span></span>  
  
 <span data-ttu-id="60a97-2905">La implementación determina la manera en que se usan estos argumentos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2905">The implementation determines the way these arguments are used.</span></span> <span data-ttu-id="60a97-2906">El `typeResolver` método debe devolver `null` si no se puede resolver el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2906">The `typeResolver` method should return `null` if it cannot resolve the type.</span></span> <span data-ttu-id="60a97-2907">Si `typeResolver` devuelve `null` y `throwOnError` es `true`, esta sobrecarga de <xref:System.Type.GetType%2A> produce una <xref:System.TypeLoadException>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2907">If `typeResolver` returns `null` and `throwOnError` is `true`, this overload of <xref:System.Type.GetType%2A> throws a <xref:System.TypeLoadException>.</span></span>  
  
 <span data-ttu-id="60a97-2908">Se muestran los efectos de las opciones de resolución de tipo diferente como una tabla en la [la resolución de nombres mixtos](#mixed_name_resolution) sección para nombres de tipo simple y completo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2908">The effects of different type resolution options are displayed as a table in the [Mixed Name Resolution](#mixed_name_resolution) section, for simple and assembly-qualified type names.</span></span>  
  
#### <a name="resolving-nested-types"></a><span data-ttu-id="60a97-2909">Resolución de tipos anidados</span><span class="sxs-lookup"><span data-stu-id="60a97-2909">Resolving Nested Types</span></span>  
 <span data-ttu-id="60a97-2910">Si `typeName` es un tipo anidado, solo el nombre del exterior que contiene el tipo se pasa a `typeResolver`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2910">If `typeName` is a nested type, only the name of the outermost containing type is passed to `typeResolver`.</span></span> <span data-ttu-id="60a97-2911">Cuando `typeResolver` devuelve este tipo, el <xref:System.Type.GetNestedType%2A> se llama al método de forma recursiva hasta que se ha resuelto el tipo anidado más interno.</span><span class="sxs-lookup"><span data-stu-id="60a97-2911">When `typeResolver` returns this type, the <xref:System.Type.GetNestedType%2A> method is called recursively until the innermost nested type has been resolved.</span></span>  
  
#### <a name="resolving-generic-types"></a><span data-ttu-id="60a97-2912">Resolución de tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-2912">Resolving Generic Types</span></span>  
 <span data-ttu-id="60a97-2913">El <xref:System.Type.GetType%2A> se denomina de forma recursiva para resolver tipos genéricos: En primer lugar para resolver el tipo genérico en Sí y, a continuación, para resolver sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2913">The <xref:System.Type.GetType%2A> is called recursively to resolve generic types: First to resolve the generic type itself, and then to resolve its type arguments.</span></span> <span data-ttu-id="60a97-2914">Si un argumento de tipo es genérico, <xref:System.Type.GetType%2A> se llama de forma recursiva para resolver sus argumentos de tipo y así sucesivamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-2914">If a type argument is generic, <xref:System.Type.GetType%2A> is called recursively to resolve its type arguments, and so on.</span></span>  
  
 <span data-ttu-id="60a97-2915">La combinación de `assemblyResolver` y `typeResolver` que proporcione debe ser capaz de resolver todos los niveles de esta recursividad.</span><span class="sxs-lookup"><span data-stu-id="60a97-2915">The combination of `assemblyResolver` and `typeResolver` that you provide must be capable of resolving all levels of this recursion.</span></span> <span data-ttu-id="60a97-2916">Por ejemplo, suponga que proporciona un `assemblyResolver` que controla la carga de `MyAssembly`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2916">For example, suppose you supply an `assemblyResolver` that controls the loading of `MyAssembly`.</span></span> <span data-ttu-id="60a97-2917">Suponga que desea resolver el tipo genérico `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-2917">Suppose you want to resolve the generic type `Dictionary<string, MyType>` (`Dictionary(Of String, MyType)` in Visual Basic).</span></span> <span data-ttu-id="60a97-2918">Es posible que pase el siguiente nombre de tipo genérico:</span><span class="sxs-lookup"><span data-stu-id="60a97-2918">You might pass the following generic type name:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[System.String,[MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="60a97-2919">Tenga en cuenta que `MyType` es el argumento de tipo calificado con el ensamblado solo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2919">Notice that `MyType` is the only assembly-qualified type argument.</span></span> <span data-ttu-id="60a97-2920">Los nombres de los <xref:System.Collections.Generic.Dictionary%602> y <xref:System.String> clases no son calificado del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2920">The names of the <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String> classes are not assembly-qualified.</span></span> <span data-ttu-id="60a97-2921">Su `typeResolver` debe ser capaz de identificador en un ensamblado o `null`, porque recibirá `null` para <xref:System.Collections.Generic.Dictionary%602> y <xref:System.String>.</span><span class="sxs-lookup"><span data-stu-id="60a97-2921">Your `typeResolver` must be able handle either an assembly or `null`, because it will receive `null` for <xref:System.Collections.Generic.Dictionary%602> and <xref:System.String>.</span></span> <span data-ttu-id="60a97-2922">Ese caso puede controlar mediante una llamada a una sobrecarga de la <xref:System.Type.GetType%2A> método que toma una cadena, porque ambos de los nombres de tipo incompletos están en Mscorlib.dll:</span><span class="sxs-lookup"><span data-stu-id="60a97-2922">It can handle that case by calling an overload of the <xref:System.Type.GetType%2A> method that takes a string, because both of the unqualified type names are in Mscorlib.dll:</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#1](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#1)]  
  
 <span data-ttu-id="60a97-2923">El `assemblyResolver` método no se llama para el tipo de diccionario y el tipo de cadena, porque esos nombres de tipo no están calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2923">The `assemblyResolver` method is not called for the dictionary type and the string type, because those type names are not assembly-qualified.</span></span>  
  
 <span data-ttu-id="60a97-2924">Ahora, supongamos que en lugar de `System.String`, el primer tipo de argumento genérico es `YourType`, desde `YourAssembly`:</span><span class="sxs-lookup"><span data-stu-id="60a97-2924">Now suppose that instead of `System.String`, the first generic argument type is `YourType`, from `YourAssembly`:</span></span>  
  
```  
"System.Collections.Generic.Dictionary`2[[YourNamespace.YourType, YourAssembly, Version=1.0.0.0, Culture=neutral, PublicKeyToken=null], [MyNamespace.MyType, MyAssembly]]"  
```  
  
 <span data-ttu-id="60a97-2925">Dado que este ensamblado es Mscorlib.dll ni ensamblado actualmente en ejecución, no puede resolver `YourType` sin un nombre completo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2925">Because this assembly is neither Mscorlib.dll nor the currently executing assembly, you cannot resolve `YourType` without an assembly-qualified name.</span></span> <span data-ttu-id="60a97-2926">Dado que su `assemblyResolve` será llama de forma recursiva, debe ser capaz de controlar este caso.</span><span class="sxs-lookup"><span data-stu-id="60a97-2926">Because your `assemblyResolve` will be called recursively, it must be able to handle this case.</span></span> <span data-ttu-id="60a97-2927">En lugar de devolver `null` para los ensamblados que no sea `MyAssembly`, ahora realiza una carga de ensamblados con el <xref:System.Reflection.AssemblyName> objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-2927">Instead of returning `null` for assemblies other than `MyAssembly`, it now performs an assembly load using the supplied <xref:System.Reflection.AssemblyName> object.</span></span>  
  
 [!code-csharp[GetTypeOnSteroids#2](~/samples/snippets/csharp/VS_Snippets_CLR/gettypeonsteroids/cs/source.cs#2)]  
  
 <span data-ttu-id="60a97-2928">Volver a [notas de uso](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="60a97-2928">Back to [Usage Notes](#usage_notes).</span></span>  
  
#### <a name="resolving-type-names-with-special-characters"></a><span data-ttu-id="60a97-2929">Resolución de nombres de tipo con caracteres especiales</span><span class="sxs-lookup"><span data-stu-id="60a97-2929">Resolving Type Names with Special Characters</span></span>  
 <span data-ttu-id="60a97-2930">Ciertos caracteres tienen significados especiales en los nombres de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2930">Certain characters have special meanings in assembly-qualified names.</span></span> <span data-ttu-id="60a97-2931">Si un nombre de tipo simple contiene estos caracteres, los caracteres producen errores de análisis cuando el nombre simple es parte de un nombre completo de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2931">If a simple type name contains these characters, the characters cause parsing errors when the simple name is part of an assembly-qualified name.</span></span> <span data-ttu-id="60a97-2932">Para evitar los errores del análisis, debe realizar el escape los caracteres especiales con una barra diagonal inversa antes de pasar el nombre completo de ensamblado para el <xref:System.Type.GetType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2932">To avoid the parsing errors, you must escape the special characters with a backslash before you can pass the assembly-qualified name to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="60a97-2933">Por ejemplo, si un tipo se denomina `Strange]Type`, debe agregarse el carácter de escape delante del corchete como sigue: `Strange\]Type`.</span><span class="sxs-lookup"><span data-stu-id="60a97-2933">For example, if a type is named `Strange]Type`, the escape character must be added ahead of the square bracket as follows: `Strange\]Type`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-2934">Los nombres de los caracteres especiales no se puede crear en Visual Basic o C#, pero se pueden crear mediante el lenguaje intermedio de Microsoft (MSIL) o emitir ensamblados dinámicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-2934">Names with such special characters cannot be created in Visual Basic or C#, but can be created by using Microsoft intermediate language (MSIL) or by emitting dynamic assemblies.</span></span>  
  
 <span data-ttu-id="60a97-2935">La siguiente tabla muestra los caracteres especiales para nombres de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2935">The following table shows the special characters for type names.</span></span>  
  
|<span data-ttu-id="60a97-2936">Carácter</span><span class="sxs-lookup"><span data-stu-id="60a97-2936">Character</span></span>|<span data-ttu-id="60a97-2937">Significado</span><span class="sxs-lookup"><span data-stu-id="60a97-2937">Meaning</span></span>|  
|---------------|-------------|  
|<span data-ttu-id="60a97-2938">`,` (coma)</span><span class="sxs-lookup"><span data-stu-id="60a97-2938">`,` (comma)</span></span>|<span data-ttu-id="60a97-2939">Delimitador para los nombres de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2939">Delimiter for assembly-qualified names.</span></span>|  
|<span data-ttu-id="60a97-2940">`[]` (los corchetes)</span><span class="sxs-lookup"><span data-stu-id="60a97-2940">`[]` (square brackets)</span></span>|<span data-ttu-id="60a97-2941">Como un par de sufijo, indica un tipo de matriz; como un par de delimitadores, incluye las listas de argumentos genéricos y los nombres de ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2941">As a suffix pair, indicates an array type; as a delimiter pair, encloses generic argument lists and assembly-qualified names.</span></span>|  
|<span data-ttu-id="60a97-2942">`&` (y comercial)</span><span class="sxs-lookup"><span data-stu-id="60a97-2942">`&` (ampersand)</span></span>|<span data-ttu-id="60a97-2943">Como sufijo, indica que un tipo es un tipo de referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-2943">As a suffix, indicates that a type is a reference type.</span></span>|  
|<span data-ttu-id="60a97-2944">`*` (asterisco)</span><span class="sxs-lookup"><span data-stu-id="60a97-2944">`*` (asterisk)</span></span>|<span data-ttu-id="60a97-2945">Como sufijo, indica que un tipo es un tipo de puntero.</span><span class="sxs-lookup"><span data-stu-id="60a97-2945">As a suffix, indicates that a type is a pointer type.</span></span>|  
|<span data-ttu-id="60a97-2946">`+` (signo más)</span><span class="sxs-lookup"><span data-stu-id="60a97-2946">`+` (plus)</span></span>|<span data-ttu-id="60a97-2947">Delimitador para los tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-2947">Delimiter for nested types.</span></span>|  
|<span data-ttu-id="60a97-2948">`\` (barra diagonal inversa)</span><span class="sxs-lookup"><span data-stu-id="60a97-2948">`\` (backslash)</span></span>|<span data-ttu-id="60a97-2949">Carácter de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2949">Escape character.</span></span>|  
  
 <span data-ttu-id="60a97-2950">Propiedades, como <xref:System.Type.AssemblyQualifiedName%2A> devuelven correctamente cadenas de caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2950">Properties such as <xref:System.Type.AssemblyQualifiedName%2A> return correctly escaped strings.</span></span> <span data-ttu-id="60a97-2951">Debe pasar correctamente cadenas de escape para el <xref:System.Type.GetType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2951">You must pass correctly escaped strings to the <xref:System.Type.GetType%2A> method.</span></span> <span data-ttu-id="60a97-2952">A su vez, el <xref:System.Type.GetType%2A> método pasa los nombres de escape correctamente a `typeResolver` y a los métodos de resolución de tipo predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2952">In turn, the <xref:System.Type.GetType%2A> method passes correctly escaped names to `typeResolver` and to the default type resolution methods.</span></span> <span data-ttu-id="60a97-2953">Si necesita comparar un nombre con un nombre sin escape en `typeResolver`, debe quitar los caracteres de escape.</span><span class="sxs-lookup"><span data-stu-id="60a97-2953">If you need to compare a name to an unescaped name in `typeResolver`, you must remove the escape characters.</span></span>  
  
 <span data-ttu-id="60a97-2954">Volver a [notas de uso](#usage_notes).</span><span class="sxs-lookup"><span data-stu-id="60a97-2954">Back to [Usage Notes](#usage_notes).</span></span>  
  
<a name="mixed_name_resolution"></a>   
## <a name="mixed-name-resolution"></a><span data-ttu-id="60a97-2955">Resolución de nombres mixtos</span><span class="sxs-lookup"><span data-stu-id="60a97-2955">Mixed Name Resolution</span></span>  
 <span data-ttu-id="60a97-2956">En la tabla siguiente se resume las interacciones entre `assemblyResolver`, `typeResolver`, resolución de nombres predeterminado, para todas las combinaciones de nombre de tipo y nombre del ensamblado y `typeName`:</span><span class="sxs-lookup"><span data-stu-id="60a97-2956">The following table summarizes the interactions between `assemblyResolver`, `typeResolver`, and default name resolution, for all combinations of type name and assembly name in `typeName`:</span></span>  
  
|<span data-ttu-id="60a97-2957">Contenido del nombre de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2957">Contents of type name</span></span>|<span data-ttu-id="60a97-2958">Método de resolución de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2958">Assembly resolver method</span></span>|<span data-ttu-id="60a97-2959">Método de resolución de tipo</span><span class="sxs-lookup"><span data-stu-id="60a97-2959">Type resolver method</span></span>|<span data-ttu-id="60a97-2960">Resultado</span><span class="sxs-lookup"><span data-stu-id="60a97-2960">Result</span></span>|  
|---------------------------|------------------------------|--------------------------|------------|  
|<span data-ttu-id="60a97-2961">tipo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2961">type, assembly</span></span>|<span data-ttu-id="60a97-2962">nulo</span><span class="sxs-lookup"><span data-stu-id="60a97-2962">null</span></span>|<span data-ttu-id="60a97-2963">nulo</span><span class="sxs-lookup"><span data-stu-id="60a97-2963">null</span></span>|<span data-ttu-id="60a97-2964">Equivalente a llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2964">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span>|  
|<span data-ttu-id="60a97-2965">tipo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2965">type, assembly</span></span>|<span data-ttu-id="60a97-2966">Proporciona</span><span class="sxs-lookup"><span data-stu-id="60a97-2966">provided</span></span>|<span data-ttu-id="60a97-2967">nulo</span><span class="sxs-lookup"><span data-stu-id="60a97-2967">null</span></span>|<span data-ttu-id="60a97-2968">`assemblyResolver` Devuelve el ensamblado o devuelve `null` si no se puede resolver el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2968">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="60a97-2969">Si el ensamblado se ha resuelto, el <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método se usa para cargar el tipo del ensamblado; en caso contrario, no hay ningún intento para resolver el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2969">If the assembly is resolved, the <xref:System.Reflection.Assembly.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload is used to load the type from the assembly; otherwise, there is no attempt to resolve the type.</span></span>|  
|<span data-ttu-id="60a97-2970">tipo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2970">type, assembly</span></span>|<span data-ttu-id="60a97-2971">nulo</span><span class="sxs-lookup"><span data-stu-id="60a97-2971">null</span></span>|<span data-ttu-id="60a97-2972">Proporciona</span><span class="sxs-lookup"><span data-stu-id="60a97-2972">provided</span></span>|<span data-ttu-id="60a97-2973">Equivalente a poner el nombre del ensamblado a un <xref:System.Reflection.AssemblyName> objeto y llamar a la <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> sobrecarga del método para obtener el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2973">Equivalent to converting the assembly name to an <xref:System.Reflection.AssemblyName> object and calling the <xref:System.Reflection.Assembly.Load%28System.Reflection.AssemblyName%29?displayProperty=nameWithType> method overload to get the assembly.</span></span> <span data-ttu-id="60a97-2974">Si el ensamblado se ha resuelto, se pasa a `typeResolver`; en caso contrario, `typeResolver` no se llama y no hay ningún intento adicional para resolver el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2974">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="60a97-2975">tipo de ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2975">type, assembly</span></span>|<span data-ttu-id="60a97-2976">Proporciona</span><span class="sxs-lookup"><span data-stu-id="60a97-2976">provided</span></span>|<span data-ttu-id="60a97-2977">Proporciona</span><span class="sxs-lookup"><span data-stu-id="60a97-2977">provided</span></span>|<span data-ttu-id="60a97-2978">`assemblyResolver` Devuelve el ensamblado o devuelve `null` si no se puede resolver el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2978">`assemblyResolver` returns the assembly or returns `null` if it cannot resolve the assembly.</span></span> <span data-ttu-id="60a97-2979">Si el ensamblado se ha resuelto, se pasa a `typeResolver`; en caso contrario, `typeResolver` no se llama y no hay ningún intento adicional para resolver el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-2979">If the assembly is resolved, it is passed to `typeResolver`; otherwise, `typeResolver` is not called and there is no further attempt to resolve the type.</span></span>|  
|<span data-ttu-id="60a97-2980">type</span><span class="sxs-lookup"><span data-stu-id="60a97-2980">type</span></span>|<span data-ttu-id="60a97-2981">null, proporcionado</span><span class="sxs-lookup"><span data-stu-id="60a97-2981">null, provided</span></span>|<span data-ttu-id="60a97-2982">nulo</span><span class="sxs-lookup"><span data-stu-id="60a97-2982">null</span></span>|<span data-ttu-id="60a97-2983">Equivalente a llamar a la <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-2983">Equivalent to calling the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29?displayProperty=nameWithType> method overload.</span></span> <span data-ttu-id="60a97-2984">Porque no se proporcionó el nombre del ensamblado, se buscan solo Mscorlib.dll y ensamblado actualmente en ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-2984">Because the assembly name is not provided, only Mscorlib.dll and the currently executing assembly are searched.</span></span> <span data-ttu-id="60a97-2985">Si `assemblyResolver` es siempre se omite.</span><span class="sxs-lookup"><span data-stu-id="60a97-2985">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="60a97-2986">type</span><span class="sxs-lookup"><span data-stu-id="60a97-2986">type</span></span>|<span data-ttu-id="60a97-2987">null, proporcionado</span><span class="sxs-lookup"><span data-stu-id="60a97-2987">null, provided</span></span>|<span data-ttu-id="60a97-2988">Proporciona</span><span class="sxs-lookup"><span data-stu-id="60a97-2988">provided</span></span>|<span data-ttu-id="60a97-2989">`typeResolver` se llama a, y `null` se pasa para el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2989">`typeResolver` is called, and `null` is passed for the assembly.</span></span> <span data-ttu-id="60a97-2990">`typeResolver` puede proporcionar un tipo de cualquier ensamblado, incluidos los ensamblados que carga para el propósito.</span><span class="sxs-lookup"><span data-stu-id="60a97-2990">`typeResolver` can provide a type from any assembly, including assemblies it loads for the purpose.</span></span> <span data-ttu-id="60a97-2991">Si `assemblyResolver` es siempre se omite.</span><span class="sxs-lookup"><span data-stu-id="60a97-2991">If `assemblyResolver` is provided, it is ignored.</span></span>|  
|<span data-ttu-id="60a97-2992">ensamblado</span><span class="sxs-lookup"><span data-stu-id="60a97-2992">assembly</span></span>|<span data-ttu-id="60a97-2993">null, proporcionado</span><span class="sxs-lookup"><span data-stu-id="60a97-2993">null, provided</span></span>|<span data-ttu-id="60a97-2994">null, proporcionado</span><span class="sxs-lookup"><span data-stu-id="60a97-2994">null, provided</span></span>|<span data-ttu-id="60a97-2995">Un <xref:System.IO.FileLoadException> se produce porque el nombre del ensamblado se analiza como si fuese un nombre de tipo calificado con el ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-2995">A <xref:System.IO.FileLoadException> is thrown, because the assembly name is parsed as if it were an assembly-qualified type name.</span></span> <span data-ttu-id="60a97-2996">Esto da como resultado un nombre de ensamblado no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-2996">This results in an invalid assembly name.</span></span>|  
  
 <span data-ttu-id="60a97-2997">Realizar copias en: [Notas de uso](#usage_notes), [resolver ensamblados](#resolving_assemblies), [resolver tipos](#resolving_types).</span><span class="sxs-lookup"><span data-stu-id="60a97-2997">Back to: [Usage Notes](#usage_notes), [Resolving Assemblies](#resolving_assemblies), [Resolving Types](#resolving_types).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-2998">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-2998"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-2999">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-2999">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-3000"><paramref name="throwOnError" /> es <see langword="true" /> y no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3000"><paramref name="throwOnError" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="60a97-3001">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3001">-or-</span></span> 
 <span data-ttu-id="60a97-3002"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3002"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="60a97-3003">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3003">-or-</span></span> 
 <span data-ttu-id="60a97-3004"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-3004"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="60a97-3005">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3005">-or-</span></span> 
 <span data-ttu-id="60a97-3006"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3006"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="60a97-3007">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3007">-or-</span></span> 
 <span data-ttu-id="60a97-3008"><paramref name="typeName" /> representa una matriz de <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3008"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3009">Se produce un error si el analizador obtiene de <paramref name="typeName" /> un nombre de tipo y un nombre de ensamblado (por ejemplo, cuando el nombre de tipo simple incluye un carácter especial sin escape).</span><span class="sxs-lookup"><span data-stu-id="60a97-3009">An error occurs when <paramref name="typeName" /> is parsed into a type name and an assembly name (for example, when the simple type name includes an unescaped special character).</span></span>  
  
<span data-ttu-id="60a97-3010">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3010">-or-</span></span> 
 <span data-ttu-id="60a97-3011"><paramref name="throwOnError" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida (por ejemplo, "MyType[,\*,]").</span><span class="sxs-lookup"><span data-stu-id="60a97-3011"><paramref name="throwOnError" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax (for example, "MyType[,\*,]").</span></span>  
  
<span data-ttu-id="60a97-3012">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3012">-or-</span></span> 
 <span data-ttu-id="60a97-3013"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3013"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-3014">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3014">-or-</span></span> 
 <span data-ttu-id="60a97-3015"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3015"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-3016">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3016">-or-</span></span> 
 <span data-ttu-id="60a97-3017"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3017"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="60a97-3018"><paramref name="throwOnError" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="60a97-3018"><paramref name="throwOnError" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="60a97-3019">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3019">The assembly or one of its dependencies was found, but could not be loaded.</span></span>  
  
<span data-ttu-id="60a97-3020">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3020">-or-</span></span> 
 <span data-ttu-id="60a97-3021"><paramref name="typeName" /> contiene un nombre de ensamblado no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3021"><paramref name="typeName" /> contains an invalid assembly name.</span></span>  
  
<span data-ttu-id="60a97-3022">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3022">-or-</span></span> 
 <span data-ttu-id="60a97-3023"><paramref name="typeName" /> es un nombre de ensamblado válido sin un nombre de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3023"><paramref name="typeName" /> is a valid assembly name without a type name.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-3024">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3024">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-3025">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3025">-or-</span></span> 
<span data-ttu-id="60a97-3026">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3026">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeArray">
      <MemberSignature Language="C#" Value="public static Type[] GetTypeArray (object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type[] GetTypeArray(object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeArray(System.Object[])" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeArray (args As Object()) As Type()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static cli::array &lt;Type ^&gt; ^ GetTypeArray(cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="static member GetTypeArray : obj[] -&gt; Type[]" Usage="System.Type.GetTypeArray args" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="args"><span data-ttu-id="60a97-3027">Matriz de objetos cuyos tipos se han de determinar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3027">An array of objects whose types to determine.</span></span></param>
        <summary><span data-ttu-id="60a97-3028">Obtiene los tipos de los objetos de la matriz especificada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3028">Gets the types of the objects in the specified array.</span></span></summary>
        <returns><span data-ttu-id="60a97-3029">Matriz de objetos <see cref="T:System.Type" /> que representa todos los tipos de los elementos correspondientes de <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3029">An array of <see cref="T:System.Type" /> objects representing the types of the corresponding elements in <paramref name="args" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60a97-3030">En el ejemplo de código siguiente se muestra cómo usar el <xref:System.Type.GetTypeArray%2A> método para enumerar los tipos de los elementos de una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3030">The following code example demonstrates how to use the <xref:System.Type.GetTypeArray%2A> method to list the types of the elements of an array.</span></span>  
  
 [!code-cpp[Type_GetTypeCode#3](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeCode/CPP/type_gettypecode.cpp#3)]
 [!code-csharp[Type_GetTypeCode#3](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeCode/CS/type_gettypecode.cs#3)]
 [!code-vb[Type_GetTypeCode#3](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeCode/VB/type_gettypecode.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3031">El valor de <paramref name="args" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3031"><paramref name="args" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-3032">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3032">-or-</span></span> 
<span data-ttu-id="60a97-3033">Uno o varios elementos de <paramref name="args" /> son <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3033">One or more of the elements in <paramref name="args" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-3034">Se invocan los inicializadores de clase y al menos uno genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-3034">The class initializers are invoked and at least one throws an exception.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="GetTypeCode">
      <MemberSignature Language="C#" Value="public static TypeCode GetTypeCode (Type type);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.TypeCode GetTypeCode(class System.Type type) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCode(System.Type)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static TypeCode GetTypeCode(Type ^ type);" />
      <MemberSignature Language="F#" Value="static member GetTypeCode : Type -&gt; TypeCode" Usage="System.Type.GetTypeCode type" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="type" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="type"><span data-ttu-id="60a97-3035">Tipo cuyo código de tipo subyacente se debe obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3035">The type whose underlying type code to get.</span></span></param>
        <summary><span data-ttu-id="60a97-3036">Obtiene el código de tipo subyacente del objeto <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3036">Gets the underlying type code of the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-3037">Código de tipo subyacente o <see cref="F:System.TypeCode.Empty" /> si <paramref name="type" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3037">The code of the underlying type, or <see cref="F:System.TypeCode.Empty" /> if <paramref name="type" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3038">Al heredar de <xref:System.Type>, puede cambiar el comportamiento de este método invalidando el <xref:System.Type.GetTypeCodeImpl%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3038">When you inherit from <xref:System.Type>, you can change the behavior of this method by overriding the <xref:System.Type.GetTypeCodeImpl%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3039">En el ejemplo de código siguiente se muestra cómo el <xref:System.TypeCode> pueden usar la enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3039">The following code example demonstrates how the <xref:System.TypeCode> enumeration can be used.</span></span> <span data-ttu-id="60a97-3040">En un bloque de decisiones dentro de la `WriteObjectInfo` método, el <xref:System.TypeCode> de un <xref:System.Object> parámetro se examina y se escribe un mensaje adecuado en la consola.</span><span class="sxs-lookup"><span data-stu-id="60a97-3040">In a decision block inside the `WriteObjectInfo` method, the <xref:System.TypeCode> of an <xref:System.Object> parameter is examined, and an appropriate message is written to the console.</span></span>  
  
 [!code-cpp[System.TypeCode#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.TypeCode/CPP/iconvertible.cpp#2)]
 [!code-csharp[System.TypeCode#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.TypeCode/CS/iconvertible.cs#2)]
 [!code-vb[System.TypeCode#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.TypeCode/VB/iconvertible.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCodeImpl" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeCodeImpl">
      <MemberSignature Language="C#" Value="protected virtual TypeCode GetTypeCodeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance valuetype System.TypeCode GetTypeCodeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeCodeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function GetTypeCodeImpl () As TypeCode" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual TypeCode GetTypeCodeImpl();" />
      <MemberSignature Language="F#" Value="abstract member GetTypeCodeImpl : unit -&gt; TypeCode&#xA;override this.GetTypeCodeImpl : unit -&gt; TypeCode" Usage="type.GetTypeCodeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TypeCode</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3041">Devuelve el código de tipo subyacente de esta instancia de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3041">Returns the underlying type code of this <see cref="T:System.Type" /> instance.</span></span></summary>
        <returns><span data-ttu-id="60a97-3042">Código de tipo del tipo subyacente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3042">The type code of the underlying type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3043">Este método proporciona la implementación de la `static` (en C#) o `Shared` (en Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3043">This method provides the implementation for the `static` (in C#) or `Shared` (in Visual Basic) <xref:System.Type.GetTypeCode%28System.Type%29> method.</span></span> <span data-ttu-id="60a97-3044">Al heredar de <xref:System.Type>, puede invalidar este método para proporcionar su propia implementación de <xref:System.Type.GetTypeCode%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3044">When you inherit from <xref:System.Type>, you can override this method to provide your own implementation of <xref:System.Type.GetTypeCode%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.TypeCode" />
        <altmember cref="M:System.Type.GetTypeCode(System.Type)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromCLSID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-3045">Obtiene el tipo asociado al identificador de clase especificado (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3045">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid -&gt; Type" Usage="System.Type.GetTypeFromCLSID clsid" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="60a97-3046">Identificador CLSID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3046">The CLSID of the type to get.</span></span></param>
        <summary><span data-ttu-id="60a97-3047">Obtiene el tipo asociado al identificador de clase especificado (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3047">Gets the type associated with the specified class identifier (CLSID).</span></span></summary>
        <returns><span data-ttu-id="60a97-3048"><see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3048"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3049">El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3049">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="60a97-3050">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3050">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="60a97-3051">Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3051">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="60a97-3052">Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.</span><span class="sxs-lookup"><span data-stu-id="60a97-3052">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="60a97-3053">Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</span><span class="sxs-lookup"><span data-stu-id="60a97-3053">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="60a97-3054">Obtener un <xref:System.Type> objeto que representa el`__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3054">Get a <xref:System.Type> object that represents the`__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="60a97-3055">Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3055">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="60a97-3056">Vea el ejemplo para ver una ilustración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3056">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="60a97-3057">El <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> sobrecarga pasa por alto cualquier excepción que se puede producir al crear instancias de un <xref:System.Type> objeto según el `clsid` argumento.</span><span class="sxs-lookup"><span data-stu-id="60a97-3057">The <xref:System.Type.GetTypeFromCLSID%28System.Guid%29> overload ignores any exception that may occur when instantiating a <xref:System.Type> object based on the `clsid` argument.</span></span> <span data-ttu-id="60a97-3058">Tenga en cuenta que si no se produce ninguna excepción `clsid` no se encuentra en el registro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3058">Note that no exception is thrown if `clsid` is not found in the registry.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3059">En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar un tipo COM que representa la aplicación Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="60a97-3059">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="60a97-3060">A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3060">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid1.cs#1)]
 [!code-vb[System.Type.GetTypeFromCLSID#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60a97-3061">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3061">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="60a97-3062">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3062">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="60a97-3063">Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3063">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="60a97-3064">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="60a97-3064">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="60a97-3065">En su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3065">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="60a97-3066">Identificador CLSID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3066">The CLSID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-3067"><see langword="true" /> para producir cualquier excepción que se genere.</span><span class="sxs-lookup"><span data-stu-id="60a97-3067"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="60a97-3068">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3068">-or-</span></span> 
 <span data-ttu-id="60a97-3069"><see langword="false" /> para pasar por alto cualquier excepción que se produzca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3069"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="60a97-3070">Obtiene el tipo asociado al identificador de clase (CLSID) especificado, que debe indicar si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3070">Gets the type associated with the specified class identifier (CLSID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3071"><see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3071"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3072">El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3072">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="60a97-3073">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3073">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="60a97-3074">Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3074">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="60a97-3075">Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.</span><span class="sxs-lookup"><span data-stu-id="60a97-3075">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="60a97-3076">Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</span><span class="sxs-lookup"><span data-stu-id="60a97-3076">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="60a97-3077">Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3077">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="60a97-3078">Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3078">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="60a97-3079">Vea el ejemplo para ver una ilustración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3079">See the example for an illustration.</span></span>  
  
 <span data-ttu-id="60a97-3080">Las excepciones, como <xref:System.OutOfMemoryException> se producirá cuando se especifica `true` para `throwOnError`, pero no se producirá para anular el Registro CLSID.</span><span class="sxs-lookup"><span data-stu-id="60a97-3080">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3081">En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar un tipo COM que representa la aplicación Microsoft Word.</span><span class="sxs-lookup"><span data-stu-id="60a97-3081">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application.</span></span> <span data-ttu-id="60a97-3082">A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3082">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="60a97-3083">Se produce una excepción si se produce un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3083">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex2.cs#2)]
 [!code-vb[System.Type.GetTypeFromCLSID#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex2.vb#2)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60a97-3084">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3084">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="60a97-3085">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3085">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="60a97-3086">Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3086">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="60a97-3087">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="60a97-3087">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="60a97-3088">En su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3088">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="60a97-3089">Identificador CLSID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3089">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="60a97-3090">Servidor desde el que se va a cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3090">The server from which to load the type.</span></span> <span data-ttu-id="60a97-3091">Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</span><span class="sxs-lookup"><span data-stu-id="60a97-3091">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="60a97-3092">Obtiene el tipo asociado al identificador de clase (CLSID) especificado desde el servidor especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3092">Gets the type associated with the specified class identifier (CLSID) from the specified server.</span></span></summary>
        <returns><span data-ttu-id="60a97-3093"><see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3093"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3094">El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3094">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="60a97-3095">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3095">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="60a97-3096">Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3096">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="60a97-3097">Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.</span><span class="sxs-lookup"><span data-stu-id="60a97-3097">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="60a97-3098">Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</span><span class="sxs-lookup"><span data-stu-id="60a97-3098">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="60a97-3099">Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3099">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="60a97-3100">Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3100">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3101">En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="60a97-3101">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="60a97-3102">A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3102">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex3.cs#3)]
 [!code-vb[System.Type.GetTypeFromCLSID#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex3.vb#3)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60a97-3103">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3103">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="60a97-3104">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3104">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="60a97-3105">Aunque el método devuelve un <see cref="T:System.Type" /> objetos del objeto que se corresponde con el GUID de .NET Framework, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3105">Although the method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for .NET Framework objects, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="60a97-3106">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="60a97-3106">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="60a97-3107">En su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3107">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromCLSID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromCLSID (Guid clsid, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromCLSID(valuetype System.Guid clsid, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromCLSID (clsid As Guid, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromCLSID(Guid clsid, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromCLSID : Guid * string * bool -&gt; Type" Usage="System.Type.GetTypeFromCLSID (clsid, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="clsid" Type="System.Guid" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="clsid"><span data-ttu-id="60a97-3108">Identificador CLSID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3108">The CLSID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="60a97-3109">Servidor desde el que se va a cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3109">The server from which to load the type.</span></span> <span data-ttu-id="60a97-3110">Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</span><span class="sxs-lookup"><span data-stu-id="60a97-3110">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-3111"><see langword="true" /> para producir cualquier excepción que se genere.</span><span class="sxs-lookup"><span data-stu-id="60a97-3111"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="60a97-3112">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3112">-or-</span></span> 
 <span data-ttu-id="60a97-3113"><see langword="false" /> para pasar por alto cualquier excepción que se produzca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3113"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="60a97-3114">Obtiene el tipo asociado al identificador de clase (CLSID) indicado desde el servidor especificado y debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3114">Gets the type associated with the specified class identifier (CLSID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3115"><see langword="System.__ComObject" /> independientemente de que CLSID sea válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3115"><see langword="System.__ComObject" /> regardless of whether the CLSID is valid.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3116">El <xref:System.Type.GetTypeFromCLSID%2A> método admite acceso enlazado en tiempo de ejecución a objetos COM no administrados de aplicaciones de .NET Framework cuando se conoce el identificador de clase del objeto COM (CLSID).</span><span class="sxs-lookup"><span data-stu-id="60a97-3116">The <xref:System.Type.GetTypeFromCLSID%2A> method supports late-bound access to unmanaged COM objects from .NET Framework apps when you know the COM object's class identifier (CLSID).</span></span>  <span data-ttu-id="60a97-3117">El identificador de clase para las clases COM se define en la clave HKEY_CLASSES_ROOT\CLSID del registro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3117">The class identifier for COM classes is defined in the HKEY_CLASSES_ROOT\CLSID key of the registry.</span></span> <span data-ttu-id="60a97-3118">Puede recuperar el valor de la <xref:System.Type.IsCOMObject%2A> propiedad para determinar si el tipo devuelto por este método es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3118">You can retrieve the value of the <xref:System.Type.IsCOMObject%2A> property to determine whether the type returned by this method is a COM object.</span></span>  
  
> [!TIP]
>  <span data-ttu-id="60a97-3119">Puede llamar a la <xref:System.Type.GetTypeFromProgID%2A> método para el acceso en tiempo de ejecución a COM objetos cuyo identificador de programación (ProgID) sabe.</span><span class="sxs-lookup"><span data-stu-id="60a97-3119">You can call the <xref:System.Type.GetTypeFromProgID%2A> method for late-bound access to COM objects whose programmatic identifier (ProgID) you know.</span></span>  
  
 <span data-ttu-id="60a97-3120">Crear una instancia de un objeto COM no administrado desde su CLSID es un proceso de dos pasos:</span><span class="sxs-lookup"><span data-stu-id="60a97-3120">Instantiating an unmanaged COM object from its CLSID is a two-step process:</span></span>  
  
1.  <span data-ttu-id="60a97-3121">Obtener un <xref:System.Type> objeto que representa el `__ComObject` que corresponde al CLSID mediante una llamada a la <xref:System.Type.GetTypeFromCLSID%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3121">Get a <xref:System.Type> object that represents the `__ComObject` that corresponds to the CLSID by calling the <xref:System.Type.GetTypeFromCLSID%2A> method.</span></span>  
  
2.  <span data-ttu-id="60a97-3122">Llame a la <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> método para crear una instancia del objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3122">Call the <xref:System.Activator.CreateInstance%28System.Type%29?displayProperty=nameWithType> method to instantiate the COM object.</span></span>  
  
 <span data-ttu-id="60a97-3123">Las excepciones, como <xref:System.OutOfMemoryException> se producirá cuando se especifica `true` para `throwOnError`, pero no se producirá para anular el Registro CLSID.</span><span class="sxs-lookup"><span data-stu-id="60a97-3123">Exceptions such as <xref:System.OutOfMemoryException> will be thrown when specifying `true` for `throwOnError`, but it will not fail for unregistered CLSIDs.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3124">En el ejemplo siguiente se usa el CLSID de Microsoft Word [objeto Application](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) para recuperar un tipo COM que representa la aplicación Microsoft Word desde un servidor llamado computer17.central.contoso.com.</span><span class="sxs-lookup"><span data-stu-id="60a97-3124">The following example uses the CLSID of the Microsoft Word [Application object](https://msdn.microsoft.com/vba/word-vba/articles/application-object-word) to retrieve a COM type that represents the Microsoft Word application from a server named computer17.central.contoso.com.</span></span> <span data-ttu-id="60a97-3125">A continuación, crea una instancia del tipo mediante una llamada a la <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> método y se cierra mediante una llamada a la [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3125">It then instantiates the type by calling the <xref:System.Activator.CreateInstance%2A?displayProperty=nameWithType> method, and closes it by calling the [Application.Quit](https://msdn.microsoft.com/VBA/Word-VBA/articles/application-quit-method-word) method.</span></span> <span data-ttu-id="60a97-3126">Se produce una excepción si se produce un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3126">An exception is thrown if an error occurs while loading the type.</span></span>  
  
 [!code-csharp[System.Type.GetTypeFromCLSID#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid_ex4.cs#4)]
 [!code-vb[System.Type.GetTypeFromCLSID#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid_ex4.vb#4)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="60a97-3127">Este método está pensado para su uso cuando se trabaja con objetos COM, no con objetos de .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3127">This method is intended for use when working with COM objects, not with .NET Framework objects.</span></span> <span data-ttu-id="60a97-3128">Todos los objetos administrados, los que son visibles para COM incluidos (es decir, sus <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> atributo es <see langword="true" />) tiene un GUID que es devuelto por la <see cref="P:System.Type.GUID" /> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3128">All managed objects, including those that are visible to COM (that is, their <see cref="T:System.Runtime.InteropServices.ComVisibleAttribute" /> attribute is <see langword="true" />) have a GUID that is returned by the <see cref="P:System.Type.GUID" /> property.</span></span> <span data-ttu-id="60a97-3129">Aunque el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> método devuelve un <see cref="T:System.Type" /> objeto que se corresponde con el GUID de un objeto administrado determinado, no puede usar dicha <see cref="T:System.Type" /> objeto va a crear una instancia de tipo mediante una llamada a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> método, como en el ejemplo siguiente se muestra.</span><span class="sxs-lookup"><span data-stu-id="60a97-3129">Although the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> method returns a <see cref="T:System.Type" /> object that corresponds to the GUID for a particular managed object, you can't use that <see cref="T:System.Type" /> object to create a type instance by calling the  <see cref="M:System.Activator.CreateInstance(System.Type)" /> method, as the following example shows.</span></span>  
  
<span data-ttu-id="60a97-3130">[! código csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [! código vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span><span class="sxs-lookup"><span data-stu-id="60a97-3130">[!code-csharp[System.Type.GetTypeFromCLSID#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.gettypefromclsid/cs/gettypefromclsid11.cs#11)] [!code-vb[System.Type.GetTypeFromCLSID#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.gettypefromclsid/vb/gettypefromclsid11.vb#11)]</span></span> 
<span data-ttu-id="60a97-3131">En su lugar, el <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> solo debe usarse para recuperar el GUID de un objeto COM no administrado y resultante <see cref="T:System.Type" /> objeto que se pasa a la <see cref="M:System.Activator.CreateInstance(System.Type)" /> el método debe representar un objeto COM no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3131">Instead, the <see cref="M:System.Type.GetTypeFromCLSID(System.Guid,System.String,System.Boolean)" /> should only be used to retrieve the GUID of an unmanaged COM object, and the resulting <see cref="T:System.Type" /> object that is passed to the <see cref="M:System.Activator.CreateInstance(System.Type)" /> method must represent an unmanaged COM object.</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromHandle">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromHandle (RuntimeTypeHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromHandle(valuetype System.RuntimeTypeHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromHandle (handle As RuntimeTypeHandle) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromHandle(RuntimeTypeHandle handle);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromHandle : RuntimeTypeHandle -&gt; Type" Usage="System.Type.GetTypeFromHandle handle" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="handle" Type="System.RuntimeTypeHandle" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="60a97-3132">Objeto que hace referencia al tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3132">The object that refers to the type.</span></span></param>
        <summary><span data-ttu-id="60a97-3133">Obtiene el tipo al que hace referencia el identificador de tipos especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3133">Gets the type referenced by the specified type handle.</span></span></summary>
        <returns><span data-ttu-id="60a97-3134">El tipo al que hace referencia el <see cref="T:System.RuntimeTypeHandle" /> especificado o <see langword="null" /> si la propiedad <see cref="P:System.RuntimeTypeHandle.Value" /> de <paramref name="handle" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3134">The type referenced by the specified <see cref="T:System.RuntimeTypeHandle" />, or <see langword="null" /> if the <see cref="P:System.RuntimeTypeHandle.Value" /> property of <paramref name="handle" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3135">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</span><span class="sxs-lookup"><span data-stu-id="60a97-3135">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3136">En el ejemplo siguiente se usa el <xref:System.Type.GetTypeFromHandle%2A> método para obtener un <xref:System.Type> objeto desde un <xref:System.RuntimeTypeHandle> proporcionada por el <xref:System.Type.GetTypeHandle%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3136">The following example uses the <xref:System.Type.GetTypeFromHandle%2A> method to get a <xref:System.Type> object from a <xref:System.RuntimeTypeHandle> provided by the <xref:System.Type.GetTypeHandle%2A> method.</span></span>  
  
 [!code-cpp[Type_GetTypeFromHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromHandle/CPP/type_gettypefromhandle.cpp#1)]
 [!code-csharp[Type_GetTypeFromHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromHandle/CS/type_gettypefromhandle.cs#1)]
 [!code-vb[Type_GetTypeFromHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromHandle/VB/type_gettypefromhandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-3137">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-3137">A class initializer is invoked and throws an exception.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetTypeFromProgID">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-3138">Obtiene el tipo asociado al identificador de programa (ProgID) especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3138">Gets the type associated with the specified program identifier (ProgID).</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string -&gt; Type" Usage="System.Type.GetTypeFromProgID progID" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="60a97-3139">ProgID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3139">The ProgID of the type to get.</span></span></param>
        <summary><span data-ttu-id="60a97-3140">Obtiene el tipo asociado al identificador de programa (ProgID) especificado y devuelve null si se produce un error al cargar <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3140">Gets the type associated with the specified program identifier (ProgID), returning null if an error is encountered while loading the <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-3141">Tipo asociado al ProgID especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3141">The type associated with the specified ProgID, if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3142">Este método se proporciona para la compatibilidad con COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3142">This method is provided for COM support.</span></span> <span data-ttu-id="60a97-3143">ProgID no se utilizan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-3143">ProgIDs are not used in the Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3144">El valor de <paramref name="progID" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3144"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="60a97-3145">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="60a97-3145">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="60a97-3146">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3146">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="60a97-3147">ProgID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3147">The ProgID of the type to get.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-3148"><see langword="true" /> para producir cualquier excepción que se genere.</span><span class="sxs-lookup"><span data-stu-id="60a97-3148"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="60a97-3149">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3149">-or-</span></span> 
 <span data-ttu-id="60a97-3150"><see langword="false" /> para pasar por alto cualquier excepción que se produzca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3150"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="60a97-3151">Obtiene el tipo asociado al identificador de programa (ProgID) especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3151">Gets the type associated with the specified program identifier (ProgID), specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3152">Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3152">The type associated with the specified program identifier (ProgID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3153">Este método se proporciona para la compatibilidad con COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3153">This method is provided for COM support.</span></span> <span data-ttu-id="60a97-3154">Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-3154">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3155">El ejemplo siguiente recupera un tipo pasando un ProgID, especificando si se debe producir una excepción si el ProgID es válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3155">The following example retrieves a type by passing a ProgID, specifying whether to throw an exception if the ProgID is invalid.</span></span> <span data-ttu-id="60a97-3156">El ejemplo muestra a continuación, el ClassID relacionados con el ProgID, junto con cualquier mensaje de excepción aplicable.</span><span class="sxs-lookup"><span data-stu-id="60a97-3156">The example then displays the ClassID related to the ProgID, along with any applicable exception message.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID2#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CPP/type_gettypefromprogid2.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID2#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID2/CS/type_gettypefromprogid2.cs#1)]
 [!code-vb[Type_GetTypeFromProgID2#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID2/VB/type_gettypefromprogid2.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3157">El valor de <paramref name="progID" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3157"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="60a97-3158">El ProgID especificado no está registrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3158">The specified ProgID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="60a97-3159">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="60a97-3159">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="60a97-3160">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3160">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="60a97-3161">ProgID del tipo que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3161">The progID of the type to get.</span></span></param>
        <param name="server"><span data-ttu-id="60a97-3162">Servidor desde el que se va a cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3162">The server from which to load the type.</span></span> <span data-ttu-id="60a97-3163">Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</span><span class="sxs-lookup"><span data-stu-id="60a97-3163">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <summary><span data-ttu-id="60a97-3164">Obtiene el tipo asociado al identificador de programa (ProgID) especificado desde el servidor especificado y devuelve null si se produce un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3164">Gets the type associated with the specified program identifier (progID) from the specified server, returning null if an error is encountered while loading the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3165">Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3165">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3166">Este método se proporciona para la compatibilidad con COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3166">This method is provided for COM support.</span></span> <span data-ttu-id="60a97-3167">Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-3167">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3168">El ejemplo siguiente recupera un tipo pasando un ProgID y nombre de servidor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3168">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="60a97-3169">En el ejemplo, a continuación, muestra el ClassID relacionado con el ProgID o produce una excepción si el ProgID o el nombre del servidor no es válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3169">The example then displays the ClassID related to the ProgID, or throws an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID3#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CPP/Type_GetTypeFromProgID3.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID3#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID3/CS/type_gettypefromprogid3.cs#1)]
 [!code-vb[Type_GetTypeFromProgID3#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID3/VB/type_gettypefromprogid3.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3170">El valor de <paramref name="prodID" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3170"><paramref name="prodID" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="60a97-3171">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="60a97-3171">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="60a97-3172">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3172">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeFromProgID">
      <MemberSignature Language="C#" Value="public static Type GetTypeFromProgID (string progID, string server, bool throwOnError);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type GetTypeFromProgID(string progID, string server, bool throwOnError) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeFromProgID(System.String,System.String,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeFromProgID (progID As String, server As String, throwOnError As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ GetTypeFromProgID(System::String ^ progID, System::String ^ server, bool throwOnError);" />
      <MemberSignature Language="F#" Value="static member GetTypeFromProgID : string * string * bool -&gt; Type" Usage="System.Type.GetTypeFromProgID (progID, server, throwOnError)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="progID" Type="System.String" />
        <Parameter Name="server" Type="System.String" />
        <Parameter Name="throwOnError" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="progID"><span data-ttu-id="60a97-3173">Identificador de programa (ProgID) del <see cref="T:System.Type" /> que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-3173">The progID of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="server"><span data-ttu-id="60a97-3174">Servidor desde el que se va a cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3174">The server from which to load the type.</span></span> <span data-ttu-id="60a97-3175">Si el nombre de servidor es <see langword="null" />, el resultado que el método devuelve automáticamente es el equipo local.</span><span class="sxs-lookup"><span data-stu-id="60a97-3175">If the server name is <see langword="null" />, this method automatically reverts to the local machine.</span></span></param>
        <param name="throwOnError"><span data-ttu-id="60a97-3176"><see langword="true" /> para producir cualquier excepción que se genere.</span><span class="sxs-lookup"><span data-stu-id="60a97-3176"><see langword="true" /> to throw any exception that occurs.</span></span>  
  
<span data-ttu-id="60a97-3177">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3177">-or-</span></span> 
 <span data-ttu-id="60a97-3178"><see langword="false" /> para pasar por alto cualquier excepción que se produzca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3178"><see langword="false" /> to ignore any exception that occurs.</span></span></param>
        <summary><span data-ttu-id="60a97-3179">Obtiene el tipo asociado al identificador de programa (ProgID) indicado desde el servidor especificado; debe indicarse si se producirá una excepción en caso de que se produzca un error al cargar el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3179">Gets the type associated with the specified program identifier (progID) from the specified server, specifying whether to throw an exception if an error occurs while loading the type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3180">Tipo asociado al identificador de programa (ProgID) especificado si <paramref name="progID" /> es una entrada de Registro válida y tiene un tipo asociado; en caso contrario, <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3180">The type associated with the specified program identifier (progID), if <paramref name="progID" /> is a valid entry in the registry and a type is associated with it; otherwise, <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3181">Este método se proporciona para la compatibilidad con COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3181">This method is provided for COM support.</span></span> <span data-ttu-id="60a97-3182">Los identificadores del programa no se usan en Microsoft .NET Framework porque se han sustituido por el concepto de espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-3182">Program IDs are not used in Microsoft .NET Framework because they have been superseded by the concept of namespace.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3183">El ejemplo siguiente recupera un tipo pasando un ProgID y nombre de servidor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3183">The following example retrieves a type by passing a ProgID and server name.</span></span> <span data-ttu-id="60a97-3184">El ejemplo muestra a continuación, el ClassID relacionados con el ProgID, especificando si se debe producir una excepción si el ProgID o el nombre del servidor no es válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3184">The example then displays the ClassID related to the ProgID, specifying whether to throw an exception if the ProgID or the server name is invalid.</span></span>  
  
 [!code-cpp[Type_GetTypeFromProgID4#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CPP/Type_GetTypeFromProgID4.cpp#1)]
 [!code-csharp[Type_GetTypeFromProgID4#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeFromProgID4/CS/type_gettypefromprogid4.cs#1)]
 [!code-vb[Type_GetTypeFromProgID4#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeFromProgID4/VB/type_gettypefromprogid4.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3185">El valor de <paramref name="progID" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3185"><paramref name="progID" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Runtime.InteropServices.COMException"><span data-ttu-id="60a97-3186">El ProgID especificado no está registrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3186">The specified progID is not registered.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="60a97-3187">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="60a97-3187">Requires full trust for the immediate caller.</span></span> <span data-ttu-id="60a97-3188">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3188">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="M:System.Runtime.InteropServices.RegistrationServices.GetProgIdForType(System.Type)" />
        <altmember cref="T:System.TypeLoadException" />
      </Docs>
    </Member>
    <Member MemberName="GetTypeHandle">
      <MemberSignature Language="C#" Value="public static RuntimeTypeHandle GetTypeHandle (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.RuntimeTypeHandle GetTypeHandle(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.GetTypeHandle(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTypeHandle (o As Object) As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static RuntimeTypeHandle GetTypeHandle(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="static member GetTypeHandle : obj -&gt; RuntimeTypeHandle" Usage="System.Type.GetTypeHandle o" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="60a97-3189">Objeto para el que se va a obtener el identificador Type.</span><span class="sxs-lookup"><span data-stu-id="60a97-3189">The object for which to get the type handle.</span></span></param>
        <summary><span data-ttu-id="60a97-3190">Obtiene el identificador para la clase <see cref="T:System.Type" /> de un objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3190">Gets the handle for the <see cref="T:System.Type" /> of a specified object.</span></span></summary>
        <returns><span data-ttu-id="60a97-3191">Identificador para la clase <see cref="T:System.Type" /> del objeto <see cref="T:System.Object" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3191">The handle for the <see cref="T:System.Type" /> of the specified <see cref="T:System.Object" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3192">Los identificadores son válidos únicamente en el dominio de aplicación en el que se obtuvieron.</span><span class="sxs-lookup"><span data-stu-id="60a97-3192">The handles are valid only in the application domain in which they were obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3193">En el ejemplo siguiente se define la clase `MyClass1`, obtiene una instancia de él y recupera el identificador de ejecución del objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-3193">The following example defines the class `MyClass1`, gets an instance of it, and retrieves the runtime handle of the object.</span></span>  
  
 [!code-cpp[Type_GetTypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_GetTypeHandle/CPP/Type_GetTypeHandle.cpp#1)]
 [!code-csharp[Type_GetTypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_GetTypeHandle/CS/type_gettypehandle.cs#1)]
 [!code-vb[Type_GetTypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_GetTypeHandle/VB/type_gettypehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3194">El valor de <paramref name="o" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3194"><paramref name="o" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="P:System.Type.TypeHandle" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="GUID">
      <MemberSignature Language="C#" Value="public abstract Guid GUID { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Guid GUID" />
      <MemberSignature Language="DocId" Value="P:System.Type.GUID" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property GUID As Guid" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Guid GUID { Guid get(); };" />
      <MemberSignature Language="F#" Value="member this.GUID : Guid" Usage="System.Type.GUID" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.GUID</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Guid</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3195">Obtiene el GUID asociado al objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3195">Gets the GUID associated with the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-3196">GUID asociado al objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3196">The GUID associated with the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3197">Un GUID está asociado a un tipo mediante el <xref:System.Runtime.InteropServices.GuidAttribute> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3197">A GUID is associated with a type using the <xref:System.Runtime.InteropServices.GuidAttribute> attribute.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3198">En el ejemplo siguiente se crea la clase `MyClass1` con un método público, se crea un `Type` objeto correspondiente a `MyClass1`y obtiene el <xref:System.Guid> estructura mediante la `GUID` propiedad de la `Type` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3198">The following example creates the class `MyClass1` with a public method, creates a `Type` object corresponding to `MyClass1`, and gets the <xref:System.Guid> structure using the `GUID` property of the `Type` class.</span></span>  
  
 [!code-cpp[Type_Guid#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_Guid/CPP/type_guid.cpp#1)]
 [!code-csharp[Type_Guid#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_Guid/CS/type_guid.cs#1)]
 [!code-vb[Type_Guid#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_Guid/VB/type_guid.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Guid" />
      </Docs>
    </Member>
    <Member MemberName="HasElementType">
      <MemberSignature Language="C#" Value="public bool HasElementType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasElementType" />
      <MemberSignature Language="DocId" Value="P:System.Type.HasElementType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasElementType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasElementType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasElementType : bool" Usage="System.Type.HasElementType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.HasElementType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3199">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual engloba o hace referencia a otro tipo; es decir, si el objeto <see cref="T:System.Type" /> actual es una matriz o un puntero, o si se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3199">Gets a value indicating whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <value><span data-ttu-id="60a97-3200">Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3200"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3201">Por ejemplo, Type.GetType("Int32[]"). HasElementType devuelve `true`, pero Type.GetType("Int32"). HasElementType devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3201">For example, Type.GetType("Int32[]").HasElementType returns `true`, but Type.GetType("Int32").HasElementType returns `false`.</span></span> <span data-ttu-id="60a97-3202">También devuelve HasElementType `true` para "Int32 \*" y "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="60a97-3202">HasElementType also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
 <span data-ttu-id="60a97-3203">Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3203">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3204">El ejemplo siguiente devuelve `true` o `false` dependiendo de si el objeto es una matriz, un tipo de referencia o un puntero.</span><span class="sxs-lookup"><span data-stu-id="60a97-3204">The following example returns `true` or `false` depending on whether or not the object is an array, a reference type, or a pointer.</span></span>  
  
 [!code-cpp[Type_HasElementType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementType/CPP/type_haselementtype.cpp#1)]
 [!code-csharp[Type_HasElementType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementType/CS/type_haselementtype.cs#1)]
 [!code-vb[Type_HasElementType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementType/VB/type_haselementtype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.HasElementTypeImpl" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <Member MemberName="HasElementTypeImpl">
      <MemberSignature Language="C#" Value="protected abstract bool HasElementTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool HasElementTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.HasElementTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function HasElementTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool HasElementTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member HasElementTypeImpl : unit -&gt; bool" Usage="type.HasElementTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3205">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.HasElementType" /> y determina si el objeto <see cref="T:System.Type" /> actual engloba a otro tipo o hace referencia a él; es decir, si el objeto <see cref="T:System.Type" /> actual es una matriz o un puntero, o se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3205">When overridden in a derived class, implements the <see cref="P:System.Type.HasElementType" /> property and determines whether the current <see cref="T:System.Type" /> encompasses or refers to another type; that is, whether the current <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="60a97-3206">Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz o un puntero, o si se pasa por referencia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3206"><see langword="true" /> if the <see cref="T:System.Type" /> is an array, a pointer, or is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3207">Por ejemplo, Type.GetType("Int32[]"). HasElementTypeImpl devuelve `true`, pero Type.GetType("Int32"). HasElementTypeImpl devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3207">For example, Type.GetType("Int32[]").HasElementTypeImpl returns `true`, but Type.GetType("Int32").HasElementTypeImpl returns `false`.</span></span> <span data-ttu-id="60a97-3208">También devuelve HasElementTypeImpl `true` para "Int32 \*" y "Int32 &".</span><span class="sxs-lookup"><span data-stu-id="60a97-3208">HasElementTypeImpl also returns `true` for "Int32\*" and "Int32&".</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3209">En el ejemplo siguiente se define la clase `MyTypeDelegator`, lo que invalida el `HasElementTypeImpl` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3209">The following example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="60a97-3210">La clase principal que se busca el `HasElementType` propiedad y muestra el elemento de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3210">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.HasElementType" />
        <altmember cref="P:System.Type.IsArray" />
        <altmember cref="P:System.Type.IsPointer" />
        <altmember cref="P:System.Type.IsByRef" />
        <altmember cref="M:System.Type.GetElementType" />
        <altmember cref="M:System.Type.GetType" />
      </Docs>
    </Member>
    <MemberGroup MemberName="InvokeMember">
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-3211">Invoca a un miembro específico del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3211">Invokes a specific member of the current <see cref="T:System.Type" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-3212">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3212">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="60a97-3213">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3213">-or-</span></span> 
<span data-ttu-id="60a97-3214">Cadena vacía ("") para llamar al miembro predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3214">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="60a97-3215">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3215">-or-</span></span> 
<span data-ttu-id="60a97-3216">Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3216">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="60a97-3217">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3217">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="60a97-3218">El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span><span class="sxs-lookup"><span data-stu-id="60a97-3218">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="60a97-3219">No es necesario especificar el tipo de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3219">The type of lookup need not be specified.</span></span> <span data-ttu-id="60a97-3220">Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3220">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-3221">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-3221">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-3222">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3222">-or-</span></span> 
<span data-ttu-id="60a97-3223">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3223">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="60a97-3224">Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</span><span class="sxs-lookup"><span data-stu-id="60a97-3224">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="60a97-3225">Objeto donde debe invocarse al miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3225">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="60a97-3226">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3226">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <summary><span data-ttu-id="60a97-3227">Invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y compara la lista de argumentos indicada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3227">Invokes the specified member, using the specified binding constraints and matching the specified argument list.</span></span></summary>
        <returns><span data-ttu-id="60a97-3228">Objeto que representa el valor devuelto del miembro invocado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3228">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3229">No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3229">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="60a97-3230">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3230">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-3231">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3231">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3232">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, los miembros privados y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3232">Specify `BindingFlags.NonPublic` to include non-public members (that is, private and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3233">Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.</span><span class="sxs-lookup"><span data-stu-id="60a97-3233">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="60a97-3234">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3234">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-3235">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3235">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-3236">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3236">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-3237">La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:</span><span class="sxs-lookup"><span data-stu-id="60a97-3237">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="60a97-3238">`CreateInstance` para invocar un constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3238">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="60a97-3239">`name` se omite.</span><span class="sxs-lookup"><span data-stu-id="60a97-3239">`name` is ignored.</span></span> <span data-ttu-id="60a97-3240">No es válido con otros indicadores de invocación.</span><span class="sxs-lookup"><span data-stu-id="60a97-3240">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="60a97-3241">`InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3241">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="60a97-3242">No es válido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3242">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="60a97-3243">Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3243">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="60a97-3244">`GetField` Para obtener el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3244">`GetField` to get the value of a field.</span></span> <span data-ttu-id="60a97-3245">No es válido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3245">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3246">`SetField` Para establecer el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3246">`SetField` to set the value of a field.</span></span> <span data-ttu-id="60a97-3247">No es válido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3247">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3248">`GetProperty` Para obtener una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3248">`GetProperty` to get a property.</span></span> <span data-ttu-id="60a97-3249">No es válido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3249">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="60a97-3250">`SetProperty` Para establecer una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3250">`SetProperty` to set a property.</span></span> <span data-ttu-id="60a97-3251">No es válido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3251">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="60a97-3252">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-3252">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-3253">Un método se invocará si se cumplen las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-3253">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="60a97-3254">El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).</span><span class="sxs-lookup"><span data-stu-id="60a97-3254">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="60a97-3255">El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3255">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="60a97-3256">El enlazador encontrará todos los métodos de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3256">The binder will find all of the matching methods.</span></span> <span data-ttu-id="60a97-3257">Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="60a97-3257">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="60a97-3258">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</span><span class="sxs-lookup"><span data-stu-id="60a97-3258">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="60a97-3259">Después de selecciona el método, se invoca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3259">After the method is selected, it is invoked.</span></span> <span data-ttu-id="60a97-3260">En ese momento se comprueba la accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3260">Accessibility is checked at that point.</span></span> <span data-ttu-id="60a97-3261">La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3261">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="60a97-3262">El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3262">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="60a97-3263">El enlazador predeterminado, selecciona a la coincidencia más específica.</span><span class="sxs-lookup"><span data-stu-id="60a97-3263">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="60a97-3264">Se omiten las restricciones de acceso para el código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden se puede obtener acceso y se invoca a través de <xref:System.Reflection> cada vez que el código es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-3264">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="60a97-3265">Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3265">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60a97-3266">Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String`, puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3266">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"});`  
  
 <span data-ttu-id="60a97-3267">Si F es un `String[]`, puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3267">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}});`  
  
 <span data-ttu-id="60a97-3268">responsable de inicializar el campo F en esta nueva matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3268">which will initialize the field F to this new array.</span></span> <span data-ttu-id="60a97-3269">También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-3269">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"});`  
  
 <span data-ttu-id="60a97-3270">Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</span><span class="sxs-lookup"><span data-stu-id="60a97-3270">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="60a97-3271">Cuando se invoca un `IDispatch` miembros, puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3271">When you invoke an `IDispatch` member, you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="60a97-3272">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="60a97-3272">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="60a97-3273">Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-3273">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="60a97-3274">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3274">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3275">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella.</span><span class="sxs-lookup"><span data-stu-id="60a97-3275">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="60a97-3276">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="60a97-3276">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="60a97-3277">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="60a97-3277">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3278">En el ejemplo siguiente se usa `InvokeMember` acceder a los miembros de un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3278">The following example uses `InvokeMember` to access members of a type.</span></span>  
  
 [!code-cpp[InvokeMem#1](~/samples/snippets/cpp/VS_Snippets_CLR/InvokeMem/CPP/invokemem.cpp#1)]
 [!code-csharp[InvokeMem#1](~/samples/snippets/csharp/VS_Snippets_CLR/InvokeMem/CS/invokemem.cs#1)]
 [!code-vb[InvokeMem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/InvokeMem/VB/invokemem.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3279"><paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3279"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3280"><paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3280"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="60a97-3281">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3281">-or-</span></span> 
 <span data-ttu-id="60a97-3282"><paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3282"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3283">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3283">-or-</span></span> 
 <span data-ttu-id="60a97-3284"><paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3284"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3285">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3285">-or-</span></span> 
 <span data-ttu-id="60a97-3286"><paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3286"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="60a97-3287">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3287">-or-</span></span> 
 <span data-ttu-id="60a97-3288"><paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3288"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3289">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3289">-or-</span></span> 
 <span data-ttu-id="60a97-3290"><paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3290"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3291">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3291">-or-</span></span> 
 <span data-ttu-id="60a97-3292"><paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.</span><span class="sxs-lookup"><span data-stu-id="60a97-3292"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="60a97-3293">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3293">-or-</span></span> 
<span data-ttu-id="60a97-3294">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3294">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3295">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3295">-or-</span></span> 
<span data-ttu-id="60a97-3296">Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3296">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="60a97-3297">El miembro especificado es un inicializador de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3297">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="60a97-3298">No se encuentran el campo o la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3298">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="60a97-3299">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3299">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="60a97-3300">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3300">-or-</span></span> 
<span data-ttu-id="60a97-3301">El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3301">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="60a97-3302">No se puede invocar al miembro especificado en <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3302">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-3303">Más de un método coincide con los criterios de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-3303">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-3304">.NET Compact Framework no admite actualmente este método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3304">The .NET Compact Framework does not currently support this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-3305">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3305">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="60a97-3306">Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3306">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="60a97-3307">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3307">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="60a97-3308">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3308">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="60a97-3309">para llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3309">to call unmanaged code.</span></span> <span data-ttu-id="60a97-3310">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3310">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Globalization.CultureInfo culture);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, class System.Globalization.CultureInfo culture) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, System::Globalization::CultureInfo ^ culture);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj&#xA;override this.InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Globalization.CultureInfo -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, culture)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Globalization.CultureInfo)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Diagnostics.DebuggerStepThrough</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-3311">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3311">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="60a97-3312">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3312">-or-</span></span> 
<span data-ttu-id="60a97-3313">Cadena vacía ("") para llamar al miembro predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3313">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="60a97-3314">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3314">-or-</span></span> 
<span data-ttu-id="60a97-3315">Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3315">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="60a97-3316">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3316">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="60a97-3317">El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span><span class="sxs-lookup"><span data-stu-id="60a97-3317">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="60a97-3318">No es necesario especificar el tipo de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3318">The type of lookup need not be specified.</span></span> <span data-ttu-id="60a97-3319">Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3319">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-3320">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-3320">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-3321">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3321">-or-</span></span> 
<span data-ttu-id="60a97-3322">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3322">A null reference (<see langword="Nothing" /> in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="60a97-3323">Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</span><span class="sxs-lookup"><span data-stu-id="60a97-3323">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="60a97-3324">Objeto donde debe invocarse al miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3324">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="60a97-3325">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3325">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="culture"><span data-ttu-id="60a97-3326">Objeto que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico <see cref="T:System.String" /> a <see cref="T:System.Double" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3326">The object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric <see cref="T:System.String" /> to a <see cref="T:System.Double" />.</span></span>  
  
<span data-ttu-id="60a97-3327">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3327">-or-</span></span> 
<span data-ttu-id="60a97-3328">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar el <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3328">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <summary><span data-ttu-id="60a97-3329">Invoca al miembro especificado, aplica las restricciones de enlace especificadas y compara la lista de argumentos y la referencia cultural igualmente especificadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3329">Invokes the specified member, using the specified binding constraints and matching the specified argument list and culture.</span></span></summary>
        <returns><span data-ttu-id="60a97-3330">Objeto que representa el valor devuelto del miembro invocado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3330">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3331">Aunque el enlazador predeterminado no procesa <xref:System.Globalization.CultureInfo> (el `culture` parámetro), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `culture`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3331">Although the default binder does not process <xref:System.Globalization.CultureInfo> (the `culture` parameter), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `culture`.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3332">No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3332">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="60a97-3333">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3333">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-3334">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3334">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3335">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3335">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3336">Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.</span><span class="sxs-lookup"><span data-stu-id="60a97-3336">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="60a97-3337">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3337">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-3338">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3338">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-3339">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3339">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-3340">La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:</span><span class="sxs-lookup"><span data-stu-id="60a97-3340">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="60a97-3341">`CreateInstance` para invocar un constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3341">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="60a97-3342">`name` se omite.</span><span class="sxs-lookup"><span data-stu-id="60a97-3342">`name` is ignored.</span></span> <span data-ttu-id="60a97-3343">No es válido con otros indicadores de invocación.</span><span class="sxs-lookup"><span data-stu-id="60a97-3343">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="60a97-3344">`InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3344">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="60a97-3345">No es válido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3345">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="60a97-3346">Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3346">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="60a97-3347">`GetField` Para obtener el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3347">`GetField` to get the value of a field.</span></span> <span data-ttu-id="60a97-3348">No es válido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3348">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3349">`SetField` Para establecer el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3349">`SetField` to set the value of a field.</span></span> <span data-ttu-id="60a97-3350">No es válido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3350">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3351">`GetProperty` Para obtener una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3351">`GetProperty` to get a property.</span></span> <span data-ttu-id="60a97-3352">No es válido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3352">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="60a97-3353">`SetProperty` Para establecer una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3353">`SetProperty` to set a property.</span></span> <span data-ttu-id="60a97-3354">No es válido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3354">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="60a97-3355">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-3355">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-3356">Un método se invocará si se cumplen las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-3356">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="60a97-3357">El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).</span><span class="sxs-lookup"><span data-stu-id="60a97-3357">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="60a97-3358">El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3358">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="60a97-3359">El enlazador encontrará todos los métodos de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3359">The binder will find all of the matching methods.</span></span> <span data-ttu-id="60a97-3360">Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="60a97-3360">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="60a97-3361">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</span><span class="sxs-lookup"><span data-stu-id="60a97-3361">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="60a97-3362">Después de selecciona el método, se invoca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3362">After the method is selected, it is invoked.</span></span> <span data-ttu-id="60a97-3363">En ese momento se comprueba la accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3363">Accessibility is checked at that point.</span></span> <span data-ttu-id="60a97-3364">La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3364">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="60a97-3365">El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3365">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="60a97-3366">El enlazador predeterminado, selecciona a la coincidencia más específica.</span><span class="sxs-lookup"><span data-stu-id="60a97-3366">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="60a97-3367">Se omiten las restricciones de acceso para el código de plena confianza; es decir, propiedades, métodos, campos y constructores privados pueden tener acceso a y se invocan mediante reflexión siempre que el código es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-3367">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through Reflection whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="60a97-3368">Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3368">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60a97-3369">Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String` puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3369">For example, if you want to set a public instance field named F on class C, and F is a `String` you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null);`  
  
 <span data-ttu-id="60a97-3370">Si F es un `String[]`, puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3370">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null);`  
  
 <span data-ttu-id="60a97-3371">responsable de inicializar el campo F en esta nueva matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3371">which will initialize the field F to this new array.</span></span> <span data-ttu-id="60a97-3372">También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-3372">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null);`  
  
 <span data-ttu-id="60a97-3373">Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</span><span class="sxs-lookup"><span data-stu-id="60a97-3373">This will change string "z" in the array that F holds to string "b".</span></span>  
  
 <span data-ttu-id="60a97-3374">Cuando se invoca un `IDispatch` miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3374">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="60a97-3375">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="60a97-3375">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="60a97-3376">Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-3376">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="60a97-3377">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3377">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3378">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella.</span><span class="sxs-lookup"><span data-stu-id="60a97-3378">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="60a97-3379">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="60a97-3379">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="60a97-3380">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="60a97-3380">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3381"><paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3381"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3382"><paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3382"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="60a97-3383">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3383">-or-</span></span> 
 <span data-ttu-id="60a97-3384"><paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3384"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3385">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3385">-or-</span></span> 
 <span data-ttu-id="60a97-3386"><paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3386"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3387">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3387">-or-</span></span> 
 <span data-ttu-id="60a97-3388"><paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3388"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="60a97-3389">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3389">-or-</span></span> 
 <span data-ttu-id="60a97-3390"><paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3390"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3391">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3391">-or-</span></span> 
 <span data-ttu-id="60a97-3392"><paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3392"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3393">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3393">-or-</span></span> 
 <span data-ttu-id="60a97-3394"><paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.</span><span class="sxs-lookup"><span data-stu-id="60a97-3394"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="60a97-3395">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3395">-or-</span></span> 
<span data-ttu-id="60a97-3396">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3396">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3397">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3397">-or-</span></span> 
<span data-ttu-id="60a97-3398">Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3398">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="60a97-3399">El miembro especificado es un inicializador de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3399">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="60a97-3400">No se encuentran el campo o la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3400">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="60a97-3401">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3401">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="60a97-3402">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3402">-or-</span></span> 
<span data-ttu-id="60a97-3403">El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3403">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="60a97-3404">No se puede invocar al miembro especificado en <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3404">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-3405">Más de un método coincide con los criterios de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-3405">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-3406">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3406">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="60a97-3407">Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3407">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="60a97-3408">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3408">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="60a97-3409">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3409">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="60a97-3410">para llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3410">to call unmanaged code.</span></span> <span data-ttu-id="60a97-3411">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3411">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="InvokeMember">
      <MemberSignature Language="C#" Value="public abstract object InvokeMember (string name, System.Reflection.BindingFlags invokeAttr, System.Reflection.Binder binder, object target, object[] args, System.Reflection.ParameterModifier[] modifiers, System.Globalization.CultureInfo culture, string[] namedParameters);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object InvokeMember(string name, valuetype System.Reflection.BindingFlags invokeAttr, class System.Reflection.Binder binder, object target, object[] args, valuetype System.Reflection.ParameterModifier[] modifiers, class System.Globalization.CultureInfo culture, string[] namedParameters) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Object ^ InvokeMember(System::String ^ name, System::Reflection::BindingFlags invokeAttr, System::Reflection::Binder ^ binder, System::Object ^ target, cli::array &lt;System::Object ^&gt; ^ args, cli::array &lt;System::Reflection::ParameterModifier&gt; ^ modifiers, System::Globalization::CultureInfo ^ culture, cli::array &lt;System::String ^&gt; ^ namedParameters);" />
      <MemberSignature Language="F#" Value="abstract member InvokeMember : string * System.Reflection.BindingFlags * System.Reflection.Binder * obj * obj[] * System.Reflection.ParameterModifier[] * System.Globalization.CultureInfo * string[] -&gt; obj" Usage="type.InvokeMember (name, invokeAttr, binder, target, args, modifiers, culture, namedParameters)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
        <InterfaceMember>M:System.Reflection.IReflect.InvokeMember(System.String,System.Reflection.BindingFlags,System.Reflection.Binder,System.Object,System.Object[],System.Reflection.ParameterModifier[],System.Globalization.CultureInfo,System.String[])</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="invokeAttr" Type="System.Reflection.BindingFlags" />
        <Parameter Name="binder" Type="System.Reflection.Binder" />
        <Parameter Name="target" Type="System.Object" />
        <Parameter Name="args" Type="System.Object[]" />
        <Parameter Name="modifiers" Type="System.Reflection.ParameterModifier[]" />
        <Parameter Name="culture" Type="System.Globalization.CultureInfo" />
        <Parameter Name="namedParameters" Type="System.String[]" />
      </Parameters>
      <Docs>
        <param name="name"><span data-ttu-id="60a97-3412">Cadena que contiene el nombre del constructor, el método, la propiedad o el miembro de campo al que se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3412">The string containing the name of the constructor, method, property, or field member to invoke.</span></span>  
  
<span data-ttu-id="60a97-3413">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3413">-or-</span></span> 
<span data-ttu-id="60a97-3414">Cadena vacía ("") para llamar al miembro predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3414">An empty string ("") to invoke the default member.</span></span>  
  
<span data-ttu-id="60a97-3415">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3415">-or-</span></span> 
<span data-ttu-id="60a97-3416">Para los miembros de <see langword="IDispatch" />, cadena que representa el identificador DispID, por ejemplo "[DispID=3]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3416">For <see langword="IDispatch" /> members, a string representing the DispID, for example "[DispID=3]".</span></span></param>
        <param name="invokeAttr"><span data-ttu-id="60a97-3417">Máscara de bits formada por una o varias enumeraciones <see cref="T:System.Reflection.BindingFlags" /> que especifican la forma en que se realiza la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3417">A bitmask comprised of one or more <see cref="T:System.Reflection.BindingFlags" /> that specify how the search is conducted.</span></span> <span data-ttu-id="60a97-3418">El acceso puede corresponder a uno de los marcadores <see langword="BindingFlags" />, como <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, etc.</span><span class="sxs-lookup"><span data-stu-id="60a97-3418">The access can be one of the <see langword="BindingFlags" /> such as <see langword="Public" />, <see langword="NonPublic" />, <see langword="Private" />, <see langword="InvokeMethod" />, <see langword="GetField" />, and so on.</span></span> <span data-ttu-id="60a97-3419">No es necesario especificar el tipo de búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3419">The type of lookup need not be specified.</span></span> <span data-ttu-id="60a97-3420">Si se omite el tipo de búsqueda, se usan <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3420">If the type of lookup is omitted, <see langword="BindingFlags.Public" /> | <see langword="BindingFlags.Instance" /> | <see langword="BindingFlags.Static" /> are used.</span></span></param>
        <param name="binder"><span data-ttu-id="60a97-3421">Objeto que define un conjunto de propiedades y permite realizar operaciones de enlace, que pueden incluir la selección de un método sobrecargado, la coerción de tipos de argumentos y la invocación de un miembro mediante reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-3421">An object that defines a set of properties and enables binding, which can involve selection of an overloaded method, coercion of argument types, and invocation of a member through reflection.</span></span>  
  
<span data-ttu-id="60a97-3422">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3422">-or-</span></span> 
<span data-ttu-id="60a97-3423">Referencia nula (Nothing en Visual Basic) para usar la propiedad <see cref="P:System.Type.DefaultBinder" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3423">A null reference (Nothing in Visual Basic), to use the <see cref="P:System.Type.DefaultBinder" />.</span></span> <span data-ttu-id="60a97-3424">Observe que la definición explícita de un objeto <see cref="T:System.Reflection.Binder" /> puede resultar necesaria para llamar correctamente a sobrecargas de método con argumentos variables.</span><span class="sxs-lookup"><span data-stu-id="60a97-3424">Note that explicitly defining a <see cref="T:System.Reflection.Binder" /> object may be required for successfully invoking method overloads with variable arguments.</span></span></param>
        <param name="target"><span data-ttu-id="60a97-3425">Objeto donde debe invocarse al miembro especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3425">The object on which to invoke the specified member.</span></span></param>
        <param name="args"><span data-ttu-id="60a97-3426">Matriz que contiene los argumentos que se van a pasar al miembro al cual se va a invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3426">An array containing the arguments to pass to the member to invoke.</span></span></param>
        <param name="modifiers"><span data-ttu-id="60a97-3427">Matriz de objetos <see cref="T:System.Reflection.ParameterModifier" /> que representan los atributos asociados al elemento correspondiente de la matriz <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3427">An array of <see cref="T:System.Reflection.ParameterModifier" /> objects representing the attributes associated with the corresponding element in the <paramref name="args" /> array.</span></span> <span data-ttu-id="60a97-3428">Los atributos asociados a un parámetro se almacenan en la firma del miembro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3428">A parameter's associated attributes are stored in the member's signature.</span></span>  
  
<span data-ttu-id="60a97-3429">El enlazador predeterminado solo procesa este parámetro cuando se llama a un componente COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3429">The default binder processes this parameter only when calling a COM component.</span></span></param>
        <param name="culture"><span data-ttu-id="60a97-3430">Objeto <see cref="T:System.Globalization.CultureInfo" /> que representa la configuración regional de globalización que se va a usar, que puede ser necesaria para las conversiones específicas de la configuración regional, como pasar un tipo numérico String a Double.</span><span class="sxs-lookup"><span data-stu-id="60a97-3430">The <see cref="T:System.Globalization.CultureInfo" /> object representing the globalization locale to use, which may be necessary for locale-specific conversions, such as converting a numeric String to a Double.</span></span>  
  
<span data-ttu-id="60a97-3431">o bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3431">-or-</span></span> 
<span data-ttu-id="60a97-3432">Referencia nula (<see langword="Nothing" /> en Visual Basic) para usar el <see cref="T:System.Globalization.CultureInfo" /> del subproceso actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3432">A null reference (<see langword="Nothing" /> in Visual Basic) to use the current thread's <see cref="T:System.Globalization.CultureInfo" />.</span></span></param>
        <param name="namedParameters"><span data-ttu-id="60a97-3433">Matriz que contiene los nombres de los parámetros a los que se pasan los valores de la matriz <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3433">An array containing the names of the parameters to which the values in the <paramref name="args" /> array are passed.</span></span></param>
        <summary><span data-ttu-id="60a97-3434">Cuando se invalida en una clase derivada, invoca al miembro especificado, aplica las restricciones de enlace igualmente especificadas y realiza una comparación con la lista de argumentos, los modificadores y la referencia cultural indicados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3434">When overridden in a derived class, invokes the specified member, using the specified binding constraints and matching the specified argument list, modifiers and culture.</span></span></summary>
        <returns><span data-ttu-id="60a97-3435">Objeto que representa el valor devuelto del miembro invocado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3435">An object representing the return value of the invoked member.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3436">`InvokeMember` llama a un miembro de constructor o método, obtiene o establece a un miembro de propiedad, obtiene o establece a un miembro de campo de datos, u Obtiene o establece un elemento de un miembro de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3436">`InvokeMember` calls a constructor member or a method member, gets or sets a property member, gets or sets a data field member, or gets or sets an element of an array member.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3437">No puede usar <xref:System.Type.InvokeMember%2A> para invocar un método genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3437">You cannot use <xref:System.Type.InvokeMember%2A> to invoke a generic method.</span></span>  
  
 <span data-ttu-id="60a97-3438">Cuando se invoca un `IDispatch` miembro puede especificar el identificador DispID en lugar del nombre de miembro, con el formato de cadena "[DispID = ##]".</span><span class="sxs-lookup"><span data-stu-id="60a97-3438">When you invoke an `IDispatch` member you can specify the DispID instead of the member name, using the string format "[DispID=##]".</span></span> <span data-ttu-id="60a97-3439">Por ejemplo, si el identificador DispID de MyComMethod es 3, puede especificar la cadena "[DispID = 3]" en lugar de "MyComMethod".</span><span class="sxs-lookup"><span data-stu-id="60a97-3439">For example, if the DispID of MyComMethod is 3, you can specify the string "[DispID=3]" instead of "MyComMethod".</span></span> <span data-ttu-id="60a97-3440">Invocar a un miembro por DispID es más rápido que buscar el miembro por su nombre.</span><span class="sxs-lookup"><span data-stu-id="60a97-3440">Invoking a member by DispID is faster than looking up the member by name.</span></span> <span data-ttu-id="60a97-3441">En escenarios de agregación compleja, el identificador DispID a veces es la única manera de invocar al miembro deseado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3441">In complex aggregation scenarios, the DispID is sometimes the only way to invoke the desired member.</span></span>  
  
 <span data-ttu-id="60a97-3442">Aunque el enlazador predeterminado no procesa <xref:System.Reflection.ParameterModifier> o <xref:System.Globalization.CultureInfo> (el `modifiers` y `culture` parámetros), puede utilizar la abstracta <xref:System.Reflection.Binder?displayProperty=nameWithType> clase para escribir un enlazador personalizado que procesan `modifiers` y `culture`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3442">Although the default binder does not process <xref:System.Reflection.ParameterModifier> or <xref:System.Globalization.CultureInfo> (the `modifiers` and `culture` parameters), you can use the abstract <xref:System.Reflection.Binder?displayProperty=nameWithType> class to write a custom binder that does process `modifiers` and `culture`.</span></span> <span data-ttu-id="60a97-3443">`ParameterModifier` solo se usa cuando se llama mediante la interoperabilidad COM, y se administran solo los parámetros que se pasan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3443">`ParameterModifier` is only used when calling through COM interop, and only parameters that are passed by reference are handled.</span></span>  
  
 <span data-ttu-id="60a97-3444">Cada parámetro de la matriz `namedParameters` obtiene el valor del elemento correspondiente en la matriz `args`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3444">Each parameter in the `namedParameters` array gets the value in the corresponding element in the `args` array.</span></span> <span data-ttu-id="60a97-3445">Si la longitud de `args` es mayor que la longitud de `namedParameters`, los valores de argumento restantes se pasan por orden.</span><span class="sxs-lookup"><span data-stu-id="60a97-3445">If the length of `args` is greater than the length of `namedParameters`, the remaining argument values are passed in order.</span></span>  
  
 <span data-ttu-id="60a97-3446">El `namedParameters` matriz puede usarse para cambiar el orden de los argumentos en una matriz de entrada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3446">The `namedParameters` array can be used to change the order of arguments in an input array.</span></span> <span data-ttu-id="60a97-3447">Por ejemplo, dado el método `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` en Visual Basic) y la matriz de entrada `{ 42, "x" }`, se puede pasar sin cambios a la matriz de entrada `args` si la matriz `{ "b", "a" }` proporcionado para `namedParameters`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3447">For example, given the method `M(string a, int b)` (`M(ByVal a As String, ByVal b As Integer)` in Visual Basic) and the input array `{ 42, "x" }`, the input array can be passed unchanged to `args` if the array `{ "b", "a" }` is supplied for `namedParameters`.</span></span>  
  
 <span data-ttu-id="60a97-3448">La siguiente <xref:System.Reflection.BindingFlags> las marcas de filtro pueden utilizarse para definir los miembros que se va a incluir en la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3448">The following <xref:System.Reflection.BindingFlags> filter flags can be used to define which members to include in the search:</span></span>  
  
-   <span data-ttu-id="60a97-3449">Especificar `BindingFlags.Public` para incluir los miembros públicos en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3449">Specify `BindingFlags.Public` to include public members in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3450">Especificar `BindingFlags.NonPublic` para incluir los miembros no públicos (es decir, miembros privados, internos y protegidos) en la búsqueda.</span><span class="sxs-lookup"><span data-stu-id="60a97-3450">Specify `BindingFlags.NonPublic` to include non-public members (that is, private, internal, and protected members) in the search.</span></span>  
  
-   <span data-ttu-id="60a97-3451">Especificar `BindingFlags.FlattenHierarchy` para incluir miembros estáticos en la jerarquía.</span><span class="sxs-lookup"><span data-stu-id="60a97-3451">Specify `BindingFlags.FlattenHierarchy` to include static members up the hierarchy.</span></span>  
  
 <span data-ttu-id="60a97-3452">La siguiente <xref:System.Reflection.BindingFlags> cualquier marcador modificador que puede utilizarse para cambiar el funcionamiento de la búsqueda:</span><span class="sxs-lookup"><span data-stu-id="60a97-3452">The following <xref:System.Reflection.BindingFlags> modifier flags can be used to change how the search works:</span></span>  
  
-   <span data-ttu-id="60a97-3453">`BindingFlags.IgnoreCase` para omitir la grafía de `name`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3453">`BindingFlags.IgnoreCase` to ignore the case of `name`.</span></span>  
  
-   <span data-ttu-id="60a97-3454">`BindingFlags.DeclaredOnly` para buscar solo los miembros declarados en el <xref:System.Type>, no los miembros que simplemente se han heredado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3454">`BindingFlags.DeclaredOnly` to search only the members declared on the <xref:System.Type>, not members that were simply inherited.</span></span>  
  
 <span data-ttu-id="60a97-3455">La siguiente <xref:System.Reflection.BindingFlags> indicadores de invocación pueden utilizarse para denotar la acción que realizará con el miembro:</span><span class="sxs-lookup"><span data-stu-id="60a97-3455">The following <xref:System.Reflection.BindingFlags> invocation flags can be used to denote what action to take with the member:</span></span>  
  
-   <span data-ttu-id="60a97-3456">`CreateInstance` para invocar un constructor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3456">`CreateInstance` to invoke a constructor.</span></span> <span data-ttu-id="60a97-3457">`name` se omite.</span><span class="sxs-lookup"><span data-stu-id="60a97-3457">`name` is ignored.</span></span> <span data-ttu-id="60a97-3458">No es válido con otros indicadores de invocación.</span><span class="sxs-lookup"><span data-stu-id="60a97-3458">Not valid with other invocation flags.</span></span>  
  
-   <span data-ttu-id="60a97-3459">`InvokeMethod` para invocar un método, pero no un constructor o un inicializador de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3459">`InvokeMethod` to invoke a method, but not a constructor or a type initializer.</span></span> <span data-ttu-id="60a97-3460">No es válido con `SetField` o `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3460">Not valid with `SetField` or `SetProperty`.</span></span> <span data-ttu-id="60a97-3461">Si `InvokeMethod` se especifica por sí mismo, `BindingFlags.Public`, `BindingFlags.Instance`, y `BindingFlags.Static` se incluyen automáticamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3461">If `InvokeMethod` is specified by itself, `BindingFlags.Public`, `BindingFlags.Instance`, and `BindingFlags.Static` are automatically included.</span></span>  
  
-   <span data-ttu-id="60a97-3462">`GetField` Para obtener el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3462">`GetField` to get the value of a field.</span></span> <span data-ttu-id="60a97-3463">No es válido con `SetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3463">Not valid with `SetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3464">`SetField` Para establecer el valor de un campo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3464">`SetField` to set the value of a field.</span></span> <span data-ttu-id="60a97-3465">No es válido con `GetField`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3465">Not valid with `GetField`.</span></span>  
  
-   <span data-ttu-id="60a97-3466">`GetProperty` Para obtener una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3466">`GetProperty` to get a property.</span></span> <span data-ttu-id="60a97-3467">No es válido con `SetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3467">Not valid with `SetProperty`.</span></span>  
  
-   <span data-ttu-id="60a97-3468">`SetProperty` Para establecer una propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3468">`SetProperty` to set a property.</span></span> <span data-ttu-id="60a97-3469">No es válido con `GetProperty`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3469">Not valid with `GetProperty`.</span></span>  
  
 <span data-ttu-id="60a97-3470">Vea <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> para obtener más información.</span><span class="sxs-lookup"><span data-stu-id="60a97-3470">See <xref:System.Reflection.BindingFlags?displayProperty=nameWithType> for more information.</span></span>  
  
 <span data-ttu-id="60a97-3471">Un método se invocará si se cumplen las condiciones siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-3471">A method will be invoked if both of the following conditions are true:</span></span>  
  
-   <span data-ttu-id="60a97-3472">El número de parámetros en la declaración del método es igual al número de argumentos de la `args` matriz (a menos que los argumentos predeterminados se definen en el miembro y `BindingFlags.OptionalParamBinding` se especifica).</span><span class="sxs-lookup"><span data-stu-id="60a97-3472">The number of parameters in the method declaration equals the number of arguments in the `args` array (unless default arguments are defined on the member and `BindingFlags.OptionalParamBinding` is specified).</span></span>  
  
-   <span data-ttu-id="60a97-3473">El tipo de cada argumento se puede convertir el enlazador para el tipo del parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-3473">The type of each argument can be converted by the binder to the type of the parameter.</span></span>  
  
 <span data-ttu-id="60a97-3474">El enlazador encontrará todos los métodos de coincidencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3474">The binder will find all of the matching methods.</span></span> <span data-ttu-id="60a97-3475">Estos métodos se encuentran en función del tipo de enlace solicitado (<xref:System.Reflection.BindingFlags> valores `InvokeMethod`, `GetProperty`, y así sucesivamente).</span><span class="sxs-lookup"><span data-stu-id="60a97-3475">These methods are found based upon the type of binding requested (<xref:System.Reflection.BindingFlags> values `InvokeMethod`, `GetProperty`, and so on).</span></span> <span data-ttu-id="60a97-3476">El conjunto de métodos se filtra por el nombre, número de argumentos y un conjunto de modificadores de búsqueda definidos en el enlazador.</span><span class="sxs-lookup"><span data-stu-id="60a97-3476">The set of methods is filtered by the name, number of arguments, and a set of search modifiers defined in the binder.</span></span>  
  
 <span data-ttu-id="60a97-3477">Después de selecciona el método, se invoca.</span><span class="sxs-lookup"><span data-stu-id="60a97-3477">After the method is selected, it is invoked.</span></span> <span data-ttu-id="60a97-3478">En ese momento se comprueba la accesibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3478">Accessibility is checked at that point.</span></span> <span data-ttu-id="60a97-3479">La búsqueda puede controlar qué conjunto de métodos se buscan en función del atributo de accesibilidad asociado al método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3479">The search may control which set of methods are searched based upon the accessibility attribute associated with the method.</span></span> <span data-ttu-id="60a97-3480">El <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> método de la <xref:System.Reflection.Binder> clase es responsable de seleccionar el método que se debe invocar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3480">The <xref:System.Reflection.Binder.BindToMethod%2A?displayProperty=nameWithType> method of the <xref:System.Reflection.Binder> class is responsible for selecting the method to be invoked.</span></span> <span data-ttu-id="60a97-3481">El enlazador predeterminado, selecciona a la coincidencia más específica.</span><span class="sxs-lookup"><span data-stu-id="60a97-3481">The default binder selects the most specific match.</span></span>  
  
 <span data-ttu-id="60a97-3482">`InvokeMember` puede usarse para invocar métodos con parámetros que tienen valores predeterminados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3482">`InvokeMember` can be used to invoke methods with parameters that have default values.</span></span> <span data-ttu-id="60a97-3483">Para enlazar a estos métodos, Reflection requiere <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> especificarse.</span><span class="sxs-lookup"><span data-stu-id="60a97-3483">To bind to these methods, Reflection requires <xref:System.Reflection.BindingFlags.OptionalParamBinding?displayProperty=nameWithType> to be specified.</span></span> <span data-ttu-id="60a97-3484">Para un parámetro que tiene un valor predeterminado, puede proporcionar un valor distinto o proporcionar <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> para usar el valor predeterminado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3484">For a parameter that has a default value, you can either supply a different value, or supply <xref:System.Reflection.Missing.Value?displayProperty=nameWithType> to use the default value.</span></span>  
  
 <span data-ttu-id="60a97-3485">Por ejemplo, considere la posibilidad de un método como MyMethod (int x, float y = 2.0).</span><span class="sxs-lookup"><span data-stu-id="60a97-3485">For example, consider a method such as MyMethod(int x, float y = 2.0).</span></span> <span data-ttu-id="60a97-3486">Para invocar este método solamente con el primer argumento como MyMethod (4), pasar uno de los marcadores de enlace anterior y dos argumentos, es decir, 4 para el primer argumento y `Missing.Value` para el segundo argumento.</span><span class="sxs-lookup"><span data-stu-id="60a97-3486">To invoke this method with only the first argument as MyMethod(4), pass one of the above binding flags and pass two arguments, namely, 4 for the first argument and `Missing.Value` for the second argument.</span></span> <span data-ttu-id="60a97-3487">A menos que use `Missing.Value`, no se puede omitir los parámetros opcionales con la `Invoke` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3487">Unless you use `Missing.Value`, you may not omit optional parameters with the `Invoke` method.</span></span> <span data-ttu-id="60a97-3488">Si debe hacerlo, use `InvokeMember` en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3488">If you must do so, use `InvokeMember` instead.</span></span>  
  
 <span data-ttu-id="60a97-3489">Se omiten las restricciones de acceso para el código de plena confianza; es decir, constructores privados, métodos, campos y propiedades pueden se puede obtener acceso y se invoca a través de <xref:System.Reflection> cada vez que el código es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-3489">Access restrictions are ignored for fully trusted code; that is, private constructors, methods, fields, and properties can be accessed and invoked through <xref:System.Reflection> whenever the code is fully trusted.</span></span>  
  
 <span data-ttu-id="60a97-3490">Puede usar `Type.InvokeMember` para establecer un campo en un valor determinado mediante la especificación de <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3490">You can use `Type.InvokeMember` to set a field to a particular value by specifying <xref:System.Reflection.BindingFlags.SetField?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60a97-3491">Por ejemplo, si desea establecer un campo de instancia público llamado F en la clase C y F es un `String`, puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3491">For example, if you want to set a public instance field named F on class C, and F is a `String`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {"strings new value"}, null, null, null);`  
  
 <span data-ttu-id="60a97-3492">Si F es un `String[]`, puede usar código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3492">If F is a `String[]`, you can use code such as:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {new String[]{"a","z","c","d"}}, null, null, null);`  
  
 <span data-ttu-id="60a97-3493">responsable de inicializar el campo F en esta nueva matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3493">which will initialize the field F to this new array.</span></span> <span data-ttu-id="60a97-3494">También puede usar `Type.InvokeMember` para establecer una posición en una matriz proporcionando el índice del valor y, a continuación, en el siguiente valor utilizando código similar al siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-3494">You can also use `Type.InvokeMember` to set a position in an array by supplying the index of the value and then the next value by using code such as the following:</span></span>  
  
 `typeof(C).InvokeMember("F", BindingFlags.SetField, null, c, new Object[] {1, "b"}, null, null, null);`  
  
 <span data-ttu-id="60a97-3495">Esta operación cambiará la cadena "z" en la matriz que contiene F a la cadena "b".</span><span class="sxs-lookup"><span data-stu-id="60a97-3495">This will change string "z" in the array that F holds to string "b".</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3496">A partir de la [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], este método puede utilizarse para tener acceso a miembros no públicos, si el llamador tiene concedidos <xref:System.Security.Permissions.ReflectionPermission> con el <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> marca y si el conjunto de permisos de los miembros no públicos se restringe al llamador conceder el conjunto o un subconjunto en ella.</span><span class="sxs-lookup"><span data-stu-id="60a97-3496">Starting with the [!INCLUDE[net_v20sp1_long](~/includes/net-v20sp1-long-md.md)], this method can be used to access non-public members if the caller has been granted <xref:System.Security.Permissions.ReflectionPermission> with the <xref:System.Security.Permissions.ReflectionPermissionFlag.RestrictedMemberAccess?displayProperty=nameWithType> flag and if the grant set of the non-public members is restricted to the caller's grant set, or a subset thereof.</span></span> <span data-ttu-id="60a97-3497">(Consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span><span class="sxs-lookup"><span data-stu-id="60a97-3497">(See [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).)</span></span>  
>   
>  <span data-ttu-id="60a97-3498">Para utilizar esta funcionalidad, la aplicación debe utilizar [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] o posterior como destino.</span><span class="sxs-lookup"><span data-stu-id="60a97-3498">To use this functionality, your application should target the [!INCLUDE[net_v35_long](~/includes/net-v35-long-md.md)] or later.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3499"><paramref name="invokeAttr" /> no contiene <see langword="CreateInstance" /> y <paramref name="name" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3499"><paramref name="invokeAttr" /> does not contain <see langword="CreateInstance" /> and <paramref name="name" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3500"><paramref name="args" /> y <paramref name="modifiers" /> no tienen la misma longitud.</span><span class="sxs-lookup"><span data-stu-id="60a97-3500"><paramref name="args" /> and <paramref name="modifiers" /> do not have the same length.</span></span>  
  
<span data-ttu-id="60a97-3501">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3501">-or-</span></span> 
 <span data-ttu-id="60a97-3502"><paramref name="invokeAttr" /> no es un atributo <see cref="T:System.Reflection.BindingFlags" /> válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3502"><paramref name="invokeAttr" /> is not a valid <see cref="T:System.Reflection.BindingFlags" /> attribute.</span></span>  
  
<span data-ttu-id="60a97-3503">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3503">-or-</span></span> 
 <span data-ttu-id="60a97-3504"><paramref name="invokeAttr" /> no contiene una de las siguientes marcas de enlace:  <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3504"><paramref name="invokeAttr" /> does not contain one of the following binding flags: <see langword="InvokeMethod" />, <see langword="CreateInstance" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3505">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3505">-or-</span></span> 
 <span data-ttu-id="60a97-3506"><paramref name="invokeAttr" /> contiene <see langword="CreateInstance" /> combinado con <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3506"><paramref name="invokeAttr" /> contains <see langword="CreateInstance" /> combined with <see langword="InvokeMethod" />, <see langword="GetField" />, <see langword="SetField" />, <see langword="GetProperty" />, or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3507">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3507">-or-</span></span> 
 <span data-ttu-id="60a97-3508"><paramref name="invokeAttr" /> contiene tanto <see langword="GetField" /> como <see langword="SetField" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3508"><paramref name="invokeAttr" /> contains both <see langword="GetField" /> and <see langword="SetField" />.</span></span>  
  
<span data-ttu-id="60a97-3509">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3509">-or-</span></span> 
 <span data-ttu-id="60a97-3510"><paramref name="invokeAttr" /> contiene tanto <see langword="GetProperty" /> como <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3510"><paramref name="invokeAttr" /> contains both <see langword="GetProperty" /> and <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3511">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3511">-or-</span></span> 
 <span data-ttu-id="60a97-3512"><paramref name="invokeAttr" /> contiene <see langword="InvokeMethod" /> combinado con <see langword="SetField" /> o <see langword="SetProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3512"><paramref name="invokeAttr" /> contains <see langword="InvokeMethod" /> combined with <see langword="SetField" /> or <see langword="SetProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3513">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3513">-or-</span></span> 
 <span data-ttu-id="60a97-3514"><paramref name="invokeAttr" /> contiene <see langword="SetField" /> y <paramref name="args" /> tiene más de un elemento.</span><span class="sxs-lookup"><span data-stu-id="60a97-3514"><paramref name="invokeAttr" /> contains <see langword="SetField" /> and <paramref name="args" /> has more than one element.</span></span>  
  
<span data-ttu-id="60a97-3515">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3515">-or-</span></span> 
<span data-ttu-id="60a97-3516">La matriz de parámetros con nombre es mayor que la matriz de argumentos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3516">The named parameter array is larger than the argument array.</span></span>  
  
<span data-ttu-id="60a97-3517">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3517">-or-</span></span> 
<span data-ttu-id="60a97-3518">Se llama a este método en un objeto COM pero no se pasa una de las siguientes marcas de enlace: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" /> o <see langword="BindingFlags.PutRefDispProperty" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3518">This method is called on a COM object and one of the following binding flags was not passed in: <see langword="BindingFlags.InvokeMethod" />, <see langword="BindingFlags.GetProperty" />, <see langword="BindingFlags.SetProperty" />, <see langword="BindingFlags.PutDispProperty" />, or <see langword="BindingFlags.PutRefDispProperty" />.</span></span>  
  
<span data-ttu-id="60a97-3519">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3519">-or-</span></span> 
<span data-ttu-id="60a97-3520">Una de las matrices de parámetros con nombre contiene una cadena que es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3520">One of the named parameter arrays contains a string that is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.MethodAccessException"><span data-ttu-id="60a97-3521">El miembro especificado es un inicializador de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3521">The specified member is a class initializer.</span></span></exception>
        <exception cref="T:System.MissingFieldException"><span data-ttu-id="60a97-3522">No se encuentran el campo o la propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3522">The field or property cannot be found.</span></span></exception>
        <exception cref="T:System.MissingMethodException"><span data-ttu-id="60a97-3523">No se encuentra ningún método que coincida con los argumentos en <paramref name="args" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3523">No method can be found that matches the arguments in <paramref name="args" />.</span></span>  
  
<span data-ttu-id="60a97-3524">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3524">-or-</span></span> 
<span data-ttu-id="60a97-3525">No se puede encontrar ningún miembro con los nombres de argumento proporcionados en <paramref name="namedParameters" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3525">No member can be found that has the argument names supplied in <paramref name="namedParameters" />.</span></span>  
  
<span data-ttu-id="60a97-3526">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-3526">-or-</span></span> 
<span data-ttu-id="60a97-3527">El objeto <see cref="T:System.Type" /> actual representa un tipo que contiene parámetros de tipo abierto, es decir, <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3527">The current <see cref="T:System.Type" /> object represents a type that contains open type parameters, that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetException"><span data-ttu-id="60a97-3528">No se puede invocar al miembro especificado en <paramref name="target" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3528">The specified member cannot be invoked on <paramref name="target" />.</span></span></exception>
        <exception cref="T:System.Reflection.AmbiguousMatchException"><span data-ttu-id="60a97-3529">Más de un método coincide con los criterios de enlace.</span><span class="sxs-lookup"><span data-stu-id="60a97-3529">More than one method matches the binding criteria.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-3530">El método representado por <paramref name="name" /> tiene uno o más parámetros de tipo genérico no especificados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3530">The method represented by <paramref name="name" /> has one or more unspecified generic type parameters.</span></span> <span data-ttu-id="60a97-3531">Es decir, la propiedad <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> del método devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3531">That is, the method's <see cref="P:System.Reflection.MethodInfo.ContainsGenericParameters" /> property returns <see langword="true" />.</span></span></exception>
        <permission cref="T:System.Security.Permissions.ReflectionPermission"><span data-ttu-id="60a97-3532">Para obtener acceso a miembros no públicos, independientemente de su concesión establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3532">for accessing non-public members regardless of their grant set.</span></span> <span data-ttu-id="60a97-3533">Enumeración asociada: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3533">Associated enumeration: <see cref="F:System.Security.Permissions.ReflectionPermissionFlag.MemberAccess" /></span></span></permission>
        <permission cref="T:System.Security.Permissions.SecurityPermission"><span data-ttu-id="60a97-3534">para llamar a código no administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3534">to call unmanaged code.</span></span> <span data-ttu-id="60a97-3535">Enumeración asociada: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span><span class="sxs-lookup"><span data-stu-id="60a97-3535">Associated enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></span></span></permission>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.Reflection.Binder" />
        <altmember cref="P:System.Type.DefaultBinder" />
        <altmember cref="T:System.Reflection.BindingFlags" />
        <altmember cref="T:System.Reflection.ParameterModifier" />
        <altmember cref="T:System.Reflection.ParameterAttributes" />
        <altmember cref="T:System.Globalization.CultureInfo" />
        <altmember cref="T:System.Security.Permissions.ReflectionPermission" />
      </Docs>
    </Member>
    <Member MemberName="IsAbstract">
      <MemberSignature Language="C#" Value="public bool IsAbstract { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAbstract" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAbstract" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAbstract As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAbstract { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAbstract : bool" Usage="System.Type.IsAbstract" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAbstract</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3536">Obtiene un valor que indica si <see cref="T:System.Type" /> es abstracto y se debe invalidar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3536">Gets a value indicating whether the <see cref="T:System.Type" /> is abstract and must be overridden.</span></span></summary>
        <value><span data-ttu-id="60a97-3537">Es <see langword="true" /> si <see cref="T:System.Type" /> es abstracto; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3537"><see langword="true" /> if the <see cref="T:System.Type" /> is abstract; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3538">El <xref:System.Type.IsAbstract%2A> propiedad devuelve `true` en los casos siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-3538">The <xref:System.Type.IsAbstract%2A> property returns `true` in the following cases:</span></span>  
  
-   <span data-ttu-id="60a97-3539">El tipo actual es abstracto; es decir, no pueden crearse instancias, pero sólo puede actuar como clase base para las clases derivadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3539">The current type is abstract; that is, it cannot be instantiated, but can only serve as the base class for derived classes.</span></span> <span data-ttu-id="60a97-3540">En C#, clases abstractas se marcan con el [abstracta](~/docs/csharp/language-reference/keywords/abstract.md) palabra clave; en Visual Basic, se marcan con el [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) palabra clave.</span><span class="sxs-lookup"><span data-stu-id="60a97-3540">In C#, abstract classes are marked with the [abstract](~/docs/csharp/language-reference/keywords/abstract.md) keyword; in Visual Basic, they are marked with the [MustInherit](~/docs/visual-basic/language-reference/modifiers/mustinherit.md) keyword.</span></span>  
  
-   <span data-ttu-id="60a97-3541">El tipo actual es una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3541">The current type is an interface.</span></span>  
  
 <span data-ttu-id="60a97-3542">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3542">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3543">En el ejemplo siguiente se crea una matriz de <xref:System.Type> objetos que representan los siguientes tipos: contiene los valores devueltos de tipo `true` si el objeto especificado es `abstract`; en caso contrario, devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3543">The following example creates an array of <xref:System.Type> objects that represent the following types:contains type returns `true` if the specified object is `abstract`; otherwise, it returns `false`.</span></span>  
  
-   <span data-ttu-id="60a97-3544">`AbstractClass`, una clase abstracta (una clase marcada como `abstract` en C# y `MustInherit` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-3544">`AbstractClass`, an abstract class (a class marked as `abstract` in C# and `MustInherit` in Visual Basic).</span></span>  
  
-   <span data-ttu-id="60a97-3545">`DerivedClass`, una clase que hereda de `AbstractClass`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3545">`DerivedClass`, a class that inherits from `AbstractClass`.</span></span>  
  
-   <span data-ttu-id="60a97-3546">`SingleClass`, una clase no heredable.</span><span class="sxs-lookup"><span data-stu-id="60a97-3546">`SingleClass`, a non-inheritable class.</span></span> <span data-ttu-id="60a97-3547">Se define como `sealed` en C# y `NotInheritable` en Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="60a97-3547">It is defined as `sealed` in C# and `NotInheritable` in Visual Basic.</span></span>  
  
-   <span data-ttu-id="60a97-3548">`ITypeInfo`, una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3548">`ITypeInfo`, an interface.</span></span>  
  
-   <span data-ttu-id="60a97-3549">`ImplementingClass`, una clase que implementa el `ITypeInfo` interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3549">`ImplementingClass`, a class that implements the `ITypeInfo` interface.</span></span>  
  
 <span data-ttu-id="60a97-3550">El método devuelve `true` sólo para `AbstractClass`, la clase abstracta, y `ITypeInfo`, la interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3550">The method returns `true` only for `AbstractClass`, the abstract class, and `ITypeInfo`, the interface.</span></span>  
  
 [!code-csharp[System.Type.IsAbstract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isabstract/cs/isabstract1.cs#1)]
 [!code-vb[System.Type.IsAbstract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isabstract/vb/isabstract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsAnsiClass">
      <MemberSignature Language="C#" Value="public bool IsAnsiClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAnsiClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAnsiClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAnsiClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAnsiClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAnsiClass : bool" Usage="System.Type.IsAnsiClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAnsiClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3551">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="AnsiClass" /> para el objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3551">Gets a value indicating whether the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-3552">Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="AnsiClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3552"><see langword="true" /> if the string format attribute <see langword="AnsiClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3553">El <xref:System.Reflection.TypeAttributes.StringFormatMask> selecciona los atributos de formato de cadena.</span><span class="sxs-lookup"><span data-stu-id="60a97-3553">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="60a97-3554">Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3554">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="60a97-3555">Si el actual <xref:System.Type> representa un tipo genérico, esta propiedad pertenece a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3555">If the current <xref:System.Type> represents a generic type, this property pertains to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3556">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3556">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3557">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3557">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3558">En el ejemplo siguiente se obtiene la información de campo y busca el `AnsiClass` atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3558">The following example gets the field information and checks for the `AnsiClass` attribute.</span></span>  
  
 [!code-cpp[Type_IsAnsiClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAnsiClass/CPP/Type_IsAnsiClass.cpp#1)]
 [!code-csharp[Type_IsAnsiClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAnsiClass/CS/type_isansiclass.cs#1)]
 [!code-vb[Type_IsAnsiClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAnsiClass/VB/type_isansiclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsArray">
      <MemberSignature Language="C#" Value="public bool IsArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsArray" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsArray : bool" Usage="System.Type.IsArray" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsArray</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3559">Obtiene un valor que indica si el tipo es una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3559">Gets a value that indicates whether the type is an array.</span></span></summary>
        <value><span data-ttu-id="60a97-3560"><see langword="true" /> si el tipo actual es una matriz; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3560"><see langword="true" /> if the current type is an array; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3561">El <xref:System.Type.IsArray%2A> propiedad devuelve `false` para el <xref:System.Array> clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3561">The <xref:System.Type.IsArray%2A> property returns `false` for the <xref:System.Array> class.</span></span> <span data-ttu-id="60a97-3562">También devuelve `false` si la instancia actual es un <xref:System.Type> objeto que representa un tipo de colección o una interfaz que se ha diseñado para trabajar con colecciones, como <xref:System.Collections.IEnumerable> o <xref:System.Collections.Generic.IEnumerable%601>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3562">It also returns `false` if the current instance is a <xref:System.Type> object that represents a collection type or an interface designed to work with collections, such as <xref:System.Collections.IEnumerable> or <xref:System.Collections.Generic.IEnumerable%601>.</span></span>  
  
 <span data-ttu-id="60a97-3563">Para comprobar si una matriz, use código como:</span><span class="sxs-lookup"><span data-stu-id="60a97-3563">To check for an array, use code such as:</span></span>  
  
```csharp  
typeof(Array).IsAssignableFrom(type)  
```  
  
```vb  
GetType(Array).IsAssignableFrom(type)  
```  
  
 <span data-ttu-id="60a97-3564">Si el tipo actual representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3564">If the current type represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3565">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-3565">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3566">El ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.IsArray%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3566">The following example demonstrates using the <xref:System.Type.IsArray%2A> property.</span></span>  
  
 [!code-csharp[System.Type.IsArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isarray/cs/isarray2.cs#1)]
 [!code-vb[System.Type.IsArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isarray/vb/isarray2.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsArrayImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsArrayImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsArrayImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsArrayImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsArrayImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsArrayImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsArrayImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsArrayImpl : unit -&gt; bool" Usage="type.IsArrayImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3567">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsArray" /> y determina si <see cref="T:System.Type" /> es una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3567">When overridden in a derived class, implements the <see cref="P:System.Type.IsArray" /> property and determines whether the <see cref="T:System.Type" /> is an array.</span></span></summary>
        <returns><span data-ttu-id="60a97-3568">Es <see langword="true" /> si <see cref="T:System.Type" /> es una matriz; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3568"><see langword="true" /> if the <see cref="T:System.Type" /> is an array; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3569">Una instancia de la <xref:System.Array> debe devolver la clase `false` porque es un objeto, no es una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3569">An instance of the <xref:System.Array> class must return `false` because it is an object, not an array.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3570">En el ejemplo siguiente se invalida el `IsArrayImpl` método en el `MyTypeDelegator` comprueba si una variable es una matriz y muestra el resultado de la clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3570">The following example overrides the `IsArrayImpl` method in the `MyTypeDelegator` class, checks if a variable is an array, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsArrayImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsArrayImpl/CPP/type_isarrayimpl.cpp#1)]
 [!code-csharp[Type_IsArrayImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsArrayImpl/CS/type_isarrayimpl.cs#1)]
 [!code-vb[Type_IsArrayImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsArrayImpl/VB/type_isarrayimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsArray" />
      </Docs>
    </Member>
    <Member MemberName="IsAssignableFrom">
      <MemberSignature Language="C#" Value="public virtual bool IsAssignableFrom (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsAssignableFrom(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsAssignableFrom(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsAssignableFrom (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsAssignableFrom(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsAssignableFrom : Type -&gt; bool&#xA;override this.IsAssignableFrom : Type -&gt; bool" Usage="type.IsAssignableFrom c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsAssignableFrom(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="60a97-3571">Tipo que se va a comparar con el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3571">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="60a97-3572">Determina si una instancia del tipo especificado se puede asignar a una instancia del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3572">Determines whether an instance of a specified type can be assigned to an instance of the current type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3573"><see langword="true" /> si alguna de las condiciones siguientes es "true":</span><span class="sxs-lookup"><span data-stu-id="60a97-3573"><see langword="true" /> if any of the following conditions is true:</span></span> <span data-ttu-id="60a97-3574">
-   <paramref name="c" /> y la instancia actual representan el mismo tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3574">
-   <paramref name="c" /> and the current instance represent the same type.</span></span>  
  <span data-ttu-id="60a97-3575">
-   <paramref name="c" /> se deriva de forma directa o indirecta de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3575">
-   <paramref name="c" /> is derived either directly or indirectly from the current instance.</span></span> <span data-ttu-id="60a97-3576"><paramref name="c" /> se deriva directamente de la instancia actual si se hereda de la instancia actual, mientras que <paramref name="c" /> se deriva indirectamente de la instancia actual si se hereda de una sucesión de una o varias clases que se heredan de la instancia actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3576"><paramref name="c" /> is derived directly from the current instance if it inherits from the current instance; <paramref name="c" /> is derived indirectly from the current instance if it inherits from a succession of one or more classes that inherit from the current instance.</span></span>  
  
<span data-ttu-id="60a97-3577">-   La instancia actual es una interfaz que <paramref name="c" /> implementa.</span><span class="sxs-lookup"><span data-stu-id="60a97-3577">-   The current instance is an interface that <paramref name="c" /> implements.</span></span>  
  <span data-ttu-id="60a97-3578">
-   <paramref name="c" /> es un parámetro de tipo genérico y la instancia actual representa una de las restricciones de <paramref name="c" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3578">
-   <paramref name="c" /> is a generic type parameter, and the current instance represents one of the constraints of <paramref name="c" />.</span></span>  
  
<span data-ttu-id="60a97-3579">En el ejemplo siguiente, la instancia actual es un objeto <see cref="T:System.Type" /> que representa la clase <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3579">In the following example, the current instance is a <see cref="T:System.Type" /> object that represents the <see cref="T:System.IO.Stream" /> class.</span></span> <span data-ttu-id="60a97-3580"><c>GenericWithConstraint</c> es un tipo genérico cuyo parámetro de tipo genérico debe ser del tipo <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3580"><c>GenericWithConstraint</c> is a generic type whose generic type parameter must be of type    <see cref="T:System.IO.Stream" />.</span></span> <span data-ttu-id="60a97-3581">La acción de pasar su parámetro de tipo genérico a <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indica que se puede asignar una instancia del parámetro de tipo genérico a un objeto <see cref="T:System.IO.Stream" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3581">Passing its generic type parameter to the <see cref="M:System.Type.IsAssignableFrom(System.Type)" /> indicates that  an instance of the generic type parameter can be assigned to an <see cref="T:System.IO.Stream" /> object.</span></span>  
  
<span data-ttu-id="60a97-3582">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span><span class="sxs-lookup"><span data-stu-id="60a97-3582">[!code-csharp[System.Type.IsAssignableFrom#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom2.cs#2)] [!code-vb[System.Type.IsAssignableFrom#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom2.vb#2)]</span></span> <span data-ttu-id="60a97-3583">
-   <paramref name="c" /> representa un tipo de valor y la instancia actual representa <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-3583">
-   <paramref name="c" /> represents a value type, and the current instance represents <c>Nullable&lt;c&gt;</c> (<c>Nullable(Of c)</c> in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-3584">Es <see langword="false" /> si ninguna de estas condiciones son true o si <paramref name="c" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3584"><see langword="false" /> if none of these conditions are true, or if <paramref name="c" /> is <see langword="null" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3585">El <xref:System.Type.IsAssignableFrom%2A> método puede utilizarse para determinar si una instancia de `c` puede asignarse a una instancia del tipo actual, el método es muy útil cuando lo está manejando de objetos cuyos tipos no se conocen en tiempo de diseño y permite condicionales Muestra la asignación, como en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3585">The <xref:System.Type.IsAssignableFrom%2A> method can be used to determine whether an instance of `c` can be assigned to an instance of the current type, The method is most useful when you are handling objects whose types are not known at design time and allows for conditional assignment, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#3)]
 [!code-vb[System.Type.IsAssignableFrom#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#3)]  
  
 <span data-ttu-id="60a97-3586">Este método garantiza que por lo tanto, una línea de código, como los siguientes se ejecutarán en tiempo de ejecución sin producir una <xref:System.InvalidCastException> excepción o una excepción similar:</span><span class="sxs-lookup"><span data-stu-id="60a97-3586">This method thus ensures that a line of code like the following will execute at runtime without throwing an <xref:System.InvalidCastException> exception or a similar exception:</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/IsAssignableFrom3.cs#4)]
 [!code-vb[System.Type.IsAssignableFrom#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/IsAssignableFrom3.vb#4)]  
  
 <span data-ttu-id="60a97-3587">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3587">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3588">Una definición de tipo genérico no es asignable desde un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3588">A generic type definition is not assignable from a closed constructed type.</span></span> <span data-ttu-id="60a97-3589">Es decir, no se puede asignar el tipo construido cerrado `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) a una variable de tipo `MyGenericList<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3589">That is, you cannot assign the closed constructed type `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) to a variable of type `MyGenericList<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3590">Si el `c` parámetro es de tipo <xref:System.Reflection.Emit.TypeBuilder>, el resultado se basa en el tipo que se van a compilar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3590">If the `c` parameter is of type <xref:System.Reflection.Emit.TypeBuilder>, the result is based on the type that is to be built.</span></span> <span data-ttu-id="60a97-3591">El ejemplo de código siguiente muestra esto utilizando un tipo integrado denominado `B`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3591">The following code example demonstrates this using a built type named `B`.</span></span>  
  
 [!code-csharp[System.Type.IsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isassignablefrom/cs/isassignablefrom_ex1.cs#1)]
 [!code-vb[System.Type.IsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isassignablefrom/vb/isassignablefrom_ex1.vb#1)]  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3592">En el ejemplo siguiente se muestra el `IsAssignableFrom` utilizando el método definido por clases, matrices de enteros y tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3592">The following example demonstrates the `IsAssignableFrom` method using defined classes, integer arrays, and generics.</span></span>  
  
 [!code-cpp[TestIsAssignableFrom#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsAssignableFrom/cpp/testisassignablefrom.cpp#1)]
 [!code-csharp[TestIsAssignableFrom#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsAssignableFrom/CS/testisassignablefrom.cs#1)]
 [!code-vb[TestIsAssignableFrom#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsAssignableFrom/VB/testisassignablefrom.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsAutoClass">
      <MemberSignature Language="C#" Value="public bool IsAutoClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoClass : bool" Usage="System.Type.IsAutoClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3593">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="AutoClass" /> para el objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3593">Gets a value indicating whether the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-3594">Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="AutoClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3594"><see langword="true" /> if the string format attribute <see langword="AutoClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3595">El <xref:System.Reflection.TypeAttributes.StringFormatMask> selecciona los atributos de formato de cadena.</span><span class="sxs-lookup"><span data-stu-id="60a97-3595">The <xref:System.Reflection.TypeAttributes.StringFormatMask> selects the string format attributes.</span></span> <span data-ttu-id="60a97-3596">Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3596">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="60a97-3597">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3597">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3598">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3598">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3599">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3599">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsUnicodeClass" />
      </Docs>
    </Member>
    <Member MemberName="IsAutoLayout">
      <MemberSignature Language="C#" Value="public bool IsAutoLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsAutoLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsAutoLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsAutoLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsAutoLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsAutoLayout : bool" Usage="System.Type.IsAutoLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsAutoLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3600">Obtiene un valor que indica si los campos de tipo de la actual se disponen automáticamente mediante Common Language Runtime.</span><span class="sxs-lookup"><span data-stu-id="60a97-3600">Gets a value indicating whether the fields of the current type are laid out automatically by the common language runtime.</span></span></summary>
        <value><span data-ttu-id="60a97-3601"><see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3601"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.AutoLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3602">Esta propiedad se proporciona por comodidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3602">This property is provided as a convenience.</span></span> <span data-ttu-id="60a97-3603">Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> está establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3603">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="60a97-3604">El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-3604">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>,<xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="60a97-3605">Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> cuando se crea el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3605">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="60a97-3606">En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> valor de enumeración para el tipo, para permitir que el tiempo de ejecución a determinar la forma adecuada para diseñar la clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3606">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Auto?displayProperty=nameWithType> enumeration value to the type, to let the runtime determine the appropriate way to lay out the class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3607">No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3607">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="60a97-3608">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3608">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3609">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="60a97-3609">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="60a97-3610">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3610">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3611">El ejemplo siguiente se crea una instancia del tipo y muestra el <xref:System.Type.IsAutoLayout%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3611">The following example creates an instance of the type and displays the <xref:System.Type.IsAutoLayout%2A> property.</span></span>  
  
 [!code-cpp[Type_IsAutoLayout#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsAutoLayout/CPP/type_isautolayout.cpp#1)]
 [!code-csharp[Type_IsAutoLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsAutoLayout/CS/type_isautolayout.cs#1)]
 [!code-vb[Type_IsAutoLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsAutoLayout/VB/type_isautolayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="60a97-3612">Metadatos y componentes autodescriptivos</span><span class="sxs-lookup"><span data-stu-id="60a97-3612">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsByRef">
      <MemberSignature Language="C#" Value="public bool IsByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRef : bool" Usage="System.Type.IsByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3613">Obtiene un valor que indica si <see cref="T:System.Type" /> se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3613">Gets a value indicating whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <value><span data-ttu-id="60a97-3614">Es <see langword="true" /> si <see cref="T:System.Type" /> se pasa por referencia; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3614"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3615">Para obtener el tipo real, desreferenciar el tipo que se ha pasado por referencia y, a continuación, llamar a <xref:System.Type.GetElementType%2A> en ese tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3615">To get to the actual type, dereference the type that was passed by reference, and then call <xref:System.Type.GetElementType%2A> on that type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3616">En el ejemplo siguiente se muestra un uso de la `IsByRef` propiedad para comprobar si un tipo especificado se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3616">The following example demonstrates a use of the `IsByRef` property to check whether a specified type is passed by reference.</span></span> <span data-ttu-id="60a97-3617">En el ejemplo se define la clase `MyTypeDelegator`, lo que invalida el `HasElementTypeImpl` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3617">The example defines the class `MyTypeDelegator`, which overrides the `HasElementTypeImpl` method.</span></span> <span data-ttu-id="60a97-3618">La clase principal que se busca el `HasElementType` propiedad y muestra el elemento de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3618">The main class checks for the `HasElementType` property and displays the element type.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsByRefImpl : unit -&gt; bool" Usage="type.IsByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3619">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsByRef" /> y determina si <see cref="T:System.Type" /> se pasa por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3619">When overridden in a derived class, implements the <see cref="P:System.Type.IsByRef" /> property and determines whether the <see cref="T:System.Type" /> is passed by reference.</span></span></summary>
        <returns><span data-ttu-id="60a97-3620">Es <see langword="true" /> si <see cref="T:System.Type" /> se pasa por referencia; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3620"><see langword="true" /> if the <see cref="T:System.Type" /> is passed by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsByRefLike">
      <MemberSignature Language="C#" Value="public virtual bool IsByRefLike { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsByRefLike" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsByRefLike" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsByRefLike As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsByRefLike { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsByRefLike : bool" Usage="System.Type.IsByRefLike" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsClass">
      <MemberSignature Language="C#" Value="public bool IsClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsClass : bool" Usage="System.Type.IsClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3621">Obtiene un valor que indica si <see cref="T:System.Type" /> es una clase o un delegado, es decir, no es un tipo de valor ni una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3621">Gets a value indicating whether the <see cref="T:System.Type" /> is a class or a delegate; that is, not a value type or interface.</span></span></summary>
        <value><span data-ttu-id="60a97-3622">Es <see langword="true" /> si <see cref="T:System.Type" /> es una clase; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3622"><see langword="true" /> if the <see cref="T:System.Type" /> is a class; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3623">Esta propiedad devuelve `true` para clases, así como los delegados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3623">This property returns `true` for classes as well as delegates.</span></span> <span data-ttu-id="60a97-3624">Devuelve `false` para tipos de valor (para las estructuras y enumeraciones) incluso si se han convertido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3624">It returns `false` for value types (for structures and enumerations) even if they are boxed.</span></span>  
  
 <span data-ttu-id="60a97-3625">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `true`. Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve `true` si la definición de tipo genérico es una definición de clase; es decir, no define una interfaz o un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3625">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `true`.If the current <xref:System.Type> represents a constructed generic type, this property returns `true` if the generic type definition is a class definition; that is, it does not define an interface or a value type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3626">Esta propiedad devuelve `true` para `Type` instancias que representan el <xref:System.Enum> y <xref:System.ValueType> clases.</span><span class="sxs-lookup"><span data-stu-id="60a97-3626">This property returns `true` for `Type` instances that represent the <xref:System.Enum> and <xref:System.ValueType> classes.</span></span> <span data-ttu-id="60a97-3627">Estas dos clases son los tipos base para las enumeraciones y tipos de valor, respectivamente, pero no son enumeraciones o tipos de valor a sí mismos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3627">These two classes are the base types for enumerations and value types, respectively, but they are not enumerations or value types themselves.</span></span> <span data-ttu-id="60a97-3628">Para obtener más información, consulte el <xref:System.Type.IsValueType%2A> y <xref:System.Type.IsEnum%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-3628">For more information, see the <xref:System.Type.IsValueType%2A> and <xref:System.Type.IsEnum%2A> properties.</span></span>  
  
 <span data-ttu-id="60a97-3629">El <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor de enumeración distingue una declaración de tipo como clase o interfaz. Sin embargo, las clases y tipos de valor se marcan con el <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> atributo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3629">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> enumeration value  distinguishes a type declaration as class or interface.However, both classes and value types are marked with the <xref:System.Reflection.TypeAttributes.Class?displayProperty=nameWithType> attribute.</span></span> <span data-ttu-id="60a97-3630">Si recupera el valor de propiedad de los atributos y el uso de un tipo el <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> valor para determinar si un tipo es una clase en lugar de un tipo de valor, también se debe llamar el <xref:System.Type.IsValueType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3630">If you retrieve the value of a type's Attributes property and use the <xref:System.Reflection.TypeAttributes.ClassSemanticsMask?displayProperty=nameWithType> value to determine whether a type is a class instead of a value type, you must also call the <xref:System.Type.IsValueType%2A> property.</span></span> <span data-ttu-id="60a97-3631">El ejemplo de la <xref:System.Reflection.TypeAttributes> enumeración contiene información adicional, así como anexample.</span><span class="sxs-lookup"><span data-stu-id="60a97-3631">The example for the <xref:System.Reflection.TypeAttributes> enumeration contains additional information as well as anexample.</span></span>  
  
 <span data-ttu-id="60a97-3632">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-3632">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3633">El ejemplo siguiente crea una instancia de un tipo y se indica si el tipo es una clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3633">The following example creates an instance of a type and indicates whether the type is a class.</span></span>  
  
 [!code-cpp[Type_IsClass#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsClass/CPP/type_isclass.cpp#1)]
 [!code-csharp[Type_IsClass#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsClass/CS/type_isclass.cs#1)]
 [!code-vb[Type_IsClass#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsClass/VB/type_isclass.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="P:System.Type.IsValueType" />
        <altmember cref="F:System.Reflection.TypeAttributes.ClassSemanticsMask" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObject">
      <MemberSignature Language="C#" Value="public bool IsCOMObject { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsCOMObject" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsCOMObject" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsCOMObject As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsCOMObject { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsCOMObject : bool" Usage="System.Type.IsCOMObject" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsCOMObject</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3634">Obtiene un valor que indica si <see cref="T:System.Type" /> es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3634">Gets a value indicating whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <value><span data-ttu-id="60a97-3635">Es <see langword="true" /> si <see cref="T:System.Type" /> es un objeto COM; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3635"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3636">Este método devuelve `false` para interfaces COM porque no son objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3636">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="60a97-3637">Interfaces COM pueden ser implementadas por objetos de Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3637">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 <span data-ttu-id="60a97-3638">También puede cargar una clase COM y obtener un `Type` objeto para esa clase mediante el uso de la [Tlbimp.exe (importador de biblioteca)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) herramienta.</span><span class="sxs-lookup"><span data-stu-id="60a97-3638">You can also load a COM class and get a `Type` object for that COM class by using the [Tlbimp.exe (Type Library Importer)](~/docs/framework/tools/tlbimp-exe-type-library-importer.md) tool.</span></span>  
  
 <span data-ttu-id="60a97-3639">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3639">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3640">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int`> (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3640">For example, if the current <xref:System.Type> represents `MyGenericType<int`> (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3641">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3641">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsCOMObjectImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsCOMObjectImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsCOMObjectImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsCOMObjectImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsCOMObjectImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsCOMObjectImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsCOMObjectImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsCOMObjectImpl : unit -&gt; bool" Usage="type.IsCOMObjectImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3642">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsCOMObject" /> y determina si <see cref="T:System.Type" /> es un objeto COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3642">When overridden in a derived class, implements the <see cref="P:System.Type.IsCOMObject" /> property and determines whether the <see cref="T:System.Type" /> is a COM object.</span></span></summary>
        <returns><span data-ttu-id="60a97-3643">Es <see langword="true" /> si <see cref="T:System.Type" /> es un objeto COM; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3643"><see langword="true" /> if the <see cref="T:System.Type" /> is a COM object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3644">Este método devuelve `false` para interfaces COM porque no son objetos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3644">This method returns `false` for COM interfaces because they are not objects.</span></span> <span data-ttu-id="60a97-3645">Interfaces COM pueden ser implementadas por objetos de Microsoft .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="60a97-3645">COM interfaces can be implemented by Microsoft .NET Framework objects.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsCOMObject" />
      </Docs>
    </Member>
    <Member MemberName="IsConstructedGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsConstructedGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsConstructedGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsConstructedGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsConstructedGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsConstructedGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsConstructedGenericType : bool" Usage="System.Type.IsConstructedGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3646">Obtiene un valor que indica si este objeto representa un tipo genérico construido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3646">Gets a value that indicates whether this object represents a constructed generic type.</span></span> <span data-ttu-id="60a97-3647">Puede crear instancias de un tipo genérico construido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3647">You can create instances of a constructed generic type.</span></span></summary>
        <value><span data-ttu-id="60a97-3648"><see langword="true" /> si este objeto representa una definición de tipo genérico construido; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3648"><see langword="true" /> if this object represents a constructed generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3649">Ha producido un tipo genérico construido tipos explícitos suministrados para todos sus parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3649">A constructed generic type has had explicit types supplied for all of its generic type parameters.</span></span> <span data-ttu-id="60a97-3650">También se denomina un tipo genérico cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3650">It is also referred to as a closed generic type.</span></span>  
  
 <span data-ttu-id="60a97-3651">Cuando esta propiedad es `true`, puede crear instancias del tipo actual; si es `false`, no puede.</span><span class="sxs-lookup"><span data-stu-id="60a97-3651">When this property is `true`, you can create instances of the current type; when it is `false`, you can't.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsContextful">
      <MemberSignature Language="C#" Value="public bool IsContextful { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsContextful" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsContextful" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsContextful As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsContextful { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsContextful : bool" Usage="System.Type.IsContextful" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsContextful</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3652">Obtiene un valor que indica si <see cref="T:System.Type" /> puede estar hospedado en un contexto.</span><span class="sxs-lookup"><span data-stu-id="60a97-3652">Gets a value indicating whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <value><span data-ttu-id="60a97-3653">Es <see langword="true" /> si <see cref="T:System.Type" /> puede estar hospedado en un contexto; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3653"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3654">Un contexto intercepta las llamadas a los miembros de clase y aplica las directivas que se aplican a la clase, como la sincronización.</span><span class="sxs-lookup"><span data-stu-id="60a97-3654">A context intercepts calls to the class members and enforces policies that are applied to the class, such as synchronization.</span></span> <span data-ttu-id="60a97-3655">Para obtener más información acerca de los contextos de comunicación remota, consulte <xref:System.Runtime.Remoting.Contexts.Context>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3655">For more detailed information on remoting contexts, see <xref:System.Runtime.Remoting.Contexts.Context>.</span></span>  
  
 <span data-ttu-id="60a97-3656">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3656">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3657">En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3657">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="60a97-3658">Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3658">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsContextfulImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsContextfulImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsContextfulImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsContextfulImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsContextfulImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsContextfulImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsContextfulImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsContextfulImpl : unit -&gt; bool&#xA;override this.IsContextfulImpl : unit -&gt; bool" Usage="type.IsContextfulImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3659">Implementa la propiedad <see cref="P:System.Type.IsContextful" /> y determina si la clase <see cref="T:System.Type" /> puede hospedarse en un contexto.</span><span class="sxs-lookup"><span data-stu-id="60a97-3659">Implements the <see cref="P:System.Type.IsContextful" /> property and determines whether the <see cref="T:System.Type" /> can be hosted in a context.</span></span></summary>
        <returns><span data-ttu-id="60a97-3660">Es <see langword="true" /> si <see cref="T:System.Type" /> puede estar hospedado en un contexto; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3660"><see langword="true" /> if the <see cref="T:System.Type" /> can be hosted in a context; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3661">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3661">This method can be overridden by a derived class.</span></span>  
  
 <span data-ttu-id="60a97-3662">Un contexto intercepta las llamadas a los miembros de clase y aplicar directivas que se aplican a la clase, como la sincronización.</span><span class="sxs-lookup"><span data-stu-id="60a97-3662">A context intercepts calls to the class members and enforce policies that are applied to the class, such as synchronization.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3663">En el ejemplo siguiente se muestra un uso de la `IsContextfulImpl` método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3663">The following example demonstrates a use of the `IsContextfulImpl` method.</span></span>  
  
 [!code-cpp[Type_IsContextfulImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextfulImpl/CPP/type_iscontextfulimpl.cpp#1)]
 [!code-csharp[Type_IsContextfulImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextfulImpl/CS/type_iscontextfulimpl.cs#1)]
 [!code-vb[Type_IsContextfulImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextfulImpl/VB/type_iscontextfulimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsContextful" />
      </Docs>
    </Member>
    <Member MemberName="IsEnum">
      <MemberSignature Language="C#" Value="public virtual bool IsEnum { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEnum" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsEnum" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsEnum As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsEnum { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEnum : bool" Usage="System.Type.IsEnum" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsEnum</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3664">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3664">Gets a value indicating whether the current <see cref="T:System.Type" /> represents an enumeration.</span></span></summary>
        <value><span data-ttu-id="60a97-3665">Es <see langword="true" /> si el objeto <see cref="T:System.Type" /> actual representa una enumeración; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3665"><see langword="true" /> if the current <see cref="T:System.Type" /> represents an enumeration; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3666">Esta propiedad devuelve `true` para una enumeración, pero no para el <xref:System.Enum> propio tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3666">This property returns `true` for an enumeration, but not for the <xref:System.Enum> type itself.</span></span>  
  
 <span data-ttu-id="60a97-3667">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3667">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3668">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3668">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3669">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3669">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3670">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-3670">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3671">En el ejemplo siguiente se muestra cómo usar el `IsEnum` propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3671">The following example demonstrates how to use the `IsEnum` property.</span></span>  
  
 [!code-cpp[TestIsEnum#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsEnum/CPP/TestIsEnum.cpp#1)]
 [!code-csharp[TestIsEnum#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsEnum/CS/testisenum.cs#1)]
 [!code-vb[TestIsEnum#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsEnum/VB/testisenum.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsEnumDefined">
      <MemberSignature Language="C#" Value="public virtual bool IsEnumDefined (object value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEnumDefined(object value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEnumDefined(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEnumDefined (value As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEnumDefined(System::Object ^ value);" />
      <MemberSignature Language="F#" Value="abstract member IsEnumDefined : obj -&gt; bool&#xA;override this.IsEnumDefined : obj -&gt; bool" Usage="type.IsEnumDefined value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="60a97-3672">Valor que se va a probar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3672">The value to be tested.</span></span></param>
        <summary><span data-ttu-id="60a97-3673">Devuelve un valor que indica si el valor especificado existe en el tipo de enumeración actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3673">Returns a value that indicates whether the specified value exists in the current enumeration type.</span></span></summary>
        <returns><span data-ttu-id="60a97-3674"><see langword="true" /> si el valor especificado es un miembro del tipo de enumeración actual; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3674"><see langword="true" /> if the specified value is a member of the current enumeration type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-3675">El tipo actual no es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3675">The current type is not an enumeration.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-3676">El valor de <paramref name="value" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3676"><paramref name="value" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-3677"><paramref name="value" /> es de un tipo que no puede ser el tipo subyacente de una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-3677"><paramref name="value" /> is of a type that cannot be the underlying type of an enumeration.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsEquivalentTo">
      <MemberSignature Language="C#" Value="public virtual bool IsEquivalentTo (Type other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsEquivalentTo(class System.Type other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsEquivalentTo(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsEquivalentTo (other As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsEquivalentTo(Type ^ other);" />
      <MemberSignature Language="F#" Value="abstract member IsEquivalentTo : Type -&gt; bool&#xA;override this.IsEquivalentTo : Type -&gt; bool" Usage="type.IsEquivalentTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="other"><span data-ttu-id="60a97-3678">Tipo COM cuya equivalencia con el tipo actual se comprueba.</span><span class="sxs-lookup"><span data-stu-id="60a97-3678">The COM type that is tested for equivalence with the current type.</span></span></param>
        <summary><span data-ttu-id="60a97-3679">Determina si dos tipos COM tienen la misma identidad y se pueden usar para la equivalencia de tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3679">Determines whether two COM types have the same identity and are eligible for type equivalence.</span></span></summary>
        <returns><span data-ttu-id="60a97-3680"><see langword="true" /> si los tipos COM son equivalentes; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3680"><see langword="true" /> if the COM types are equivalent; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="60a97-3681">Este método también devuelve <see langword="false" /> si un tipo está en un ensamblado que se carga para la ejecución y el otro está en un ensamblado que se carga en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-3681">This method also returns <see langword="false" /> if one type is in an assembly that is loaded for execution, and the other is in an assembly that is loaded into the reflection-only context.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3682">A partir del [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], common language runtime admite la incrustación de información de tipos COM directamente en los ensamblados administrados, en lugar de requerir a los ensamblados administrados obtener información de tipos COM de interoperabilidad ensamblados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3682">Beginning with the [!INCLUDE[net_v40_long](~/includes/net-v40-long-md.md)], the common language runtime supports the embedding of type information for COM types directly into managed assemblies, instead of requiring the managed assemblies to obtain type information for COM types from interop assemblies.</span></span> <span data-ttu-id="60a97-3683">Dado que la información de tipos incrustada solo incluye los tipos y miembros que realmente usa un ensamblado administrado, dos ensamblados administrados pueden tener vistas muy diferentes del mismo tipo COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3683">Because the embedded type information includes only the types and members that are actually used by a managed assembly, two managed assemblies might have very different views of the same COM type.</span></span> <span data-ttu-id="60a97-3684">Cada ensamblado administrado tiene un objeto <xref:System.Type> diferente para representar su vista del tipo COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3684">Each managed assembly has a different <xref:System.Type> object to represent its view of the COM type.</span></span> <span data-ttu-id="60a97-3685">Common Language Runtime admite la equivalencia de tipos entre estas distintas vistas de interfaces, estructuras, enumeraciones y delegados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3685">The common language runtime supports type equivalence between these different views for interfaces, structures, enumerations, and delegates.</span></span>  
  
 <span data-ttu-id="60a97-3686">La equivalencia de tipos significa que un objeto COM que se pasa de un ensamblado administrado a otro se puede convertir al tipo administrado adecuado en el ensamblado receptor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3686">Type equivalence means that a COM object that is passed from one managed assembly to another can be cast to the appropriate managed type in the receiving assembly.</span></span> <span data-ttu-id="60a97-3687">El <xref:System.Type.IsEquivalentTo%2A> método permite a un ensamblado determinar que un objeto COM obtenido de otro ensamblado tiene la misma identidad de COM como uno de los tipos de interoperabilidad de primera insertados propios de ensamblado y, por lo tanto, se puede convertir a ese tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3687">The <xref:System.Type.IsEquivalentTo%2A> method enables an assembly to determine that a COM object obtained from another assembly has the same COM identity as one of the first assembly's own embedded interop types, and thus can be cast to that type.</span></span>  
  
 <span data-ttu-id="60a97-3688">Para obtener más información, consulte [equivalencia de tipos y tipos de interoperabilidad incrustados](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-3688">For more information, see [Type Equivalence and Embedded Interop Types](~/docs/framework/interop/type-equivalence-and-embedded-interop-types.md).</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsExplicitLayout">
      <MemberSignature Language="C#" Value="public bool IsExplicitLayout { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsExplicitLayout" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsExplicitLayout" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsExplicitLayout As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsExplicitLayout { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsExplicitLayout : bool" Usage="System.Type.IsExplicitLayout" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsExplicitLayout</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3689">Obtiene un valor que indica si los campos del tipo actual se disponen en los desplazamientos especificados explícitamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3689">Gets a value indicating whether the fields of the current type are laid out at explicitly specified offsets.</span></span></summary>
        <value><span data-ttu-id="60a97-3690"><see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3690"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.ExplicitLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3691">Esta propiedad se proporciona por comodidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3691">This property is provided as a convenience.</span></span> <span data-ttu-id="60a97-3692">Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> está establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3692">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="60a97-3693">El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-3693">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="60a97-3694">Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> cuando se crea el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3694">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="60a97-3695">En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> valor de enumeración para el tipo, para especificar que los desplazamientos a la que se iniciará los campos se especifican explícitamente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3695">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Explicit?displayProperty=nameWithType> enumeration value to the type, to specify that the offsets at which the fields start are specified explicitly.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3696">No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3696">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="60a97-3697">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3697">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3698">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3698">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3699">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3699">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3700">El ejemplo siguiente se crea una instancia de un tipo y muestra el valor de su <xref:System.Type.IsExplicitLayout%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3700">The following example creates an instance of a type and displays the value of its <xref:System.Type.IsExplicitLayout%2A> property.</span></span> <span data-ttu-id="60a97-3701">Usa el `MySystemTime` (clase), que se encuentra también en el ejemplo de código para <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3701">It uses the `MySystemTime` class, which is also in the code example for <xref:System.Runtime.InteropServices.StructLayoutAttribute>.</span></span>  
  
 [!code-csharp[Type_IsExplicitLayout#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsExplicitLayout/CS/type_isexplicitlayout.cs#1)]
 [!code-vb[Type_IsExplicitLayout#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsExplicitLayout/VB/type_isexplicitlayout.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsLayoutSequential" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="60a97-3702">Metadatos y componentes autodescriptivos</span><span class="sxs-lookup"><span data-stu-id="60a97-3702">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericMethodParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericMethodParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericMethodParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericMethodParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericMethodParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericMethodParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericMethodParameter : bool" Usage="System.Type.IsGenericMethodParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsGenericParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericParameter : bool" Usage="System.Type.IsGenericParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3703">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa un parámetro de tipo en la definición de un método o tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3703">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a type parameter in the definition of a generic type or method.</span></span></summary>
        <value><span data-ttu-id="60a97-3704"><see langword="true" /> si el objeto <see cref="T:System.Type" /> representa un parámetro de tipo de una definición de tipo genérico o de una definición de método genérico; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3704"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a type parameter of a generic type definition or generic method definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3705"><xref:System.Type> objetos que representan los parámetros de tipo genérico se pueden obtener mediante una llamada a la <xref:System.Type.GetGenericArguments%2A> método de un <xref:System.Type> objeto que representa una definición de tipo genérico, o la <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> método de un <xref:System.Reflection.MethodInfo> objeto que representa un método genérico definición.</span><span class="sxs-lookup"><span data-stu-id="60a97-3705"><xref:System.Type> objects that represent generic type parameters can be obtained by calling the <xref:System.Type.GetGenericArguments%2A> method of a <xref:System.Type> object that represents a generic type definition, or the <xref:System.Reflection.MethodInfo.GetGenericArguments%2A> method of a <xref:System.Reflection.MethodInfo> object that represents a generic method definition.</span></span>  
  
-   <span data-ttu-id="60a97-3706">Para un tipo genérico o una definición de método, el <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `true` para todos los elementos de la matriz resultante.</span><span class="sxs-lookup"><span data-stu-id="60a97-3706">For a generic type or method definition, the <xref:System.Type.IsGenericParameter%2A> property returns `true` for every element of the resulting array.</span></span>  
  
-   <span data-ttu-id="60a97-3707">Para un tipo construido cerrado o un método, el <xref:System.Type.IsGenericParameter%2A> propiedad devuelve `false` para todos los elementos de la matriz devuelta por la <xref:System.Type.GetGenericArguments%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3707">For a closed constructed type or method, the <xref:System.Type.IsGenericParameter%2A> property returns `false` for every element of the array returned by the <xref:System.Type.GetGenericArguments%2A> method.</span></span>  
  
-   <span data-ttu-id="60a97-3708">Para un tipo construido abierto o método, algunos elementos de la matriz podrían ser tipos específicos y otros podrían ser parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3708">For an open constructed type or method, some elements of the array might be specific types and others might be type parameters.</span></span> <span data-ttu-id="60a97-3709"><xref:System.Type.IsGenericParameter%2A> Devuelve `false` para los tipos y `true` para los parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3709"><xref:System.Type.IsGenericParameter%2A> returns `false` for the types and `true` for the type parameters.</span></span> <span data-ttu-id="60a97-3710">El ejemplo de código para el <xref:System.Type.ContainsGenericParameters%2A> propiedad muestra una clase genérica con una mezcla de tipos y parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3710">The code example for the <xref:System.Type.ContainsGenericParameters%2A> property demonstrates a generic class with a mixture of types and type parameters.</span></span>  
  
 <span data-ttu-id="60a97-3711">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3711">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3712">En el ejemplo siguiente se usa el <xref:System.Type.IsGenericParameter%2A> propiedad va a comprobar los parámetros de tipo genérico en un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3712">The following example uses the <xref:System.Type.IsGenericParameter%2A> property to test for generic type parameters in a generic type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericParameter#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CPP/source.cpp#2)]
 [!code-csharp[System.Type.IsGenericParameter#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericParameter/CS/source.cs#2)]
 [!code-vb[System.Type.IsGenericParameter#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericParameter/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.GenericParameterPosition" />
        <altmember cref="M:System.Type.GetGenericArguments" />
        <altmember cref="M:System.Type.GetGenericParameterConstraints" />
        <altmember cref="P:System.Type.GenericParameterAttributes" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-3713">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-3713">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-3714">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-3714">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericType">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericType : bool" Usage="System.Type.IsGenericType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3715">Obtiene un valor que indica si el tipo actual es genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3715">Gets a value indicating whether the current type is a generic type.</span></span></summary>
        <value><span data-ttu-id="60a97-3716"><see langword="true" /> Si el tipo actual es un tipo genérico; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3716"><see langword="true" /> if the current type is a generic type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3717">Use la <xref:System.Type.IsGenericType%2A> propiedad para determinar si un <xref:System.Type> objeto representa un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3717">Use the <xref:System.Type.IsGenericType%2A> property to determine whether a <xref:System.Type> object represents a generic type.</span></span> <span data-ttu-id="60a97-3718">Use la <xref:System.Type.ContainsGenericParameters%2A> propiedad para determinar si un <xref:System.Type> objeto representa un tipo construido abierto o un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3718">Use the <xref:System.Type.ContainsGenericParameters%2A> property to determine whether a <xref:System.Type> object represents an open constructed type or a closed constructed type.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3719">El <xref:System.Type.IsGenericType%2A> propiedad devuelve `false` si el tipo inmediato no es genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3719">The <xref:System.Type.IsGenericType%2A> property returns `false` if the immediate type is not generic.</span></span> <span data-ttu-id="60a97-3720">Por ejemplo, una matriz cuyos elementos son de tipo `A<int>` (`A(Of Integer)` en Visual Basic) no es un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3720">For example, an array whose elements are of type `A<int>` (`A(Of Integer)` in Visual Basic) is not itself a generic type.</span></span>  
  
 <span data-ttu-id="60a97-3721">En la tabla siguiente se resume las condiciones invariables para los términos comunes usados en la reflexión genérica.</span><span class="sxs-lookup"><span data-stu-id="60a97-3721">The following table summarizes the invariant conditions for common terms used in generic reflection.</span></span>  
  
|<span data-ttu-id="60a97-3722">Término</span><span class="sxs-lookup"><span data-stu-id="60a97-3722">Term</span></span>|<span data-ttu-id="60a97-3723">Invariable</span><span class="sxs-lookup"><span data-stu-id="60a97-3723">Invariant</span></span>|  
|----------|---------------|  
|<span data-ttu-id="60a97-3724">definición de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="60a97-3724">generic type definition</span></span>|<span data-ttu-id="60a97-3725">La propiedad <xref:System.Type.IsGenericTypeDefinition%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3725">The <xref:System.Type.IsGenericTypeDefinition%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3726">Define un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3726">Defines a generic type.</span></span> <span data-ttu-id="60a97-3727">Se crea un tipo construido mediante una llamada a la <xref:System.Type.MakeGenericType%2A> método en un <xref:System.Type> objeto que representa una definición de tipo genérico y especifica una matriz de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3727">A constructed type is created by calling the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object that represents a generic type definition and specifying an array of type arguments.</span></span><br /><br /> <span data-ttu-id="60a97-3728"><xref:System.Type.MakeGenericType%2A> se puede llamar solo en definiciones de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3728"><xref:System.Type.MakeGenericType%2A> can be called only on generic type definitions.</span></span><br /><br /> <span data-ttu-id="60a97-3729">Cualquier definición de tipo genérico es un tipo genérico (la <xref:System.Type.IsGenericType%2A> propiedad es `true`), pero la conversión no es verdadera.</span><span class="sxs-lookup"><span data-stu-id="60a97-3729">Any generic type definition is a generic type (the <xref:System.Type.IsGenericType%2A> property is `true`), but the converse is not true.</span></span>|  
|<span data-ttu-id="60a97-3730">tipo genérico</span><span class="sxs-lookup"><span data-stu-id="60a97-3730">generic type</span></span>|<span data-ttu-id="60a97-3731">La propiedad <xref:System.Type.IsGenericType%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3731">The <xref:System.Type.IsGenericType%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3732">Puede ser una definición de tipo genérico, un tipo construido abierto o un tipo construido cerrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3732">Can be a generic type definition, an open constructed type, or a closed constructed type.</span></span><br /><br /> <span data-ttu-id="60a97-3733">Tenga en cuenta que un tipo de matriz cuyo tipo de elemento es genérico no es un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3733">Note that an array type whose element type is generic is not itself a generic type.</span></span> <span data-ttu-id="60a97-3734">Lo mismo puede decirse de un <xref:System.Type> objeto que representa un puntero a un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3734">The same is true of a <xref:System.Type> object representing a pointer to a generic type.</span></span>|  
|<span data-ttu-id="60a97-3735">tipo construido abierto</span><span class="sxs-lookup"><span data-stu-id="60a97-3735">open constructed type</span></span>|<span data-ttu-id="60a97-3736">La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3736">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3737">Algunos ejemplos son un tipo genérico que ha sin asignar parámetros de tipo, un tipo que está anidado en una definición de tipo genérico o en un tipo construido abierto o un tipo genérico que tiene un argumento de tipo para el que el <xref:System.Type.ContainsGenericParameters%2A> propiedad es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3737">Examples are a generic type that has unassigned type parameters, a type that is nested in a generic type definition or in an open constructed type, or a generic type that has a type argument for which the <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3738">No es posible crear una instancia de un tipo construido abierto.</span><span class="sxs-lookup"><span data-stu-id="60a97-3738">It is not possible to create an instance of an open constructed type.</span></span><br /><br /> <span data-ttu-id="60a97-3739">Tenga en cuenta que no se podrá abrir todos los tipos construidos son genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3739">Note that not all open constructed types are generic.</span></span> <span data-ttu-id="60a97-3740">Por ejemplo, una matriz cuyo tipo de elemento es una definición de tipo genérico no es genérica y un puntero a un tipo construido abierto no es genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3740">For example, an array whose element type is a generic type definition is not generic, and a pointer to an open constructed type is not generic.</span></span>|  
|<span data-ttu-id="60a97-3741">tipo construido cerrado</span><span class="sxs-lookup"><span data-stu-id="60a97-3741">closed constructed type</span></span>|<span data-ttu-id="60a97-3742">La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3742">The <xref:System.Type.ContainsGenericParameters%2A> property is `false`.</span></span><br /><br /> <span data-ttu-id="60a97-3743">Cuando examina de forma recursiva, el tipo no tiene ningún parámetro genérico sin asignar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3743">When examined recursively, the type has no unassigned generic parameters.</span></span>|  
|<span data-ttu-id="60a97-3744">parámetro de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="60a97-3744">generic type parameter</span></span>|<span data-ttu-id="60a97-3745">La propiedad <xref:System.Type.IsGenericParameter%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3745">The <xref:System.Type.IsGenericParameter%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3746">La propiedad <xref:System.Type.ContainsGenericParameters%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3746">The <xref:System.Type.ContainsGenericParameters%2A> property is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3747">En una definición de tipo genérico, un marcador de posición para un tipo que se asignará más tarde.</span><span class="sxs-lookup"><span data-stu-id="60a97-3747">In a generic type definition, a placeholder for a type that will be assigned later.</span></span>|  
|<span data-ttu-id="60a97-3748">argumento de tipo genérico</span><span class="sxs-lookup"><span data-stu-id="60a97-3748">generic type argument</span></span>|<span data-ttu-id="60a97-3749">Puede ser cualquier tipo, incluidos un parámetro de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3749">Can be any type, including a generic type parameter.</span></span><br /><br /> <span data-ttu-id="60a97-3750">Argumentos de tipo se especifican como una matriz de <xref:System.Type> objetos pasan a la <xref:System.Type.MakeGenericType%2A> método cuando se crea un tipo genérico construido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3750">Type arguments are specified as an array of <xref:System.Type> objects passed to the <xref:System.Type.MakeGenericType%2A> method when creating a constructed generic type.</span></span> <span data-ttu-id="60a97-3751">Si son instancias del tipo resultante en crearse, la <xref:System.Type.ContainsGenericParameters%2A> propiedad debe ser `false` para todos los argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3751">If instances of the resulting type are to be created, the <xref:System.Type.ContainsGenericParameters%2A> property must be `false` for all the type arguments.</span></span>|  
  
 <span data-ttu-id="60a97-3752">El ejemplo de código y la tabla siguiente muestran algunos de estos términos y las invariantes.</span><span class="sxs-lookup"><span data-stu-id="60a97-3752">The following code example and table illustrate some of these terms and invariants.</span></span> <span data-ttu-id="60a97-3753">La `Derived` clase es de especial interés porque su tipo base es un tipo construido que tiene una mezcla de tipos y parámetros de tipo en su lista de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3753">The `Derived` class is of particular interest because its base type is a constructed type that has a mixture of types and type parameters in its type argument list.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.IsGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/remarks.cs#2)]
 [!code-vb[System.Type.IsGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/remarks.vb#2)]  
  
 <span data-ttu-id="60a97-3754">La siguiente tabla muestra ejemplos que usan y compilación en las clases `Base`, `Derived`, y `G`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3754">The following table shows examples that use and build on the classes `Base`, `Derived`, and `G`.</span></span> <span data-ttu-id="60a97-3755">Cuando el código de C++ y C# es el mismo, se muestra una sola entrada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3755">When the C++ and C# code is the same, only one entry is shown.</span></span>  
  
|<span data-ttu-id="60a97-3756">Ejemplo</span><span class="sxs-lookup"><span data-stu-id="60a97-3756">Example</span></span>|<span data-ttu-id="60a97-3757">Invariables</span><span class="sxs-lookup"><span data-stu-id="60a97-3757">Invariants</span></span>|  
|-------------|----------------|  
|`Derived(Of V)`<br /><br /> `Derived<V>`|<span data-ttu-id="60a97-3758">Para este tipo:</span><span class="sxs-lookup"><span data-stu-id="60a97-3758">For this type:</span></span><br /><br /> <span data-ttu-id="60a97-3759">El valor de <xref:System.Type.IsGenericType%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3759"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3760">El valor de <xref:System.Type.IsGenericTypeDefinition%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3760"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3761">El valor de <xref:System.Type.ContainsGenericParameters%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3761"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Base(Of String, V)`<br /><br /> `Base<String,V>`<br /><br /> `Base<String^,V>`|<span data-ttu-id="60a97-3762">Para este tipo:</span><span class="sxs-lookup"><span data-stu-id="60a97-3762">For this type:</span></span><br /><br /> <span data-ttu-id="60a97-3763">El valor de <xref:System.Type.IsGenericType%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3763"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3764">El valor de <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3764"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="60a97-3765">El valor de <xref:System.Type.ContainsGenericParameters%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3765"><xref:System.Type.ContainsGenericParameters%2A> is `true`.</span></span>|  
|`Dim d() As Derived(Of Integer)`<br /><br /> `Derived<int>[] d;`<br /><br /> `array<Derived<int>^>^ d;`|<span data-ttu-id="60a97-3766">Para el tipo de variable `d`:</span><span class="sxs-lookup"><span data-stu-id="60a97-3766">For the type of variable `d`:</span></span><br /><br /> <span data-ttu-id="60a97-3767"><xref:System.Type.IsGenericType%2A> es `false` porque `d` es una matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-3767"><xref:System.Type.IsGenericType%2A> is `false` because `d` is an array.</span></span><br /><br /> <span data-ttu-id="60a97-3768">El valor de <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3768"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="60a97-3769">El valor de <xref:System.Type.ContainsGenericParameters%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3769"><xref:System.Type.ContainsGenericParameters%2A> is `false`.</span></span>|  
|<span data-ttu-id="60a97-3770">`T`, `U`, y `V` (en todas partes aparecen)</span><span class="sxs-lookup"><span data-stu-id="60a97-3770">`T`, `U`, and `V` (everywhere they appear)</span></span>|<span data-ttu-id="60a97-3771">El valor de <xref:System.Type.IsGenericParameter%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3771"><xref:System.Type.IsGenericParameter%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3772"><xref:System.Type.IsGenericType%2A> es `false` porque no hay ninguna manera de restringir un parámetro de tipo para tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3772"><xref:System.Type.IsGenericType%2A> is `false` because there is no way to constrain a type parameter to generic types.</span></span><br /><br /> <span data-ttu-id="60a97-3773">El valor de <xref:System.Type.IsGenericTypeDefinition%2A> es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3773"><xref:System.Type.IsGenericTypeDefinition%2A> is `false`.</span></span><br /><br /> <span data-ttu-id="60a97-3774"><xref:System.Type.ContainsGenericParameters%2A> es `true` porque `T`, `U`, y `V` son parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3774"><xref:System.Type.ContainsGenericParameters%2A> is `true` because `T`, `U`, and `V` are themselves generic type parameters.</span></span> <span data-ttu-id="60a97-3775">Esto no implica nada sobre los argumentos de tipo que se asignan a ellos más adelante.</span><span class="sxs-lookup"><span data-stu-id="60a97-3775">This does not imply anything about type arguments that are assigned to them later.</span></span>|  
|<span data-ttu-id="60a97-3776">El tipo de campo `F`</span><span class="sxs-lookup"><span data-stu-id="60a97-3776">The type of field `F`</span></span>|<span data-ttu-id="60a97-3777">El valor de <xref:System.Type.IsGenericType%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3777"><xref:System.Type.IsGenericType%2A> is `true`.</span></span><br /><br /> <span data-ttu-id="60a97-3778"><xref:System.Type.IsGenericTypeDefinition%2A> es `false` porque se asignó un tipo para el parámetro de tipo de `G`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3778"><xref:System.Type.IsGenericTypeDefinition%2A> is `false` because a type has been assigned to the type parameter of `G`.</span></span> <span data-ttu-id="60a97-3779">Tenga en cuenta que esto es equivalente a haber llamado el <xref:System.Type.MakeGenericType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-3779">Note that this is equivalent to having called the <xref:System.Type.MakeGenericType%2A> method.</span></span><br /><br /> <span data-ttu-id="60a97-3780"><xref:System.Type.ContainsGenericParameters%2A> es `true` porque el tipo de campo `F` tiene un argumento de tipo que es un tipo construido abierto.</span><span class="sxs-lookup"><span data-stu-id="60a97-3780"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the type of field `F` has a type argument that is an open constructed type.</span></span> <span data-ttu-id="60a97-3781">El tipo construido es abierto porque su argumento de tipo (es decir, `Base`) es una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3781">The constructed type is open because its type argument (that is, `Base`) is a generic type definition.</span></span> <span data-ttu-id="60a97-3782">Esto ilustra la naturaleza recursiva de la <xref:System.Type.IsGenericType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3782">This illustrates the recursive nature of the <xref:System.Type.IsGenericType%2A> property.</span></span>|  
|<span data-ttu-id="60a97-3783">La clase anidada `Nested`</span><span class="sxs-lookup"><span data-stu-id="60a97-3783">The nested class `Nested`</span></span>|<span data-ttu-id="60a97-3784"><xref:System.Type.IsGenericType%2A> es `true`, aunque la `Nested` clase no tiene ningún parámetro de tipo genérico propios, porque está anidada en un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3784"><xref:System.Type.IsGenericType%2A> is `true`, even though the `Nested` class has no generic type parameters of its own, because it is nested in a generic type.</span></span><br /><br /> <span data-ttu-id="60a97-3785">El valor de <xref:System.Type.IsGenericTypeDefinition%2A> es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3785"><xref:System.Type.IsGenericTypeDefinition%2A> is `true`.</span></span> <span data-ttu-id="60a97-3786">Es decir, puede llamar a la <xref:System.Type.MakeGenericType%2A> método y proporcionar el parámetro de tipo del tipo envolvente, `Derived`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3786">That is, you can call the <xref:System.Type.MakeGenericType%2A> method and supply the type parameter of the enclosing type, `Derived`.</span></span><br /><br /> <span data-ttu-id="60a97-3787"><xref:System.Type.ContainsGenericParameters%2A> es `true` porque el tipo de la envolvente, `Derived`, tiene parámetros de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3787"><xref:System.Type.ContainsGenericParameters%2A> is `true` because the enclosing type, `Derived`, has generic type parameters.</span></span> <span data-ttu-id="60a97-3788">Esto ilustra la naturaleza recursiva de la <xref:System.Type.ContainsGenericParameters%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3788">This illustrates the recursive nature of the <xref:System.Type.ContainsGenericParameters%2A> property.</span></span>|  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3789">En el ejemplo de código siguiente se muestra el valor de la <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, y <xref:System.Type.ContainsGenericParameters%2A> las propiedades de los tipos descritos en la sección Comentarios.</span><span class="sxs-lookup"><span data-stu-id="60a97-3789">The following code example displays the value of the <xref:System.Type.IsGenericType%2A>, <xref:System.Type.IsGenericTypeDefinition%2A>, <xref:System.Type.IsGenericParameter%2A>, and <xref:System.Type.ContainsGenericParameters%2A> properties for the types described in the Remarks section.</span></span> <span data-ttu-id="60a97-3790">Para obtener una explicación de los valores de propiedad, vea la tabla que aparece en la sección Comentarios.</span><span class="sxs-lookup"><span data-stu-id="60a97-3790">For explanations of the property values, see the accompanying table in Remarks.</span></span>  
  
 [!code-cpp[System.Type.IsGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericType/cpp/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericType/cs/source.cs#1)]
 [!code-vb[System.Type.IsGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericType/vb/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-3791">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-3791">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-3792">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-3792">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeDefinition : bool" Usage="System.Type.IsGenericTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3793">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa una definición de tipo genérico, a partir de la cual se pueden construir otros tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3793">Gets a value indicating whether the current <see cref="T:System.Type" /> represents a generic type definition, from which other generic types can be constructed.</span></span></summary>
        <value><span data-ttu-id="60a97-3794"><see langword="true" /> si el objeto <see cref="T:System.Type" /> representa una definición de tipo genérico; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3794"><see langword="true" /> if the <see cref="T:System.Type" /> object represents a generic type definition; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3795">Una definición de tipo genérico es una plantilla desde el que se pueden construir otros tipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3795">A generic type definition is a template from which other types can be constructed.</span></span> <span data-ttu-id="60a97-3796">Por ejemplo, desde la definición de tipo genérico `G<T>` (expresada en sintaxis de C#; `G(Of T)` en Visual Basic o `generic <typename T> ref class G` en C++) puede construir y crear instancias del tipo `G<int>` (`G(Of Integer)` en Visual Basic), mediante una llamada a la <xref:System.Type.MakeGenericType%2A> método con una lista de argumentos genéricos que contiene el <xref:System.Int32> tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3796">For example, from the generic type definition `G<T>` (expressed in C# syntax; `G(Of T)` in Visual Basic or `generic <typename T> ref class G` in C++) you can construct and instantiate the type `G<int>` (`G(Of Integer)` in Visual Basic), by calling the <xref:System.Type.MakeGenericType%2A> method with a generic argument list containing the <xref:System.Int32> type.</span></span> <span data-ttu-id="60a97-3797">Dado un <xref:System.Type> construido de objeto que representa este tipo, el <xref:System.Type.GetGenericTypeDefinition%2A> método obtiene la definición de tipo genérico vuelva a intentarlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3797">Given a <xref:System.Type> object representing this constructed type, the <xref:System.Type.GetGenericTypeDefinition%2A> method gets the generic type definition back again.</span></span>  
  
 <span data-ttu-id="60a97-3798">Use el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad para determinar si se pueden crear nuevos tipos del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3798">Use the <xref:System.Type.IsGenericTypeDefinition%2A> property to determine whether you can create new types from the current type.</span></span> <span data-ttu-id="60a97-3799">Si el <xref:System.Type.IsGenericTypeDefinition%2A> propiedad devuelve `true`, puede llamar a la <xref:System.Type.MakeGenericType%2A> método para crear nuevos tipos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3799">If the <xref:System.Type.IsGenericTypeDefinition%2A> property returns `true`, you can call the <xref:System.Type.MakeGenericType%2A> method to create new generic types.</span></span>  
  
 <span data-ttu-id="60a97-3800">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3800">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3801">El ejemplo siguiente muestra información sobre un tipo, incluso si es una definición de tipo genérico o no.</span><span class="sxs-lookup"><span data-stu-id="60a97-3801">The following example displays information about a type, including whether or not it is a generic type definition.</span></span> <span data-ttu-id="60a97-3802">Se muestra información para un tipo construido, para su definición de tipo genérico y para un tipo normal.</span><span class="sxs-lookup"><span data-stu-id="60a97-3802">Information is displayed for a constructed type, for its generic type definition, and for an ordinary type.</span></span>  
  
 [!code-cpp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/CS/source.cs#1)]
 [!code-vb[System.Type.IsGenericTypeDefinition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsGenericTypeDefinition/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.ContainsGenericParameters" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-3803">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-3803">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-3804">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-3804">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsGenericTypeParameter">
      <MemberSignature Language="C#" Value="public virtual bool IsGenericTypeParameter { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsGenericTypeParameter" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsGenericTypeParameter" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsGenericTypeParameter As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsGenericTypeParameter { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsGenericTypeParameter : bool" Usage="System.Type.IsGenericTypeParameter" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsImport">
      <MemberSignature Language="C#" Value="public bool IsImport { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsImport" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsImport" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsImport As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsImport { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsImport : bool" Usage="System.Type.IsImport" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsImport</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3805">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> tiene aplicado un atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />, lo que indica que se ha importado de una biblioteca de tipos COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-3805">Gets a value indicating whether the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" /> attribute applied, indicating that it was imported from a COM type library.</span></span></summary>
        <value><span data-ttu-id="60a97-3806"><see langword="true" /> si <see cref="T:System.Type" /> tiene un atributo <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3806"><see langword="true" /> if the <see cref="T:System.Type" /> has a <see cref="T:System.Runtime.InteropServices.ComImportAttribute" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3807">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3807">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3808">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>.`</span><span class="sxs-lookup"><span data-stu-id="60a97-3808">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>.`</span></span>  
  
 <span data-ttu-id="60a97-3809">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3809">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsInstanceOfType">
      <MemberSignature Language="C#" Value="public virtual bool IsInstanceOfType (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsInstanceOfType(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsInstanceOfType(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsInstanceOfType (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsInstanceOfType(System::Object ^ o);" />
      <MemberSignature Language="F#" Value="abstract member IsInstanceOfType : obj -&gt; bool&#xA;override this.IsInstanceOfType : obj -&gt; bool" Usage="type.IsInstanceOfType o" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsInstanceOfType(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o"><span data-ttu-id="60a97-3810">Objeto que se va a comparar con el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3810">The object to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="60a97-3811">Determina si el objeto especificado es una instancia del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-3811">Determines whether the specified object is an instance of the current <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-3812">Es <see langword="true" /> si el objeto <see langword="Type" /> actual se encuentra en la jerarquía de herencia del objeto representado por <paramref name="o" />, o si el objeto <see langword="Type" /> actual es una interfaz que implementa <paramref name="o" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3812"><see langword="true" /> if the current <see langword="Type" /> is in the inheritance hierarchy of the object represented by <paramref name="o" />, or if the current <see langword="Type" /> is an interface that <paramref name="o" /> implements.</span></span> <span data-ttu-id="60a97-3813"><see langword="false" /> si no se cumple ninguna de estas condiciones, o si <paramref name="o" /> es <see langword="null" />, o si el objeto <see langword="Type" /> actual es un tipo genérico abierto (es decir, la propiedad <see cref="P:System.Type.ContainsGenericParameters" /> devuelve <see langword="true" />).</span><span class="sxs-lookup"><span data-stu-id="60a97-3813"><see langword="false" /> if neither of these conditions is the case, if <paramref name="o" /> is <see langword="null" />, or if the current <see langword="Type" /> is an open generic type (that is, <see cref="P:System.Type.ContainsGenericParameters" /> returns <see langword="true" />).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3814">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3814">This method can be overridden by a derived class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3815">Un tipo construido no es una instancia de su definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-3815">A constructed type is not an instance of its generic type definition.</span></span> <span data-ttu-id="60a97-3816">Es decir, `MyGenericList<int>` (`MyGenericList(Of Integer)` en Visual Basic) no es una instancia de `MyGenericList<T>` (`MyGenericList(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-3816">That is, `MyGenericList<int>` (`MyGenericList(Of Integer)` in Visual Basic) is not an instance of `MyGenericList<T>` (`MyGenericList(Of T)` in Visual Basic).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3817">En el siguiente ejemplo se muestra el uso del método `IsInstanceOfType`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3817">The following example demonstrates the use of the `IsInstanceOfType` method.</span></span>  
  
 [!code-cpp[TestIsInstanceOfType#1](~/samples/snippets/cpp/VS_Snippets_CLR/TestIsInstanceOfType/CPP/testisinstanceoftype.cpp#1)]
 [!code-csharp[TestIsInstanceOfType#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsInstanceOfType/CS/testisinstanceoftype.cs#1)]
 [!code-vb[TestIsInstanceOfType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsInstanceOfType/VB/testisinstanceoftype.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInterface">
      <MemberSignature Language="C#" Value="public bool IsInterface { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsInterface" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsInterface" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsInterface As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsInterface { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsInterface : bool" Usage="System.Type.IsInterface" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsInterface</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3818">Obtiene un valor que indica si <see cref="T:System.Type" /> es una interfaz, es decir, no es una clase ni un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3818">Gets a value indicating whether the <see cref="T:System.Type" /> is an interface; that is, not a class or a value type.</span></span></summary>
        <value><span data-ttu-id="60a97-3819">Es <see langword="true" /> si <see cref="T:System.Type" /> es una interfaz; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3819"><see langword="true" /> if the <see cref="T:System.Type" /> is an interface; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3820">El <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distingue una declaración de tipo clase, interfaz o tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-3820">The <xref:System.Reflection.TypeAttributes.ClassSemanticsMask> distinguishes a type declaration as class, interface or value type.</span></span>  
  
 <span data-ttu-id="60a97-3821">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3821">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3822">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-3822">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3823">El ejemplo siguiente se crea una interfaz, busca el tipo de interfaz e indica si una clase tiene el `IsInterface` conjunto de propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-3823">The following example creates an interface, checks for the interface type, and indicates whether a class has the `IsInterface` property set.</span></span>  
  
 [!code-cpp[Type_IsInterface#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsInterface/CPP/type_isinterface.cpp#1)]
 [!code-csharp[Type_IsInterface#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsInterface/CS/type_isinterface.cs#1)]
 [!code-vb[Type_IsInterface#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsInterface/VB/type_isinterface.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsLayoutSequential">
      <MemberSignature Language="C#" Value="public bool IsLayoutSequential { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsLayoutSequential" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsLayoutSequential" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsLayoutSequential As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsLayoutSequential { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsLayoutSequential : bool" Usage="System.Type.IsLayoutSequential" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsLayoutSequential</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3824">Obtiene un valor que indica si los campos del tipo actual se disponen secuencialmente, en el orden que se definieron o emitieron en los metadatos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3824">Gets a value indicating whether the fields of the current type are laid out sequentially, in the order that they were defined or emitted to the metadata.</span></span></summary>
        <value><span data-ttu-id="60a97-3825"><see langword="true" /> si la propiedad <see cref="P:System.Type.Attributes" /> del tipo actual incluye <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3825"><see langword="true" /> if the <see cref="P:System.Type.Attributes" /> property of the current type includes <see cref="F:System.Reflection.TypeAttributes.SequentialLayout" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3826">Esta propiedad se proporciona por comodidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3826">This property is provided as a convenience.</span></span> <span data-ttu-id="60a97-3827">Como alternativa, puede usar el <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> valor de enumeración para seleccionar los atributos de diseño de tipo y la prueba si <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> está establecido.</span><span class="sxs-lookup"><span data-stu-id="60a97-3827">Alternatively, you can use the <xref:System.Reflection.TypeAttributes.LayoutMask?displayProperty=nameWithType> enumeration value to select the type layout attributes, and then test whether <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> is set.</span></span> <span data-ttu-id="60a97-3828">El <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, y <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> valores de enumeración indican la manera en que los campos del tipo se colocan en la memoria.</span><span class="sxs-lookup"><span data-stu-id="60a97-3828">The <xref:System.Reflection.TypeAttributes.AutoLayout?displayProperty=nameWithType>, <xref:System.Reflection.TypeAttributes.ExplicitLayout?displayProperty=nameWithType>, and <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> enumeration values indicate the way the fields of the type are laid out in memory.</span></span>  
  
 <span data-ttu-id="60a97-3829">Para los tipos dinámicos, puede especificar <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> cuando se crea el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3829">For dynamic types, you can specify <xref:System.Reflection.TypeAttributes.SequentialLayout?displayProperty=nameWithType> when you create the type.</span></span> <span data-ttu-id="60a97-3830">En el código, se aplican los <xref:System.Runtime.InteropServices.StructLayoutAttribute> atributo con el <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeración para el tipo, para especificar que el diseño es secuencial.</span><span class="sxs-lookup"><span data-stu-id="60a97-3830">In code, apply the <xref:System.Runtime.InteropServices.StructLayoutAttribute> attribute with the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value to the type, to specify that layout is sequential.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3831">No puede usar el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método para determinar si el <xref:System.Runtime.InteropServices.StructLayoutAttribute> se ha aplicado a un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3831">You cannot use the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method to determine whether the <xref:System.Runtime.InteropServices.StructLayoutAttribute> has been applied to a type.</span></span>  
  
 <span data-ttu-id="60a97-3832">Para obtener más información, vea la sección 9.1.2 de la especificación para la documentación de Common Language Infrastructure (CLI), "Partition II: Definición de metadatos y la semántica".</span><span class="sxs-lookup"><span data-stu-id="60a97-3832">For more information, see section 9.1.2 of the specification for the Common Language Infrastructure (CLI) documentation, "Partition II: Metadata Definition and Semantics".</span></span> <span data-ttu-id="60a97-3833">La documentación está disponible en línea; vea [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) (Estándares de ECMA C# y Common Language Infrastructure) en MSDN y [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) (Estándar ECMA-335: Common Language Infrastructure [CLI]) en el sitio web de Ecma International.</span><span class="sxs-lookup"><span data-stu-id="60a97-3833">The documentation is available online; see [ECMA C# and Common Language Infrastructure Standards](https://go.microsoft.com/fwlink/?LinkID=99212) on MSDN and [Standard ECMA-335 - Common Language Infrastructure (CLI)](https://go.microsoft.com/fwlink/?LinkID=65552) on the Ecma International Web site.</span></span>  
  
 <span data-ttu-id="60a97-3834">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3834">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-3835">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3835">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-3836">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3836">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3837">En el ejemplo siguiente se crea una instancia de una clase para el que el <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> valor de enumeración en el <xref:System.Runtime.InteropServices.StructLayoutAttribute> (clase) se ha establecido, busca el <xref:System.Type.IsLayoutSequential%2A> propiedad y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3837">The following example creates an instance of a class for which the <xref:System.Runtime.InteropServices.LayoutKind.Sequential?displayProperty=nameWithType> enumeration value in the <xref:System.Runtime.InteropServices.StructLayoutAttribute> class has been set, checks for the <xref:System.Type.IsLayoutSequential%2A> property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsLayoutSequential#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsLayoutSequential/CPP/type_islayoutsequential.cpp#1)]
 [!code-csharp[Type_IsLayoutSequential#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsLayoutSequential/CS/type_islayoutsequential.cs#1)]
 [!code-vb[Type_IsLayoutSequential#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsLayoutSequential/VB/type_islayoutsequential.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAutoLayout" />
        <altmember cref="P:System.Type.IsExplicitLayout" />
        <related type="Article" href="~/docs/standard/metadata-and-self-describing-components.md"><span data-ttu-id="60a97-3838">Metadatos y componentes autodescriptivos</span><span class="sxs-lookup"><span data-stu-id="60a97-3838">Metadata and Self-Describing Components</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRef">
      <MemberSignature Language="C#" Value="public bool IsMarshalByRef { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsMarshalByRef" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsMarshalByRef" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsMarshalByRef As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsMarshalByRef { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsMarshalByRef : bool" Usage="System.Type.IsMarshalByRef" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsMarshalByRef</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3839">Obtiene un valor que indica si <see cref="T:System.Type" /> se calcula por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3839">Gets a value indicating whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <value><span data-ttu-id="60a97-3840">Es <see langword="true" /> si <see cref="T:System.Type" /> se calcula por referencia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3840"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="60a97-3841">En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3841">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="60a97-3842">Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3842">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsMarshalByRefImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsMarshalByRefImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsMarshalByRefImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsMarshalByRefImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsMarshalByRefImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsMarshalByRefImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsMarshalByRefImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsMarshalByRefImpl : unit -&gt; bool&#xA;override this.IsMarshalByRefImpl : unit -&gt; bool" Usage="type.IsMarshalByRefImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3843">Implementa la propiedad <see cref="P:System.Type.IsMarshalByRef" /> y determina si las referencias de <see cref="T:System.Type" /> se calculan por referencia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3843">Implements the <see cref="P:System.Type.IsMarshalByRef" /> property and determines whether the <see cref="T:System.Type" /> is marshaled by reference.</span></span></summary>
        <returns><span data-ttu-id="60a97-3844">Es <see langword="true" /> si <see cref="T:System.Type" /> se calcula por referencia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3844"><see langword="true" /> if the <see cref="T:System.Type" /> is marshaled by reference; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3845">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-3845">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3846">El ejemplo siguiente determina si el tipo especificado se calcula por referencia y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3846">The following example determines whether the given type is marshaled by reference and displays the result.</span></span>  
  
 [!code-cpp[Type_IsMarshalByRefImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CPP/type_ismarshalbyrefimpl.cpp#1)]
 [!code-csharp[Type_IsMarshalByRefImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsMarshalByRefImpl/CS/type_ismarshalbyrefimpl.cs#1)]
 [!code-vb[Type_IsMarshalByRefImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsMarshalByRefImpl/VB/type_ismarshalbyrefimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsMarshalByRef" />
      </Docs>
    </Member>
    <Member MemberName="IsNested">
      <MemberSignature Language="C#" Value="public bool IsNested { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNested" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNested" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNested As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNested { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNested : bool" Usage="System.Type.IsNested" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3847">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> actual representa un tipo cuya definición está anidada dentro de la definición de otro tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3847">Gets a value indicating whether the current <see cref="T:System.Type" /> object represents a type whose definition is nested inside the definition of another type.</span></span></summary>
        <value><span data-ttu-id="60a97-3848">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado dentro de otro tipo; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3848"><see langword="true" /> if the <see cref="T:System.Type" /> is nested inside another type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3849">El <xref:System.Type.IsNested%2A> propiedad devuelve `true` para todos los tipos, independientemente de la visibilidad anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3849">The <xref:System.Type.IsNested%2A> property returns `true` for all nested types, regardless of visibility.</span></span> <span data-ttu-id="60a97-3850">Para probar el anidamiento y visibilidad al mismo tiempo, utilice las propiedades relacionadas <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, o <xref:System.Type.IsNestedPublic%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3850">To test for nesting and visibility at the same time, use the related properties <xref:System.Type.IsNestedAssembly%2A>, <xref:System.Type.IsNestedFamily%2A>, <xref:System.Type.IsNestedFamANDAssem%2A>, <xref:System.Type.IsNestedFamORAssem%2A>, <xref:System.Type.IsNestedPrivate%2A>, or <xref:System.Type.IsNestedPublic%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3851">El <xref:System.Reflection.TypeAttributes.VisibilityMask> miembro de enumeración selecciona los atributos de visibilidad para un tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3851">The <xref:System.Reflection.TypeAttributes.VisibilityMask> enumeration member selects the visibility attributes for a type.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3852">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3852">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3853">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3853">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsNestedAssembly" />
        <altmember cref="P:System.Type.IsNestedFamily" />
        <altmember cref="P:System.Type.IsNestedFamANDAssem" />
        <altmember cref="P:System.Type.IsNestedFamORAssem" />
        <altmember cref="P:System.Type.IsNestedPrivate" />
        <altmember cref="P:System.Type.IsNestedPublic" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedAssembly">
      <MemberSignature Language="C#" Value="public bool IsNestedAssembly { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedAssembly" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedAssembly" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedAssembly As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedAssembly { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedAssembly : bool" Usage="System.Type.IsNestedAssembly" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedAssembly</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3854">Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propio ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3854">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own assembly.</span></span></summary>
        <value><span data-ttu-id="60a97-3855">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propio ensamblado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3855"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3856">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3856">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3857"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3857"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3858">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3858">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3859">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3859">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamANDAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamANDAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamANDAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamANDAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamANDAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamANDAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamANDAssem : bool" Usage="System.Type.IsNestedFamANDAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamANDAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3860">Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan tanto a su propia familia como a su propio ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3860">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly.</span></span></summary>
        <value><span data-ttu-id="60a97-3861">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia y a su propio ensamblado; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3861"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to both its own family and its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3862">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3862">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3863"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3863"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-3864">Los lenguajes C# y Visual Basic no incluyen semántica que le permite definir un tipo anidado que solo es visible para los tipos protegidos en su propio ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3864">The C# and Visual Basic languages do not include semantics that allow you to define a nested type that is visible only to protected types in its own assembly.</span></span> <span data-ttu-id="60a97-3865">`protected internal` visibilidad en C# y `Protected Friend` visibilidad en Visual Basic define un tipo anidado que esté visible para los tipos protegidos y tipos en el mismo ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3865">`protected internal` visibility in C# and `Protected Friend` visibility in Visual Basic define a nested type that is visible both to protected types and to types in the same assembly.</span></span>  
  
 <span data-ttu-id="60a97-3866">Un <xref:System.Type> familia del objeto se define como todos los objetos del mismo <xref:System.Type> y de sus subtipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3866">A <xref:System.Type> object's family is defined as all objects of the same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3867">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3867">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3868">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3868">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamily">
      <MemberSignature Language="C#" Value="public bool IsNestedFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamily" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamily As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamily { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamily : bool" Usage="System.Type.IsNestedFamily" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamily</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3869">Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propia familia.</span><span class="sxs-lookup"><span data-stu-id="60a97-3869">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only within its own family.</span></span></summary>
        <value><span data-ttu-id="60a97-3870">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo se ve dentro de su propia familia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3870"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only within its own family; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3871">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3871">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3872"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="60a97-3873">Un <xref:System.Type> familia del objeto se define como todos los objetos exactamente del mismo <xref:System.Type> y de sus subtipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3873">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3874">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3874">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3875">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3875">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedFamORAssem">
      <MemberSignature Language="C#" Value="public bool IsNestedFamORAssem { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedFamORAssem" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedFamORAssem" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedFamORAssem As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedFamORAssem { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedFamORAssem : bool" Usage="System.Type.IsNestedFamORAssem" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedFamORAssem</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3876">Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3876">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and visible only to classes that belong to either its own family or to its own assembly.</span></span></summary>
        <value><span data-ttu-id="60a97-3877">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y solo está visible para las clases que pertenezcan a su propia familia o a su propio ensamblado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3877"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and visible only to classes that belong to its own family or to its own assembly; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3878">Si la visibilidad de un tipo es `protected internal` en C# o `Protected Friend` en Visual Basic, el <xref:System.Type.IsNestedFamORAssem%2A> propiedad devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3878">If the visibility of a type is `protected internal` in C# or `Protected Friend` in Visual Basic, the <xref:System.Type.IsNestedFamORAssem%2A> property returns `true`.</span></span>  
  
 <span data-ttu-id="60a97-3879">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3879">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3880"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3880"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
 <span data-ttu-id="60a97-3881">Un <xref:System.Type> familia del objeto se define como todos los objetos exactamente del mismo <xref:System.Type> y de sus subtipos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3881">A <xref:System.Type> object's family is defined as all objects of the exact same <xref:System.Type> and of its subtypes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3882">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3882">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3883">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3883">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPrivate">
      <MemberSignature Language="C#" Value="public bool IsNestedPrivate { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPrivate" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPrivate" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPrivate As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPrivate { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPrivate : bool" Usage="System.Type.IsNestedPrivate" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPrivate</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3884">Obtiene un valor que indica si <see cref="T:System.Type" /> está anidado y se ha declarado privado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3884">Gets a value indicating whether the <see cref="T:System.Type" /> is nested and declared private.</span></span></summary>
        <value><span data-ttu-id="60a97-3885">Es <see langword="true" /> si <see cref="T:System.Type" /> está anidado y se ha declarado privado; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3885"><see langword="true" /> if the <see cref="T:System.Type" /> is nested and declared private; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3886">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3886">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3887"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3888">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3888">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3889">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3889">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNestedPublic">
      <MemberSignature Language="C#" Value="public bool IsNestedPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNestedPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNestedPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNestedPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNestedPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNestedPublic : bool" Usage="System.Type.IsNestedPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNestedPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3890">Obtiene un valor que indica si hay una clase anidada que se ha declarado pública.</span><span class="sxs-lookup"><span data-stu-id="60a97-3890">Gets a value indicating whether a class is nested and declared public.</span></span></summary>
        <value><span data-ttu-id="60a97-3891">Es <see langword="true" /> si la clase está anidada y se ha declarado pública; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3891"><see langword="true" /> if the class is nested and declared public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3892">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3892">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3893"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3893"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3894">El ejemplo siguiente crea una clase externa con un número de clases anidadas que tienen distintos tipos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3894">The following example creates an outer class with a number of nested classes that have various types of visibility.</span></span> <span data-ttu-id="60a97-3895">A continuación, recupera el valor de un número de relacionados con la visibilidad <xref:System.Type> propiedades para el tipo de elemento primario y cada uno de sus tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-3895">It then retrieves the value of a number of visibility-related <xref:System.Type> properties for the parent type and each of its nested types.</span></span>  
  
 [!code-csharp[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.isnestedfamandassem/cs/isnestedfamilyandassembly1.cs#1)]
 [!code-vb[System.Type.IsNestedFamAndAssem#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.isnestedfamandassem/vb/isnestedfamilyandassembly1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsNotPublic">
      <MemberSignature Language="C#" Value="public bool IsNotPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsNotPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsNotPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsNotPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsNotPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsNotPublic : bool" Usage="System.Type.IsNotPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsNotPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3896">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> no se ha declarado público.</span><span class="sxs-lookup"><span data-stu-id="60a97-3896">Gets a value indicating whether the <see cref="T:System.Type" /> is not declared public.</span></span></summary>
        <value><span data-ttu-id="60a97-3897"><see langword="true" /> si el objeto <see cref="T:System.Type" /> no se ha declarado público y no es un tipo anidado; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3897"><see langword="true" /> if the <see cref="T:System.Type" /> is not declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3898">No use esta propiedad con los tipos anidados Utilice el <xref:System.Type.IsNestedPublic%2A> propiedad en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3898">Do not use this property with nested types; use the <xref:System.Type.IsNestedPublic%2A> property instead.</span></span>  
  
 <span data-ttu-id="60a97-3899">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3899">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3900">Este ejemplo de utiliza `IsNotPublic` propiedad va a obtener la visibilidad del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3900">This example usesthe `IsNotPublic` property to get the visibility of the type.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.IsNotPublic Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#1)]
 [!code-vb[Classic Type.IsNotPublic Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#1)]  
  
 <span data-ttu-id="60a97-3901">En el ejemplo de código siguiente se muestra por qué no se puede usar `IsPublic` y `IsNotPublic` para las clases anidadas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3901">The following code example demonstrates why you cannot use `IsPublic` and `IsNotPublic` for nested classes.</span></span>  
  
 [!code-cpp[Classic Type.IsNotPublic Example#2](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CPP/source.cpp#2)]
 [!code-csharp[Classic Type.IsNotPublic Example#2](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/CS/source.cs#2)]
 [!code-vb[Classic Type.IsNotPublic Example#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.IsNotPublic Example/VB/source.vb#2)]  
  
 <span data-ttu-id="60a97-3902">Las clases anidadas, omita los resultados de `IsPublic` y `IsNotPublic` y preste atención solo a los resultados de `IsNestedPublic` y `IsNestedPrivate`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3902">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of `IsNestedPublic` and `IsNestedPrivate`.</span></span> <span data-ttu-id="60a97-3903">El resultado de la reflexión para este fragmento de código sería como sigue:</span><span class="sxs-lookup"><span data-stu-id="60a97-3903">The reflection output for this code fragment would be as follows:</span></span>  
  
|<span data-ttu-id="60a97-3904">Clase</span><span class="sxs-lookup"><span data-stu-id="60a97-3904">Class</span></span>|<span data-ttu-id="60a97-3905">IsNotPublic</span><span class="sxs-lookup"><span data-stu-id="60a97-3905">IsNotPublic</span></span>|<span data-ttu-id="60a97-3906">IsPublic</span><span class="sxs-lookup"><span data-stu-id="60a97-3906">IsPublic</span></span>|<span data-ttu-id="60a97-3907">IsNestedPublic</span><span class="sxs-lookup"><span data-stu-id="60a97-3907">IsNestedPublic</span></span>|<span data-ttu-id="60a97-3908">IsNestedPrivate</span><span class="sxs-lookup"><span data-stu-id="60a97-3908">IsNestedPrivate</span></span>|  
|-----------|-----------------|--------------|--------------------|---------------------|  
|<span data-ttu-id="60a97-3909">A</span><span class="sxs-lookup"><span data-stu-id="60a97-3909">A</span></span>|<span data-ttu-id="60a97-3910">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3910">FALSE</span></span>|<span data-ttu-id="60a97-3911">true</span><span class="sxs-lookup"><span data-stu-id="60a97-3911">TRUE</span></span>|<span data-ttu-id="60a97-3912">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3912">FALSE</span></span>|<span data-ttu-id="60a97-3913">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3913">FALSE</span></span>|  
|<span data-ttu-id="60a97-3914">B</span><span class="sxs-lookup"><span data-stu-id="60a97-3914">B</span></span>|<span data-ttu-id="60a97-3915">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3915">FALSE</span></span>|<span data-ttu-id="60a97-3916">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3916">FALSE</span></span>|<span data-ttu-id="60a97-3917">true</span><span class="sxs-lookup"><span data-stu-id="60a97-3917">TRUE</span></span>|<span data-ttu-id="60a97-3918">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3918">FALSE</span></span>|  
|<span data-ttu-id="60a97-3919">C</span><span class="sxs-lookup"><span data-stu-id="60a97-3919">C</span></span>|<span data-ttu-id="60a97-3920">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3920">FALSE</span></span>|<span data-ttu-id="60a97-3921">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3921">FALSE</span></span>|<span data-ttu-id="60a97-3922">false</span><span class="sxs-lookup"><span data-stu-id="60a97-3922">FALSE</span></span>|<span data-ttu-id="60a97-3923">true</span><span class="sxs-lookup"><span data-stu-id="60a97-3923">TRUE</span></span>|  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsPointer">
      <MemberSignature Language="C#" Value="public bool IsPointer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPointer" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPointer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPointer As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPointer { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPointer : bool" Usage="System.Type.IsPointer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPointer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3924">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es un puntero.</span><span class="sxs-lookup"><span data-stu-id="60a97-3924">Gets a value indicating whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <value><span data-ttu-id="60a97-3925">Es <see langword="true" /> si <see cref="T:System.Type" /> es un puntero; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3925"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3926">Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3926">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 <span data-ttu-id="60a97-3927">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-3927">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3928">El ejemplo siguiente muestra un uso de la `IsPointer` propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3928">The following example shows a use of the `IsPointer` property.</span></span>  
  
 [!code-cpp[Type_HasElementTypeImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_HasElementTypeImpl/CPP/type_haselementtypeimpl.cpp#1)]
 [!code-csharp[Type_HasElementTypeImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_HasElementTypeImpl/CS/type_haselementtypeimpl.cs#1)]
 [!code-vb[Type_HasElementTypeImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_HasElementTypeImpl/VB/type_haselementtypeimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Type.IsPointerImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPointerImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPointerImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPointerImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPointerImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPointerImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPointerImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPointerImpl : unit -&gt; bool" Usage="type.IsPointerImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3929">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsPointer" /> y determina si <see cref="T:System.Type" /> es un puntero.</span><span class="sxs-lookup"><span data-stu-id="60a97-3929">When overridden in a derived class, implements the <see cref="P:System.Type.IsPointer" /> property and determines whether the <see cref="T:System.Type" /> is a pointer.</span></span></summary>
        <returns><span data-ttu-id="60a97-3930">Es <see langword="true" /> si <see cref="T:System.Type" /> es un puntero; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3930"><see langword="true" /> if the <see cref="T:System.Type" /> is a pointer; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.IsPointer" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitive">
      <MemberSignature Language="C#" Value="public bool IsPrimitive { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPrimitive" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPrimitive" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPrimitive As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPrimitive { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPrimitive : bool" Usage="System.Type.IsPrimitive" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPrimitive</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3931">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es uno de los tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3931">Gets a value indicating whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <value><span data-ttu-id="60a97-3932">Es <see langword="true" /> si <see cref="T:System.Type" /> es uno de los tipos primitivos; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3932"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3933">Los tipos primitivos son <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, y <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3933">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.IntPtr>, <xref:System.UIntPtr>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
 <span data-ttu-id="60a97-3934">Si el actual <xref:System.Type> representa un tipo genérico o un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3934">If the current <xref:System.Type> represents a generic type, or a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3935">En el ejemplo siguiente se muestra el `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, y <xref:System.Type.IsPrimitive%2A> propiedades de la <xref:System.Type> clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-3935">The following example demonstrates the `IsContextful`, <xref:System.Type.IsMarshalByRef%2A>, and <xref:System.Type.IsPrimitive%2A> properties of the <xref:System.Type> class.</span></span> <span data-ttu-id="60a97-3936">Comprueba si el tipo especificado puede hospedarse en el contexto, si se pueden calcular las referencias por referencia, y si el tipo es un tipo de datos primitivo.</span><span class="sxs-lookup"><span data-stu-id="60a97-3936">It checks whether the given type can be hosted in the context, whether it can be marshaled by reference, and whether the type is a primitive data type.</span></span>  
  
 [!code-cpp[Type_IsContextful#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsContextful/CPP/type_iscontextful.cpp#1)]
 [!code-csharp[Type_IsContextful#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsContextful/CS/type_iscontextful.cs#1)]
 [!code-vb[Type_IsContextful#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsContextful/VB/type_iscontextful.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="M:System.Type.IsPrimitiveImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsPrimitiveImpl">
      <MemberSignature Language="C#" Value="protected abstract bool IsPrimitiveImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsPrimitiveImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsPrimitiveImpl" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function IsPrimitiveImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract bool IsPrimitiveImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsPrimitiveImpl : unit -&gt; bool" Usage="type.IsPrimitiveImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-3937">Cuando se invalida en una clase derivada, implementa la propiedad <see cref="P:System.Type.IsPrimitive" /> y determina si <see cref="T:System.Type" /> es uno de los tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="60a97-3937">When overridden in a derived class, implements the <see cref="P:System.Type.IsPrimitive" /> property and determines whether the <see cref="T:System.Type" /> is one of the primitive types.</span></span></summary>
        <returns><span data-ttu-id="60a97-3938">Es <see langword="true" /> si <see cref="T:System.Type" /> es uno de los tipos primitivos; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3938"><see langword="true" /> if the <see cref="T:System.Type" /> is one of the primitive types; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3939">Los tipos primitivos son <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, y <xref:System.Single>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3939">The primitive types are <xref:System.Boolean>, <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Char>, <xref:System.Double>, and <xref:System.Single>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3940">El ejemplo siguiente determina si el tipo especificado es un tipo primitivo y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3940">The following example determines whether the given type is a primitive type and displays the result.</span></span>  
  
 [!code-cpp[Type_IsPrimitiveImpl#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CPP/type_isprimitiveimpl.cpp#1)]
 [!code-csharp[Type_IsPrimitiveImpl#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsPrimitiveImpl/CS/type_isprimitiveimpl.cs#1)]
 [!code-vb[Type_IsPrimitiveImpl#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsPrimitiveImpl/VB/type_isprimitiveimpl.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Boolean" />
        <altmember cref="T:System.Byte" />
        <altmember cref="T:System.SByte" />
        <altmember cref="T:System.Int16" />
        <altmember cref="T:System.UInt16" />
        <altmember cref="T:System.Int32" />
        <altmember cref="T:System.UInt32" />
        <altmember cref="T:System.Int64" />
        <altmember cref="T:System.UInt64" />
        <altmember cref="T:System.Char" />
        <altmember cref="T:System.Double" />
        <altmember cref="T:System.Single" />
        <altmember cref="P:System.Type.IsPrimitive" />
      </Docs>
    </Member>
    <Member MemberName="IsPublic">
      <MemberSignature Language="C#" Value="public bool IsPublic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPublic" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsPublic" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPublic As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPublic { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPublic : bool" Usage="System.Type.IsPublic" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsPublic</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3941">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> se ha declarado público.</span><span class="sxs-lookup"><span data-stu-id="60a97-3941">Gets a value indicating whether the <see cref="T:System.Type" /> is declared public.</span></span></summary>
        <value><span data-ttu-id="60a97-3942"><see langword="true" /> si el objeto <see cref="T:System.Type" /> se ha declarado el público y no es un tipo anidado; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3942"><see langword="true" /> if the <see cref="T:System.Type" /> is declared public and is not a nested type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3943">No use con los tipos anidados Utilice <xref:System.Type.IsNestedPublic%2A> en su lugar.</span><span class="sxs-lookup"><span data-stu-id="60a97-3943">Do not use with nested types; use <xref:System.Type.IsNestedPublic%2A> instead.</span></span>  
  
 <span data-ttu-id="60a97-3944">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3944">If the current <xref:System.Type> represents a type parameter of a generic type, this property returns `true`.</span></span>  
  
 <span data-ttu-id="60a97-3945"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selecciona los atributos de visibilidad.</span><span class="sxs-lookup"><span data-stu-id="60a97-3945"><xref:System.Reflection.TypeAttributes.VisibilityMask?displayProperty=nameWithType> selects the visibility attributes.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3946">En el ejemplo siguiente se crea una instancia de `MyTestClass`, busca el `IsPublic` propiedad y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3946">The following example creates an instance of `MyTestClass`, checks for the `IsPublic` property, and displays the result.</span></span>  
  
 [!code-cpp[Type.IsPublic#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.IsPublic/CPP/type_ispublic.cpp#1)]
 [!code-csharp[Type.IsPublic#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.IsPublic/CS/type_ispublic.cs#1)]
 [!code-vb[Type.IsPublic#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.IsPublic/VB/type_ispublic.vb#1)]  
  
 <span data-ttu-id="60a97-3947">Las clases anidadas, omita los resultados de `IsPublic` y `IsNotPublic` y preste atención solo a los resultados de <xref:System.Type.IsNestedPublic%2A> y <xref:System.Type.IsNestedPrivate%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-3947">For nested classes, ignore the results of `IsPublic` and `IsNotPublic` and pay attention only to the results of <xref:System.Type.IsNestedPublic%2A> and <xref:System.Type.IsNestedPrivate%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSealed">
      <MemberSignature Language="C#" Value="public bool IsSealed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSealed" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSealed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSealed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSealed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSealed : bool" Usage="System.Type.IsSealed" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSealed</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3948">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> se declaró "sealed".</span><span class="sxs-lookup"><span data-stu-id="60a97-3948">Gets a value indicating whether the <see cref="T:System.Type" /> is declared sealed.</span></span></summary>
        <value><span data-ttu-id="60a97-3949">Es <see langword="true" /> si <see cref="T:System.Type" /> se declara "sealed"; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3949"><see langword="true" /> if the <see cref="T:System.Type" /> is declared sealed; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3950">Si el actual <xref:System.Type> representa un parámetro de tipo de un tipo genérico, esta propiedad siempre devuelve `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3950">If the current <xref:System.Type> represents a type parameter of a generic type, this property always returns `true`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-3951">En el ejemplo siguiente se crea una instancia de un `sealed` de clases, busca el `IsSealed` propiedad y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3951">The following example creates an instance of a `sealed` class, checks for the `IsSealed` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsSealed#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSealed/CPP/type_issealed.cpp#1)]
 [!code-csharp[Type_IsSealed#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSealed/CS/type_issealed.cs#1)]
 [!code-vb[Type_IsSealed#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSealed/VB/type_issealed.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSecurityCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityCritical : bool" Usage="System.Type.IsSecurityCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3952">Obtiene un valor que indica si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual y, por tanto, puede realizar operaciones críticas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3952">Gets a value that indicates whether the current type is security-critical or security-safe-critical at the current trust level, and therefore can perform critical operations.</span></span></summary>
        <value><span data-ttu-id="60a97-3953"><see langword="true" /> si el tipo actual es crítico para la seguridad o crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3953"><see langword="true" /> if the current type is security-critical or security-safe-critical at the current trust level; <see langword="false" /> if it is transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3954">El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="60a97-3954">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="60a97-3955">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-3955">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="60a97-3956">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="60a97-3956">Security level</span></span>|<span data-ttu-id="60a97-3957">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="60a97-3957">IsSecurityCritical</span></span>|<span data-ttu-id="60a97-3958">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="60a97-3958">IsSecuritySafeCritical</span></span>|<span data-ttu-id="60a97-3959">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="60a97-3959">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="60a97-3960">Crítico</span><span class="sxs-lookup"><span data-stu-id="60a97-3960">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="60a97-3961">Crítico seguro</span><span class="sxs-lookup"><span data-stu-id="60a97-3961">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="60a97-3962">Transparente</span><span class="sxs-lookup"><span data-stu-id="60a97-3962">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="60a97-3963">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="60a97-3963">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60a97-3964">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3964">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="60a97-3965">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3965">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="60a97-3966">El ensamblado y todos sus tipos se tratan como transparentes.</span><span class="sxs-lookup"><span data-stu-id="60a97-3966">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="60a97-3967">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="60a97-3967">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="60a97-3968">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-3968">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="60a97-3969">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-3969">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="60a97-3970">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-3970">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="60a97-3971">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-3971">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="60a97-3972">Consideraciones de seguridad sobre la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-3972">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="60a97-3973">Cambios de seguridad en .NET Framework</span><span class="sxs-lookup"><span data-stu-id="60a97-3973">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecuritySafeCritical">
      <MemberSignature Language="C#" Value="public virtual bool IsSecuritySafeCritical { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecuritySafeCritical" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecuritySafeCritical" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecuritySafeCritical As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecuritySafeCritical { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecuritySafeCritical : bool" Usage="System.Type.IsSecuritySafeCritical" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3974">Obtiene un valor que indica si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; es decir, si puede realizar operaciones críticas y está disponible desde código transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3974">Gets a value that indicates whether the current type is security-safe-critical at the current trust level; that is, whether it can perform critical operations and can be accessed by transparent code.</span></span></summary>
        <value><span data-ttu-id="60a97-3975"><see langword="true" /> si el tipo actual es crítico para la seguridad y disponible desde código transparente en el nivel de confianza actual; <see langword="false" /> si es crítico para la seguridad o transparente.</span><span class="sxs-lookup"><span data-stu-id="60a97-3975"><see langword="true" /> if the current type is security-safe-critical at the current trust level; <see langword="false" /> if it is security-critical or transparent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3976">El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="60a97-3976">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="60a97-3977">Las combinaciones de estas propiedades se muestran en la tabla siguiente:</span><span class="sxs-lookup"><span data-stu-id="60a97-3977">The combinations of these properties are shown in the following table:</span></span>  
  
|<span data-ttu-id="60a97-3978">Nivel de seguridad</span><span class="sxs-lookup"><span data-stu-id="60a97-3978">Security level</span></span>|<span data-ttu-id="60a97-3979">IsSecurityCritical</span><span class="sxs-lookup"><span data-stu-id="60a97-3979">IsSecurityCritical</span></span>|<span data-ttu-id="60a97-3980">IsSecuritySafeCritical</span><span class="sxs-lookup"><span data-stu-id="60a97-3980">IsSecuritySafeCritical</span></span>|<span data-ttu-id="60a97-3981">IsSecurityTransparent</span><span class="sxs-lookup"><span data-stu-id="60a97-3981">IsSecurityTransparent</span></span>|  
|--------------------|------------------------|----------------------------|---------------------------|  
|<span data-ttu-id="60a97-3982">Crítico</span><span class="sxs-lookup"><span data-stu-id="60a97-3982">Critical</span></span>|`true`|`false`|`false`|  
|<span data-ttu-id="60a97-3983">Crítico seguro</span><span class="sxs-lookup"><span data-stu-id="60a97-3983">Safe critical</span></span>|`true`|`true`|`false`|  
|<span data-ttu-id="60a97-3984">Transparente</span><span class="sxs-lookup"><span data-stu-id="60a97-3984">Transparent</span></span>|`false`|`false`|`true`|  
  
 <span data-ttu-id="60a97-3985">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="60a97-3985">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60a97-3986">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3986">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="60a97-3987">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-3987">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="60a97-3988">El ensamblado y todos sus tipos se tratan como transparentes.</span><span class="sxs-lookup"><span data-stu-id="60a97-3988">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="60a97-3989">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="60a97-3989">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="60a97-3990">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-3990">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="60a97-3991">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-3991">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="60a97-3992">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-3992">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="60a97-3993">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-3993">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecurityTransparent" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="60a97-3994">Consideraciones de seguridad sobre la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-3994">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="60a97-3995">Cambios de seguridad en .NET Framework</span><span class="sxs-lookup"><span data-stu-id="60a97-3995">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSecurityTransparent">
      <MemberSignature Language="C#" Value="public virtual bool IsSecurityTransparent { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSecurityTransparent" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSecurityTransparent" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSecurityTransparent As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSecurityTransparent { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSecurityTransparent : bool" Usage="System.Type.IsSecurityTransparent" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-3996">Obtiene un valor que indica si el tipo actual es transparente en el nivel de confianza actual y, por tanto, no puede realizar operaciones críticas.</span><span class="sxs-lookup"><span data-stu-id="60a97-3996">Gets a value that indicates whether the current type is transparent at the current trust level, and therefore cannot perform critical operations.</span></span></summary>
        <value><span data-ttu-id="60a97-3997"><see langword="true" /> si el tipo es transparente para la seguridad en el nivel de confianza actual; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-3997"><see langword="true" /> if the type is security-transparent at the current trust level; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-3998">Si esta propiedad devuelve `true`, <xref:System.Type.IsSecurityCritical%2A> y <xref:System.Type.IsSecuritySafeCritical%2A> devuelven propiedades `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-3998">If this property returns `true`, the <xref:System.Type.IsSecurityCritical%2A> and <xref:System.Type.IsSecuritySafeCritical%2A> properties return `false`.</span></span>  
  
 <span data-ttu-id="60a97-3999">El <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, y <xref:System.Type.IsSecurityTransparent%2A> notifican el nivel de transparencia del tipo en su nivel de confianza actual, determinado por common language runtime (CLR).</span><span class="sxs-lookup"><span data-stu-id="60a97-3999">The <xref:System.Type.IsSecurityCritical%2A>, <xref:System.Type.IsSecuritySafeCritical%2A>, and <xref:System.Type.IsSecurityTransparent%2A> properties report the transparency level of the type at its current trust level, as determined by the common language runtime (CLR).</span></span> <span data-ttu-id="60a97-4000">Usar estas propiedades es mucho más fácil que examinar las anotaciones de seguridad de un ensamblado y sus tipos, comprobar el nivel de confianza actual e intentar duplicar las reglas del runtime.</span><span class="sxs-lookup"><span data-stu-id="60a97-4000">Using these properties is much simpler than examining the security annotations of an assembly and its types, checking the current trust level, and attempting to duplicate the runtime's rules.</span></span>  
  
> [!IMPORTANT]
>  <span data-ttu-id="60a97-4001">Para los ensamblados de confianza parcial, el valor de esta propiedad depende del nivel de confianza actual del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4001">For partial-trust assemblies, the value of this property depends on the current trust level of the assembly.</span></span> <span data-ttu-id="60a97-4002">Si el ensamblado se carga en un dominio de aplicación de confianza parcial (por ejemplo, en un dominio de aplicación en espacio aislado), el runtime omite las anotaciones de seguridad del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4002">If the assembly is loaded into a partially trusted application domain (for example, into a sandboxed application domain), then the runtime ignores the security annotations of the assembly.</span></span> <span data-ttu-id="60a97-4003">El ensamblado y todos sus tipos se tratan como transparentes.</span><span class="sxs-lookup"><span data-stu-id="60a97-4003">The assembly and all its types are treated as transparent.</span></span> <span data-ttu-id="60a97-4004">El tiempo de ejecución presta atención a las anotaciones de seguridad de un ensamblado de confianza parcial sólo cuando ese ensamblado se carga en un dominio de aplicación de plena confianza (por ejemplo, en el dominio de aplicación predeterminado de una aplicación de escritorio).</span><span class="sxs-lookup"><span data-stu-id="60a97-4004">The runtime pays attention to the security annotations of a partial-trust assembly only when that assembly is loaded into a fully trusted application domain (for example, into the default application domain of a desktop application).</span></span> <span data-ttu-id="60a97-4005">Por el contrario, un ensamblado de confianza (es decir, un ensamblado con nombre seguro que se instala en la caché global de ensamblados) siempre se carga con plena confianza, independientemente del nivel de confianza del dominio de aplicación, por lo que su nivel de confianza actual siempre es de plena confianza.</span><span class="sxs-lookup"><span data-stu-id="60a97-4005">By contrast, a trusted assembly (that is, a strong-named assembly that is installed in the global assembly cache) is always loaded with full trust regardless of the trust level of the application domain, so its current trust level is always fully trusted.</span></span> <span data-ttu-id="60a97-4006">Puede determinar los niveles de confianza actuales de ensamblados y dominios de aplicación mediante el <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> y <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-4006">You can determine the current trust levels of assemblies and application domains by using the <xref:System.Reflection.Assembly.IsFullyTrusted%2A?displayProperty=nameWithType> and <xref:System.AppDomain.IsFullyTrusted%2A?displayProperty=nameWithType> properties.</span></span>  
  
 <span data-ttu-id="60a97-4007">Para obtener más información sobre la reflexión y transparencia, consulte [consideraciones de seguridad para la reflexión](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-4007">For more information about reflection and transparency, see [Security Considerations for Reflection](~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md).</span></span> <span data-ttu-id="60a97-4008">Para obtener información acerca de la transparencia, consulte [cambios de seguridad](~/docs/framework/security/security-changes.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-4008">For information about transparency, see [Security Changes](~/docs/framework/security/security-changes.md).</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Type.IsSecurityCritical" />
        <altmember cref="P:System.Type.IsSecuritySafeCritical" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/security-considerations-for-reflection.md"><span data-ttu-id="60a97-4009">Consideraciones de seguridad sobre la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-4009">Security Considerations for Reflection</span></span></related>
        <related type="Article" href="~/docs/framework/security/security-changes.md"><span data-ttu-id="60a97-4010">Cambios de seguridad en .NET Framework</span><span class="sxs-lookup"><span data-stu-id="60a97-4010">Security Changes in the .NET Framework</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="IsSerializable">
      <MemberSignature Language="C#" Value="public virtual bool IsSerializable { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSerializable" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSerializable" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSerializable As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSerializable { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSerializable : bool" Usage="System.Type.IsSerializable" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSerializable</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4011">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es serializable.</span><span class="sxs-lookup"><span data-stu-id="60a97-4011">Gets a value indicating whether the <see cref="T:System.Type" /> is serializable.</span></span></summary>
        <value><span data-ttu-id="60a97-4012">Es <see langword="true" /> si <see cref="T:System.Type" /> es serializable; de lo contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4012"><see langword="true" /> if the <see cref="T:System.Type" /> is serializable; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 
<span data-ttu-id="60a97-4013">Tipos que se definen en .NET Standard no se marcan con <xref:System.SerializableAttribute>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4013">Types that are defined in the .NET Standard are not marked with <xref:System.SerializableAttribute>.</span></span> <span data-ttu-id="60a97-4014">En su lugar, cada implementación de .NET determina si un tipo es serializable.</span><span class="sxs-lookup"><span data-stu-id="60a97-4014">Instead, each .NET implementation determines whether a type is serializable.</span></span> <span data-ttu-id="60a97-4015">En tiempo de ejecución, puede usar el <xref:System.Type.IsSerializable%2A> propiedad para determinar si esa implementación admite la serialización de una instancia del tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4015">At run time, you can use the <xref:System.Type.IsSerializable%2A> property to determine whether that implementation supports serialization of an instance of the type.</span></span> <span data-ttu-id="60a97-4016">Para obtener más información y un ejemplo, vea [cómo determinar si un objeto de .NET Standard es serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-4016">For more information and an example, see [How to determine if a .NET Standard object is serializable](~/docs/standard/serialization/how-to-determine-if-netstandard-object-is-serializable.md).</span></span>
  
 <span data-ttu-id="60a97-4017">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4017">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-4018">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4018">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-4019">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4019">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4020">En el ejemplo siguiente se crea una instancia de `MyTestClass` (clase), Establece el atributo [Serializable] y comprueba el `IsSerializable` propiedad `true` o `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4020">The following example creates an instance of `MyTestClass` class, sets the [Serializable] attribute, and checks the `IsSerializable` property for `true` or `false`.</span></span>  
  
 [!code-cpp[Type_IsSerializable#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsSerializable/CPP/type_isserializable.cpp#1)]
 [!code-csharp[Type_IsSerializable#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsSerializable/CS/type_isserializable.cs#1)]
 [!code-vb[Type_IsSerializable#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsSerializable/VB/type_isserializable.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="T:System.Runtime.Serialization.ISerializable" />
      </Docs>
    </Member>
    <Member MemberName="IsSignatureType">
      <MemberSignature Language="C#" Value="public virtual bool IsSignatureType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSignatureType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSignatureType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSignatureType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSignatureType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSignatureType : bool" Usage="System.Type.IsSignatureType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsSpecialName">
      <MemberSignature Language="C#" Value="public bool IsSpecialName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSpecialName" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSpecialName" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsSpecialName As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsSpecialName { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSpecialName : bool" Usage="System.Type.IsSpecialName" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsSpecialName</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4021">Obtiene un valor que indica si el tipo tiene un nombre que requiere un tratamiento especial.</span><span class="sxs-lookup"><span data-stu-id="60a97-4021">Gets a value indicating whether the type has a name that requires special handling.</span></span></summary>
        <value><span data-ttu-id="60a97-4022">Es <see langword="true" /> si el tipo tiene un nombre que requiere un tratamiento especial; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4022"><see langword="true" /> if the type has a name that requires special handling; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4023">Los nombres que comienzan por o contengan un carácter de subrayado (_), los descriptores de acceso de propiedad y métodos de sobrecarga de operadores son ejemplos de tipos que pueden requerir un tratamiento especial por algunos compiladores.</span><span class="sxs-lookup"><span data-stu-id="60a97-4023">Names that begin with or contain an underscore character (_), property accessors, and operator overloading methods are examples of types that might require special treatment by some compilers.</span></span>  
  
 <span data-ttu-id="60a97-4024">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4024">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-4025">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4025">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-4026">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4026">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
      </Docs>
    </Member>
    <Member MemberName="IsSubclassOf">
      <MemberSignature Language="C#" Value="public virtual bool IsSubclassOf (Type c);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool IsSubclassOf(class System.Type c) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsSubclassOf(System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function IsSubclassOf (c As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool IsSubclassOf(Type ^ c);" />
      <MemberSignature Language="F#" Value="abstract member IsSubclassOf : Type -&gt; bool&#xA;override this.IsSubclassOf : Type -&gt; bool" Usage="type.IsSubclassOf c" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.IsSubclassOf(System.Type)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="c" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="c"><span data-ttu-id="60a97-4027">Tipo que se va a comparar con el tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4027">The type to compare with the current type.</span></span></param>
        <summary><span data-ttu-id="60a97-4028">Determina si el <see cref="T:System.Type" /> actual se deriva del <see cref="T:System.Type" /> especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4028">Determines whether the current <see cref="T:System.Type" /> derives from the specified <see cref="T:System.Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-4029">Es <see langword="true" /> si el <see langword="Type" /> actual se quita de <paramref name="c" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4029"><see langword="true" /> if the current <see langword="Type" /> derives from <paramref name="c" />; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="60a97-4030">Este método también devuelve <see langword="false" /> si <paramref name="c" /> y el <see langword="Type" /> actual son iguales.</span><span class="sxs-lookup"><span data-stu-id="60a97-4030">This method also returns <see langword="false" /> if <paramref name="c" /> and the current <see langword="Type" /> are equal.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4031">Puede llamar a la <xref:System.Type.IsSubclassOf%2A> método para determinar ninguno de los siguientes:</span><span class="sxs-lookup"><span data-stu-id="60a97-4031">You can call the <xref:System.Type.IsSubclassOf%2A> method to determine any of the following:</span></span>  
  
-   <span data-ttu-id="60a97-4032">Si una clase se deriva de otro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4032">Whether one class derives from another.</span></span>  
  
-   <span data-ttu-id="60a97-4033">Si un tipo se deriva de <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4033">Whether a type derives from <xref:System.ValueType>.</span></span> <span data-ttu-id="60a97-4034">Sin embargo, el <xref:System.Type.IsValueType%2A> es una forma más eficaz para determinar si un tipo es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-4034">However, the <xref:System.Type.IsValueType%2A> is a more efficient way to determine whether a type is a value type.</span></span>  
  
-   <span data-ttu-id="60a97-4035">Si un tipo se deriva de <xref:System.Enum>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4035">Whether a type derives from <xref:System.Enum>.</span></span> <span data-ttu-id="60a97-4036">Sin embargo, el <xref:System.Type.IsEnum%2A> método es una forma más eficaz para determinar si un tipo es una enumeración.</span><span class="sxs-lookup"><span data-stu-id="60a97-4036">However, the <xref:System.Type.IsEnum%2A> method is a more efficient way to determine whether a type is an enumeration.</span></span>  
  
-   <span data-ttu-id="60a97-4037">Si un tipo es un delegado, es decir, si bien deriva <xref:System.Delegate> o <xref:System.MulticastDelegate>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4037">Whether a type is a delegate, that is, whether it derives from either <xref:System.Delegate> or <xref:System.MulticastDelegate>.</span></span>  
  
 <span data-ttu-id="60a97-4038">El <xref:System.Type.IsSubclassOf%2A> método no se puede usar para determinar si una interfaz se deriva de otra interfaz, o si una clase implementa una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4038">The <xref:System.Type.IsSubclassOf%2A> method cannot be used to determine whether an interface derives from another interface, or whether a class implements an interface.</span></span> <span data-ttu-id="60a97-4039">Use el <xref:System.Type.IsAssignableFrom%2A> método para ese propósito, como se muestra en el ejemplo siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4039">Use the <xref:System.Type.IsAssignableFrom%2A> method for that purpose, as the following example shows.</span></span>  
  
 [!code-csharp[System.Type.IsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.issubclassof/cs/issubclassof_interface1.cs#1)]
 [!code-vb[System.Type.IsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.issubclassof/vb/issubclassof_interface1.vb#1)]  
  
 <span data-ttu-id="60a97-4040">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, se deriva de su restricción de clase o de <xref:System.Object?displayProperty=nameWithType> si tiene ninguna restricción de clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-4040">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, it derives from its class constraint or from <xref:System.Object?displayProperty=nameWithType> if it has no class constraint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-4041">Excepto cuando se usa con las interfaces, <xref:System.Type.IsSubclassOf%2A> es el elemento opuesto de <xref:System.Type.IsAssignableFrom%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4041">Except when used with interfaces, <xref:System.Type.IsSubclassOf%2A> is the converse of <xref:System.Type.IsAssignableFrom%2A>.</span></span> <span data-ttu-id="60a97-4042">Es decir, si `t1.IsSubclassOf(t2)` es `true`, a continuación, `t2.IsAssignableFrom(t1)` también es `true`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4042">That is, if `t1.IsSubclassOf(t2)` is `true`, then `t2.IsAssignableFrom(t1)` is also `true`.</span></span>  
  
 <span data-ttu-id="60a97-4043">Este método puede reemplazarse por una clase derivada.</span><span class="sxs-lookup"><span data-stu-id="60a97-4043">This method can be overridden by a derived class.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4044">En el ejemplo siguiente se crea una clase denominada `Class1` y una clase derivada denominada `DerivedC1`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4044">The following example creates a class named `Class1` and a derived class named `DerivedC1`.</span></span> <span data-ttu-id="60a97-4045">Lo llama el <xref:System.Type.IsSubclassOf%2A> método para mostrar que `DerivedC1` es una subclase de `Class1`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4045">It calls the <xref:System.Type.IsSubclassOf%2A> method to show that `DerivedC1` is a subclass of `Class1`.</span></span>  
  
 [!code-csharp[TestIsSubclassOf#1](~/samples/snippets/csharp/VS_Snippets_CLR/TestIsSubclassOf/CS/testissubclassof.cs#1)]
 [!code-vb[TestIsSubclassOf#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/TestIsSubclassOf/VB/testissubclassof.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-4046">El valor de <paramref name="c" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4046"><paramref name="c" /> is <see langword="null" />.</span></span></exception>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
    <Member MemberName="IsSZArray">
      <MemberSignature Language="C#" Value="public virtual bool IsSZArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsSZArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsSZArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsSZArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsSZArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsSZArray : bool" Usage="System.Type.IsSZArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsTypeDefinition">
      <MemberSignature Language="C#" Value="public virtual bool IsTypeDefinition { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsTypeDefinition" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsTypeDefinition" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsTypeDefinition As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsTypeDefinition { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsTypeDefinition : bool" Usage="System.Type.IsTypeDefinition" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsUnicodeClass">
      <MemberSignature Language="C#" Value="public bool IsUnicodeClass { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsUnicodeClass" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsUnicodeClass" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsUnicodeClass As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsUnicodeClass { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsUnicodeClass : bool" Usage="System.Type.IsUnicodeClass" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsUnicodeClass</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4047">Obtiene un valor que indica si se selecciona el atributo de formato de cadena <see langword="UnicodeClass" /> para el objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4047">Gets a value indicating whether the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-4048">Es <see langword="true" /> si se selecciona el atributo de formato de cadena <see langword="UnicodeClass" /> para <see cref="T:System.Type" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4048"><see langword="true" /> if the string format attribute <see langword="UnicodeClass" /> is selected for the <see cref="T:System.Type" />; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4049">El <xref:System.Reflection.TypeAttributes.StringFormatMask> se utiliza para seleccionar los atributos de formato de cadena.</span><span class="sxs-lookup"><span data-stu-id="60a97-4049">The <xref:System.Reflection.TypeAttributes.StringFormatMask> is used to select the string format attributes.</span></span> <span data-ttu-id="60a97-4050">Los atributos de formato de cadena mejoran la interoperabilidad definiendo cómo se deben interpretar las cadenas.</span><span class="sxs-lookup"><span data-stu-id="60a97-4050">The string format attributes enhance interoperability by defining how strings should be interpreted.</span></span>  
  
 <span data-ttu-id="60a97-4051">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4051">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-4052">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4052">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-4053">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4053">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns `false`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsAnsiClass" />
        <altmember cref="P:System.Type.IsAutoClass" />
      </Docs>
    </Member>
    <Member MemberName="IsValueType">
      <MemberSignature Language="C#" Value="public bool IsValueType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsValueType" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsValueType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsValueType As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsValueType { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsValueType : bool" Usage="System.Type.IsValueType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.IsValueType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4054">Obtiene un valor que indica si el objeto <see cref="T:System.Type" /> es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-4054">Gets a value indicating whether the <see cref="T:System.Type" /> is a value type.</span></span></summary>
        <value><span data-ttu-id="60a97-4055">Es <see langword="true" /> si <see cref="T:System.Type" /> es un tipo de valor; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4055"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4056">Tipos de valor son tipos que se representan como secuencias de bits; tipos de valor no son clases o interfaces.</span><span class="sxs-lookup"><span data-stu-id="60a97-4056">Value types are types that are represented as sequences of bits; value types are not classes or interfaces.</span></span> <span data-ttu-id="60a97-4057">Tipos de valor se conocen como "structs" en algunos lenguajes de programación.</span><span class="sxs-lookup"><span data-stu-id="60a97-4057">Value types are referred to as "structs" in some programming languages.</span></span> <span data-ttu-id="60a97-4058">Las enumeraciones son un caso especial de tipos de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-4058">Enums are a special case of value types.</span></span>  
  
 <span data-ttu-id="60a97-4059">Esta propiedad devuelve `false` para el <xref:System.ValueType> clase porque <xref:System.ValueType> no es un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-4059">This property returns `false` for the <xref:System.ValueType> class, because <xref:System.ValueType> is not a value type itself.</span></span> <span data-ttu-id="60a97-4060">Es la clase base para todos los tipos de valor y, por lo tanto, cualquier tipo de valor puede asignarse a él.</span><span class="sxs-lookup"><span data-stu-id="60a97-4060">It is the base class for all value types, and therefore any value type can be assigned to it.</span></span> <span data-ttu-id="60a97-4061">Esto no sería posible si <xref:System.ValueType> propio era un tipo de valor.</span><span class="sxs-lookup"><span data-stu-id="60a97-4061">This would not be possible if <xref:System.ValueType> itself was a value type.</span></span> <span data-ttu-id="60a97-4062">Tipos de valor se aplica cuando se asignan a un campo de tipo <xref:System.ValueType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4062">Value types are boxed when they are assigned to a field of type <xref:System.ValueType>.</span></span>  
  
 <span data-ttu-id="60a97-4063">Esta propiedad devuelve `true` para enumeraciones, pero no para el <xref:System.Enum> propio tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4063">This property returns `true` for enumerations, but not for the <xref:System.Enum> type itself.</span></span> <span data-ttu-id="60a97-4064">Para obtener un ejemplo que demuestra este comportamiento, consulte <xref:System.Type.IsEnum%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4064">For an example that demonstrates this behavior, see <xref:System.Type.IsEnum%2A>.</span></span>  
  
 <span data-ttu-id="60a97-4065">Esta propiedad es de sólo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-4065">This property is read-only.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4066">En el ejemplo siguiente se crea una variable de tipo `MyEnum`, busca el `IsValueType` propiedad y muestra el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4066">The following example creates a variable of type `MyEnum`, checks for the `IsValueType` property, and displays the result.</span></span>  
  
 [!code-cpp[Type_IsValueType#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_IsValueType/CPP/type_isvaluetype.cpp#1)]
 [!code-csharp[Type_IsValueType#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_IsValueType/CS/type_isvaluetype.cs#1)]
 [!code-vb[Type_IsValueType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_IsValueType/VB/type_isvaluetype.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="M:System.Type.IsValueTypeImpl" />
      </Docs>
    </Member>
    <Member MemberName="IsValueTypeImpl">
      <MemberSignature Language="C#" Value="protected virtual bool IsValueTypeImpl ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance bool IsValueTypeImpl() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.IsValueTypeImpl" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Function IsValueTypeImpl () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual bool IsValueTypeImpl();" />
      <MemberSignature Language="F#" Value="abstract member IsValueTypeImpl : unit -&gt; bool&#xA;override this.IsValueTypeImpl : unit -&gt; bool" Usage="type.IsValueTypeImpl " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-4067">Implementa la propiedad <see cref="P:System.Type.IsValueType" /> y determina si <see cref="T:System.Type" /> es un tipo de valor; es decir, no es una clase ni una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4067">Implements the <see cref="P:System.Type.IsValueType" /> property and determines whether the <see cref="T:System.Type" /> is a value type; that is, not a class or an interface.</span></span></summary>
        <returns><span data-ttu-id="60a97-4068">Es <see langword="true" /> si <see cref="T:System.Type" /> es un tipo de valor; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4068"><see langword="true" /> if the <see cref="T:System.Type" /> is a value type; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4069">Este método se proporciona para habilitar la implementación de sistemas de tipo alternativo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4069">This method is provided to enable the implementation of alternate type systems.</span></span> <span data-ttu-id="60a97-4070">No se usa generalmente en el código de la aplicación.</span><span class="sxs-lookup"><span data-stu-id="60a97-4070">It is not generally used in application code.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.TypeAttributes" />
        <altmember cref="P:System.Type.IsClass" />
        <altmember cref="P:System.Type.IsInterface" />
        <altmember cref="T:System.ValueType" />
        <altmember cref="P:System.Type.IsValueType" />
      </Docs>
    </Member>
    <Member MemberName="IsVariableBoundArray">
      <MemberSignature Language="C#" Value="public virtual bool IsVariableBoundArray { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVariableBoundArray" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVariableBoundArray" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property IsVariableBoundArray As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property bool IsVariableBoundArray { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVariableBoundArray : bool" Usage="System.Type.IsVariableBoundArray" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsVisible">
      <MemberSignature Language="C#" Value="public bool IsVisible { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsVisible" />
      <MemberSignature Language="DocId" Value="P:System.Type.IsVisible" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsVisible As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsVisible { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsVisible : bool" Usage="System.Type.IsVisible" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4071">Obtiene un valor que indica si se puede obtener acceso al objeto <see cref="T:System.Type" /> mediante el código fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4071">Gets a value indicating whether the <see cref="T:System.Type" /> can be accessed by code outside the assembly.</span></span></summary>
        <value><span data-ttu-id="60a97-4072"><see langword="true" /> si el objeto <see cref="T:System.Type" /> actual es un tipo público o un tipo anidado público del que todos los tipos envolventes son públicos; de lo contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4072"><see langword="true" /> if the current <see cref="T:System.Type" /> is a public type or a public nested type such that all the enclosing types are public; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4073">Utilice esta propiedad para determinar si un tipo forma parte de la interfaz pública de un ensamblado de componente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4073">Use this property to determine whether a type is part of the public interface of a component assembly.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4074">En el ejemplo de código siguiente se prueba dos clases, solo uno de los cuales es visible fuera del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4074">The following code example tests two classes, only one of which is visible outside the assembly.</span></span>  
  
 [!code-cpp[System.Type.IsVisible#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.IsVisible/CPP/source.cpp#1)]
 [!code-csharp[System.Type.IsVisible#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.IsVisible/CS/source.cs#1)]
 [!code-vb[System.Type.IsVisible#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.IsVisible/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="MakeArrayType">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="60a97-4075">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4075">Returns a <see cref="T:System.Type" /> object that represents an array of the current type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType();" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : unit -&gt; Type&#xA;override this.MakeArrayType : unit -&gt; Type" Usage="type.MakeArrayType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-4076">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</span><span class="sxs-lookup"><span data-stu-id="60a97-4076">Returns a <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></summary>
        <returns><span data-ttu-id="60a97-4077">Objeto <see cref="T:System.Type" /> que representa una matriz unidimensional del tipo actual, con un límite inferior de cero.</span><span class="sxs-lookup"><span data-stu-id="60a97-4077">A <see cref="T:System.Type" /> object representing a one-dimensional array of the current type, with a lower bound of zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4078">El <xref:System.Type.MakeArrayType%2A> método proporciona una manera de generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-4078">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
 <span data-ttu-id="60a97-4079">**Tenga en cuenta** common language runtime hace una distinción entre los vectores (es decir, las matrices unidimensionales que siempre son de base cero) y las matrices multidimensionales.</span><span class="sxs-lookup"><span data-stu-id="60a97-4079">**Note** The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="60a97-4080">Un vector, que siempre tiene solo una dimensión, no es igual a una matriz multidimensional que se produce tener solo una dimensión.</span><span class="sxs-lookup"><span data-stu-id="60a97-4080">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="60a97-4081">Esta sobrecarga del método solo puede utilizarse para crear tipos de vector y es la única forma de crear un tipo de vector.</span><span class="sxs-lookup"><span data-stu-id="60a97-4081">This method overload can only be used to create vector types, and it is the only way to create a vector type.</span></span> <span data-ttu-id="60a97-4082">Use el <xref:System.Type.MakeArrayType%28System.Int32%29> sobrecarga del método para crear tipos de matriz multidimensional.</span><span class="sxs-lookup"><span data-stu-id="60a97-4082">Use the <xref:System.Type.MakeArrayType%28System.Int32%29> method overload to create multidimensional array types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4083">En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-4083">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4084">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4084">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="60a97-4085">Las clases derivadas deben proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-4085">Derived classes must provide an implementation.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-4086">El tipo actual es <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4086">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="60a97-4087">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4087">-or-</span></span> 
<span data-ttu-id="60a97-4088">El tipo actual es un tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4088">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="60a97-4089">Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4089">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeArrayType">
      <MemberSignature Language="C#" Value="public virtual Type MakeArrayType (int rank);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeArrayType(int32 rank) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeArrayType(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeArrayType (rank As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeArrayType(int rank);" />
      <MemberSignature Language="F#" Value="abstract member MakeArrayType : int -&gt; Type&#xA;override this.MakeArrayType : int -&gt; Type" Usage="type.MakeArrayType rank" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="rank" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="rank"><span data-ttu-id="60a97-4090">Número de dimensiones de la matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4090">The number of dimensions for the array.</span></span> <span data-ttu-id="60a97-4091">Este número debe ser menor o igual que 32.</span><span class="sxs-lookup"><span data-stu-id="60a97-4091">This number must be less than or equal to 32.</span></span></param>
        <summary><span data-ttu-id="60a97-4092">Devuelve un objeto <see cref="T:System.Type" /> que representa una matriz del tipo actual, con el número de dimensiones especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4092">Returns a <see cref="T:System.Type" /> object representing an array of the current type, with the specified number of dimensions.</span></span></summary>
        <returns><span data-ttu-id="60a97-4093">Objeto que representa una matriz del tipo actual, con el número de dimensiones especificado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4093">An object representing an array of the current type, with the specified number of dimensions.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4094">El <xref:System.Type.MakeArrayType%2A> método proporciona una manera de generar tipos de matriz cuyos tipos de elemento se calculan en tiempo de ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-4094">The <xref:System.Type.MakeArrayType%2A> method provides a way to generate array types whose element types are computed at run time.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-4095">Common language runtime hace una distinción entre los vectores (es decir, las matrices unidimensionales que siempre son de base cero) y las matrices multidimensionales.</span><span class="sxs-lookup"><span data-stu-id="60a97-4095">The common language runtime makes a distinction between vectors (that is, one-dimensional arrays that are always zero-based) and multidimensional arrays.</span></span> <span data-ttu-id="60a97-4096">Un vector, que siempre tiene solo una dimensión, no es igual a una matriz multidimensional que se produce tener solo una dimensión.</span><span class="sxs-lookup"><span data-stu-id="60a97-4096">A vector, which always has only one dimension, is not the same as a multidimensional array that happens to have only one dimension.</span></span> <span data-ttu-id="60a97-4097">No se puede utilizar esta sobrecarga del método para crear un tipo de vector; Si `rank` es 1, esta sobrecarga del método devuelve un tipo de matriz multidimensional que se produce al tener una dimensión.</span><span class="sxs-lookup"><span data-stu-id="60a97-4097">You cannot use this method overload to create a vector type; if `rank` is 1, this method overload returns a multidimensional array type that happens to have one dimension.</span></span> <span data-ttu-id="60a97-4098">Use el <xref:System.Type.MakeArrayType> sobrecarga del método para crear tipos de vector.</span><span class="sxs-lookup"><span data-stu-id="60a97-4098">Use the <xref:System.Type.MakeArrayType> method overload to create vector types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4099">En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-4099">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IndexOutOfRangeException"><span data-ttu-id="60a97-4100"><paramref name="rank" /> no es válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-4100"><paramref name="rank" /> is invalid.</span></span> <span data-ttu-id="60a97-4101">Por ejemplo, 0 o negativo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4101">For example, 0 or negative.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4102">No se admite el método invocado en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4102">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-4103">El tipo actual es <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4103">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="60a97-4104">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4104">-or-</span></span> 
<span data-ttu-id="60a97-4105">El tipo actual es un tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4105">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="60a97-4106">Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4106">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span>  
  
<span data-ttu-id="60a97-4107">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4107">-or-</span></span> 
 <span data-ttu-id="60a97-4108"><paramref name="rank" /> es mayor que 32.</span><span class="sxs-lookup"><span data-stu-id="60a97-4108"><paramref name="rank" /> is greater than 32.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeByRefType">
      <MemberSignature Language="C#" Value="public virtual Type MakeByRefType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeByRefType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeByRefType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeByRefType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeByRefType();" />
      <MemberSignature Language="F#" Value="abstract member MakeByRefType : unit -&gt; Type&#xA;override this.MakeByRefType : unit -&gt; Type" Usage="type.MakeByRefType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-4109">Devuelve un objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-4109">Returns a <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></summary>
        <returns><span data-ttu-id="60a97-4110">Objeto <see cref="T:System.Type" /> que representa el tipo actual cuando se pasa como un parámetro <see langword="ref" /> (<see langword="ByRef" /> en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-4110">A <see cref="T:System.Type" /> object that represents the current type when passed as a <see langword="ref" /> parameter (<see langword="ByRef" /> parameter in Visual Basic).</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4111">El <xref:System.Type.MakeByRefType%2A> método proporciona una manera de generar `ref` tipos (`ByRef` en Visual Basic) para el parámetro contiene una lista.</span><span class="sxs-lookup"><span data-stu-id="60a97-4111">The <xref:System.Type.MakeByRefType%2A> method provides a way to generate `ref` types (`ByRef` in Visual Basic) for parameter lists.</span></span>  
  
 <span data-ttu-id="60a97-4112">Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si el actual <xref:System.Type> objeto representa <xref:System.Int32>, este método devuelve un <xref:System.Type> que representa el objeto `Int32&`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4112">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32&`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4113">En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-4113">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4114">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4114">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-4115">El tipo actual es <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4115">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="60a97-4116">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4116">-or-</span></span> 
<span data-ttu-id="60a97-4117">El tipo actual es un tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4117">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="60a97-4118">Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4118">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeArrayType" />
        <altmember cref="M:System.Type.MakePointerType" />
      </Docs>
    </Member>
    <Member MemberName="MakeGenericMethodParameter">
      <MemberSignature Language="C#" Value="public static Type MakeGenericMethodParameter (int position);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type MakeGenericMethodParameter(int32 position) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericMethodParameter(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function MakeGenericMethodParameter (position As Integer) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ MakeGenericMethodParameter(int position);" />
      <MemberSignature Language="F#" Value="static member MakeGenericMethodParameter : int -&gt; Type" Usage="System.Type.MakeGenericMethodParameter position" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="position" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="position">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="MakeGenericType">
      <MemberSignature Language="C#" Value="public virtual Type MakeGenericType (params Type[] typeArguments);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakeGenericType(class System.Type[] typeArguments) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakeGenericType(System.Type[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakeGenericType (ParamArray typeArguments As Type()) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakeGenericType(... cli::array &lt;Type ^&gt; ^ typeArguments);" />
      <MemberSignature Language="F#" Value="abstract member MakeGenericType : Type[] -&gt; Type&#xA;override this.MakeGenericType : Type[] -&gt; Type" Usage="type.MakeGenericType typeArguments" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeArguments" Type="System.Type[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="typeArguments"><span data-ttu-id="60a97-4119">Matriz de tipos que se va a sustituir por los parámetros del tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4119">An array of types to be substituted for the type parameters of the current generic type.</span></span></param>
        <summary><span data-ttu-id="60a97-4120">Sustituye los elementos de una matriz de tipos por los parámetros de tipo de la definición de tipo genérico actual y devuelve un objeto <see cref="T:System.Type" /> que representa el tipo construido resultante.</span><span class="sxs-lookup"><span data-stu-id="60a97-4120">Substitutes the elements of an array of types for the type parameters of the current generic type definition and returns a <see cref="T:System.Type" /> object representing the resulting constructed type.</span></span></summary>
        <returns><span data-ttu-id="60a97-4121">Objeto <see cref="T:System.Type" /> que representa el tipo construido formado al sustituir los elementos de <paramref name="typeArguments" /> por los parámetros del tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4121">A <see cref="T:System.Type" /> representing the constructed type formed by substituting the elements of <paramref name="typeArguments" /> for the type parameters of the current generic type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4122">El <xref:System.Type.MakeGenericType%2A> método le permite escribir código que asigna tipos específicos a los parámetros de tipo de una definición de tipo genérico, creando así un <xref:System.Type> objeto que representa un tipo construido en particular.</span><span class="sxs-lookup"><span data-stu-id="60a97-4122">The <xref:System.Type.MakeGenericType%2A> method allows you to write code that assigns specific types to the type parameters of a generic type definition, thus creating a <xref:System.Type> object that represents a particular constructed type.</span></span> <span data-ttu-id="60a97-4123">Puede usar esto <xref:System.Type> objeto para crear instancias de tiempo de ejecución del tipo construido.</span><span class="sxs-lookup"><span data-stu-id="60a97-4123">You can use this <xref:System.Type> object to create run-time instances of the constructed type.</span></span>  
  
 <span data-ttu-id="60a97-4124">Tipos construyen con <xref:System.Type.MakeGenericType%2A> pueden estar abiertos, es decir, algunos de sus argumentos de tipo pueden ser parámetros de tipo de métodos genéricos o tipos de inclusión.</span><span class="sxs-lookup"><span data-stu-id="60a97-4124">Types constructed with <xref:System.Type.MakeGenericType%2A> can be open, that is, some of their type arguments can be type parameters of enclosing generic methods or types.</span></span> <span data-ttu-id="60a97-4125">Puede usar estos tipos construidos abiertos al emitir ensamblados dinámicos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4125">You might use such open constructed types when you emit dynamic assemblies.</span></span> <span data-ttu-id="60a97-4126">Por ejemplo, considere las clases `Base` y `Derived` en el código siguiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4126">For example, consider the classes `Base` and `Derived` in the following code.</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#1)]
 [!code-csharp[System.Type.MakeGenericType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#1)]
 [!code-vb[System.Type.MakeGenericType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#1)]  
  
 <span data-ttu-id="60a97-4127">Para generar `Derived` en un ensamblado dinámico, es necesario construir su tipo base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4127">To generate `Derived` in a dynamic assembly, it is necessary to construct its base type.</span></span> <span data-ttu-id="60a97-4128">Para ello, llame a la <xref:System.Type.MakeGenericType%2A> método en un <xref:System.Type> objeto que representa la clase `Base`, utilizando los argumentos de tipo genérico <xref:System.Int32> y el parámetro de tipo `V` desde `Derived`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4128">To do this, call the <xref:System.Type.MakeGenericType%2A> method on a <xref:System.Type> object representing the class `Base`, using the generic type arguments <xref:System.Int32> and the type parameter `V` from `Derived`.</span></span> <span data-ttu-id="60a97-4129">Dado que los tipos y parámetros de tipo genérico se representan mediante <xref:System.Type> objetos, se puede pasar una matriz que contiene ambos a la <xref:System.Type.MakeGenericType%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-4129">Because types and generic type parameters are both represented by <xref:System.Type> objects, an array containing both can be passed to the <xref:System.Type.MakeGenericType%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-4130">Un tipo construido, como `Base<int, V>` es útil cuando emitir código, pero no se puede llamar a la <xref:System.Type.MakeGenericType%2A> método en este tipo porque no es una definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4130">A constructed type such as `Base<int, V>` is useful when emitting code, but you cannot call the <xref:System.Type.MakeGenericType%2A> method on this type because it is not a generic type definition.</span></span> <span data-ttu-id="60a97-4131">Para crear un tipo construido cerrado que se puede crear instancias, primero llame a la <xref:System.Type.GetGenericTypeDefinition%2A> método para obtener un <xref:System.Type> objeto que representa la definición de tipo genérico y, a continuación, llame a <xref:System.Type.MakeGenericType%2A> con los argumentos de tipo deseado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4131">To create a closed constructed type that can be instantiated, first call the <xref:System.Type.GetGenericTypeDefinition%2A> method to get a <xref:System.Type> object representing the generic type definition and then call <xref:System.Type.MakeGenericType%2A> with the desired type arguments.</span></span>  
  
 <span data-ttu-id="60a97-4132">El <xref:System.Type> objeto devuelto por <xref:System.Type.MakeGenericType%2A> es el mismo que el <xref:System.Type> obtenido mediante una llamada a la <xref:System.Object.GetType%2A> método resultante construido tipo, o la <xref:System.Object.GetType%2A> construye de método de cualquier tipo que se creó desde la misma genérico definición de tipo con los mismos argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4132">The <xref:System.Type> object returned by <xref:System.Type.MakeGenericType%2A> is the same as the <xref:System.Type> obtained by calling the <xref:System.Object.GetType%2A> method of the resulting constructed type, or the <xref:System.Object.GetType%2A> method of any constructed type that was created from the same generic type definition using the same type arguments.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="60a97-4133">Una matriz de tipos genéricos no es un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4133">An array of generic types is not itself a generic type.</span></span> <span data-ttu-id="60a97-4134">No se puede llamar a <xref:System.Type.MakeGenericType%2A> en una matriz de tipo como `C<T>[]` (`Dim ac() As C(Of T)` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-4134">You cannot call <xref:System.Type.MakeGenericType%2A> on an array type such as `C<T>[]` (`Dim ac() As C(Of T)` in Visual Basic).</span></span> <span data-ttu-id="60a97-4135">Para construir un tipo genérico cerrado de `C<T>[]`, llame a <xref:System.Type.GetElementType%2A> para obtener la definición de tipo genérico `C<T>`; llame a <xref:System.Type.MakeGenericType%2A> en la definición de tipo genérico para crear el tipo construido; y, por último, llame a la <xref:System.Type.MakeArrayType%2A> método en el tipo construido para crear el tipo de matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4135">To construct a closed generic type from `C<T>[]`, call <xref:System.Type.GetElementType%2A> to obtain the generic type definition `C<T>`; call <xref:System.Type.MakeGenericType%2A> on the generic type definition to create the constructed type; and finally call the <xref:System.Type.MakeArrayType%2A> method on the constructed type to create the array type.</span></span> <span data-ttu-id="60a97-4136">Lo mismo puede decirse de tipos de puntero y `ref` tipos (`ByRef` en Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="60a97-4136">The same is true of pointer types and `ref` types (`ByRef` in Visual Basic).</span></span>  
  
 <span data-ttu-id="60a97-4137">Para obtener una lista de las condiciones invariables para los términos usados en la reflexión genérica, vea los comentarios de la propiedad <xref:System.Type.IsGenericType%2A>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4137">For a list of the invariant conditions for terms used in generic reflection, see the <xref:System.Type.IsGenericType%2A> property remarks.</span></span>  
  
## <a name="nested-types"></a><span data-ttu-id="60a97-4138">Tipos anidados</span><span class="sxs-lookup"><span data-stu-id="60a97-4138">Nested Types</span></span>  
 <span data-ttu-id="60a97-4139">Si se define un tipo genérico con C#, C++ o Visual Basic, sus tipos anidados son todos genéricos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4139">If a generic type is defined using C#, C++, or Visual Basic, then its nested types are all generic.</span></span> <span data-ttu-id="60a97-4140">Esto es cierto incluso si los tipos anidados no tienen ningún parámetro de tipo de sus propios, porque los tres lenguajes incluyen los parámetros de tipo de tipos envolventes en las listas de parámetros de tipo de tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-4140">This is true even if the nested types have no type parameters of their own, because all three languages include the type parameters of enclosing types in the type parameter lists of nested types.</span></span> <span data-ttu-id="60a97-4141">Tenga en cuenta las siguientes clases:</span><span class="sxs-lookup"><span data-stu-id="60a97-4141">Consider the following classes:</span></span>  
  
 [!code-cpp[System.Type.MakeGenericType#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.type.makegenerictype/cpp/remarks.cpp#2)]
 [!code-csharp[System.Type.MakeGenericType#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.makegenerictype/cs/remarks.cs#2)]
 [!code-vb[System.Type.MakeGenericType#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.makegenerictype/vb/remarks.vb#2)]  
  
 <span data-ttu-id="60a97-4142">La lista de parámetros de tipo de la clase anidada `Inner` tiene dos parámetros de tipo, `T` y `U`, el primero de los cuales es el parámetro de tipo de su clase envolvente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4142">The type parameter list of the nested class `Inner` has two type parameters, `T` and `U`, the first of which is the type parameter of its enclosing class.</span></span> <span data-ttu-id="60a97-4143">De forma similar, la lista de parámetros de tipo de la clase anidada `Innermost1` tiene tres parámetros de tipo, `T`, `U`, y `V`, con `T` y `U` procedentes de sus clases envolventes.</span><span class="sxs-lookup"><span data-stu-id="60a97-4143">Similarly, the type parameter list of the nested class `Innermost1` has three type parameters, `T`, `U`, and `V`, with `T` and `U` coming from its enclosing classes.</span></span> <span data-ttu-id="60a97-4144">La clase anidada `Innermost2` tiene dos parámetros de tipo, `T` y `U`, que proceden de sus clases envolventes.</span><span class="sxs-lookup"><span data-stu-id="60a97-4144">The nested class `Innermost2` has two type parameters, `T` and `U`, which come from its enclosing classes.</span></span>  
  
 <span data-ttu-id="60a97-4145">Si la lista de parámetros de tipo envolvente tiene más de un parámetro de tipo, se incluyen todos los parámetros de tipo en el orden en la lista de parámetros de tipo del tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4145">If the parameter list of the enclosing type has more than one type parameter, all the type parameters in order are included in the type parameter list of the nested type.</span></span>  
  
 <span data-ttu-id="60a97-4146">Para construir un tipo genérico de la definición de tipo genérico para un tipo anidado, llame a la <xref:System.Type.MakeGenericType%2A> método con la matriz formada al concatenar las matrices de argumento de tipo de todos los tipos envolventes, que comienza con el tipo genérico exterior y terminando con el tipo de matriz de argumentos del tipo anidado en Sí, si tiene sus propios parámetros de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4146">To construct a generic type from the generic type definition for a nested type, call the <xref:System.Type.MakeGenericType%2A> method with the array formed by concatenating the type argument arrays of all the enclosing types, beginning with the outermost generic type, and ending with the type argument array of the nested type itself, if it has type parameters of its own.</span></span> <span data-ttu-id="60a97-4147">Para crear una instancia de `Innermost1`, llame a la <xref:System.Type.MakeGenericType%2A> método con una matriz que contiene tres tipos, que se asignará a T, U y V. Para crear una instancia de `Innermost2`, llame a la <xref:System.Type.MakeGenericType%2A> método con una matriz que contiene dos tipos, que se asignará a T y U.</span><span class="sxs-lookup"><span data-stu-id="60a97-4147">To create an instance of `Innermost1`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing three types, to be assigned to T, U, and V. To create an instance of `Innermost2`, call the <xref:System.Type.MakeGenericType%2A> method with an array containing two types, to be assigned to T and U.</span></span>  
  
 <span data-ttu-id="60a97-4148">Los lenguajes de propagan los parámetros de tipo de tipos envolventes de esta manera, por lo que puede usar los parámetros de tipo de un tipo envolvente para definir los campos de tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-4148">The languages propagate the type parameters of enclosing types in this fashion so you can use the type parameters of an enclosing type to define fields of nested types.</span></span> <span data-ttu-id="60a97-4149">En caso contrario, los parámetros de tipo no sería en el ámbito dentro de los cuerpos de los tipos anidados.</span><span class="sxs-lookup"><span data-stu-id="60a97-4149">Otherwise, the type parameters would not be in scope within the bodies of the nested types.</span></span> <span data-ttu-id="60a97-4150">Es posible definir tipos anidados sin propagar los parámetros de tipo de tipos envolventes mediante la emisión de código en ensamblados dinámicos o mediante el uso de la [Ilasm.exe (ensamblador de IL)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-4150">It is possible to define nested types without propagating the type parameters of enclosing types, by emitting code in dynamic assemblies or by using the [Ilasm.exe (IL Assembler)](~/docs/framework/tools/ilasm-exe-il-assembler.md).</span></span> <span data-ttu-id="60a97-4151">Considere el siguiente código para el ensamblador de MSIL:</span><span class="sxs-lookup"><span data-stu-id="60a97-4151">Consider the following code for the MSIL assembler:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<U> {  
        .class nested public Innermost {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="60a97-4152">En este ejemplo, no es posible definir un campo de tipo `T` o `U` en clase `Innermost`, ya que los parámetros de tipo no están en ámbito.</span><span class="sxs-lookup"><span data-stu-id="60a97-4152">In this example, it is not possible to define a field of type `T` or `U` in class `Innermost`, because those type parameters are not in scope.</span></span> <span data-ttu-id="60a97-4153">El siguiente código ensamblador define clases anidadas que se comportan de la manera que si estuvieran definidas en C++, Visual Basic y C#:</span><span class="sxs-lookup"><span data-stu-id="60a97-4153">The following assembler code defines nested classes that behave the way they would if defined in C++, Visual Basic, and C#:</span></span>  
  
```  
.class public Outer<T> {  
    .class nested public Inner<T, U> {  
        .class nested public Innermost<T, U, V> {  
        }  
    }  
}  
```  
  
 <span data-ttu-id="60a97-4154">Puede usar el [Ildasm.exe (Desensamblador de IL)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) para examinar las clases anidadas definidas en los lenguajes de alto nivel y observar este esquema de nomenclatura.</span><span class="sxs-lookup"><span data-stu-id="60a97-4154">You can use the [Ildasm.exe (IL Disassembler)](~/docs/framework/tools/ildasm-exe-il-disassembler.md) to examine nested classes defined in the high-level languages and observe this naming scheme.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4155">En el ejemplo siguiente se usa el <xref:System.Type.MakeGenericType%2A> método para crear un tipo construido a partir de la definición de tipo genérico para el <xref:System.Collections.Generic.Dictionary%602> tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4155">The following example uses the <xref:System.Type.MakeGenericType%2A> method to create a constructed type from the generic type definition for the <xref:System.Collections.Generic.Dictionary%602> type.</span></span> <span data-ttu-id="60a97-4156">Representa el tipo construido un <xref:System.Collections.Generic.Dictionary%602> de `Test` objetos con claves de cadena.</span><span class="sxs-lookup"><span data-stu-id="60a97-4156">The constructed type represents a <xref:System.Collections.Generic.Dictionary%602> of `Test` objects with string keys.</span></span>  
  
 [!code-cpp[System.Type.BindGenericParameters#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CPP/source.cpp#1)]
 [!code-csharp[System.Type.BindGenericParameters#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.BindGenericParameters/CS/source.cs#1)]
 [!code-vb[System.Type.BindGenericParameters#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.BindGenericParameters/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="60a97-4157">El tipo actual no representa una definición de un tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4157">The current type does not represent a generic type definition.</span></span> <span data-ttu-id="60a97-4158">Es decir, <see cref="P:System.Type.IsGenericTypeDefinition" /> devuelve <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4158">That is, <see cref="P:System.Type.IsGenericTypeDefinition" /> returns <see langword="false" />.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-4159">El valor de <paramref name="typeArguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4159"><paramref name="typeArguments" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="60a97-4160">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4160">-or-</span></span> 
<span data-ttu-id="60a97-4161">Cualquier elemento de <paramref name="typeArguments" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4161">Any element of <paramref name="typeArguments" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-4162">El número de elementos de <paramref name="typeArguments" /> no es el mismo que el número de parámetros de tipo de la definición de tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4162">The number of elements in <paramref name="typeArguments" /> is not the same as the number of type parameters in the current generic type definition.</span></span>  
  
<span data-ttu-id="60a97-4163">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4163">-or-</span></span> 
<span data-ttu-id="60a97-4164">Un elemento de <paramref name="typeArguments" /> no satisface las restricciones especificadas para el parámetro de tipo correspondiente del tipo genérico actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4164">Any element of <paramref name="typeArguments" /> does not satisfy the constraints specified for the corresponding type parameter of the current generic type.</span></span>  
  
<span data-ttu-id="60a97-4165">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4165">-or-</span></span> 
 <span data-ttu-id="60a97-4166"><paramref name="typeArguments" /> contiene un elemento que es un tipo de puntero (<see cref="P:System.Type.IsPointer" /> devuelve <see langword="true" />), un tipo por referencia (<see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />), o <see cref="T:System.Void" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4166"><paramref name="typeArguments" /> contains an element that is a pointer type (<see cref="P:System.Type.IsPointer" /> returns <see langword="true" />), a by-ref type (<see cref="P:System.Type.IsByRef" /> returns <see langword="true" />), or <see cref="T:System.Void" />.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4167">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4167">The invoked method is not supported in the base class.</span></span> <span data-ttu-id="60a97-4168">Las clases derivadas deben proporcionar una implementación.</span><span class="sxs-lookup"><span data-stu-id="60a97-4168">Derived classes must provide an implementation.</span></span></exception>
        <altmember cref="P:System.Type.IsGenericTypeDefinition" />
        <altmember cref="M:System.Type.GetGenericTypeDefinition" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/reflection-and-generic-types.md"><span data-ttu-id="60a97-4169">Reflexión y tipos genéricos</span><span class="sxs-lookup"><span data-stu-id="60a97-4169">Reflection and Generic Types</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-examine-and-instantiate-generic-types-with-reflection.md"><span data-ttu-id="60a97-4170">Cómo: Examinar y crear instancias de tipos genéricos mediante la reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-4170">How to: Examine and Instantiate Generic Types with Reflection</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="MakePointerType">
      <MemberSignature Language="C#" Value="public virtual Type MakePointerType ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Type MakePointerType() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.MakePointerType" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function MakePointerType () As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual Type ^ MakePointerType();" />
      <MemberSignature Language="F#" Value="abstract member MakePointerType : unit -&gt; Type&#xA;override this.MakePointerType : unit -&gt; Type" Usage="type.MakePointerType " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-4171">Devuelve un objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4171">Returns a <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></summary>
        <returns><span data-ttu-id="60a97-4172">Objeto <see cref="T:System.Type" /> que representa un puntero al tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4172">A <see cref="T:System.Type" /> object that represents a pointer to the current type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4173">El <xref:System.Type.MakePointerType%2A> método proporciona una manera de generar los tipos de puntero para listas de parámetros.</span><span class="sxs-lookup"><span data-stu-id="60a97-4173">The <xref:System.Type.MakePointerType%2A> method provides a way to generate pointer types for parameter lists.</span></span>  
  
 <span data-ttu-id="60a97-4174">Mediante la sintaxis de lenguaje intermedio de Microsoft (MSIL), si el actual <xref:System.Type> objeto representa <xref:System.Int32>, este método devuelve un <xref:System.Type> que representa el objeto `Int32*`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4174">Using the syntax of Microsoft intermediate language (MSIL), if the current <xref:System.Type> object represents <xref:System.Int32>, this method returns a <xref:System.Type> object representing `Int32*`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4175">En el ejemplo de código siguiente se crea la matriz, `ref` (`ByRef` en Visual Basic) y tipos de puntero para el `Test` clase.</span><span class="sxs-lookup"><span data-stu-id="60a97-4175">The following code example creates array, `ref` (`ByRef` in Visual Basic), and pointer types for the `Test` class.</span></span>  
  
 [!code-cpp[System.Type.MakeXxxType#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CPP/source.cpp#1)]
 [!code-csharp[System.Type.MakeXxxType#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Type.MakeXxxType/CS/source.cs#1)]
 [!code-vb[System.Type.MakeXxxType#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Type.MakeXxxType/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4176">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4176">The invoked method is not supported in the base class.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-4177">El tipo actual es <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4177">The current type is <see cref="T:System.TypedReference" />.</span></span>  
  
<span data-ttu-id="60a97-4178">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4178">-or-</span></span> 
<span data-ttu-id="60a97-4179">El tipo actual es un tipo <see langword="ByRef" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4179">The current type is a <see langword="ByRef" /> type.</span></span> <span data-ttu-id="60a97-4180">Es decir, <see cref="P:System.Type.IsByRef" /> devuelve <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4180">That is, <see cref="P:System.Type.IsByRef" /> returns <see langword="true" />.</span></span></exception>
        <altmember cref="M:System.Type.MakeByRefType" />
        <altmember cref="M:System.Type.MakeArrayType" />
      </Docs>
    </Member>
    <Member MemberName="MemberType">
      <MemberSignature Language="C#" Value="public override System.Reflection.MemberTypes MemberType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Reflection.MemberTypes MemberType" />
      <MemberSignature Language="DocId" Value="P:System.Type.MemberType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MemberType As MemberTypes" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Reflection::MemberTypes MemberType { System::Reflection::MemberTypes get(); };" />
      <MemberSignature Language="F#" Value="member this.MemberType : System.Reflection.MemberTypes" Usage="System.Type.MemberType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.MemberType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.MemberTypes</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4181">Obtiene un valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un tipo o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4181">Gets a <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></summary>
        <value><span data-ttu-id="60a97-4182">Valor de <see cref="T:System.Reflection.MemberTypes" /> que indica que este miembro es un tipo o un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4182">A <see cref="T:System.Reflection.MemberTypes" /> value indicating that this member is a type or a nested type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4183">Esta propiedad invalida <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4183">This property overrides <xref:System.Reflection.MemberInfo.MemberType%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="60a97-4184">Por lo tanto, cuando se examina un conjunto de <xref:System.Reflection.MemberInfo> objetos: por ejemplo, la matriz devuelta por <xref:System.Type.GetMembers%2A> : la <xref:System.Reflection.MemberInfo.MemberType%2A> propiedad devuelve <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> cuando un miembro determinado es un tipo anidado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4184">Therefore, when you examine a set of <xref:System.Reflection.MemberInfo> objects - for example, the array returned by <xref:System.Type.GetMembers%2A> - the <xref:System.Reflection.MemberInfo.MemberType%2A> property returns <xref:System.Reflection.MemberTypes.NestedType?displayProperty=nameWithType> when a given member is a nested type.</span></span>  
  
 <span data-ttu-id="60a97-4185">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad se aplica a la definición de tipo genérico del que se construyó el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4185">If the current <xref:System.Type> represents a constructed generic type, this property applies to the generic type definition from which the type was constructed.</span></span> <span data-ttu-id="60a97-4186">Por ejemplo, si el actual <xref:System.Type> representa `MyGenericType<int>` (`MyGenericType(Of Integer)` en Visual Basic), el valor de esta propiedad viene determinada por `MyGenericType<T>`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4186">For example, if the current <xref:System.Type> represents `MyGenericType<int>` (`MyGenericType(Of Integer)` in Visual Basic), the value of this property is determined by `MyGenericType<T>`.</span></span>  
  
 <span data-ttu-id="60a97-4187">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad siempre devuelve <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4187">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property always returns <xref:System.Reflection.MemberTypes.TypeInfo?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4188">El siguiente ejemplo de código muestra la `MemberType` campo como un parámetro a la `GetMember` método:</span><span class="sxs-lookup"><span data-stu-id="60a97-4188">The following code example shows the `MemberType` field as a parameter to the `GetMember` method:</span></span>  
  
 [!code-cpp[Classic Type.MemberType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.MemberType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.MemberType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.MemberType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.MemberType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberTypes" />
      </Docs>
    </Member>
    <Member MemberName="Missing">
      <MemberSignature Language="C#" Value="public static readonly object Missing;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly object Missing" />
      <MemberSignature Language="DocId" Value="F:System.Type.Missing" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Missing As Object " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Object ^ Missing;" />
      <MemberSignature Language="F#" Value=" staticval mutable Missing : obj" Usage="System.Type.Missing" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4189">Representa un valor que falta en la información de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4189">Represents a missing value in the <see cref="T:System.Type" /> information.</span></span> <span data-ttu-id="60a97-4190">Este campo es de solo lectura.</span><span class="sxs-lookup"><span data-stu-id="60a97-4190">This field is read-only.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4191">Use el `Missing` campo para la invocación mediante reflexión para obtener el valor predeterminado de un parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4191">Use the `Missing` field for invocation through reflection to obtain the default value of a parameter.</span></span> <span data-ttu-id="60a97-4192">Si el `Missing` campo se pasa un valor de parámetro y no hay ningún valor predeterminado para ese parámetro, un <xref:System.ArgumentException> se produce.</span><span class="sxs-lookup"><span data-stu-id="60a97-4192">If the `Missing` field is passed in for a parameter value and there is no default value for that parameter, an <xref:System.ArgumentException> is thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4193">En el ejemplo de código siguiente se muestra el uso de la `Missing` campo para invocar un método con sus argumentos predeterminados.</span><span class="sxs-lookup"><span data-stu-id="60a97-4193">The following code example shows the use of the `Missing` field to invoke a method with its default arguments.</span></span>  
  
 [!code-cpp[Classic Type.Missing Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cpp/source.cpp#1)]
 [!code-csharp[Classic Type.Missing Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.Missing Example/cs/source.cs#1)]
 [!code-vb[Classic Type.Missing Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.Missing Example/VB/source.vb#1)]  
  
 <span data-ttu-id="60a97-4194">Este código genera el siguiente resultado:</span><span class="sxs-lookup"><span data-stu-id="60a97-4194">This code produces the following output:</span></span>  
  
 <span data-ttu-id="60a97-4195">un = 10 b = 55.3 c = 12</span><span class="sxs-lookup"><span data-stu-id="60a97-4195">a = 10 b = 55.3 c = 12</span></span>  
  
 <span data-ttu-id="60a97-4196">un = 10 b = 1.3 c = 1</span><span class="sxs-lookup"><span data-stu-id="60a97-4196">a = 10 b = 1.3 c = 1</span></span>  
  
 <span data-ttu-id="60a97-4197">un = 10 b = 1.2 c = 1</span><span class="sxs-lookup"><span data-stu-id="60a97-4197">a = 10 b = 1.2 c = 1</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Missing" />
      </Docs>
    </Member>
    <Member MemberName="Module">
      <MemberSignature Language="C#" Value="public abstract System.Reflection.Module Module { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.Module Module" />
      <MemberSignature Language="DocId" Value="P:System.Type.Module" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Module As Module" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Reflection::Module ^ Module { System::Reflection::Module ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Module : System.Reflection.Module" Usage="System.Type.Module" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Module</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Reflection.Module</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4198">Obtiene el módulo (la DLL) en que se define el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4198">Gets the module (the DLL) in which the current <see cref="T:System.Type" /> is defined.</span></span></summary>
        <value><span data-ttu-id="60a97-4199">Módulo en el que se define el objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4199">The module in which the current <see cref="T:System.Type" /> is defined.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4200">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve el módulo en el que se ha definido la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4200">If the current <xref:System.Type> represents a constructed generic type, this property returns the module in which the generic type definition was defined.</span></span> <span data-ttu-id="60a97-4201">Por ejemplo, si crea una instancia de `MyGenericStack<int>`, <xref:System.Type.Module%2A> propiedad para el tipo construido devuelve el módulo en el que `MyGenericStack<T>` está definido.</span><span class="sxs-lookup"><span data-stu-id="60a97-4201">For example, if you create an instance of `MyGenericStack<int>`, the <xref:System.Type.Module%2A> property for the constructed type returns the module in which `MyGenericStack<T>` is defined.</span></span>  
  
 <span data-ttu-id="60a97-4202">De forma similar, si el actual <xref:System.Type> representa un parámetro genérico `T`, esta propiedad devuelve el ensamblado que contiene el tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4202">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the assembly that contains the generic type that defines `T`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4203">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.Namespace%2A> y `Module` propiedades y el <xref:System.Type.ToString%2A> método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4203">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and `Module` properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.Module" />
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Type.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Type.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Namespace">
      <MemberSignature Language="C#" Value="public abstract string Namespace { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Namespace" />
      <MemberSignature Language="DocId" Value="P:System.Type.Namespace" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Namespace As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Namespace { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Namespace : string" Usage="System.Type.Namespace" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.Namespace</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4204">Obtiene el espacio de nombres de <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4204">Gets the namespace of the <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-4205">Espacio de nombres de <see cref="T:System.Type" />; <see langword="null" /> si la instancia actual no tiene un espacio de nombres o representa un parámetro genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4205">The namespace of the <see cref="T:System.Type" />; <see langword="null" /> if the current instance has no namespace or represents a generic parameter.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4206">Un espacio de nombres es una ventaja nomenclatura de tiempo de diseño lógica, que se usa principalmente para definir un ámbito en una aplicación y organizar clases y otros tipos en una única estructura jerárquica.</span><span class="sxs-lookup"><span data-stu-id="60a97-4206">A namespace is a logical design-time naming convenience, used mainly to define scope in an application and organize classes and other types in a single hierarchical structure.</span></span> <span data-ttu-id="60a97-4207">Desde el punto de vista del tiempo de ejecución, no hay ningún espacio de nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-4207">From the viewpoint of the runtime, there are no namespaces.</span></span>  
  
 <span data-ttu-id="60a97-4208">Si el actual <xref:System.Type> representa un tipo genérico construido, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico.</span><span class="sxs-lookup"><span data-stu-id="60a97-4208">If the current <xref:System.Type> represents a constructed generic type, this property returns the namespace that contains the generic type definition.</span></span> <span data-ttu-id="60a97-4209">De forma similar, si el actual <xref:System.Type> representa un parámetro genérico `T`, esta propiedad devuelve el espacio de nombres que contiene la definición de tipo genérico que define `T`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4209">Similarly, if the current <xref:System.Type> represents a generic parameter `T`, this property returns the namespace that contains the generic type definition that defines `T`.</span></span>  
  
 <span data-ttu-id="60a97-4210">Si el actual <xref:System.Type> objeto representa un parámetro genérico, esta propiedad devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4210">If the current <xref:System.Type> object represents a generic parameter, this property returns `null`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4211">En el ejemplo siguiente se muestra cómo utilizar el `Namespace` y <xref:System.Type.Module%2A> propiedades y el <xref:System.Type.ToString%2A> método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4211">This following example demonstrates a use of the `Namespace` and <xref:System.Type.Module%2A> properties and the <xref:System.Type.ToString%2A> method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
        <altmember cref="P:System.Type.FullName" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-4212">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-4212">Specifying Fully Qualified Type Names</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Equality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : Type * Type -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60a97-4213">Primer objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4213">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="60a97-4214">Segundo objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4214">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="60a97-4215">Indica si dos objetos <see cref="T:System.Type" /> son iguales.</span><span class="sxs-lookup"><span data-stu-id="60a97-4215">Indicates whether two <see cref="T:System.Type" /> objects are equal.</span></span></summary>
        <returns><span data-ttu-id="60a97-4216"><see langword="true" /> si <paramref name="left" /> es igual a <paramref name="right" />; en caso contrario, <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4216"><see langword="true" /> if <paramref name="left" /> is equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (Type left, Type right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(class System.Type left, class System.Type right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.op_Inequality(System.Type,System.Type)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Type, right As Type) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(Type ^ left, Type ^ right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : Type * Type -&gt; bool" Usage="System.Type.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netcore-2.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Type" />
        <Parameter Name="right" Type="System.Type" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="60a97-4217">Primer objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4217">The first object to compare.</span></span></param>
        <param name="right"><span data-ttu-id="60a97-4218">Segundo objeto que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4218">The second object to compare.</span></span></param>
        <summary><span data-ttu-id="60a97-4219">Indica si dos objetos <see cref="T:System.Type" /> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="60a97-4219">Indicates whether two <see cref="T:System.Type" /> objects are not equal.</span></span></summary>
        <returns><span data-ttu-id="60a97-4220">Es <see langword="true" /> si <paramref name="left" /> no es igual a <paramref name="right" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4220"><see langword="true" /> if <paramref name="left" /> is not equal to <paramref name="right" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ReflectedType">
      <MemberSignature Language="C#" Value="public override Type ReflectedType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type ReflectedType" />
      <MemberSignature Language="DocId" Value="P:System.Type.ReflectedType" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property ReflectedType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property Type ^ ReflectedType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ReflectedType : Type" Usage="System.Type.ReflectedType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.ReflectedType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4221">Obtiene el objeto de clase usado para obtener este miembro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4221">Gets the class object that was used to obtain this member.</span></span></summary>
        <value><span data-ttu-id="60a97-4222">Objeto <see langword="Type" /> a través del cual se obtuvo este objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4222">The <see langword="Type" /> object through which this <see cref="T:System.Type" /> object was obtained.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4223">Para <xref:System.Type> objetos, el valor de esta propiedad siempre es el mismo que el valor de la <xref:System.Type.DeclaringType%2A> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-4223">For <xref:System.Type> objects, the value of this property is always the same as the value of the <xref:System.Type.DeclaringType%2A> property.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4224">Este ejemplo muestra el tipo reflejado de una clase anidada.</span><span class="sxs-lookup"><span data-stu-id="60a97-4224">This example displays the reflected type of a nested class.</span></span>  
  
 [!code-cpp[Classic Type.ReflectedType Example#1](~/samples/snippets/cpp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Type.ReflectedType Example#1](~/samples/snippets/csharp/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/CS/source.cs#1)]
 [!code-vb[Classic Type.ReflectedType Example#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_Classic/classic Type.ReflectedType Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.MemberInfo" />
        <altmember cref="P:System.Type.DeclaringType" />
      </Docs>
    </Member>
    <Member MemberName="ReflectionOnlyGetType">
      <MemberSignature Language="C#" Value="public static Type ReflectionOnlyGetType (string typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ReflectionOnlyGetType(System.String,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ReflectionOnlyGetType (typeName As String, throwIfNotFound As Boolean, ignoreCase As Boolean) As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static Type ^ ReflectionOnlyGetType(System::String ^ typeName, bool throwIfNotFound, bool ignoreCase);" />
      <MemberSignature Language="F#" Value="static member ReflectionOnlyGetType : string * bool * bool -&gt; Type" Usage="System.Type.ReflectionOnlyGetType (typeName, throwIfNotFound, ignoreCase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="typeName" Type="System.String" />
        <Parameter Name="throwIfNotFound" Type="System.Boolean" />
        <Parameter Name="ignoreCase" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="typeName"><span data-ttu-id="60a97-4225">Nombre calificado con el ensamblado del <see cref="T:System.Type" /> que se va a obtener.</span><span class="sxs-lookup"><span data-stu-id="60a97-4225">The assembly-qualified name of the <see cref="T:System.Type" /> to get.</span></span></param>
        <param name="throwIfNotFound"><span data-ttu-id="60a97-4226"><see langword="true" /> para iniciar una excepción <see cref="T:System.TypeLoadException" /> si no se puede encontrar el tipo; <see langword="false" /> para devolver <see langword="null" /> si el tipo no se puede encontrar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4226"><see langword="true" /> to throw a <see cref="T:System.TypeLoadException" /> if the type cannot be found; <see langword="false" /> to return <see langword="null" /> if the type cannot be found.</span></span> <span data-ttu-id="60a97-4227">Si se especifica <see langword="false" /> se suprimen otras condiciones de excepción, pero no todas.</span><span class="sxs-lookup"><span data-stu-id="60a97-4227">Specifying <see langword="false" /> also suppresses some other exception conditions, but not all of them.</span></span> <span data-ttu-id="60a97-4228">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-4228">See the Exceptions section.</span></span></param>
        <param name="ignoreCase"><span data-ttu-id="60a97-4229"><see langword="true" /> para realizar una búsqueda de <paramref name="typeName" /> que no distinga entre mayúsculas y minúsculas; <see langword="false" /> para realizar una búsqueda de <paramref name="typeName" /> que distinga entre mayúsculas y minúsculas.</span><span class="sxs-lookup"><span data-stu-id="60a97-4229"><see langword="true" /> to perform a case-insensitive search for <paramref name="typeName" />; <see langword="false" /> to perform a case-sensitive search for <paramref name="typeName" />.</span></span></param>
        <summary><span data-ttu-id="60a97-4230">Obtiene el objeto <see cref="T:System.Type" /> con el nombre indicado, que especifica si se va a realizar una búsqueda donde se distingue entre mayúsculas y minúsculas y si se va a producir una excepción en caso de que no se encuentre el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4230">Gets the <see cref="T:System.Type" /> with the specified name, specifying whether to perform a case-sensitive search and whether to throw an exception if the type is not found.</span></span> <span data-ttu-id="60a97-4231">Se carga el tipo solo para reflexión, no para ejecución.</span><span class="sxs-lookup"><span data-stu-id="60a97-4231">The type is loaded for reflection only, not for execution.</span></span></summary>
        <returns><span data-ttu-id="60a97-4232">Tipo con el nombre especificado, si se encuentra; de lo contrario <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4232">The type with the specified name, if found; otherwise, <see langword="null" />.</span></span> <span data-ttu-id="60a97-4233">Si el tipo no se encuentra, el parámetro <paramref name="throwIfNotFound" /> especifica si se devuelve <see langword="null" /> o se produce una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-4233">If the type is not found, the <paramref name="throwIfNotFound" /> parameter specifies whether <see langword="null" /> is returned or an exception is thrown.</span></span> <span data-ttu-id="60a97-4234">En algunos casos, se produce una excepción con independencia del valor de <paramref name="throwIfNotFound" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4234">In some cases, an exception is thrown regardless of the value of <paramref name="throwIfNotFound" />.</span></span> <span data-ttu-id="60a97-4235">Vea la sección Excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-4235">See the Exceptions section.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4236">Si el ensamblado que contiene el tipo ya no se carga en el contexto de solo reflexión, usando la <xref:System.Type.ReflectionOnlyGetType%2A> método es equivalente a la primera carga el ensamblado solo para reflexión, utilizando el <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> método y, a continuación, cargar el tipo mediante una llamada a la del ensamblado <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-4236">If the assembly containing the type is not already loaded into the reflection-only context, using the <xref:System.Type.ReflectionOnlyGetType%2A> method is equivalent to first loading the assembly for reflection only, using the <xref:System.Reflection.Assembly.ReflectionOnlyLoad%2A> method, and then loading the type by calling the assembly's <xref:System.Reflection.Assembly.GetType%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="60a97-4237">Para obtener información acerca de los nombres de ensamblado, vea el <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-4237">For information about assembly-qualified names, see the <xref:System.Type.AssemblyQualifiedName%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="60a97-4238">Para obtener más información sobre cómo especificar los nombres de tipo, consulte el <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> sobrecarga del método.</span><span class="sxs-lookup"><span data-stu-id="60a97-4238">For additional details on specifying type names, see the <xref:System.Type.GetType%28System.String%2CSystem.Boolean%2CSystem.Boolean%29> method overload.</span></span>  
  
 <span data-ttu-id="60a97-4239">Si el ensamblado ya está cargado para la ejecución, se carga otra copia en el contexto de solo reflexión.</span><span class="sxs-lookup"><span data-stu-id="60a97-4239">If the assembly is already loaded for execution, another copy is loaded into the reflection-only context.</span></span>  
  
 <span data-ttu-id="60a97-4240">El `throwIfNotFound` parámetro especifica lo que sucede cuando no se encuentra el tipo y también suprime algunas condiciones de excepción, como se describe en la sección excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-4240">The `throwIfNotFound` parameter specifies what happens when the type is not found, and also suppresses certain other exception conditions, as described in the Exceptions section.</span></span> <span data-ttu-id="60a97-4241">Algunas excepciones se producen independientemente del valor de `throwIfNotFound`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4241">Some exceptions are thrown regardless of the value of `throwIfNotFound`.</span></span> <span data-ttu-id="60a97-4242">Por ejemplo, si el ensamblado no es válido, un <xref:System.BadImageFormatException> se produce incluso si `throwIfNotFound` es `false`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4242">For example, if the assembly is not valid, a <xref:System.BadImageFormatException> is thrown even if `throwIfNotFound` is `false`.</span></span>  
  
 <span data-ttu-id="60a97-4243">Para obtener más información sobre cómo usar el contexto de solo reflexión, vea [Cómo: Cargar ensamblados en el contexto de solo reflexión](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span><span class="sxs-lookup"><span data-stu-id="60a97-4243">For more information about using the reflection-only context, see [How to: Load Assemblies into the Reflection-Only Context](~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="60a97-4244">El valor de <paramref name="typeName" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4244"><paramref name="typeName" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Reflection.TargetInvocationException"><span data-ttu-id="60a97-4245">Se invoca un inicializador de clase y genera una excepción.</span><span class="sxs-lookup"><span data-stu-id="60a97-4245">A class initializer is invoked and throws an exception.</span></span></exception>
        <exception cref="T:System.TypeLoadException"><span data-ttu-id="60a97-4246"><paramref name="throwIfNotFound" /> es <see langword="true" /> y no se encuentra el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4246"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the type is not found.</span></span>  
  
<span data-ttu-id="60a97-4247">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4247">-or-</span></span> 
 <span data-ttu-id="60a97-4248"><paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> contiene caracteres no válidos, como una pestaña insertada.</span><span class="sxs-lookup"><span data-stu-id="60a97-4248"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid characters, such as an embedded tab.</span></span> 
<span data-ttu-id="60a97-4249">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4249">-or-</span></span> 
 <span data-ttu-id="60a97-4250"><paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> es una cadena vacía.</span><span class="sxs-lookup"><span data-stu-id="60a97-4250"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> is an empty string.</span></span>  
  
<span data-ttu-id="60a97-4251">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4251">-or-</span></span> 
 <span data-ttu-id="60a97-4252"><paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> representa un tipo de matriz con un tamaño no válido.</span><span class="sxs-lookup"><span data-stu-id="60a97-4252"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> represents an array type with an invalid size.</span></span>  
  
<span data-ttu-id="60a97-4253">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4253">-or-</span></span> 
 <span data-ttu-id="60a97-4254"><paramref name="typeName" /> representa una matriz de objetos <see cref="T:System.TypedReference" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4254"><paramref name="typeName" /> represents an array of <see cref="T:System.TypedReference" /> objects.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="60a97-4255"><paramref name="typeName" /> no incluye el nombre del ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4255"><paramref name="typeName" /> does not include the assembly name.</span></span>  
  
<span data-ttu-id="60a97-4256">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4256">-or-</span></span> 
 <span data-ttu-id="60a97-4257"><paramref name="throwIfNotFound" /> es <see langword="true" /> y <paramref name="typeName" /> contiene sintaxis no válida; por ejemplo, "MyType[,\*,]".</span><span class="sxs-lookup"><span data-stu-id="60a97-4257"><paramref name="throwIfNotFound" /> is <see langword="true" /> and <paramref name="typeName" /> contains invalid syntax; for example, "MyType[,\*,]".</span></span>  
  
<span data-ttu-id="60a97-4258">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4258">-or-</span></span> 
 <span data-ttu-id="60a97-4259"><paramref name="typeName" /> representa un tipo genérico que tiene un tipo de puntero, un tipo <see langword="ByRef" /> o <see cref="T:System.Void" /> como uno de sus argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4259"><paramref name="typeName" /> represents a generic type that has a pointer type, a <see langword="ByRef" /> type, or <see cref="T:System.Void" /> as one of its type arguments.</span></span>  
  
<span data-ttu-id="60a97-4260">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4260">-or-</span></span> 
 <span data-ttu-id="60a97-4261"><paramref name="typeName" /> representa un tipo genérico que tiene un número incorrecto de argumentos de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4261"><paramref name="typeName" /> represents a generic type that has an incorrect number of type arguments.</span></span>  
  
<span data-ttu-id="60a97-4262">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4262">-or-</span></span> 
 <span data-ttu-id="60a97-4263"><paramref name="typeName" /> representa un tipo genérico y uno de sus argumentos de tipo no satisface las restricciones del parámetro de tipo correspondiente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4263"><paramref name="typeName" /> represents a generic type, and one of its type arguments does not satisfy the constraints for the corresponding type parameter.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="60a97-4264"><paramref name="throwIfNotFound" /> es <see langword="true" /> y no se encontró el ensamblado o alguna de sus dependencias.</span><span class="sxs-lookup"><span data-stu-id="60a97-4264"><paramref name="throwIfNotFound" /> is <see langword="true" /> and the assembly or one of its dependencies was not found.</span></span></exception>
        <exception cref="T:System.IO.FileLoadException"><span data-ttu-id="60a97-4265">Se encontró el ensamblado o una de sus dependencias, pero no se pudo cargar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4265">The assembly or one of its dependencies was found, but could not be loaded.</span></span></exception>
        <exception cref="T:System.BadImageFormatException"><span data-ttu-id="60a97-4266">El ensamblado o alguna de sus dependencias no son válidos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4266">The assembly or one of its dependencies is not valid.</span></span>  
  
<span data-ttu-id="60a97-4267">O bien</span><span class="sxs-lookup"><span data-stu-id="60a97-4267">-or-</span></span> 
<span data-ttu-id="60a97-4268">El ensamblado se compiló con una versión de Common Language Runtime posterior a la versión que está cargada actualmente.</span><span class="sxs-lookup"><span data-stu-id="60a97-4268">The assembly was compiled with a later version of the common language runtime than the version that is currently loaded.</span></span></exception>
        <altmember cref="T:System.String" />
        <altmember cref="T:System.TypeLoadException" />
        <altmember cref="P:System.Type.AssemblyQualifiedName" />
        <altmember cref="M:System.Reflection.Assembly.GetAssembly(System.Type)" />
        <altmember cref="M:System.Reflection.Assembly.GetType(System.String)" />
        <altmember cref="T:System.Reflection.AssemblyName" />
        <related type="Article" href="~/docs/framework/reflection-and-codedom/specifying-fully-qualified-type-names.md"><span data-ttu-id="60a97-4269">Especificar nombres de tipo completos</span><span class="sxs-lookup"><span data-stu-id="60a97-4269">Specifying Fully Qualified Type Names</span></span></related>
        <related type="Article" href="~/docs/framework/reflection-and-codedom/how-to-load-assemblies-into-the-reflection-only-context.md"><span data-ttu-id="60a97-4270">Cómo: Cargar ensamblados en el contexto de sólo reflexión</span><span class="sxs-lookup"><span data-stu-id="60a97-4270">How to: Load Assemblies into the Reflection-Only Context</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="StructLayoutAttribute">
      <MemberSignature Language="C#" Value="public virtual System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Runtime.InteropServices.StructLayoutAttribute StructLayoutAttribute" />
      <MemberSignature Language="DocId" Value="P:System.Type.StructLayoutAttribute" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property StructLayoutAttribute As StructLayoutAttribute" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::InteropServices::StructLayoutAttribute ^ StructLayoutAttribute { System::Runtime::InteropServices::StructLayoutAttribute ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.StructLayoutAttribute : System.Runtime.InteropServices.StructLayoutAttribute" Usage="System.Type.StructLayoutAttribute" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.InteropServices.StructLayoutAttribute</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4271">Obtiene una clase <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que describe el diseño del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4271">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the layout of the current type.</span></span></summary>
        <value><span data-ttu-id="60a97-4272">Obtiene una clase <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> que describe las características de diseño generales del tipo actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4272">Gets a <see cref="T:System.Runtime.InteropServices.StructLayoutAttribute" /> that describes the gross layout features of the current type.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4273"><xref:System.Runtime.InteropServices.StructLayoutAttribute> no se devuelve el <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> método.</span><span class="sxs-lookup"><span data-stu-id="60a97-4273"><xref:System.Runtime.InteropServices.StructLayoutAttribute> is not returned by the <xref:System.Reflection.MemberInfo.GetCustomAttributes%2A> method.</span></span> <span data-ttu-id="60a97-4274">En su lugar, puede usar esta propiedad para obtenerlo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4274">Instead, use this property to get it.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4275">En primer lugar, el siguiente ejemplo de código define una clase, una estructura y una estructura con atributos de diseño especial (las estructuras anidadas dentro de la clase).</span><span class="sxs-lookup"><span data-stu-id="60a97-4275">The following code example first defines a class, a structure, and a structure with special layout attributes (the structures are nested within the class).</span></span> <span data-ttu-id="60a97-4276">El ejemplo se utiliza el <xref:System.Type.StructLayoutAttribute%2A> propiedad para obtener un <xref:System.Runtime.InteropServices.StructLayoutAttribute> para cada tipo y muestra las propiedades de los atributos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4276">The example then uses the <xref:System.Type.StructLayoutAttribute%2A> property to obtain a <xref:System.Runtime.InteropServices.StructLayoutAttribute> for each type, and displays the properties of the attributes.</span></span>  
  
 [!code-cpp[Type.StructLayoutAttribute#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type.StructLayoutAttribute/CPP/Type.StructLayoutAttribute.cpp#1)]
 [!code-csharp[Type.StructLayoutAttribute#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type.StructLayoutAttribute/CS/source.cs#1)]
 [!code-vb[Type.StructLayoutAttribute#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type.StructLayoutAttribute/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4277">El método invocado no se admite en la clase base.</span><span class="sxs-lookup"><span data-stu-id="60a97-4277">The invoked method is not supported in the base class.</span></span></exception>
        <altmember cref="T:System.Runtime.InteropServices.StructLayoutAttribute" />
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetIDsOfNames">
      <MemberSignature Language="C#" Value="void _Type.GetIDsOfNames (ref Guid riid, IntPtr rgszNames, uint cNames, uint lcid, IntPtr rgDispId);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetIDsOfNames([in]valuetype System.Guid&amp; riid, native int rgszNames, unsigned int32 cNames, unsigned int32 lcid, native int rgDispId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetIDsOfNames (ByRef riid As Guid, rgszNames As IntPtr, cNames As UInteger, lcid As UInteger, rgDispId As IntPtr) Implements _Type.GetIDsOfNames" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetIDsOfNames(Guid % riid, IntPtr rgszNames, System::UInt32 cNames, System::UInt32 lcid, IntPtr rgDispId) = System::Runtime::InteropServices::_Type::GetIDsOfNames;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetIDsOfNames(System.Guid@,System.IntPtr,System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="rgszNames" Type="System.IntPtr" />
        <Parameter Name="cNames" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="rgDispId" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="riid"><span data-ttu-id="60a97-4278">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4278">Reserved for future use.</span></span> <span data-ttu-id="60a97-4279">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="60a97-4279">Must be IID_NULL.</span></span></param>
        <param name="rgszNames"><span data-ttu-id="60a97-4280">Matriz que se pasa con los nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4280">Passed-in array of names to be mapped.</span></span></param>
        <param name="cNames"><span data-ttu-id="60a97-4281">Número de nombres que se van a asignar.</span><span class="sxs-lookup"><span data-stu-id="60a97-4281">Count of the names to be mapped.</span></span></param>
        <param name="lcid"><span data-ttu-id="60a97-4282">Contexto de configuración regional en el que se van a interpretar los nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-4282">The locale context in which to interpret the names.</span></span></param>
        <param name="rgDispId"><span data-ttu-id="60a97-4283">Matriz asignada por el llamador que recibe los identificadores que corresponden a los nombres.</span><span class="sxs-lookup"><span data-stu-id="60a97-4283">Caller-allocated array which receives the IDs corresponding to the names.</span></span></param>
        <summary><span data-ttu-id="60a97-4284">Asigna un conjunto de nombres a un conjunto correspondiente de identificadores de envío.</span><span class="sxs-lookup"><span data-stu-id="60a97-4284">Maps a set of names to a corresponding set of dispatch identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4285">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4285">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="60a97-4286">Para obtener más información sobre `IDispatch::GetIDsOfNames`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="60a97-4286">For more information about `IDispatch::GetIDsOfNames`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="60a97-4287">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-4287">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfo">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfo (uint iTInfo, uint lcid, IntPtr ppTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfo(unsigned int32 iTInfo, unsigned int32 lcid, native int ppTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfo (iTInfo As UInteger, lcid As UInteger, ppTInfo As IntPtr) Implements _Type.GetTypeInfo" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfo(System::UInt32 iTInfo, System::UInt32 lcid, IntPtr ppTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfo(System.UInt32,System.UInt32,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="iTInfo" Type="System.UInt32" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="ppTInfo" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="iTInfo"><span data-ttu-id="60a97-4288">Información de tipos que se va a devolver.</span><span class="sxs-lookup"><span data-stu-id="60a97-4288">The type information to return.</span></span></param>
        <param name="lcid"><span data-ttu-id="60a97-4289">Identificador de la configuración regional de la información de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4289">The locale identifier for the type information.</span></span></param>
        <param name="ppTInfo"><span data-ttu-id="60a97-4290">Puntero al objeto de información de tipo solicitado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4290">A pointer to the requested type information object.</span></span></param>
        <summary><span data-ttu-id="60a97-4291">Recupera la información de tipo de un objeto, que se puede usar después para obtener la información de tipo de una interfaz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4291">Retrieves the type information for an object, which can then be used to get the type information for an interface.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4292">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4292">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="60a97-4293">Para obtener más información sobre `IDispatch::GetTypeInfo`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="60a97-4293">For more information about `IDispatch::GetTypeInfo`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="60a97-4294">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-4294">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.GetTypeInfoCount">
      <MemberSignature Language="C#" Value="void _Type.GetTypeInfoCount (out uint pcTInfo);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.GetTypeInfoCount([out] unsigned int32&amp; pcTInfo) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#GetTypeInfoCount(System.UInt32@)" />
      <MemberSignature Language="VB.NET" Value="Sub GetTypeInfoCount (ByRef pcTInfo As UInteger) Implements _Type.GetTypeInfoCount" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.GetTypeInfoCount([Runtime::InteropServices::Out] System::UInt32 % pcTInfo) = System::Runtime::InteropServices::_Type::GetTypeInfoCount;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.GetTypeInfoCount(System.UInt32@)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pcTInfo" Type="System.UInt32" RefType="out" />
      </Parameters>
      <Docs>
        <param name="pcTInfo"><span data-ttu-id="60a97-4295">Señala a una ubicación que recibe el número de interfaces de información de tipo proporcionado por el objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-4295">Points to a location that receives the number of type information interfaces provided by the object.</span></span></param>
        <summary><span data-ttu-id="60a97-4296">Recupera el número de interfaces de información de tipo que proporciona un objeto (0 ó 1).</span><span class="sxs-lookup"><span data-stu-id="60a97-4296">Retrieves the number of type information interfaces that an object provides (either 0 or 1).</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4297">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4297">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="60a97-4298">Para obtener más información sobre `IDispatch::GetTypeInfoCount`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="60a97-4298">For more information about `IDispatch::GetTypeInfoCount`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="60a97-4299">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-4299">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.InteropServices._Type.Invoke">
      <MemberSignature Language="C#" Value="void _Type.Invoke (uint dispIdMember, ref Guid riid, uint lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.InteropServices._Type.Invoke(unsigned int32 dispIdMember, [in]valuetype System.Guid&amp; riid, unsigned int32 lcid, int16 wFlags, native int pDispParams, native int pVarResult, native int pExcepInfo, native int puArgErr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.System#Runtime#InteropServices#_Type#Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Sub Invoke (dispIdMember As UInteger, ByRef riid As Guid, lcid As UInteger, wFlags As Short, pDispParams As IntPtr, pVarResult As IntPtr, pExcepInfo As IntPtr, puArgErr As IntPtr) Implements _Type.Invoke" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.InteropServices._Type.Invoke(System::UInt32 dispIdMember, Guid % riid, System::UInt32 lcid, short wFlags, IntPtr pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr) = System::Runtime::InteropServices::_Type::Invoke;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.Invoke(System.UInt32,System.Guid@,System.UInt32,System.Int16,System.IntPtr,System.IntPtr,System.IntPtr,System.IntPtr)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dispIdMember" Type="System.UInt32" />
        <Parameter Name="riid" Type="System.Guid" RefType="ref" />
        <Parameter Name="lcid" Type="System.UInt32" />
        <Parameter Name="wFlags" Type="System.Int16" />
        <Parameter Name="pDispParams" Type="System.IntPtr" />
        <Parameter Name="pVarResult" Type="System.IntPtr" />
        <Parameter Name="pExcepInfo" Type="System.IntPtr" />
        <Parameter Name="puArgErr" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="dispIdMember"><span data-ttu-id="60a97-4300">Identifica el miembro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4300">Identifies the member.</span></span></param>
        <param name="riid"><span data-ttu-id="60a97-4301">Reservado para un uso futuro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4301">Reserved for future use.</span></span> <span data-ttu-id="60a97-4302">Debe ser IID_NULL.</span><span class="sxs-lookup"><span data-stu-id="60a97-4302">Must be IID_NULL.</span></span></param>
        <param name="lcid"><span data-ttu-id="60a97-4303">Contexto de la configuración regional en que se interpretan los argumentos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4303">The locale context in which to interpret arguments.</span></span></param>
        <param name="wFlags"><span data-ttu-id="60a97-4304">Marcas que describen el contexto de la llamada.</span><span class="sxs-lookup"><span data-stu-id="60a97-4304">Flags describing the context of the call.</span></span></param>
        <param name="pDispParams"><span data-ttu-id="60a97-4305">Puntero a una estructura que contiene una matriz de argumentos, una matriz de valores DISPID de argumento para argumentos con nombre y recuentos del número de elementos de cada matriz.</span><span class="sxs-lookup"><span data-stu-id="60a97-4305">Pointer to a structure containing an array of arguments, an array of argument DISPIDs for named arguments, and counts for the number of elements in the arrays.</span></span></param>
        <param name="pVarResult"><span data-ttu-id="60a97-4306">Puntero a la ubicación donde se va a almacenar el resultado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4306">Pointer to the location where the result is to be stored.</span></span></param>
        <param name="pExcepInfo"><span data-ttu-id="60a97-4307">Puntero a una estructura que contiene información de excepciones.</span><span class="sxs-lookup"><span data-stu-id="60a97-4307">Pointer to a structure that contains exception information.</span></span></param>
        <param name="puArgErr"><span data-ttu-id="60a97-4308">Índice del primer argumento que tiene un error.</span><span class="sxs-lookup"><span data-stu-id="60a97-4308">The index of the first argument that has an error.</span></span></param>
        <summary><span data-ttu-id="60a97-4309">Proporciona acceso a las propiedades y los métodos expuestos por un objeto.</span><span class="sxs-lookup"><span data-stu-id="60a97-4309">Provides access to properties and methods exposed by an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4310">Este método es para el acceso a las clases administradas desde código no administrado y no debe llamarse desde código administrado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4310">This method is for access to managed classes from unmanaged code, and should not be called from managed code.</span></span> <span data-ttu-id="60a97-4311">Para obtener más información sobre `IDispatch::Invoke`, vea MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="60a97-4311">For more information about `IDispatch::Invoke`, see the MSDN Library.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotImplementedException"><span data-ttu-id="60a97-4312">No se admite el acceso enlazado en tiempo de ejecución mediante la interfaz <c>IDispatch</c> de COM.</span><span class="sxs-lookup"><span data-stu-id="60a97-4312">Late-bound access using the COM <c>IDispatch</c> interface is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Type.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="type.ToString " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.InteropServices._Type.ToString</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="60a97-4313">Devuelve un valor <see langword="String" /> que representa el nombre del objeto <see langword="Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4313">Returns a <see langword="String" /> representing the name of the current <see langword="Type" />.</span></span></summary>
        <returns><span data-ttu-id="60a97-4314">Valor <see cref="T:System.String" /> que representa el nombre del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4314">A <see cref="T:System.String" /> representing the name of the current <see cref="T:System.Type" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4315">Este método devuelve el common language runtime espacio de nombres completo y el nombre de todos los tipos primitivos.</span><span class="sxs-lookup"><span data-stu-id="60a97-4315">This method returns the fully qualified common language runtime namespace and name for all primitive types.</span></span> <span data-ttu-id="60a97-4316">Por ejemplo, la instrucción de C# `(long)0.Type().ToString()` devuelve "System.Int64" en lugar de simplemente "Int64".</span><span class="sxs-lookup"><span data-stu-id="60a97-4316">For example, the C# instruction, `(long)0.Type().ToString()` returns "System.Int64" instead of merely "Int64".</span></span>  
  
 <span data-ttu-id="60a97-4317">Si el actual <xref:System.Type> representa un tipo genérico, el tipo y sus argumentos de tipo se califican por espacio de nombres y por tipo anidado, pero no por ensamblado.</span><span class="sxs-lookup"><span data-stu-id="60a97-4317">If the current <xref:System.Type> represents a generic type, the type and its type arguments are qualified by namespace and by nested type, but not by assembly.</span></span> <span data-ttu-id="60a97-4318">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o método genérico, este método devuelve el nombre no completo del parámetro de tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4318">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this method returns the unqualified name of the type parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4319">En el ejemplo siguiente se muestra cómo utilizar el <xref:System.Type.Namespace%2A> y <xref:System.Type.Module%2A> propiedades y el `ToString` método <xref:System.Type>.</span><span class="sxs-lookup"><span data-stu-id="60a97-4319">This following example demonstrates a use of the <xref:System.Type.Namespace%2A> and <xref:System.Type.Module%2A> properties and the `ToString` method of <xref:System.Type>.</span></span>  
  
 [!code-cpp[Type_ToString#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_ToString/CPP/type_tostring.cpp#1)]
 [!code-csharp[Type_ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_ToString/CS/type_tostring.cs#1)]
 [!code-vb[Type_ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_ToString/VB/type_tostring.vb#1)]  
  
 <span data-ttu-id="60a97-4320">En el ejemplo siguiente se comparan las cadenas devueltas por la <xref:System.Type.ToString%2A> método y el `Name`, <xref:System.Type.FullName%2A>, y <xref:System.Type.AssemblyQualifiedName%2A> propiedades.</span><span class="sxs-lookup"><span data-stu-id="60a97-4320">The following example compares the strings returned by the <xref:System.Type.ToString%2A> method and the `Name`, <xref:System.Type.FullName%2A>, and <xref:System.Type.AssemblyQualifiedName%2A> properties.</span></span>  
  
 [!code-csharp[System.Type.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.type.tostring/cs/fullname1.cs#1)]
 [!code-vb[System.Type.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.type.tostring/vb/fullname1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.String" />
      </Docs>
    </Member>
    <Member MemberName="TypeHandle">
      <MemberSignature Language="C#" Value="public virtual RuntimeTypeHandle TypeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.RuntimeTypeHandle TypeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeHandle" />
      <MemberSignature Language="VB.NET" Value="Public Overridable ReadOnly Property TypeHandle As RuntimeTypeHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property RuntimeTypeHandle TypeHandle { RuntimeTypeHandle get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeHandle : RuntimeTypeHandle" Usage="System.Type.TypeHandle" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeHandle</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.RuntimeTypeHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4321">Obtiene el identificador del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4321">Gets the handle for the current <see cref="T:System.Type" />.</span></span></summary>
        <value><span data-ttu-id="60a97-4322">Identificador del objeto <see cref="T:System.Type" /> actual.</span><span class="sxs-lookup"><span data-stu-id="60a97-4322">The handle for the current <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4323">`TypeHandle` Encapsula un puntero a una estructura de datos interna que representa el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4323">`TypeHandle` encapsulates a pointer to an internal data structure that represents the type.</span></span> <span data-ttu-id="60a97-4324">Este identificador es único durante la vida del proceso.</span><span class="sxs-lookup"><span data-stu-id="60a97-4324">This handle is unique during the process lifetime.</span></span> <span data-ttu-id="60a97-4325">El identificador es válido únicamente en el dominio de aplicación en el que se ha obtenido.</span><span class="sxs-lookup"><span data-stu-id="60a97-4325">The handle is valid only in the application domain in which it was obtained.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="60a97-4326">El ejemplo siguiente devuelve el identificador del tipo correspondiente y pasa el identificador a un método que obtiene el tipo a partir del identificador y lo muestra.</span><span class="sxs-lookup"><span data-stu-id="60a97-4326">The following example returns the handle of the corresponding type and passes the handle to a method that gets the type from the handle and displays it.</span></span>  
  
 [!code-cpp[Type_TypeHandle#1](~/samples/snippets/cpp/VS_Snippets_CLR/Type_TypeHandle/CPP/type_typehandle.cpp#1)]
 [!code-csharp[Type_TypeHandle#1](~/samples/snippets/csharp/VS_Snippets_CLR/Type_TypeHandle/CS/type_typehandle.cs#1)]
 [!code-vb[Type_TypeHandle#1](~/samples/snippets/visualbasic/VS_Snippets_CLR/Type_TypeHandle/VB/type_typehandle.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="60a97-4327">.NET Compact Framework no admite actualmente esta propiedad.</span><span class="sxs-lookup"><span data-stu-id="60a97-4327">The .NET Compact Framework does not currently support this property.</span></span></exception>
        <altmember cref="T:System.RuntimeTypeHandle" />
        <altmember cref="M:System.Type.GetTypeHandle(System.Object)" />
        <altmember cref="M:System.Type.GetTypeFromHandle(System.RuntimeTypeHandle)" />
      </Docs>
    </Member>
    <Member MemberName="TypeInitializer">
      <MemberSignature Language="C#" Value="public System.Reflection.ConstructorInfo TypeInitializer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Reflection.ConstructorInfo TypeInitializer" />
      <MemberSignature Language="DocId" Value="P:System.Type.TypeInitializer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property TypeInitializer As ConstructorInfo" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Reflection::ConstructorInfo ^ TypeInitializer { System::Reflection::ConstructorInfo ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.TypeInitializer : System.Reflection.ConstructorInfo" Usage="System.Type.TypeInitializer" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.TypeInitializer</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Reflection.ConstructorInfo</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4328">Obtiene el inicializador para el tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4328">Gets the initializer for the type.</span></span></summary>
        <value><span data-ttu-id="60a97-4329">Objeto que contiene el nombre del constructor de clase para <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4329">An object that contains the name of the class constructor for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="60a97-4330">Inicializadores de clase también están disponibles a través de la <xref:System.Type.FindMembers%2A> método, o a través de las sobrecargas de los <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, y <xref:System.Type.GetConstructors%2A> los métodos que toman <xref:System.Reflection.BindingFlags> como un parámetro.</span><span class="sxs-lookup"><span data-stu-id="60a97-4330">Class initializers are also available through the <xref:System.Type.FindMembers%2A> method, or through overloads of the <xref:System.Type.GetMember%2A>, <xref:System.Type.GetMembers%2A>, <xref:System.Type.GetConstructor%2A>, and <xref:System.Type.GetConstructors%2A> methods that take <xref:System.Reflection.BindingFlags> as a parameter.</span></span>  
  
 <span data-ttu-id="60a97-4331">Si el actual <xref:System.Type> representa un parámetro de tipo en la definición de un tipo genérico o un método genérico, esta propiedad devuelve `null`.</span><span class="sxs-lookup"><span data-stu-id="60a97-4331">If the current <xref:System.Type> represents a type parameter in the definition of a generic type or generic method, this property returns `null`.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Reflection.ConstructorInfo" />
      </Docs>
    </Member>
    <Member MemberName="UnderlyingSystemType">
      <MemberSignature Language="C#" Value="public abstract Type UnderlyingSystemType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Type UnderlyingSystemType" />
      <MemberSignature Language="DocId" Value="P:System.Type.UnderlyingSystemType" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UnderlyingSystemType As Type" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property Type ^ UnderlyingSystemType { Type ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UnderlyingSystemType : Type" Usage="System.Type.UnderlyingSystemType" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Runtime.InteropServices._Type.UnderlyingSystemType</InterfaceMember>
        <InterfaceMember>P:System.Reflection.IReflect.UnderlyingSystemType</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Type</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="60a97-4332">Indica el tipo proporcionado por Common Language Runtime para representar este tipo.</span><span class="sxs-lookup"><span data-stu-id="60a97-4332">Indicates the type provided by the common language runtime that represents this type.</span></span></summary>
        <value><span data-ttu-id="60a97-4333">Tipo de sistema subyacente para el objeto <see cref="T:System.Type" />.</span><span class="sxs-lookup"><span data-stu-id="60a97-4333">The underlying system type for the <see cref="T:System.Type" />.</span></span></value>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Type.BaseType" />
      </Docs>
    </Member>
  </Members>
</Type>