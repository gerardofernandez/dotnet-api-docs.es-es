<Type Name="IntPtr" FullName="System.IntPtr">
  <Metadata><Meta Name="ms.openlocfilehash" Value="47eb803e009fa1e162a9c1a54e144beee7591a73" /><Meta Name="ms.sourcegitcommit" Value="bac13a81377b1c4ebf3990e3287a6f1700f73751" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="es-ES" /><Meta Name="ms.lasthandoff" Value="03/19/2019" /><Meta Name="ms.locfileid" Value="57959266" /></Metadata><TypeSignature Language="C#" Value="public struct IntPtr : System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit native int extends System.ValueType implements class System.Runtime.Serialization.ISerializable" />
  <TypeSignature Language="DocId" Value="T:System.IntPtr" />
  <TypeSignature Language="VB.NET" Value="Public Structure IntPtr&#xA;Implements ISerializable" />
  <TypeSignature Language="C++ CLI" Value="public value class IntPtr : System::Runtime::Serialization::ISerializable" />
  <TypeSignature Language="F#" Value="type nativeint = struct&#xA;    interface ISerializable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.10.0</AssemblyVersion>
    <AssemblyVersion>4.0.20.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Runtime.Serialization.ISerializable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netcore-3.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="bf066-101">Tipo específico de la plataforma que se usa para representar un puntero o un identificador.</span><span class="sxs-lookup"><span data-stu-id="bf066-101">A platform-specific type that is used to represent a pointer or a handle.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-102">El <xref:System.IntPtr> tipo está diseñado para ser un entero cuyo tamaño es específico de la plataforma.</span><span class="sxs-lookup"><span data-stu-id="bf066-102">The <xref:System.IntPtr> type is designed to be an integer whose size is platform-specific.</span></span> <span data-ttu-id="bf066-103">Es decir, una instancia de este tipo debe ser de 32 bits en sistemas operativos y hardware de 32 bits y 64 bits en sistemas operativos y hardware de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="bf066-103">That is, an instance of this type is expected to be 32-bits on 32-bit hardware and operating systems, and 64-bits on 64-bit hardware and operating systems.</span></span>  
  
 <span data-ttu-id="bf066-104">El <xref:System.IntPtr> tipo puede usarse por los lenguajes que admiten punteros y como un medio común para hacer referencia a los datos entre los lenguajes que no admiten punteros.</span><span class="sxs-lookup"><span data-stu-id="bf066-104">The <xref:System.IntPtr> type can be used by languages that support pointers, and as a common means of referring to data between languages that do and do not support pointers.</span></span>  
  
 <span data-ttu-id="bf066-105"><xref:System.IntPtr> objetos también pueden utilizarse para controlar identificadores.</span><span class="sxs-lookup"><span data-stu-id="bf066-105"><xref:System.IntPtr> objects can also be used to hold handles.</span></span> <span data-ttu-id="bf066-106">Por ejemplo, las instancias de <xref:System.IntPtr> se usan ampliamente en el <xref:System.IO.FileStream?displayProperty=nameWithType> clase para contener los identificadores de archivos.</span><span class="sxs-lookup"><span data-stu-id="bf066-106">For example, instances of <xref:System.IntPtr> are used extensively in the <xref:System.IO.FileStream?displayProperty=nameWithType> class to hold file handles.</span></span>  
  
 <span data-ttu-id="bf066-107">El <xref:System.IntPtr> tipo es conforme a CLS, mientras que el <xref:System.UIntPtr> no es de tipo.</span><span class="sxs-lookup"><span data-stu-id="bf066-107">The <xref:System.IntPtr> type is CLS-compliant, while the <xref:System.UIntPtr> type is not.</span></span> <span data-ttu-id="bf066-108">Solo el <xref:System.IntPtr> tipo se usa en common language runtime.</span><span class="sxs-lookup"><span data-stu-id="bf066-108">Only the <xref:System.IntPtr> type is used in the common language runtime.</span></span> <span data-ttu-id="bf066-109">El <xref:System.UIntPtr> tipo sirve principalmente para mantener la simetría arquitectónica con el <xref:System.IntPtr> tipo.</span><span class="sxs-lookup"><span data-stu-id="bf066-109">The <xref:System.UIntPtr> type is provided mostly to maintain architectural symmetry with the <xref:System.IntPtr> type.</span></span>  
  
 <span data-ttu-id="bf066-110">Este tipo implementa la <xref:System.Runtime.Serialization.ISerializable> interfaz.</span><span class="sxs-lookup"><span data-stu-id="bf066-110">This type implements the <xref:System.Runtime.Serialization.ISerializable> interface.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bf066-111">El ejemplo siguiente utiliza punteros administrados para invertir los caracteres en una matriz.</span><span class="sxs-lookup"><span data-stu-id="bf066-111">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="bf066-112">Una vez que inicialice un <xref:System.String> de objetos y obtiene su longitud, hace lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bf066-112">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
1.  <span data-ttu-id="bf066-113">Las llamadas del <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> método para copiar la cadena de Unicode a memoria no administrada como un carácter de ANSI (un byte).</span><span class="sxs-lookup"><span data-stu-id="bf066-113">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as an ANSI (one-byte) character.</span></span> <span data-ttu-id="bf066-114">El método devuelve un <xref:System.IntPtr> objeto que apunta al principio de la cadena no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-114">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span> <span data-ttu-id="bf066-115">El ejemplo de Visual Basic utiliza este puntero directamente; en los ejemplos de C++ y C#, se convierte en un puntero a un byte.</span><span class="sxs-lookup"><span data-stu-id="bf066-115">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
2.  <span data-ttu-id="bf066-116">Las llamadas del <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> método para asignar el mismo número de bytes que se ocupa de la cadena no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-116">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="bf066-117">El método devuelve un <xref:System.IntPtr> objeto que apunta al principio del bloque de memoria no administrado.</span><span class="sxs-lookup"><span data-stu-id="bf066-117">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span> <span data-ttu-id="bf066-118">El ejemplo de Visual Basic utiliza este puntero directamente; en los ejemplos de C++ y C#, se convierte en un puntero a un byte.</span><span class="sxs-lookup"><span data-stu-id="bf066-118">The Visual Basic example uses this pointer directly; in the C++ and C# examples, it is cast to a pointer to a byte.</span></span>  
  
3.  <span data-ttu-id="bf066-119">El ejemplo de Visual Basic define una variable denominada `offset` que es igual que la longitud de la cadena ANSI.</span><span class="sxs-lookup"><span data-stu-id="bf066-119">The Visual Basic example defines a variable named `offset` that is equal to the length of the ANSI string.</span></span> <span data-ttu-id="bf066-120">Sirve para determinar el desplazamiento en la memoria no administrada que se copia en la siguiente carta en la cadena ANSI.</span><span class="sxs-lookup"><span data-stu-id="bf066-120">It is used to determine the offset into unmanaged memory to which the next charter in the ANSI string is copied.</span></span> <span data-ttu-id="bf066-121">Dado que su valor inicial es la longitud de la cadena, la operación de copia copiará un carácter desde el principio de la cadena hasta el final del bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="bf066-121">Because its starting value is the length of the string, the copy operation will copy a character from the start of the string to the end of the memory block.</span></span>  
  
     <span data-ttu-id="bf066-122">La llamada de ejemplos de C# y C++ el <xref:System.IntPtr.ToPointer%2A> método para obtener un puntero no administrado a la dirección inicial de la cadena y el bloque de memoria, no administrado agregue uno menor que la longitud de la cadena a la dirección inicial de la cadena ANSI.</span><span class="sxs-lookup"><span data-stu-id="bf066-122">The C# and C++ examples call the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and they add one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="bf066-123">Puesto que ahora apunta el puntero de cadena no administrada al final de la cadena, la operación de copia copiará un carácter desde el final de la cadena al principio del bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="bf066-123">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
4.  <span data-ttu-id="bf066-124">Utiliza un bucle para copiar cada carácter de la cadena en el bloque de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-124">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span>  
  
     <span data-ttu-id="bf066-125">El ejemplo de Visual Basic llama a la <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> método para leer los bytes (o caracteres de byte único) con un desplazamiento especificado desde el puntero administrado a la cadena ANSI.</span><span class="sxs-lookup"><span data-stu-id="bf066-125">The Visual Basic example calls the <xref:System.Runtime.InteropServices.Marshal.ReadByte%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType> method to read the byte (or one-byte character) at a specified offset from the managed pointer to the ANSI string.</span></span> <span data-ttu-id="bf066-126">El desplazamiento se incrementa con cada iteración del bucle.</span><span class="sxs-lookup"><span data-stu-id="bf066-126">The offset is incremented with each iteration of the loop.</span></span> <span data-ttu-id="bf066-127">A continuación, llama el <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> método para escribir los bytes en la dirección de memoria definido por la dirección inicial del bloque no administrado de memoria más `offset`.</span><span class="sxs-lookup"><span data-stu-id="bf066-127">It then calls the <xref:System.Runtime.InteropServices.Marshal.WriteByte%28System.IntPtr%2CSystem.Int32%2CSystem.Byte%29?displayProperty=nameWithType> method to write the byte to the memory address defined by the starting address of the unmanaged block of memory plus `offset`.</span></span> <span data-ttu-id="bf066-128">A continuación, se reduce `offset`.</span><span class="sxs-lookup"><span data-stu-id="bf066-128">It then decrements `offset`.</span></span>  
  
     <span data-ttu-id="bf066-129">Ejemplos de C++ y C# realizan la operación de copia, a continuación, disminuir el puntero a la dirección de la ubicación siguiente en la cadena ANSI no administrada e incrementar el puntero a la siguiente dirección en el bloque no administrado.</span><span class="sxs-lookup"><span data-stu-id="bf066-129">The C# and C++ examples perform the copy operation, then decrement the pointer to the address of the next location in the unmanaged ANSI string and increment the pointer to the next address in the unmanaged block.</span></span>  
  
5.  <span data-ttu-id="bf066-130">Llamar todos los ejemplos del <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> para convertir el bloque de memoria no administrada que contiene la cadena copiada de ANSI a Unicode administrado <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="bf066-130">All examples call the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
6.  <span data-ttu-id="bf066-131">Después de mostrar las cadenas originales e invertidas, llamar todos los ejemplos el <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> método para liberar la memoria asignada para la cadena ANSI no administrada y el bloque de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-131">After displaying the original and reversed strings, all examples call the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.intptr/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr/cs/topointer.cs#1)]
 [!code-vb[System.IntPtr#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr/vb/topointer.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="bf066-132">Este tipo es seguro para la ejecución de subprocesos.</span><span class="sxs-lookup"><span data-stu-id="bf066-132">This type is thread safe.</span></span></threadsafe>
    <altmember cref="T:System.UIntPtr" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bf066-133">Inicializa una nueva instancia de la clase <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-133">Initializes a new instance of <see cref="T:System.IntPtr" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(int value);" />
      <MemberSignature Language="F#" Value="new nativeint : int -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-134">Puntero o identificador contenido en un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-134">A pointer or handle contained in a 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="bf066-135">Inicializa una nueva instancia de <see cref="T:System.IntPtr" /> usando el puntero o identificador de 32 bits especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-135">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 32-bit pointer or handle.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(long value);" />
      <MemberSignature Language="F#" Value="new nativeint : int64 -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-136">Puntero o identificador contenido en un entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-136">A pointer or handle contained in a 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="bf066-137">Inicializa una nueva instancia de <see cref="T:System.IntPtr" /> usando el puntero de 64 bits especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-137">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified 64-bit pointer.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-138">Solo se produce una excepción si el valor de `value` requiere más bits de la plataforma actual admite.</span><span class="sxs-lookup"><span data-stu-id="bf066-138">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="bf066-139">En una plataforma de 32 bits, <paramref name="value" /> es demasiado grande para representarse como un <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-139">On a 32-bit platform, <paramref name="value" /> is too large or too small to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.#ctor(System.Void*)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IntPtr(void* value);" />
      <MemberSignature Language="F#" Value="new nativeint : nativeptr&lt;unit&gt; -&gt; nativeint" Usage="new System.nativeint value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-140">Puntero a un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-140">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="bf066-141">Inicializa una nueva instancia de <see cref="T:System.IntPtr" /> usando el puntero especificado a un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-141">Initializes a new instance of <see cref="T:System.IntPtr" /> using the specified pointer to an unspecified type.</span></span></summary>
        <remarks>To be added.</remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="bf066-142">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="bf066-142">requires full trust for the immediate caller.</span></span> <span data-ttu-id="bf066-143">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="bf066-143">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="T:System.Void" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static IntPtr Add (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Add(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Add(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member Add : nativeint * int -&gt; nativeint" Usage="System.nativeint.Add (pointer, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="bf066-144">Puntero al que se va a sumar el desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="bf066-144">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="bf066-145">Desplazamiento que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="bf066-145">The offset to add.</span></span></param>
        <summary><span data-ttu-id="bf066-146">Suma un desplazamiento al valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-146">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="bf066-147">Nuevo puntero que es el resultado de sumar <paramref name="offset" /> a <paramref name="pointer" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-147">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-148">El <xref:System.IntPtr.Add%2A> método no produce una excepción si el resultado es demasiado grande para representarse como un puntero en la plataforma especificada.</span><span class="sxs-lookup"><span data-stu-id="bf066-148">The <xref:System.IntPtr.Add%2A> method does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="bf066-149">En su lugar, la operación de suma se realiza en un contexto no comprobado.</span><span class="sxs-lookup"><span data-stu-id="bf066-149">Instead, the addition operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="bf066-150">Los lenguajes que no admiten la sobrecarga de operadores personalizados ni pueden usar este método para agregar un desplazamiento al valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-150">Languages that do not support operator overloading or custom operators can use this method to add an offset to the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bf066-151">El ejemplo siguiente crea un <xref:System.IntPtr> objeto que apunta al principio de una matriz de diez elementos y, a continuación, llama a la <xref:System.IntPtr.Add%2A> método para recorrer en iteración los elementos de la matriz.</span><span class="sxs-lookup"><span data-stu-id="bf066-151">The following example instantiates an <xref:System.IntPtr> object that points to the beginning of a ten-element array, and then calls the <xref:System.IntPtr.Add%2A> method to iterate the elements in the array.</span></span>  
  
 [!code-csharp[System.IntPtr.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.add/cs/add1.cs#1)]
 [!code-vb[System.IntPtr.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="nativeint.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="bf066-152">Objeto que se va a comparar con esta instancia o <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-152">An object to compare with this instance or <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="bf066-153">Devuelve un valor que indica si esta instancia equivale a un objeto especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-153">Returns a value indicating whether this instance is equal to a specified object.</span></span></summary>
        <returns><span data-ttu-id="bf066-154">Es <see langword="true" /> si <paramref name="obj" /> es una instancia de <see cref="T:System.IntPtr" /> y es igual al valor de esta instancia; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-154"><see langword="true" /> if <paramref name="obj" /> is an instance of <see cref="T:System.IntPtr" /> and equals the value of this instance; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="nativeint.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bf066-155">Devuelve el código hash de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bf066-155">Returns the hash code for this instance.</span></span></summary>
        <returns><span data-ttu-id="bf066-156">Código hash de un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-156">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static IntPtr operator + (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Addition(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Addition(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator +(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member ( + ) : nativeint * int -&gt; nativeint" Usage="pointer + offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="bf066-157">Puntero al que se va a sumar el desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="bf066-157">The pointer to add the offset to.</span></span></param>
        <param name="offset"><span data-ttu-id="bf066-158">Desplazamiento que se va a sumar.</span><span class="sxs-lookup"><span data-stu-id="bf066-158">The offset to add.</span></span></param>
        <summary><span data-ttu-id="bf066-159">Suma un desplazamiento al valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-159">Adds an offset to the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="bf066-160">Nuevo puntero que es el resultado de sumar <paramref name="offset" /> a <paramref name="pointer" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-160">A new pointer that reflects the addition of <paramref name="offset" /> to <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-161">El <xref:System.IntPtr.op_Addition%2A> método define la operación de suma para <xref:System.IntPtr> objetos.</span><span class="sxs-lookup"><span data-stu-id="bf066-161">The <xref:System.IntPtr.op_Addition%2A> method defines the addition operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="bf066-162">Permite código como el siguiente.</span><span class="sxs-lookup"><span data-stu-id="bf066-162">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/addition1.cs#1)]
 [!code-vb[System.IntPtr.op_Addition#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/addition1.vb#1)]  
  
 <span data-ttu-id="bf066-163">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.IntPtr.Add%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf066-163">Languages that do not support custom operators can call the <xref:System.IntPtr.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="bf066-164">La operación de suma no produce una excepción si el resultado es demasiado grande para representarse como un puntero en la plataforma especificada.</span><span class="sxs-lookup"><span data-stu-id="bf066-164">The addition operation does not throw an exception if the result is too large to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="bf066-165">En su lugar, se realiza en un contexto no comprobado.</span><span class="sxs-lookup"><span data-stu-id="bf066-165">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="bf066-166">Es el método equivalente para este operador <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bf066-166">The equivalent method for this operator is <xref:System.IntPtr.Add%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Add(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Equality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="F#" Value="static member ( = ) : nativeint * nativeint -&gt; bool" Usage="value1 = value2" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="bf066-167">Primer puntero o controlador que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="bf066-167">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="bf066-168">Segundo puntero o controlador que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="bf066-168">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="bf066-169">Determina si dos instancias especificadas de <see cref="T:System.IntPtr" /> son iguales.</span><span class="sxs-lookup"><span data-stu-id="bf066-169">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are equal.</span></span></summary>
        <returns><span data-ttu-id="bf066-170">Es <see langword="true" /> si <paramref name="value1" /> es igual a <paramref name="value2" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-170"><see langword="true" /> if <paramref name="value1" /> equals <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="bf066-171">Es el método equivalente para este operador <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bf066-171">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bf066-172">Convierte un tipo de datos especificado en un valor <see cref="T:System.IntPtr" /> o un valor <see cref="T:System.IntPtr" /> en un tipo de datos especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-172">Converts a specified data type to an <see cref="T:System.IntPtr" /> value, or an <see cref="T:System.IntPtr" /> value to a specified data type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int32)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(int value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-173">Entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-173">A 32-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="bf066-174">Convierte el valor de un entero de 32 bits con signo en un <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-174">Converts the value of a 32-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="bf066-175">Nueva instancia de <see cref="T:System.IntPtr" /> inicializada en <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-175">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Int64)~System.IntPtr" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Long) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(long value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : int64 -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-176">Entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-176">A 64-bit signed integer.</span></span></param>
        <summary><span data-ttu-id="bf066-177">Convierte el valor de un entero de 64 bits con signo en un <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-177">Converts the value of a 64-bit signed integer to an <see cref="T:System.IntPtr" />.</span></span></summary>
        <returns><span data-ttu-id="bf066-178">Nueva instancia de <see cref="T:System.IntPtr" /> inicializada en <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-178">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="bf066-179">En una plataforma de 32 bits, <paramref name="value" /> es demasiado grande para representarse como <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-179">On a 32-bit platform, <paramref name="value" /> is too large to represent as an <see cref="T:System.IntPtr" />.</span></span></exception>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; int" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-180">Puntero o controlador que se va a convertir.</span><span class="sxs-lookup"><span data-stu-id="bf066-180">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="bf066-181">Convierte el valor del <see cref="T:System.IntPtr" /> especificado en un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-181">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="bf066-182">Contenido de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-182">The contents of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-183">Solo se produce una excepción si el valor de `value` requiere más bits de la plataforma actual admite.</span><span class="sxs-lookup"><span data-stu-id="bf066-183">An exception is only thrown if the value of `value` requires more bits than the current platform supports.</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="bf066-184">En una plataforma de 64 bits, el valor de <paramref name="value" /> es demasiado grande para representarse como un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-184">On a 64-bit platform, the value of <paramref name="value" /> is too large to represent as a 32-bit signed integer.</span></span></exception>
        <altmember cref="M:System.IntPtr.ToInt32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As IntPtr) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; int64" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-185">Puntero o controlador que se va a convertir.</span><span class="sxs-lookup"><span data-stu-id="bf066-185">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="bf066-186">Convierte el valor del <see cref="T:System.IntPtr" /> especificado en un entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-186">Converts the value of the specified <see cref="T:System.IntPtr" /> to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="bf066-187">Contenido de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-187">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToInt64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator void* (IntPtr value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname void* op_Explicit(native int value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.IntPtr)~System.Void*" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator void*(IntPtr value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeint -&gt; nativeptr&lt;unit&gt;" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-188">Puntero o controlador que se va a convertir.</span><span class="sxs-lookup"><span data-stu-id="bf066-188">The pointer or handle to convert.</span></span></param>
        <summary><span data-ttu-id="bf066-189">Convierte el valor del <see cref="T:System.IntPtr" /> especificado en un puntero a un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-189">Converts the value of the specified <see cref="T:System.IntPtr" /> to a pointer to an unspecified type.</span></span>  
  
<span data-ttu-id="bf066-190">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="bf066-190">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bf066-191">Contenido de <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-191">The contents of <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <altmember cref="M:System.IntPtr.ToPointer" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator IntPtr (void* value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Explicit(void* value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Explicit(System.Void*)~System.IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator IntPtr(void* value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : nativeptr&lt;unit&gt; -&gt; nativeint" Usage="System.nativeint.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netframework-4.8;netcore-2.0;dotnet-uwp-10.0">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Void*" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="bf066-192">Puntero a un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-192">A pointer to an unspecified type.</span></span></param>
        <summary><span data-ttu-id="bf066-193">Convierte el puntero especificado a un tipo no especificado en un <see cref="T:System.IntPtr" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-193">Converts the specified pointer to an unspecified type to an <see cref="T:System.IntPtr" />.</span></span>  
  
<span data-ttu-id="bf066-194">Esta API no es conforme a CLS.</span><span class="sxs-lookup"><span data-stu-id="bf066-194">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="bf066-195">Nueva instancia de <see cref="T:System.IntPtr" /> inicializada en <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-195">A new instance of <see cref="T:System.IntPtr" /> initialized to <paramref name="value" />.</span></span></returns>
        <remarks></remarks>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="bf066-196">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="bf066-196">requires full trust for the immediate caller.</span></span> <span data-ttu-id="bf066-197">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="bf066-197">This member cannot be used by partially trusted or transparent code.</span></span></permission>
        <altmember cref="Overload:System.IntPtr.#ctor" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(native int value1, native int value2) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Inequality(System.IntPtr,System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (value1 As IntPtr, value2 As IntPtr) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(IntPtr value1, IntPtr value2);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : nativeint * nativeint -&gt; bool" Usage="System.nativeint.op_Inequality (value1, value2)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value1" Type="System.IntPtr" />
        <Parameter Name="value2" Type="System.IntPtr" />
      </Parameters>
      <Docs>
        <param name="value1"><span data-ttu-id="bf066-198">Primer puntero o controlador que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="bf066-198">The first pointer or handle to compare.</span></span></param>
        <param name="value2"><span data-ttu-id="bf066-199">Segundo puntero o controlador que se va a comparar.</span><span class="sxs-lookup"><span data-stu-id="bf066-199">The second pointer or handle to compare.</span></span></param>
        <summary><span data-ttu-id="bf066-200">Determina si dos instancias especificadas de <see cref="T:System.IntPtr" /> no son iguales.</span><span class="sxs-lookup"><span data-stu-id="bf066-200">Determines whether two specified instances of <see cref="T:System.IntPtr" /> are not equal.</span></span></summary>
        <returns><span data-ttu-id="bf066-201">Es <see langword="true" /> si <paramref name="value1" /> no es igual a <paramref name="value2" />; en caso contrario, es <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-201"><see langword="true" /> if <paramref name="value1" /> does not equal <paramref name="value2" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[<span data-ttu-id="bf066-202">Es el método equivalente para este operador <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bf066-202">The equivalent method for this operator is <xref:System.IntPtr.Equals%28System.Object%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static IntPtr operator - (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname native int op_Subtraction(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr operator -(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member ( - ) : nativeint * int -&gt; nativeint" Usage="pointer - offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="bf066-203">Puntero del que se va a restar el desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="bf066-203">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="bf066-204">Desplazamiento que se va a restar.</span><span class="sxs-lookup"><span data-stu-id="bf066-204">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="bf066-205">Resta un desplazamiento del valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-205">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="bf066-206">Nuevo puntero que es el resultado de restar <paramref name="offset" /> de <paramref name="pointer" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-206">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-207">El <xref:System.IntPtr.op_Subtraction%2A> método define la operación de resta para <xref:System.IntPtr> objetos.</span><span class="sxs-lookup"><span data-stu-id="bf066-207">The <xref:System.IntPtr.op_Subtraction%2A> method defines the subtraction operation for <xref:System.IntPtr> objects.</span></span> <span data-ttu-id="bf066-208">Permite código como el siguiente.</span><span class="sxs-lookup"><span data-stu-id="bf066-208">It enables code such as the following.</span></span>  
  
 [!code-csharp[System.IntPtr.op_Addition#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.op_addition/cs/op_subtraction1.cs#2)]
 [!code-vb[System.IntPtr.op_Addition#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.op_addition/vb/op_subtraction1.vb#2)]  
  
 <span data-ttu-id="bf066-209">Los lenguajes que no admiten operadores personalizados pueden llamar los <xref:System.IntPtr.Subtract%2A> método en su lugar.</span><span class="sxs-lookup"><span data-stu-id="bf066-209">Languages that do not support custom operators can call the <xref:System.IntPtr.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="bf066-210">La operación de resta no produce una excepción si el resultado es demasiado pequeño para representarse como un puntero en la plataforma especificada.</span><span class="sxs-lookup"><span data-stu-id="bf066-210">The subtraction operation does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="bf066-211">En su lugar, se realiza en un contexto no comprobado.</span><span class="sxs-lookup"><span data-stu-id="bf066-211">Instead, it is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="bf066-212">Es el método equivalente para este operador <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="bf066-212">The equivalent method for this operator is <xref:System.IntPtr.Subtract%28System.IntPtr%2CSystem.Int32%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Size">
      <MemberSignature Language="C#" Value="public static int Size { get; }" />
      <MemberSignature Language="ILAsm" Value=".property int32 Size" />
      <MemberSignature Language="DocId" Value="P:System.IntPtr.Size" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Size As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property int Size { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Size : int" Usage="System.nativeint.Size" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>get: System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bf066-213">Obtiene el tamaño de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bf066-213">Gets the size of this instance.</span></span></summary>
        <value><span data-ttu-id="bf066-214">Tamaño de un puntero o identificador en este proceso, medido en bytes.</span><span class="sxs-lookup"><span data-stu-id="bf066-214">The size of a pointer or handle in this process, measured in bytes.</span></span> <span data-ttu-id="bf066-215">El valor de esta propiedad es 4 en un proceso de 32 bits y 8 en un proceso de 64 bits.</span><span class="sxs-lookup"><span data-stu-id="bf066-215">The value of this property is 4 in a 32-bit process, and 8 in a 64-bit process.</span></span> <span data-ttu-id="bf066-216">Puede definir el tipo de proceso estableciendo el modificador <see langword="/platform" /> cuando se compila el código con los compiladores de C# y Visual Basic.</span><span class="sxs-lookup"><span data-stu-id="bf066-216">You can define the process type by setting the <see langword="/platform" /> switch when you compile your code with the C# and Visual Basic compilers.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static IntPtr Subtract (IntPtr pointer, int offset);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig native int Subtract(native int pointer, int32 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.Subtract(System.IntPtr,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (pointer As IntPtr, offset As Integer) As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static IntPtr Subtract(IntPtr pointer, int offset);" />
      <MemberSignature Language="F#" Value="static member Subtract : nativeint * int -&gt; nativeint" Usage="System.nativeint.Subtract (pointer, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.MayCorruptInstance, System.Runtime.ConstrainedExecution.Cer.MayFail)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="pointer" Type="System.IntPtr" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="pointer"><span data-ttu-id="bf066-217">Puntero del que se va a restar el desplazamiento.</span><span class="sxs-lookup"><span data-stu-id="bf066-217">The pointer to subtract the offset from.</span></span></param>
        <param name="offset"><span data-ttu-id="bf066-218">Desplazamiento que se va a restar.</span><span class="sxs-lookup"><span data-stu-id="bf066-218">The offset to subtract.</span></span></param>
        <summary><span data-ttu-id="bf066-219">Resta un desplazamiento del valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-219">Subtracts an offset from the value of a pointer.</span></span></summary>
        <returns><span data-ttu-id="bf066-220">Nuevo puntero que es el resultado de restar <paramref name="offset" /> de <paramref name="pointer" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-220">A new pointer that reflects the subtraction of <paramref name="offset" /> from <paramref name="pointer" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-221">El <xref:System.IntPtr.Subtract%2A> método no produce una excepción si el resultado es demasiado pequeño para representarse como un puntero en la plataforma especificada.</span><span class="sxs-lookup"><span data-stu-id="bf066-221">The <xref:System.IntPtr.Subtract%2A> method does not throw an exception if the result is too small to represent as a pointer on the specified platform.</span></span> <span data-ttu-id="bf066-222">En su lugar, la operación de resta se realiza en un contexto no comprobado.</span><span class="sxs-lookup"><span data-stu-id="bf066-222">Instead, the subtraction operation is performed in an unchecked context.</span></span>  
  
 <span data-ttu-id="bf066-223">Los lenguajes que no admiten la sobrecarga de operadores personalizados ni pueden usar este método para restar un desplazamiento del valor de un puntero.</span><span class="sxs-lookup"><span data-stu-id="bf066-223">Languages that do not support operator overloading or custom operators can use this method to subtract an offset from the value of a pointer.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="bf066-224">El ejemplo siguiente crea un <xref:System.IntPtr> objeto que apunta al final de una matriz de diez elementos y, a continuación, llama a la <xref:System.IntPtr.Subtract%2A> método para recorrer en iteración los elementos de la matriz en orden inverso.</span><span class="sxs-lookup"><span data-stu-id="bf066-224">The following example instantiates an <xref:System.IntPtr> object that points to the end of a ten-element array, and then calls the <xref:System.IntPtr.Subtract%2A> method to iterate the elements in the array in reverse order.</span></span>  
  
 [!code-csharp[System.IntPtr.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.IntPtr.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.IntPtr.op_Subtraction(System.IntPtr,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="System.IEquatable&lt;System.IntPtr&gt;.Equals">
      <MemberSignature Language="C#" Value="bool IEquatable&lt;IntPtr&gt;.Equals (IntPtr other);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance bool System.IEquatable&lt;System.IntPtr&gt;.Equals(native int other) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#IEquatable&lt;System#IntPtr&gt;#Equals(System.IntPtr)" />
      <MemberSignature Language="VB.NET" Value="Function Equals (other As IntPtr) As Boolean Implements IEquatable(Of IntPtr).Equals" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberSignature Language="C++ CLI" Value=" virtual bool System.IEquatable&lt;System.IntPtr&gt;.Equals(IntPtr other) = IEquatable&lt;IntPtr&gt;::Equals;" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.IntPtr" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0" />
      </Parameters>
      <Docs>
        <param name="other">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Runtime.Serialization.ISerializable.GetObjectData">
      <MemberSignature Language="C#" Value="void ISerializable.GetObjectData (System.Runtime.Serialization.SerializationInfo info, System.Runtime.Serialization.StreamingContext context);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.Runtime.Serialization.ISerializable.GetObjectData(class System.Runtime.Serialization.SerializationInfo info, valuetype System.Runtime.Serialization.StreamingContext context) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.System#Runtime#Serialization#ISerializable#GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)" />
      <MemberSignature Language="VB.NET" Value="Sub GetObjectData (info As SerializationInfo, context As StreamingContext) Implements ISerializable.GetObjectData" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.Runtime.Serialization.ISerializable.GetObjectData(System::Runtime::Serialization::SerializationInfo ^ info, System::Runtime::Serialization::StreamingContext context) = System::Runtime::Serialization::ISerializable::GetObjectData;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Runtime.Serialization.ISerializable.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="info" Type="System.Runtime.Serialization.SerializationInfo" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="context" Type="System.Runtime.Serialization.StreamingContext" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="info"><span data-ttu-id="bf066-225">Objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> que se va a rellenar con datos.</span><span class="sxs-lookup"><span data-stu-id="bf066-225">The <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object to populate with data.</span></span></param>
        <param name="context"><span data-ttu-id="bf066-226">Destino de esta serialización.</span><span class="sxs-lookup"><span data-stu-id="bf066-226">The destination for this serialization.</span></span> <span data-ttu-id="bf066-227">(Este parámetro no se usa; especifique <see langword="null" />).</span><span class="sxs-lookup"><span data-stu-id="bf066-227">(This parameter is not used; specify <see langword="null" />.)</span></span></param>
        <summary><span data-ttu-id="bf066-228">Rellena un objeto <see cref="T:System.Runtime.Serialization.SerializationInfo" /> con los datos necesarios para serializar el objeto <see cref="T:System.IntPtr" /> actual.</span><span class="sxs-lookup"><span data-stu-id="bf066-228">Populates a <see cref="T:System.Runtime.Serialization.SerializationInfo" /> object with the data needed to serialize the current <see cref="T:System.IntPtr" /> object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-229">Este método rellena el `info` parámetro con el valor del elemento actual <xref:System.IntPtr> objeto.</span><span class="sxs-lookup"><span data-stu-id="bf066-229">This method populates the `info` parameter with the value of the current <xref:System.IntPtr> object.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="bf066-230"><paramref name="info" /> es <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="bf066-230"><paramref name="info" /> is <see langword="null" />.</span></span></exception>
        <permission cref="T:System.Security.SecurityCriticalAttribute"><span data-ttu-id="bf066-231">requiere plena confianza para el llamador inmediato.</span><span class="sxs-lookup"><span data-stu-id="bf066-231">requires full trust for the immediate caller.</span></span> <span data-ttu-id="bf066-232">Este miembro no se puede usar código de confianza parcial o transparente.</span><span class="sxs-lookup"><span data-stu-id="bf066-232">This member cannot be used by partially trusted or transparent code.</span></span></permission>
      </Docs>
    </Member>
    <Member MemberName="ToInt32">
      <MemberSignature Language="C#" Value="public int ToInt32 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ToInt32() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt32" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt32 () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ToInt32();" />
      <MemberSignature Language="F#" Value="member this.ToInt32 : unit -&gt; int" Usage="nativeint.ToInt32 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bf066-233">Convierte el valor de esta instancia a un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-233">Converts the value of this instance to a 32-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="bf066-234">Entero de 32 bits con signo igual al valor de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bf066-234">A 32-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><span data-ttu-id="bf066-235">En una plataforma de 64 bits, el valor de esta instancia es demasiado grande para representarse como un entero de 32 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-235">On a 64-bit platform, the value of this instance is too large or too small to represent as a 32-bit signed integer.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ToInt64">
      <MemberSignature Language="C#" Value="public long ToInt64 ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 ToInt64() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToInt64" />
      <MemberSignature Language="VB.NET" Value="Public Function ToInt64 () As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long ToInt64();" />
      <MemberSignature Language="F#" Value="member this.ToInt64 : unit -&gt; int64" Usage="nativeint.ToInt64 " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bf066-236">Convierte el valor de esta instancia a un entero de 64 bits con signo.</span><span class="sxs-lookup"><span data-stu-id="bf066-236">Converts the value of this instance to a 64-bit signed integer.</span></span></summary>
        <returns><span data-ttu-id="bf066-237">Entero de 64 bits con signo igual al valor de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bf066-237">A 64-bit signed integer equal to the value of this instance.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToPointer">
      <MemberSignature Language="C#" Value="public void* ToPointer ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void* ToPointer() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToPointer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void* ToPointer();" />
      <MemberSignature Language="F#" Value="member this.ToPointer : unit -&gt; nativeptr&lt;unit&gt;" Usage="nativeint.ToPointer " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.Runtime.ConstrainedExecution.ReliabilityContract(System.Runtime.ConstrainedExecution.Consistency.WillNotCorruptState, System.Runtime.ConstrainedExecution.Cer.Success)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void*</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bf066-238">Convierte el valor de esta instancia a un puntero a un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-238">Converts the value of this instance to a pointer to an unspecified type.</span></span></summary>
        <returns><span data-ttu-id="bf066-239">Puntero a <see cref="T:System.Void" />; es decir, puntero a memoria que contiene datos de un tipo no especificado.</span><span class="sxs-lookup"><span data-stu-id="bf066-239">A pointer to <see cref="T:System.Void" />; that is, a pointer to memory containing data of an unspecified type.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="bf066-240">El ejemplo siguiente utiliza punteros administrados para invertir los caracteres en una matriz.</span><span class="sxs-lookup"><span data-stu-id="bf066-240">The following example uses managed pointers to reverse the characters in an array.</span></span> <span data-ttu-id="bf066-241">Una vez que inicialice un <xref:System.String> de objetos y obtiene su longitud, hace lo siguiente:</span><span class="sxs-lookup"><span data-stu-id="bf066-241">After it initializes a <xref:System.String> object and gets its length, it does the following:</span></span>  
  
-   <span data-ttu-id="bf066-242">Las llamadas del <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> método para copiar la cadena de Unicode a memoria no administrada como caracteres de ANSI (un byte).</span><span class="sxs-lookup"><span data-stu-id="bf066-242">Calls the <xref:System.Runtime.InteropServices.Marshal.StringToHGlobalAnsi%2A?displayProperty=nameWithType> method to copy the Unicode string to unmanaged memory as ANSI (one-byte) characters.</span></span> <span data-ttu-id="bf066-243">El método devuelve un <xref:System.IntPtr> objeto que apunta al principio de la cadena no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-243">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged string.</span></span>  
  
-   <span data-ttu-id="bf066-244">Las llamadas del <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> método para asignar el mismo número de bytes que se ocupa de la cadena no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-244">Calls the <xref:System.Runtime.InteropServices.Marshal.AllocHGlobal%2A?displayProperty=nameWithType> method to allocate the same number of bytes as the unmanaged string occupies.</span></span> <span data-ttu-id="bf066-245">El método devuelve un <xref:System.IntPtr> objeto que apunta al principio del bloque de memoria no administrado.</span><span class="sxs-lookup"><span data-stu-id="bf066-245">The method returns an <xref:System.IntPtr> object that points to the beginning of the unmanaged block of memory.</span></span>  
  
-   <span data-ttu-id="bf066-246">Las llamadas del <xref:System.IntPtr.ToPointer%2A> método para obtener un puntero no administrado a la dirección inicial de la cadena y el bloque de memoria, no administrado y agrega uno menor que la longitud de la cadena a la dirección inicial de la cadena ANSI.</span><span class="sxs-lookup"><span data-stu-id="bf066-246">Calls the <xref:System.IntPtr.ToPointer%2A> method to get an unmanaged pointer to the starting address of the string and the unmanaged block of memory, and adds one less than the length of the string to the starting address of the ANSI string.</span></span> <span data-ttu-id="bf066-247">Puesto que ahora apunta el puntero de cadena no administrada al final de la cadena, la operación de copia copiará un carácter desde el final de la cadena al principio del bloque de memoria.</span><span class="sxs-lookup"><span data-stu-id="bf066-247">Because the unmanaged string pointer now points to the end of the string, the copy operation will copy a character from the end of the string to the start of the memory block.</span></span>  
  
-   <span data-ttu-id="bf066-248">Utiliza un bucle para copiar cada carácter de la cadena en el bloque de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-248">Uses a loop to copy each character from the string to the unmanaged block of memory.</span></span> <span data-ttu-id="bf066-249">Después de cada operación de copia, se disminuye el puntero a la dirección de la ubicación siguiente en la cadena ANSI no administrada y aumenta el puntero a la dirección siguiente en el bloque no administrado.</span><span class="sxs-lookup"><span data-stu-id="bf066-249">After each copy operation, it decrements the pointer to the address of the next location in the unmanaged ANSI string and increments the pointer to the next address in the unmanaged block.</span></span>  
  
-   <span data-ttu-id="bf066-250">Las llamadas del <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> para convertir el bloque de memoria no administrada que contiene la cadena copiada de ANSI a Unicode administrado <xref:System.String> objeto.</span><span class="sxs-lookup"><span data-stu-id="bf066-250">Calls the <xref:System.Runtime.InteropServices.Marshal.PtrToStringAnsi%2A?displayProperty=nameWithType> to convert the unmanaged memory block containing the copied ANSI string to a managed Unicode <xref:System.String> object.</span></span>  
  
-   <span data-ttu-id="bf066-251">Después de mostrar las cadenas originales e invertidas, llama a la <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> método para liberar la memoria asignada para la cadena ANSI no administrada y el bloque de memoria no administrada.</span><span class="sxs-lookup"><span data-stu-id="bf066-251">After displaying the original and reversed strings, calls the <xref:System.Runtime.InteropServices.Marshal.FreeHGlobal%2A?displayProperty=nameWithType> method to free the memory allocated for the unmanaged ANSI string and the unmanaged block of memory.</span></span>  
  
 [!code-cpp[System.IntPtr.ToPointer#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cpp/topointer.cpp#1)]
 [!code-csharp[System.IntPtr.ToPointer#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/System.IntPtr.ToPointer/cs/topointer.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="bf066-252">Convierte el valor numérico del objeto <see cref="T:System.IntPtr" /> actual en su representación de cadena equivalente.</span><span class="sxs-lookup"><span data-stu-id="bf066-252">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="nativeint.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="bf066-253">Convierte el valor numérico del objeto <see cref="T:System.IntPtr" /> actual en su representación de cadena equivalente.</span><span class="sxs-lookup"><span data-stu-id="bf066-253">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="bf066-254">Representación de cadena del valor de esta instancia.</span><span class="sxs-lookup"><span data-stu-id="bf066-254">The string representation of the value of this instance.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-255">Si el valor de la <xref:System.IntPtr.Size%2A> propiedad para esta instancia es 4, a continuación, este método es equivalente a <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; de lo contrario, este método es equivalente a <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bf066-255">If the value of the <xref:System.IntPtr.Size%2A> property for this instance is 4, then this method is equivalent to <xref:System.Int32.ToString%2A?displayProperty=nameWithType>; otherwise, this method is equivalent to <xref:System.Int64.ToString%2A?displayProperty=nameWithType>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.IntPtr.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="nativeint.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.0;netstandard-1.1;netstandard-1.2;netframework-4.8">
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.0;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.5;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="bf066-256">Especificación de formato que rige la conversión del objeto <see cref="T:System.IntPtr" /> actual.</span><span class="sxs-lookup"><span data-stu-id="bf066-256">A format specification that governs how the current <see cref="T:System.IntPtr" /> object is converted.</span></span></param>
        <summary><span data-ttu-id="bf066-257">Convierte el valor numérico del objeto <see cref="T:System.IntPtr" /> actual en su representación de cadena equivalente.</span><span class="sxs-lookup"><span data-stu-id="bf066-257">Converts the numeric value of the current <see cref="T:System.IntPtr" /> object to its equivalent string representation.</span></span></summary>
        <returns><span data-ttu-id="bf066-258">Representación de cadena del valor del objeto <see cref="T:System.IntPtr" /> actual.</span><span class="sxs-lookup"><span data-stu-id="bf066-258">The string representation of the value of the current <see cref="T:System.IntPtr" /> object.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-259">Si el `format` parámetro es `null` o una cadena vacía (""), el valor devuelto tiene el formato con el especificador de formato general ("G").</span><span class="sxs-lookup"><span data-stu-id="bf066-259">If the `format` parameter is `null` or an empty string (""), the return value is formatted with the general format specifier ("G").</span></span> <span data-ttu-id="bf066-260">Para obtener más información sobre los especificadores de formato numérico, consulte el [cadenas de formato numérico estándar](~/docs/standard/base-types/standard-numeric-format-strings.md) tema.</span><span class="sxs-lookup"><span data-stu-id="bf066-260">For more information about numeric format specifiers, see the [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) topic.</span></span>  
  
 <span data-ttu-id="bf066-261">El valor devuelto se da formato con la referencia cultural invariable.</span><span class="sxs-lookup"><span data-stu-id="bf066-261">The return value is formatted using the invariant culture.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Globalization.CultureInfo.InvariantCulture" />
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="bf066-262">Cadenas con formato numérico estándar</span><span class="sxs-lookup"><span data-stu-id="bf066-262">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="bf066-263">Cadenas con formato numérico personalizado</span><span class="sxs-lookup"><span data-stu-id="bf066-263">Custom Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/formatting-types.md"><span data-ttu-id="bf066-264">Aplicar formato a tipos en .NET</span><span class="sxs-lookup"><span data-stu-id="bf066-264">Formatting Types in .NET</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly IntPtr Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly native int Zero" />
      <MemberSignature Language="DocId" Value="F:System.IntPtr.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As IntPtr " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly IntPtr Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : nativeint" Usage="System.nativeint.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.10.0</AssemblyVersion>
        <AssemblyVersion>4.0.20.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="bf066-265">Campo de solo lectura que representa un puntero o identificador que se inicializó en cero.</span><span class="sxs-lookup"><span data-stu-id="bf066-265">A read-only field that represents a pointer or handle that has been initialized to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="bf066-266">El valor de este campo no es equivalente a `null`.</span><span class="sxs-lookup"><span data-stu-id="bf066-266">The value of this field is not equivalent to `null`.</span></span> <span data-ttu-id="bf066-267">Utilice este campo para determinar de forma eficaz si una instancia de <xref:System.IntPtr> se ha establecido en un valor distinto de cero.</span><span class="sxs-lookup"><span data-stu-id="bf066-267">Use this field to efficiently determine whether an instance of <xref:System.IntPtr> has been set to a value other than zero.</span></span>  
  
 <span data-ttu-id="bf066-268">Por ejemplo, suponga que la variable ip es una instancia de <xref:System.IntPtr>.</span><span class="sxs-lookup"><span data-stu-id="bf066-268">For example, assume the variable, ip, is an instance of <xref:System.IntPtr>.</span></span> <span data-ttu-id="bf066-269">Puede determinar si se ha establecido al compararlo con el valor devuelto por el constructor, por ejemplo: " `if ip != new IntPtr(0)...` ".</span><span class="sxs-lookup"><span data-stu-id="bf066-269">You can determine if it has been set by comparing it to the value returned by a constructor, for example: " `if ip != new IntPtr(0)...` ".</span></span> <span data-ttu-id="bf066-270">Sin embargo, la invocación de un constructor para obtener un puntero de generarlas es ineficaz.</span><span class="sxs-lookup"><span data-stu-id="bf066-270">However, invoking a constructor to get an unintialized pointer is inefficient.</span></span> <span data-ttu-id="bf066-271">Es mejor que codificar " `if ip != IntPtr.Zero...` ", o " `if !IntPtr.Zero.Equals(ip)...` ".</span><span class="sxs-lookup"><span data-stu-id="bf066-271">It is better to code either " `if ip != IntPtr.Zero...` ", or " `if !IntPtr.Zero.Equals(ip)...` ".</span></span>  
  
 <span data-ttu-id="bf066-272">Al llamar a la API de Windows desde el código administrado, puede pasar <xref:System.IntPtr.Zero?displayProperty=nameWithType> en lugar de `null` si se espera un argumento sea un puntero o un `null`.</span><span class="sxs-lookup"><span data-stu-id="bf066-272">When calling the Windows API from managed code, you can pass <xref:System.IntPtr.Zero?displayProperty=nameWithType> instead of `null` if an argument is expected to be either a pointer or a `null`.</span></span> <span data-ttu-id="bf066-273">Por ejemplo, la llamada siguiente a la Windows `CreateFile` función suministros <xref:System.IntPtr.Zero?displayProperty=nameWithType> para el `pSecurityAttributes` y `hTemplateFile` valores de argumento.</span><span class="sxs-lookup"><span data-stu-id="bf066-273">For example, the following call to the Windows `CreateFile` function supplies <xref:System.IntPtr.Zero?displayProperty=nameWithType> for the `pSecurityAttributes` and `hTemplateFile` argument values.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero4.cs#2)]
 [!code-vb[System.IntPtr.Zero#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero4.vb#2)]  
  
> [!NOTE]
>  <span data-ttu-id="bf066-274">Aunque <xref:System.IntPtr.Zero> es equivalente a `null` para las funciones de API de Windows con parámetros o valores devueltos que pueden ser cualquier punteros o `null`, <xref:System.IntPtr.Zero> no es equivalente a `null`.</span><span class="sxs-lookup"><span data-stu-id="bf066-274">Although <xref:System.IntPtr.Zero> is equivalent to `null` for Windows API functions with parameters or return values that can be either pointers or `null`, <xref:System.IntPtr.Zero> is not equivalent to `null`.</span></span> <span data-ttu-id="bf066-275">Pasar `null` a la `IntPtr.Zero.Equals` método siempre devuelve `false`.</span><span class="sxs-lookup"><span data-stu-id="bf066-275">Passing `null` to the `IntPtr.Zero.Equals` method always returns `false`.</span></span>  
  
 <span data-ttu-id="bf066-276">También puede probar para una `null` devolver valor de llamadas a funciones API de Windows que devuelven un puntero o un `null` comparando el valor devuelto con <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bf066-276">You can also test for a `null` return value from Windows API function calls that return either a pointer or a `null` by comparing the returned value with <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="bf066-277">Por ejemplo, la llamada a la `GetWindow` function en el ejemplo siguiente se intenta recuperar el identificador de una ventana que no existe.</span><span class="sxs-lookup"><span data-stu-id="bf066-277">For example, the call to the `GetWindow` function in the following example tries to retrieve the handle of a non-existent window.</span></span> <span data-ttu-id="bf066-278">Si se llama a desde código no administrado, la función debería devolver `null`, pero cuando se llama desde código administrado, devuelve <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="bf066-278">If it were called from unmanaged code, the function would return `null`, but when it is called from managed code, it returns <xref:System.IntPtr.Zero?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.IntPtr.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.intptr.zero/cs/zero2.cs#1)]
 [!code-vb[System.IntPtr.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.intptr.zero/vb/zero2.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>